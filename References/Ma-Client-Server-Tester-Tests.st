MaNetworkTestCase subclass: #MaClientServerTestCase	instanceVariableNames: 'server busy mergedBag testObjects'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Tester-Tests'!!MaClientServerTestCase methodsFor: 'test UDP ByteArray server' stamp: 'cmm 11/10/2008 11:28'!newBagFrom: start to: stop 	^ ((start to: stop) collect: [ : n | n asWords ]) asBag! !!MaClientServerTestCase methodsFor: 'test UDP ByteArray server' stamp: 'cmm 7/24/2018 15:40'!sendOutUdpByteArrayRequestsFrom: start to: stop 	"Send the server the numbers, in English words, from 500 to 1000."	| bag mySocket |	bag := self		newBagFrom: start		to: stop.	mySocket := MaClientSocket location:		(MaServerLocation			host: NetNameResolver maLocalHostName			port: self class defaultServerPort).	mySocket networkProtocol: #udp.	[ busy := true.	bag do:		[ : each | mySocket			sendData: each			startingAt: 2			count: each size - 2			waitForReplyIn: nil ].	busy := false ] fork! !!MaClientServerTestCase methodsFor: 'test UDP ByteArray server' stamp: 'cmm 11/11/2008 16:27'!startUdpByteArrayServer	server := MaServerSocket new		networkProtocol: #udp ;		yourself.	"Server will load this Bag."	mergedBag := Bag new.	server 		processOn: self class defaultServerPort		using: [ : requestLifecycle | mergedBag add: requestLifecycle requestByteArray asString ]! !!MaClientServerTestCase methodsFor: 'test UDP ByteArray server' stamp: 'cmm 9/19/2014 16:07'!testUdpByteArrayLayer	self		remotePerform: #startUdpByteArrayServer			in: 'server' ;		remotePerform: #sendOutUdpByteArrayRequestsFrom:to:			withArguments: #(500 1000 )			in: 'client1' ;		remotePerform: #sendOutUdpByteArrayRequestsFrom:to:			withArguments: #(750 1250 )			in: 'client2' ;		remotePerform: #waitUntilDone			in: 'client1' ;		remotePerform: #waitUntilDone			in: 'client2' ;		remotePerform: #verifyMergedBag			in: 'server' ;		remotePerform: #stopServer			in: 'server' ;		remotePerform: #verifyServerStopped			in: 'server'! !!MaClientServerTestCase methodsFor: 'test UDP ByteArray server' stamp: 'cmm 11/11/2008 16:52'!verifyMergedBag	| shouldBag |	shouldBag := Bag new.	{  (500 to: 1000). (750 to: 1250)  } do: 		[ : eachRange | 		eachRange first 			to: eachRange last			do: 				[ : n | 				| words |				words := n asWords.				shouldBag add: (words 						copyFrom: 2						to: words size - 1) ] ].	"May we expect at least half of them to get through..?"	self assert: mergedBag size > (shouldBag size * 0.5) truncated.	self assert: (shouldBag maIncludesAll: mergedBag)! !!MaClientServerTestCase methodsFor: 'shared' stamp: 'cmm 11/10/2008 15:47'!noteBusyWhile: aBlock 		[ busy := true.	aBlock value ] ensure: [ busy := false ]! !!MaClientServerTestCase methodsFor: 'shared' stamp: 'cmm 11/5/2013 16:30'!objectProtocolForTestServer	^ { 		MacsTestRequest.		DateAndTime.		Duration.		Association.		UUID.		"String not needed, it is supported automatically."		MacsTestResponse	 }! !!MaClientServerTestCase methodsFor: 'shared' stamp: 'cmm 11/9/2008 11:15'!stopServer	server shutdown! !!MaClientServerTestCase methodsFor: 'shared' stamp: 'cmm 9/19/2014 16:05'!verifyServerStopped	self assert: server isRunning not! !!MaClientServerTestCase methodsFor: 'shared' stamp: 'cmm 8/24/2005 20:50'!waitUntilDone	[ busy ] whileTrue: [ (Delay forSeconds: 1) wait ].	^ nil! !!MaClientServerTestCase methodsFor: 'test object server' stamp: 'cmm 11/9/2008 11:35'!objectProcessorBlock	^ [ : aMacsTestRequest | MacsTestResponse fromRequest: aMacsTestRequest ]! !!MaClientServerTestCase methodsFor: 'test object server' stamp: 'cmm 7/24/2018 15:40'!startObjectRequests	| myLink |	myLink := MaNetworkServerLink location:		(MaServerLocation			host: NetNameResolver maLocalHostName			port: self class defaultServerPort).	"			interface: #udp"	[ busy := true.	200 timesRepeat:		[ | eachRequest myResponse remoteResponse |		eachRequest := MacsTestRequest new.		remoteResponse := myLink submit: eachRequest.		myResponse := self objectProcessorBlock value: eachRequest.		self			 assert: remoteResponse ~~ myResponse ;			 assert: remoteResponse response1 = myResponse response1 ;			 assert: remoteResponse response2 = myResponse response2 ].	busy := false ] fork! !!MaClientServerTestCase methodsFor: 'test object server' stamp: 'cmm 11/5/2013 16:30'!startObjectServer	server := MaNetworkRequestServer protocol: self objectProtocolForTestServer.	server 		processOn: self class defaultServerPort		using: self objectProcessorBlock! !!MaClientServerTestCase methodsFor: 'test object server' stamp: 'cmm 9/19/2014 16:06'!testObjectLayer	self				remotePerform: #startObjectServer		in: 'server' ;				remotePerform: #startObjectRequests		in: 'client1' ;				remotePerform: #startObjectRequests		in: 'client2' ;				remotePerform: #waitUntilDone		in: 'client1' ;				remotePerform: #waitUntilDone		in: 'client2' ;				remotePerform: #stopServer		in: 'server' ;				remotePerform: #verifyServerStopped		in: 'server'! !!MaClientServerTestCase methodsFor: 'armored code' stamp: 'cmm 11/5/2013 16:30'!playerProtocol	^ super playerProtocol , self objectProtocolForTestServer! !!MaClientServerTestCase methodsFor: 'test UDP object server' stamp: 'cmm 7/24/2018 15:40'!sendObjectsToUdpServer: aCollection 	| myLink |	myLink := MaNetworkServerLink location:		(MaServerLocation			host: NetNameResolver maLocalHostName			port: self class defaultServerPort).	myLink		 networkProtocol: #udp ;		 protocol: self objectProtocolForTestServer.	[ self noteBusyWhile:		[ aCollection do:			[ : each | myLink submit: each ] ] ] fork! !!MaClientServerTestCase methodsFor: 'test UDP object server' stamp: 'cmm 11/5/2013 16:30'!startUdpObjectServer	server := MaNetworkRequestServer protocol: self objectProtocolForTestServer.	server networkProtocol: #udp.	testObjects := Bag new.	server 		processOn: self class defaultServerPort		using: [ : eachMacsTestRequest | testObjects add: eachMacsTestRequest ]! !!MaClientServerTestCase methodsFor: 'test UDP object server' stamp: 'cmm 9/19/2014 16:07'!testUdpObjectLayer	| sampleObjects1 sampleObjects2 |	sampleObjects1 := (1 to: 1000) collect: [ : e | MacsTestRequest new ].	sampleObjects2 := (1 to: 1000) collect: [ : e | MacsTestRequest new ].	self		remotePerform: #startUdpObjectServer			in: 'server' ;		remotePerform: #sendObjectsToUdpServer:			with: sampleObjects1			in: 'client1' ;		remotePerform: #sendObjectsToUdpServer:			with: sampleObjects2			in: 'client2' ;		remotePerform: #waitUntilDone			in: 'client1' ;		remotePerform: #waitUntilDone			in: 'client2' ;		remotePerform: #verifyMostObjectsReceived:			with: sampleObjects1 , sampleObjects2			in: 'server' ;		remotePerform: #stopServer			in: 'server' ;		remotePerform: #verifyServerStopped			in: 'server'! !!MaClientServerTestCase methodsFor: 'test UDP object server' stamp: 'cmm 11/10/2008 15:58'!verifyMostObjectsReceived: aCollection 	self assert: testObjects size > (aCollection size * 0.8) truncated.	testObjects do: 		[ : eachReceivedUdp | 		self assert: (aCollection anySatisfy: 				[ : eachTestFixture | 				eachTestFixture object1 = eachReceivedUdp object1 and: [ eachTestFixture object2 = eachReceivedUdp object2 ] ]) ]! !!MaClientServerTestCase methodsFor: 'test ByteArray server' stamp: 'cmm 7/24/2018 15:40'!startByteArrayRequests	| mySocket requestByteArray response eachResponse randomStream byteArrayRandomizer requestSize largestTest |	largestTest := 9000.	randomStream := Random new.	response := ByteArray new: 4000.	"<- purposely too small"	requestByteArray := ByteArray new: largestTest.	byteArrayRandomizer := 	[ : size | 	1 		to: size		do: 			[ : index | 			requestByteArray 				at: index				put: (randomStream nextInt: 256) - 1 ] ].	mySocket := MaClientSocket location: 		(MaServerLocation 			host: NetNameResolver maLocalHostName			port: self class defaultServerPort).		[ busy := true.	1 		to: 200		do: 			[ : count | 			requestSize := randomStream nextInt: largestTest.			byteArrayRandomizer value: requestSize.			eachResponse := mySocket 				sendData: requestByteArray				startingAt: 1				count: requestSize				waitForReplyIn: response.			self should: 				[ (requestByteArray 					copyFrom: 1					to: requestSize) reverse = (eachResponse 						copyFrom: 1						to: requestSize) ] ].	busy := false ] fork! !!MaClientServerTestCase methodsFor: 'test ByteArray server' stamp: 'cmm 11/10/2008 16:05'!startByteArrayServer	server := MaServerSocket new.	server 		processOn: self class defaultServerPort		using: [ : requestLifecycle | requestLifecycle requestByteArray reverse ]! !!MaClientServerTestCase methodsFor: 'test ByteArray server' stamp: 'cmm 9/19/2014 16:06'!testByteArrayLayer	self		remotePerform: #startByteArrayServer			in: 'server' ;		remotePerform: #startByteArrayRequests			in: 'client1' ;		remotePerform: #startByteArrayRequests			in: 'client2' ;		remotePerform: #waitUntilDone			in: 'client1' ;		remotePerform: #waitUntilDone			in: 'client2' ;		remotePerform: #stopServer			in: 'server' ;		remotePerform: #verifyServerStopped			in: 'server'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientServerTestCase class	instanceVariableNames: ''!!MaClientServerTestCase class methodsFor: 'accessing' stamp: 'cmm 2/7/2009 10:56'!defaultServerPort	^ 60948! !!MaClientServerTestCase class methodsFor: 'initialize-release' stamp: 'cmm 2/7/2009 10:04'!initialize	super initialize.	Smalltalk addToStartUpList: self! !MaNetworkTestSuite subclass: #MaClientServerTestSuite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Tester-Tests'!!MaClientServerTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 1/1/2013 15:00'!playerNames	^ #('client1' 'client2' 'server' )! !!MaClientServerTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 2/6/2009 17:19'!suiteName	^ 'macs'! !!MaClientServerTestSuite methodsFor: 'overriding' stamp: 'cmm 10/29/2013 15:31'!startingPort	"Pick a port number range that won't conflict with the defaults, in case another application is running."	^ 44421! !MaClientServerRequest subclass: #MacsTestRequest	instanceVariableNames: 'object1 object2'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Tester-Tests'!!MacsTestRequest methodsFor: 'accessing' stamp: 'cmm 11/9/2008 11:29'!initialize	super initialize.	object1 := DateAndTime 		date: 			(Date 				newDay: (1 to: 365) atRandom				year: (1900 to: 2100) atRandom)		time: Time now.	object2 := UUID new -> (1 to: 100000) atRandom asWords! !!MacsTestRequest methodsFor: 'accessing' stamp: 'cmm 11/9/2008 10:57'!object1	^object1! !!MacsTestRequest methodsFor: 'accessing' stamp: 'cmm 11/9/2008 10:57'!object1: aDateAndTime	object1 := aDateAndTime! !!MacsTestRequest methodsFor: 'accessing' stamp: 'cmm 11/9/2008 10:57'!object2	^object2! !!MacsTestRequest methodsFor: 'accessing' stamp: 'cmm 11/9/2008 10:58'!object2: anAssociation	object2 := anAssociation! !MaObject subclass: #MacsTestResponse	instanceVariableNames: 'response1 response2'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Tester-Tests'!!MacsTestResponse methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2008 17:35'!initializeFrom: aMacsTestRequest 	response1 := DateAndTime 		date: (aMacsTestRequest object1 asDate addDays: 1)		time: aMacsTestRequest object1 asTime.	response2 := aMacsTestRequest object2 value -> aMacsTestRequest object2 key! !!MacsTestResponse methodsFor: 'accessing' stamp: 'cmm 11/9/2008 11:14'!response1	^response1! !!MacsTestResponse methodsFor: 'accessing' stamp: 'cmm 11/9/2008 11:14'!response2	^response2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MacsTestResponse class	instanceVariableNames: ''!!MacsTestResponse class methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2008 11:10'!fromRequest: aMacsTestRequest 	^ self new		initializeFrom: aMacsTestRequest ;		yourself! !MaClientServerTestCase initialize!