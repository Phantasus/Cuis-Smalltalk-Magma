MaAttributableObject subclass: #MagmaDataRepair	instanceVariableNames: 'location session startBlock enumerateBlock checkBlock doBlock repairBlock mode count lastCommit strongReferences'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Data Repair'!!MagmaDataRepair commentStamp: 'cmm 4/23/2014 16:42' prior: 0!A MaDataRepair is used to perform data repairs on Magma models in a controlled and reliable fashion.  The requirements of a data-repair are:	- identify and report all data which will be evaluated so it can known that no objects were skipped simply due to them not being evaluated.	- identify and report what objects are in need of repair.	- repair broken data objects.	- verify and report whether data is fixed.Example:(MagmaDataRepair	at: (MagmaRemoteLocation host: 'prod1' port: 51199)	enumerate: [ : session : repair | session root accountsDo: [ : eachAccount | eachAccount isThirdParty ifTrue: [ repair check: eachAccount] ] ]	check: [ : eachAccount : repair | eachAccount importFilters anySatisfy: [ : each | each maOriginalClass = MaxImportFilter ] ])	repair: [ : eachAccount : repair | eachAccount importFilters withIndexDo: [ : eachFilter : index | eachAccount importFilters at: index put: eachFilter asKeywordFilter ] ]!!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 4/4/2014 20:45'!anyDataToRepair	doBlock := [ : each | ^ true ].	self enumerateCheckAndDo.	^ false! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 12/29/2013 14:15'!close	session ifNotNil:		[ session disconnectAndClose.		session := nil.		MagmaNotification signal: 'session closed.' ]! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 12/28/2013 15:34'!ensureOpen	session ifNil: [ self open ]! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 5/20/2014 22:08'!enumerateCheckAndDo	"findBlock must send #check: to the receiver with the objects needing checked."	count := 0.	self ensureOpen.	startBlock cull: session cull: self.	lastCommit := Time millisecondClockValue.	enumerateBlock cull: session cull: self! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 4/4/2014 13:29'!open	self close.	session := location newSession.	session connectAs: 'data-repair'! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 11/22/2016 16:10'!primRepair	"safeMode causes the receiver to open its own transaction, and also to verify no data to repair before committing."	repairBlock ifNil: [ MagmaUserError signal: 'repairBlock must be specified to repair.' ].	MagmaRepairNotification signal: 'Repair mode: ' , mode.	self open.	[ self anyDataToRepair		ifTrue:			[ | commitNumberBefore failed |			failed := false.			MagmaRepairNotification signal: 'Found data to repair.  Attempting repair.'.			commitNumberBefore := session remoteCommitNumber.			session begin.			"Do the repair."			doBlock := repairBlock.			self enumerateCheckAndDo.			self improveMode				ifTrue: [ session commit ]				ifFalse:					[ MagmaRepairNotification signal: 'Verifying repair before committing.'.					self anyDataToRepair						ifTrue:							[ MagmaRepairNotification signal: 'Still found data to repair.  Aborting.'.							failed := true.							session abort ]						ifFalse:							[ MagmaRepairNotification signal: 'No data left to repair.  Committing.'.							session commit ] ].			"Close to force a new session when evaluating anyDataToRepair."			self close.			(failed or:				[ MagmaRepairNotification signal: 'Verifying repair...'.				self anyDataToRepair ])				ifTrue:					[ | errMsg |					errMsg := String streamContents:						[ : stream | stream maPrint: 'Verification failed.  '.						self improveMode							ifTrue: [ stream maPrint: 'Some improvement may have been committed.' ]							ifFalse:								[ failed ifFalse: [ stream maPrint: '(Perhaps the repair tried to change immutable objects?)' ].								stream maPrint: 'Repair failed.  Commit number prior to repair was ', commitNumberBefore ] ].					MagmaRepairNotification signal: errMsg.					MagmaRepairFailure signal: errMsg ]				ifFalse: [ MagmaRepairNotification signal: 'Verification complete.  Repair successful.' ] ]		ifFalse: [ MagmaRepairNotification signal: 'No data to repair.' ] ] ensure: [ self close ]! !!MagmaDataRepair methodsFor: 'private' stamp: 'cmm 4/3/2014 14:25'!signalCount	MagmaRepairNotification signal: 'Total:  ' , count asString , ' objects needing repair.'! !!MagmaDataRepair methodsFor: 'actions' stamp: 'cmm 4/16/2014 10:22'!check	"Answer a boolean whether there is any data needing repair."	| found |	mode := #check.	MagmaRepairNotification signal: 'Repair mode:  #check.'.	found := self anyDataToRepair.	MagmaRepairNotification signal:		(found			ifTrue: [ 'Found data in need of repair.' ]			ifFalse: [ 'All data found clean, no data to repair.' ]).	^ found! !!MagmaDataRepair methodsFor: 'actions' stamp: 'cmm 4/16/2014 10:22'!count	"Answer the number of objects needing repair."	mode := #count.	MagmaRepairNotification signal: 'Repair mode:  #count.'.	self		 enumerateCheckAndDo ;		 signalCount.	^ count! !!MagmaDataRepair methodsFor: 'actions' stamp: 'cmm 4/16/2014 10:22'!identify	| badData |	mode := #identify.	badData := OrderedCollection new.	doBlock := [ : badObject | badData add: badObject ].	MagmaRepairNotification signal: 'Repair mode:  #identify'.	self enumerateCheckAndDo."	badData do: [ : each | MagmaRepairNotification signal: 'Found needing repair: ', each asString ]."	self signalCount.	^ badData! !!MagmaDataRepair methodsFor: 'actions' stamp: 'cmm 4/16/2014 10:21'!improve	"Commit repairs as we go, allowing some but possibly not all objects to be repaired, an improvement."	mode := #improve.	self primRepair! !!MagmaDataRepair methodsFor: 'actions' stamp: 'cmm 4/16/2014 10:21'!repair	mode := #repair.	self primRepair! !!MagmaDataRepair methodsFor: 'user-responsibility' stamp: 'cmm 11/22/2016 15:39'!check: anObject 	"Your data-repair script must send #check: to the passed-in DataRepair object (2nd arg of the block), with the object to be checked by the checkBlock.  See the class comment for an example."	(checkBlock		cull: anObject		cull: self) ifTrue:		[ count := count + 1.		doBlock			cull: anObject			cull: self.		strongReferences add: anObject.		(self improveMode and: [ (Time millisecondsSince: lastCommit) > (80 * 1000) ]) ifTrue:			[ session commitAndBegin.			lastCommit := Time millisecondClockValue ] ]! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:35'!commitNumberAfter	^ self attributeNamed: #commitNumberAfter! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:35'!commitNumberAfter: aString 	self		attributeNamed: #commitNumberAfter		put: aString! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:30'!commitNumberBefore	^ self attributeNamed: #commitNumberBefore! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:35'!commitNumberBefore: aString 	self		attributeNamed: #commitNumberBefore		put: aString! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:36'!description	^ self attributeNamed: #description! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:37'!description: aString 	self		attributeNamed: #description		put: aString! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:21'!timestamp	^ self attributeNamed: #timestamp! !!MagmaDataRepair methodsFor: 'accounting' stamp: 'cmm 12/29/2013 14:20'!timestamp: aString 	self		attributeNamed: #timestamp		put: aString! !!MagmaDataRepair methodsFor: 'testing' stamp: 'cmm 4/16/2014 10:19'!improveMode	^ mode = #improve! !!MagmaDataRepair methodsFor: 'initialize-release' stamp: 'cmm 11/22/2016 15:39'!initialize	super initialize.	doBlock := startBlock := [].	strongReferences := IdentitySet new! !!MagmaDataRepair methodsFor: 'initialize-release' stamp: 'cmm 4/3/2014 13:36'!repairBlock: aBlock	"A block, up to two arguments where 1st is the object produced by my findBlock, and the 2nd, the receiver."	repairBlock := aBlock! !!MagmaDataRepair methodsFor: 'initialize-release' stamp: 'cmm 5/19/2014 22:07'!setLocation: aMagmaLocation startBlock: startBlockArg enumerateBlock: enumerateBlockArg checkBlock: checkBlockArg repairBlock: repairBlockArg 	location := aMagmaLocation.	startBlock := startBlockArg.	enumerateBlock := enumerateBlockArg.	checkBlock := checkBlockArg.	repairBlock := repairBlockArg.	^ self! !!MagmaDataRepair methodsFor: 'accessing' stamp: 'cmm 12/28/2013 11:20'!location	"The database location to be repaired."	^ location! !!MagmaDataRepair methodsFor: 'accessing' stamp: 'cmm 12/29/2013 15:07'!session	^ session! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaDataRepair class	instanceVariableNames: ''!!MagmaDataRepair class methodsFor: 'create' stamp: 'cmm 5/19/2014 22:07'!at: aMagmaLocation start: startBlockArg enumerate: enumerateBlock check: checkBlock repair: repairBlock 	^ self new		setLocation: aMagmaLocation		startBlock: startBlockArg		enumerateBlock: enumerateBlock		checkBlock: checkBlock		repairBlock: repairBlock! !