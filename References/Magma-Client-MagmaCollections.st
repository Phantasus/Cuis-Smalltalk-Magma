MaObject subclass: #MagmaCollectionIndex	instanceVariableNames: 'attribute recordSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCollectionIndex methodsFor: 'convert' stamp: 'cmm 5/28/2007 10:25'!asDescription	"This is used so my classes do not have to be part of the client-server protocol."	^ MagmaIndexDescription 		attribute: self attribute		keySize: self keySize		recordSize: self recordSize! !!MagmaCollectionIndex methodsFor: 'accessing'!attribute	"the accessor symbol for any kind of object that has this attribute.	These are used to determine what whether the receiver is appropriate to restrict	or sort a Query."	^attribute! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'brp 7/18/2006 20:17'!lowestPossibleKey	^ 0! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'cmm 12/10/2002 23:30'!recordSize	^recordSize! !!MagmaCollectionIndex methodsFor: 'private'!attribute: aSymbol	attribute := aSymbol! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 2/25/2011 15:56'!defaultRecordSize	^ 32! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 12/1/2014 15:51'!highestPossibleKey	^ (1 bitShift: self keySize) - 1! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 4/11/2005 16:26'!indexHashFor: anObject 	"Answer the Integer hash used to locate anObject."	self validateCanIndex: anObject.	^ self indexHashForIndexObject: (self indexObjectFor: anObject)! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 12/5/2002 17:31'!indexHashesFor: anObject 	"Answer an Integer or Array of Integers that will be used to locate the receiver."	self validateCanIndex: anObject.	^self indexHashesForIndexObject: (self indexObjectFor: anObject)! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 7/2/2006 22:30'!indexHashesForIndexObject: anObject 	"Answer a collection of Integers which are the MaHashIndex locations at which anObject will be indexed."	^ (anObject isCollection and: [ anObject maOriginalClass isPointers ]) 		ifTrue: [ anObject collect: [ : each | self indexHashForIndexObject: each ] ]		ifFalse: [ Array with: (self indexHashForIndexObject: anObject) ]! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 2/8/2009 15:37'!indexObjectFor: anObject 	"Answer the object by which I am indexed."	^ anObject yourself perform: attribute yourself! !!MagmaCollectionIndex methodsFor: 'testing' stamp: 'cmm 2/8/2009 12:04'!canIndex: anObject 	"MutatingProxy's respond to #respondsTo:, ensure we send it to the domain object."	^ anObject yourself respondsTo: attribute yourself! !!MagmaCollectionIndex methodsFor: 'must override' stamp: 'cmm 11/7/2002 23:06'!indexHashForIndexObject: anObject	self subclassResponsibility! !!MagmaCollectionIndex methodsFor: 'must override' stamp: 'cmm 2/22/2004 21:47'!keySize	"Answer an Integer number of bits, in multiples of 8, that each key value can be."	self subclassResponsibility! !!MagmaCollectionIndex methodsFor: 'initialize' stamp: 'cmm 2/25/2011 15:55'!initialize	super initialize.	self recordSize: self defaultRecordSize! !!MagmaCollectionIndex methodsFor: 'initialize' stamp: 'cmm 9/21/2005 14:19'!recordSize: anInteger	"Only set this ONCE, when you create.  It is not changeable after the dictionary is created."	(MaHashIndex validRecordSizes includes: anInteger)		ifTrue: [ recordSize := anInteger ]		ifFalse:			[ MagmaUserError signal: 'recordSize must be one of ', MaHashIndex validRecordSizes printString ]! !!MagmaCollectionIndex methodsFor: 'printing' stamp: 'cmm 4/22/2002 22:25'!maPrintAbbreviatedOn: aStream	aStream nextPutAll: self attribute! !!MagmaCollectionIndex methodsFor: 'validate' stamp: 'cmm 8/17/2005 21:18'!validRecordSizes	"Record sizes must be a power of 2 so that slots in every MaHashIndexRecord will be uniformely sized."	^ #(2 4 8 16 32 64 128)! !!MagmaCollectionIndex methodsFor: 'validate' stamp: 'cmm 5/1/2002 23:12'!validateCanIndex: anObject	(self canIndex: anObject)		ifFalse:			[ MagmaUserError signal:				'Cannot calculate the hashIndexFor: ' , anObject printString ]! !!MagmaCollectionIndex methodsFor: '*magma-tester' stamp: 'cmm 6/14/2006 12:49'!ascendingSortBlock	^ [ :a :b | (self indexHashFor: a) < (self indexHashFor: b) ]! !!MagmaCollectionIndex methodsFor: '*magma-tester' stamp: 'cmm 6/14/2006 12:49'!descendingSortBlock	^ [ :a :b | (self indexHashFor: a) > (self indexHashFor: b) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaCollectionIndex class	instanceVariableNames: ''!!MagmaCollectionIndex class methodsFor: 'creation' stamp: 'cmm 9/26/2004 20:22'!attribute: aSymbol	^ super new		attribute: aSymbol;		yourself! !MagmaCollectionIndex subclass: #MaByteSequenceIndex	instanceVariableNames: 'keySize meaningfulCharacters'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaByteSequenceIndex commentStamp: 'cmm 12/25/2004 23:47' prior: 0!I represent an index that is based on a sequence of bytes to calculate the index-hash value.  I know the number of meaningful characters I can be searched by based on my bit-size.!!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 7/16/2007 23:23'!indexHashForIndexObject: aStringOrByteArray 	"Answer the index hash value of the receiver, a value for a MaHashIndex."	| answer power |	aStringOrByteArray maOriginalClass isBytes ifFalse: 		[ MagmaInvalidIndexObject signal: 'Not a valid index object.  Need a byte-object please.' ].	answer := 0.	power := meaningfulCharacters - 1.	aStringOrByteArray do: 		[ : eachChar | 		(eachChar asInteger 			between: 0			and: self sizeOfCharacterSet - 1) ifTrue: 			[ answer := answer + (eachChar asInteger * (self sizeOfCharacterSet raisedTo: power)).			power := power - 1.			power < 0 ifTrue: [ ^ answer ] ] ].	^ answer! !!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 2/22/2004 21:04'!keySize	^keySize! !!MaByteSequenceIndex methodsFor: 'accessing'!meaningfulCharacters	"Answer the number of characters this index will use to index."		^meaningfulCharacters! !!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 3/13/2005 20:02'!sizeOfCharacterSet	^ 256! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 7/31/2018 00:03'!initialize	super initialize.	self keySize: 64! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 7/18/2007 21:04'!initializeNumberOfMeaningfulCharacters	meaningfulCharacters := ((2 raisedTo: keySize) maLog: self sizeOfCharacterSet) truncated! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 11/20/2010 19:35'!keySize: numberOfBits 	"Only set this ONCE, when you create.  It is not changeable after the dictionary is created."	(MaHashIndex validKeySizes includes: numberOfBits)		ifFalse: [ MagmaUserError signal: 'keySize must be one of ' , MaHashIndex validKeySizes printString ].	keySize := numberOfBits.	self initializeNumberOfMeaningfulCharacters! !MaByteSequenceIndex subclass: #MaAsciiStringIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaAsciiStringIndex commentStamp: 'cmm 8/20/2006 22:12' prior: 0!THIS CLASS IS NOW DEPRECATED.USE MaSearchStringIndex with #beAscii for full ascii-range index.I search based on an exactly matching sequence of ASCII characters (characters between 0 and 127).!!MaAsciiStringIndex methodsFor: 'accessing' stamp: 'cmm 8/20/2006 23:59'!canIndex: anObject	^(super canIndex: anObject) and: [ (self indexObjectFor: anObject) isString ]! !!MaAsciiStringIndex methodsFor: 'accessing' stamp: 'cmm 7/16/2007 23:13'!indexHashForIndexObject: aString 	"Answer the index hash value of the receiver, a value	for a MaHashIndex.  Only ASCII values 0 - 127 are meaningful,	all others in aString are ignored."	aString isString ifFalse: 		[ MagmaInvalidIndexObject signal: 'Not a valid index object.  Need a String please.' ].	^ super indexHashForIndexObject: aString! !!MaAsciiStringIndex methodsFor: 'private accessing'!sizeOfCharacterSet	^128! !MagmaCollectionIndex subclass: #MaDateAndTimeIndex	instanceVariableNames: 'epoch duration precision keySize'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Magma-Client-MagmaCollections'!!MaDateAndTimeIndex commentStamp: 'brp 12/21/2005 15:07' prior: 0!This class indexes DateAndTime attributes.A DateAndTime has four instance variables:	julianDayNumber 	- any day since 24 November -4713	seconds				- seconds since midnight	nanoSeconds		- up to 10 rasiedTo: 9 per second	offset				- a Duration from UTCThis would require many byes of hash space. Fortunately most of this power is seldom used.This class allows the user to specify the earliest date indexed (epoch), the clock precision and how far into the future dates may be specified (duration). All dates are manipulated in UTC.This allows a far more compact hash value to be generated!!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 15:08'!duration	^ duration! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 14:57'!epoch	^ epoch! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 14:57'!precision	^ precision! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'cmm 12/2/2014 16:01'!indexHashForIndexObject: aDateAndTime 	^ aDateAndTime		ifNil: [ 0 ]		ifNotNil:			[ | delta hash |			delta := aDateAndTime asDateAndTime asUTC - epoch.			hash := (delta asSeconds * self magnification) asInteger.			delta nanoSeconds isZero ifFalse: [ hash := hash + (delta nanoSeconds / (precision / 1 second * NanosInSecond)) floor ].			hash < 0 ifTrue: [ MagmaInvalidIndexObject signal: 'Not a valid DateAndTime: . The index object must be greater than ' , epoch printString ].			hash ]! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'cmm 1/22/2015 16:17'!keySize	^ keySize! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'brp 12/21/2005 15:26'!magnification	"Answer the factor by which the modified julian day number must be 	multiplied in order to accomodate the clock precision"	^ 1 second / self precision! !!MaDateAndTimeIndex methodsFor: 'initialize' stamp: 'cmm 11/21/2014 21:39'!initialize	super initialize.	self		setEpoch: DateAndTime epoch		duration: (365.24 * 1000) ceiling days		precision: 1 minute! !!MaDateAndTimeIndex methodsFor: 'initialize' stamp: 'cmm 1/22/2015 16:18'!setEpoch: startingDateAndTime duration: aDuration precision: durationUnits 	| bits |	epoch := startingDateAndTime asUTC.	duration := aDuration.	precision := durationUnits.	"The keySize is a function of the epoch, duration, and precision"	bits := (self duration asSeconds * self magnification log: 2) ceiling.	keySize := (bits / 8) ceiling * 8! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaDateAndTimeIndex class	instanceVariableNames: ''!!MaDateAndTimeIndex class methodsFor: 'create' stamp: 'cmm 11/21/2014 21:42'!attribute: attributeSymbol epoch: startingDateAndTime duration: aDuration precision: durationUnits 	^ (self attribute: attributeSymbol)		setEpoch: startingDateAndTime		duration: aDuration		precision: durationUnits! !MagmaCollectionIndex subclass: #MaDateIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaDateIndex commentStamp: 'cmm 12/25/2004 23:51' prior: 0!I am a 24-bit index useful for indexing objects by a Date.!!MaDateIndex methodsFor: 'as yet unclassified' stamp: 'cmm 8/4/2006 14:04'!indexHashForIndexObject: aDate	(aDate respondsTo: #julianDayNumber)		ifFalse:			[ MagmaInvalidIndexObject signal: 'Not a valid date.' ].	^ aDate julianDayNumber! !!MaDateIndex methodsFor: 'as yet unclassified' stamp: 'cmm 4/8/2004 00:41'!keySize"Rationale for 24-bit index:	Date julianDayNumber: (2 raisedTo: 24) (prints 10 May 41222)Will Squeak still be around then??"	^ 24! !MagmaCollectionIndex subclass: #MaFloatIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaFloatIndex commentStamp: 'cmm 12/25/2004 23:51' prior: 0!I am a 32-bit index usefulf or indexing objects by a Float value.!!MaFloatIndex methodsFor: 'as yet unclassified' stamp: 'cmm 12/17/2014 16:12'!indexHashForIndexObject: aFloat	^aFloat asFloat hashKey32! !!MaFloatIndex methodsFor: 'as yet unclassified' stamp: 'cmm 2/22/2004 21:59'!keySize	^ 32! !MagmaCollectionIndex subclass: #MaIntegerIndex	instanceVariableNames: 'keySize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaIntegerIndex methodsFor: 'overriding' stamp: 'cmm 7/17/2005 21:25'!indexHashForIndexObject: anInteger	^ anInteger! !!MaIntegerIndex methodsFor: 'overriding' stamp: 'cmm 11/20/2010 19:35'!keySize: numberOfBits	"Only set this ONCE, when you create.  It is not changeable after the index is created."	(MaHashIndex validKeySizes includes: numberOfBits)		ifFalse: [ MagmaUserError signal: 'keySize must be one of ' , MaHashIndex validKeySizes printString ].	keySize := numberOfBits! !!MaIntegerIndex methodsFor: 'initialize' stamp: 'cmm 7/17/2005 21:26'!initialize	super initialize.	keySize := 32! !!MaIntegerIndex methodsFor: 'accessing' stamp: 'cmm 7/18/2005 13:29'!keySize	^ keySize! !MaByteSequenceIndex subclass: #MaSearchStringIndex	instanceVariableNames: 'lowChar highChar'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaSearchStringIndex commentStamp: 'cmm 12/25/2004 23:50' prior: 0!I represent an index with just 64 characters of the ascii range utilized; 33 - 96, so we must do without the {, }, |, ~, and space characters.  This increases my number of meaningful characters and eliminates the need for case-sensitive matching.!!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:33'!beAlpha	"Set up this index to include only alpha characters; 		(65 to: 90) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 65		highChar: 90! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:33'!beAlphaNumeric	"Set up this index to include only alpha characters; 		(48 to: 90) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 48		highChar: 90! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:38'!beAscii	"Set up this index to include basic punctuation; 		(0 to: 127) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 0		highChar: 127! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:32'!bePunctuated	"Set up this index to include basic punctuation; 		(33 to: 96) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 33		highChar: 96! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:32'!setLowChar: lowInteger highChar: highInteger	lowChar := lowInteger.	highChar := highInteger.	self initializeNumberOfMeaningfulCharacters! !!MaSearchStringIndex methodsFor: 'testing' stamp: 'cmm 8/21/2006 00:11'!canIndex: anObject 	^ (super canIndex: anObject) and: [ (self indexObjectFor: anObject) isCollection ]! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 22:11'!conditionedKeyword: aString 	"Answer the keyword aString conditioned for keyword search (i.e., padded to meaningfulCharacters, characters not in my lowChar..highChar range stripped)."	| stringIndex conditionedStringIndex conditionedString |	conditionedString := (String new: meaningfulCharacters) atAllPut: (Character value: self lowChar).	stringIndex := 1.	conditionedStringIndex := 1.	"First, load conditionedString with conditioned characters from aString."	[ conditionedStringIndex <= meaningfulCharacters and: [ stringIndex <= aString size ] ] whileTrue: 		[ | conditionedChar |		conditionedChar := (aString at: stringIndex) asUppercase.		(conditionedChar asciiValue 			between: self lowChar			and: self highChar) ifTrue: 			[ conditionedString 				at: conditionedStringIndex				put: conditionedChar.			conditionedStringIndex := conditionedStringIndex + 1 ].		stringIndex := stringIndex + 1 ].	^ conditionedString! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:03'!highChar	^ highChar ifNil: 		[ self bePunctuated.		highChar ]! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 22:31'!indexHashForIndexObject: aString 	"Answer the index hash value of the receiver, a value for a MaHashIndex."	"First, load zeroString with conditioned characters from aString."	"Now compute the hash value."	| answer conditionedString |	aString isString ifFalse: 		[ MagmaInvalidIndexObject signal: 'Invalid index object, need a String.' ].	conditionedString := self conditionedKeyword: aString.	answer := 0.	conditionedString doWithIndex: 		[ : eachChar : index | 		answer := answer + ((eachChar asciiValue - self lowChar) * (self sizeOfCharacterSet raisedTo: meaningfulCharacters - index)) ].	^ answer! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:04'!lowChar	^ lowChar ifNil: 		[ self bePunctuated.		lowChar ]! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:28'!sizeOfCharacterSet	^ self highChar - self lowChar + 1! !MaSearchStringIndex subclass: #MaKeywordIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaKeywordIndex commentStamp: 'cmm 7/31/2018 00:00' prior: 0!I am just like a MaSearchStringIndex except I index a collection of Strings (i.e., keywords) instead of a single String.  Your indexed attribute should answer a collection of Strings.!!MaKeywordIndex methodsFor: '*magma-tester' stamp: 'cmm 7/2/2006 22:38'!ascendingSortBlock	^ [ : a : b | (self indexHashesFor: a) min < (self indexHashesFor: b) min ]! !MagmaCollectionIndex subclass: #MaUUIDIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MaUUIDIndex commentStamp: 'brp 12/20/2005 09:50' prior: 0!This class is as index on a 16 Byte UUID.!!MaUUIDIndex methodsFor: 'private' stamp: 'cmm 2/25/2011 15:55'!defaultRecordSize	^ 8! !!MaUUIDIndex methodsFor: 'must override' stamp: 'brp 12/21/2005 09:38'!indexHashForIndexObject: anUUID	"anUUID is a 16 byte ByteArray"	^ anUUID maUint: self keySize at: 0! !!MaUUIDIndex methodsFor: 'must override' stamp: 'brp 12/20/2005 09:56'!keySize	"Answer an Integer number of bits, in multiples of 8, that each key value can be."	^ 128	"UUID new size * 8"! !MaObject subclass: #MagmaCollectionReader	instanceVariableNames: 'collection expression trunk segment pageSize reversed'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCollectionReader commentStamp: 'cmm 2/14/2008 09:04' prior: 0!I represent a set of objects contained by a MagmaCollection satisfying my query 'expression'.  Though I am not a Collection, I can be thought of one in terms of reading objects (I can't add or remove any objects for you, but I can hand you my #collection who'll do it for you).I am created by sending #where: to a MagmaCollection.  My #size is how many objects satisfy the query, which may take some time to compute if the where expression uses more than one range condition.I am persistable in Magma just like any object.  I can be stored as a "pre-defined" query or something.  I'll work just fine after enduring storage and retrieval to a Magma database.!!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 2/28/2015 13:12'!add: anObject	collection add: anObject! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 2/18/2008 17:11'!anyOne	^ self isLoaded 		ifTrue: [ segment objects anyOne value ]		ifFalse: [ self first ]! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 1/2/2008 12:55'!at: anInteger 	^ self 		at: anInteger		ifAbsent: [ MagmaUserError signal: 'out of bounds' ]! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/26/2007 10:15'!at: anInteger ifAbsent: aBlock 	^ self 		primAt: 			(reversed 				ifTrue: [ self lastKnownSize - anInteger + 1 ]				ifFalse: [ anInteger ])		ifOutOfBounds: aBlock! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/26/2007 10:16'!at: anInteger ifOutOfBounds: aBlockself deprecated: 'Use #at:ifAbsent:'.	^ self		primAt: 			(reversed				ifTrue: [ self lastKnownSize - anInteger + 1 ]				ifFalse: [ anInteger ])		ifOutOfBounds: aBlock! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 4/18/2013 10:00'!cachedObjectAfter: anObject 	| found |self maMarked: 'delete'.	found := false.	self segmentObjects do:		[ : each | found ifTrue: [ ^ each value ].		each value = anObject ifTrue: [ found := true ] ].	^ nil! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 4/18/2013 10:25'!cachedObjectBefore: anObject 	| prior | prior := nil.self maMarked: 'delete'.	self segmentObjects do:		[ : each | each value = anObject ifTrue: [ ^ prior ].		prior := each value ].	^ nil! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/30/2002 23:49'!collection	^collection! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'brp 10/28/2005 13:16'!first	^ self at: 1! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/4/2011 20:51'!fourth	^ self at: 4! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 8/1/2006 20:40'!last	^ self at: self lastKnownSize! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 2/17/2008 15:02'!lastKnownSize	self subclassResponsibility ! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 6/23/2011 12:06'!nextToLast	^ self at: self lastKnownSize-1! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:12'!pageSize	"The number of object retrieved to memory at a time."	^ pageSize! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/16/2006 20:00'!pageSize: anInteger 	"Tell the receiver to retrieve anInteger number of elements at a time when 'scrolling' to a new part of the collection via at:."	pageSize := anInteger.	"We must refresh because my segments are laid out by my page-size and is also how my changes are merged."	self refresh! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 6/5/2006 20:58'!refresh	"clear out my caches.  The next access will force retrieve my latest state from the server."	self initializeSegments! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/4/2011 20:51'!second	^ self at: 2! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/4/2011 17:31'!segmentObjects	^ segment		ifNil: [ Array empty ]		ifNotNil: [ segment objects ]! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 6/5/2006 20:56'!size	"Retrieve the latest-known size from the server, regardless if I'm already loaded."	self refresh.	^ self lastKnownSize! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/4/2011 20:51'!third	^ self at: 3! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/2/2006 22:46'!where: aBlock 	| newReader |	newReader := self collection where: aBlock.	newReader expression: newReader expression & self expression.	^ newReader! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/2/2006 22:58'!where: aBlock distinct: makeDistinct sortBy: attributeSymbol descending: shouldDescend 	^ ((self where: aBlock)		sortBy: attributeSymbol makeDistinct: makeDistinct)		descending: shouldDescend ;		yourself! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/2/2006 22:59'!where: aBlock distinct: makeDistinct sortedBy: attributeSymbol descending: shouldDescend 	| answer |	answer := self 		where: aBlock		distinct: makeDistinct		sortBy: attributeSymbol		descending: shouldDescend.	[ answer sortComplete ] whileFalse: [ (Delay forMilliseconds: 400) wait ].	^ answer! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:59'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum := 0.	self do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].	^ sum! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:01'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:01'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:02'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/17/2009 22:44'!do: oneArgBlock 	| index |	index := 0.		[ oneArgBlock value: 		(self 			at: (index := index + 1)			ifAbsent: [ ^ self ]) ] repeat! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!errorNotFound: anObject	MagmaUserError signal: 'Object is not in the collection.'! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/17/2009 20:16'!maDetect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	"foundBlock takes one argument, the found object.""This implementation copied directly from Collection.  For compatibility with the Ma base additions methods too!!"	self 		do: [ :element | (aBlock value: element) ifTrue: [ ^foundBlock value: element ] ].	^exceptionBlock value! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!reject: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:element | (aBlock value: element) == false]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:57'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 8/1/2006 21:29'!withIndexDo: elementAndIndexBlock 	| x |	x := 0.	self do: 		[ : each | 		elementAndIndexBlock 			value: each			value: (x := x + 1) ]! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 11/11/2007 22:47'!asArray	^ self asArray: self lastKnownSize! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 8/1/2006 20:35'!asArray: count 	"Answer an Array of up to count elements contained in me."	| a |	a := Array new: (count min: self lastKnownSize).	self withIndexDo: 		[ : each : x | 		a 			at: x			put: each.		x = count ifTrue: [ ^ a ] ].	^ a! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 8/8/2006 21:00'!asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 5/26/2014 19:47'!asOrderedCollection	^ OrderedCollection withAll: self! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 11/16/2004 23:04'!asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 5/28/2006 21:45'!ascend	self descending: false! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/19/2018 14:32'!ascending: aBoolean 	self descending: aBoolean not! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 5/28/2006 21:45'!descend	self descending: true! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/9/2006 16:02'!descending: aBoolean 	self isSorted ifFalse: [ MagmaUserError signal: 'not sorted' ].	reversed := aBoolean! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 7/26/2006 20:20'!fractionSorted	"For MagmaCollections that are sorted in a background server process, we must ask the server for progress."	^ collection fractionLoaded! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/16/2006 16:31'!isDescending	^ reversed! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/8/2006 16:22'!isSorted	^ self sortIndex notNil! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 7/3/2006 23:21'!sortBy: attributeSymbol 	"Determine if I am already sorted by attributeSymbol and, if so, answer self immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me."	^ self 		sortBy: attributeSymbol		makeDistinct: false! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 1/4/2010 09:54'!sortBy: attributeSymbol makeDistinct: aBoolean 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately, but it is being sorted in the background."	^ self 		sortBy: attributeSymbol		makeDistinct: aBoolean		descending: false! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 1/4/2010 09:43'!sortBy: attributeSymbol makeDistinct: aBoolean descending: shouldDescend 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately, but it is being sorted in the background."	^ (aBoolean not and: [ self isSorted and: [ self sortIndex attribute = attributeSymbol ] ]) 		ifTrue: [ self ]		ifFalse: 			[ (self 				newReducedReaderOn: attributeSymbol				makeDistinct: aBoolean)				descending: shouldDescend ;				yourself ]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/13/2006 17:08'!sortComplete	^ self fractionSorted = 1! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/5/2007 15:58'!sortIndex	trunk ifNil: 		[ expression isClause 			ifTrue: [ ^ self indexNamed: expression attribute ]			ifFalse: [ self isNewCollection ifTrue: [ ^ nil ] ].		trunk := collection getTrunk: expression ].	^ trunk sortAttribute ifNotNilDo: [ : attribute | self indexNamed: attribute ]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 1/4/2010 09:57'!sortedBy: attributeSymbol makeDistinct: aBoolean 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately only after the sort has completed."	^ self 		sortedBy: attributeSymbol		makeDistinct: aBoolean		descending: false! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 1/4/2010 09:56'!sortedBy: attributeSymbol makeDistinct: aBoolean descending: shouldDescend 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately only after the sort has completed."	| answer |	answer := self 		sortBy: attributeSymbol		makeDistinct: aBoolean		descending: shouldDescend.	[ answer sortComplete ] whileFalse: [ (Delay forMilliseconds: 400) wait ].	^ answer! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 4/2/2012 20:24'!stopSorting	collection ifNotNil: [ collection stopLoading]! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 4/14/2005 23:08'!collection: aMagmaCollection	collection := aMagmaCollection.	self setUpListener! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 2/14/2008 13:09'!initialize	super initialize.	self pageSize: 125.	reversed := false! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 2/17/2008 22:04'!initializeSegments	trunk := nil.	"let's share the trunk"	segment := nil! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 4/1/2012 18:34'!release	self stopSorting! !!MagmaCollectionReader methodsFor: 'copying' stamp: 'brp 5/13/2005 19:52'!copyFrom: startIndex to: endIndex	^ (startIndex to: endIndex) collect: [ :i | self at: i ]! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 1/20/2013 17:33'!doesNotUnderstand: aMessage 	| clause |	clause := MagmaClause new		reader: self ;		attribute: aMessage selector ;		yourself.	self expression ifNil: [ self expression: clause ].	^ clause! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 12:54'!expression	^ expression! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 12/9/2014 14:45'!expression: aTerm 	aTerm ifNotNil: [ aTerm validateUsing: self ].	expression := aTerm! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:20'!normalize	self expression normalize! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:11'!read: attributeSymbol at: key	"Answers a MaLargeCollectionReader with access to all elements at key."	^ self		read: attributeSymbol		from: key		to: key! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: lowKey	"Answers a MaLargeCollectionReader with access to all of my elements after lowKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: lowKey)		toHash: index highestPossibleKey! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: startKey to: endKey	"Answers a MaLargeCollectionReader with access to all of my elements between startKey and endKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: startKey)		toHash: (index indexHashForIndexObject: endKey)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: startKey upTo: endKey      "Answers a MaLargeCollectionReader with access to all of my elements between startKey and endKey, but NOT including endKey.  This is useful with MaByteSequenceIndexDefinitions where you want to find all matching the left-side of a particular key."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: startKey)		toHash: ((index indexHashForIndexObject: endKey) - 1 max: 0)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol to: highKey	"Answers a MaLargeCollectionReader with access to all of my elements up to highKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: 0		toHash: (index indexHashForIndexObject: highKey)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 1/20/2013 17:33'!readIndex: aMagmaCollectionIndex fromHash: lowHashValue toHash: highHashValue 	"Answers a MaLargeCollectionReader."	| clause |	clause := MagmaClause new		reader: self ;		attribute: aMagmaCollectionIndex attribute ;		lowKey: lowHashValue ;		highKey: highHashValue ;		yourself.	self expression ifNil: [ self expression: clause ].	^ clause! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/16/2006 14:01'!fixUpExpression	expression reader: self! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/14/2006 15:35'!indexNamed: attributeSymbol	^ collection indexNamed: attributeSymbol! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/2/2009 14:33'!isLoaded	"Answer whether I have a page of objects loaded."	^ segment notNil! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/24/2014 15:33'!isLoaded: anInteger	"Answer whether I have the page of objects loaded which includes anInteger index."	^ segment notNil and: [ segment includesIndex: 1 ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/20/2008 12:01'!loadFromIndex: indexInteger pageSize: pageSizeInteger 	"we can simply integrate the non-persistents all into one dedicated page at the beginning?"	(self segmentContaining: indexInteger) ifNotNilDo: 		[ : desiredSegment | 		"if swapping to a different segment, save memory by clipping its objects."		(segment notNil and: [ segment ~= desiredSegment ]) ifTrue: [ segment initializeObjects ].		segment := desiredSegment.		collection isNewCollection ifFalse: 			[ self mergeChanges.			"If merging changes caused segments to shift enough where indexInteger is no longer part of the originally-retrieved segment, then re-retrieve it given that we now know which segment will contain it."			(self isFiltered and: [ segment notNil and: [ (segment includesIndex: indexInteger) not ] ]) 				ifTrue: 					[ self 						loadFromIndex: indexInteger						pageSize: pageSizeInteger ]				ifFalse: [ self stronglyReferencePage ] ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/17/2008 22:07'!localAdditionsSegment	"Only Filtered readers should have this."	^ nil! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 1/22/2015 19:21'!maTransientVariables 	^ #('trunk' 'segment' 'changesSegment' )! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/17/2008 11:13'!merge: oneArgBlock at: hashKey advance: anInteger 	self subclassResponsibility! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/18/2008 17:06'!mergeAddition: anObject at: hashKey 	"Fixup my segments by acknowledging that anObject exists in this reader at positions hashKeys.  If anObject is in the range of the active page (i.e., my 'segment'), then add it to its objects collection."	| sortNeeded |	sortNeeded := false.	self 		merge: 			[ : containingSegment | 			containingSegment == segment ifTrue: 				[ sortNeeded := true.				segment addObject: hashKey->anObject ] ]		at: hashKey		advance: 1.	^ sortNeeded! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 6/8/2006 16:13'!mergeChanges	self isSorted 		ifTrue: [ self mergeChangesSorted ]		ifFalse: [ self mergeChangesUnsorted ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/18/2008 23:44'!mergeChangesSorted	"I am sorted.  My segment may be populated with the desired segment, my segments are populated.  Merge in my collections changes, fixing up my segments as necessary."	| sortNeeded sortIndex |	sortNeeded := false.	sortIndex := self sortIndex.	collection changes additionsDo: 		[ : eachObject : eachHashes | 		(expression qualifyingHashesOf: eachObject) do: 			[ : eachAttributeAndHash | 			eachAttributeAndHash key = sortIndex attribute ifTrue: 				[ sortNeeded := sortNeeded | (self 						mergeAddition: eachObject						at: eachAttributeAndHash value) ] ] ].	sortNeeded ifTrue: [ segment sortObjects: expression ascendingSortBlock ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 10/13/2006 16:35'!newReducedReaderOn: attribute makeDistinct: aBoolean 	"Create a new MagmaCollection and install it on the server without going through the normal transaction process.  This is nothing more than a transient object that happens to require server support."	| newMc index |	index := self indexNamed: attribute.	newMc := MagmaCollection new.	newMc addIndex: index.	collection isNewCollection 		ifTrue: 			[ aBoolean 				ifTrue: [ self asSet do: [ : each | newMc add: each ] ]				ifFalse: [ self do: [ : each | newMc add: each ] ] ]		ifFalse: 			[ collection 				load: newMc				from: self				makeDistinct: aBoolean ].	^ newMc read: attribute! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 11/24/2009 14:26'!primAt: indexInteger ifOutOfBounds: aBlock 	"Interrogates the committed and uncommitted contents of the underlying collection."	^ indexInteger < 1 		ifTrue: aBlock		ifFalse: 			[ (self isLoaded and: [ segment includesIndex: indexInteger ]) 				ifTrue: 					[ segment 						at: indexInteger						ifAbsent: aBlock ]				ifFalse: 					[ self 						loadFromIndex: indexInteger						pageSize: pageSize.					(segment notNil and: [ segment includesIndex: indexInteger ]) 						ifTrue: 							[ segment 								at: indexInteger								ifAbsent: aBlock ]						ifFalse: aBlock ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/17/2008 12:05'!refreshSegment: aMagmaCollectionReaderSegment loadObjects: aBoolean 	self 		refreshSegment: aMagmaCollectionReaderSegment		loadObjects: aBoolean		pageSize: pageSize! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/18/2008 17:05'!refreshSegment: aMagmaCollectionReaderSegment loadObjects: aBoolean pageSize: anInteger 	aMagmaCollectionReaderSegment = self localAdditionsSegment ifFalse: 		[ collection 			refreshSegment: aMagmaCollectionReaderSegment			where: expression			pageSize: anInteger			using: (self session ifNotNil: [ self session resetReadStrategy ])			loadObjects: aBoolean ].	self trunk: aMagmaCollectionReaderSegment trunk.	self sortIndex ifNotNilDo: [ : sortIndex | aMagmaCollectionReaderSegment sortObjects: expression ascendingSortBlock ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 1/20/2010 12:52'!removeListener	| didTry |	didTry := false.	[ collection removeDependent: self ] 		on: Error		do: 			[ : err | 			"Bug in Squeak; sometimes it gets a 'Subscript out of bounds' when trying to remove from its own DependentsArray!!"			didTry ifFalse: 				[ (Delay forSeconds: 1) wait.				didTry := true.				err retry ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/17/2008 11:14'!segmentContaining: anInteger 	self subclassResponsibility! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/17/2008 11:15'!segmentSpanningKey: anInteger 	self subclassResponsibility! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/18/2002 15:44'!session	^collection session! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/14/2005 23:09'!setUpListener	"Whenever aMagmaCollection changes, we need to remerge its changes in with me."	collection addDependent: self! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 11/16/2004 22:57'!species	^ OrderedCollection! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/18/2008 17:11'!stronglyReferencePage	| session |	session := self session.	(session notNil and: [ session inTransaction and: [ segment notNil ] ]) ifTrue: [ session stronglyReference: segment objects value ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 2/14/2008 10:36'!trunk: aMaQueryTrunk 	trunk := aMaQueryTrunk.	"Share aMaQueryTrunk among all my segments."	segment ifNotNil: [ segment trunk: aMaQueryTrunk ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/2/2006 21:36'!update: addedOrRemovedSymbol	"My collection has had an object added or removed, I will now need to remerge its uncommitted contents into my segment."	self initializeSegments! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 14:56'!ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock valueWithPossibleArgument: self! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 14:57'!ifEmpty: emptyBlock ifNotEmptyDo: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	"Evaluate the notEmptyBlock with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock value: self! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 14:57'!ifNotEmpty: aBlock	"Evaluate the given block unless the receiver is empty.      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	self isEmpty ifFalse: [^ aBlock valueWithPossibleArgument: self].! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 14:56'!ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	 If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifFalse: [ ^notEmptyBlock valueWithPossibleArgument: self ].	^emptyBlock value! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 13:16'!ifNotEmptyDo: aBlock 	"Evaluate the given block with the receiver as its argument."	self isEmpty ifFalse: [ ^ aBlock value: self ]! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 14:57'!ifNotEmptyDo: notEmptyBlock ifEmpty: emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	Evaluate the notEmptyBlock with the receiver as its argument"	self isEmpty ifFalse: [ ^notEmptyBlock value: self ].	^emptyBlock value! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 4/14/2006 13:03'!includes: anObject	(collection includes: anObject) ifFalse: [ ^ false ].	^ expression evaluate: anObject! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/20/2011 18:08'!isEmpty	^ self lastKnownSize = 0! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 2/17/2008 21:22'!isFiltered	"Multiple conditions used in a #where: requires server-level filtering, which is slower than MagmaCollectionOptimizedReader's.  Answer whether my expression could not be optimized."	^ false! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 12:31'!isNewCollection	^ collection isNewCollection! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 2/27/2017 22:39'!isSequenceable	^ true! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 11/8/2004 18:42'!notEmpty	^ self isEmpty not! !!MagmaCollectionReader methodsFor: 'cached object access' stamp: 'cmm 9/13/2012 17:32'!indexOfCachedObject: anObject 	self segmentObjects withIndexDo:		[ : each : index | anObject = each value ifTrue: [ ^ index ] ].	^ 0! !!MagmaCollectionReader methodsFor: 'search' stamp: 'cmm 12/30/2010 19:43'!maNewSearchContext	^ (Smalltalk classNamed: #MagmaCollectionContext) reader: self! !!MagmaCollectionReader methodsFor: 'serialization' stamp: 'cmm 12/12/2010 20:00'!maWantsPostMaterialization 	^ true! !!MagmaCollectionReader methodsFor: '*magma-tester' stamp: 'cmm 7/4/2006 22:46'!sortBlock	^ self isDescending 		ifTrue: [ self sortIndex descendingSortBlock ]		ifFalse: [ self sortIndex ascendingSortBlock ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaCollectionReader class	instanceVariableNames: ''!!MagmaCollectionReader class methodsFor: 'class initialization' stamp: 'cmm 12/28/2015 14:46'!initialize	Smalltalk hasMaui ifTrue:		[ (Smalltalk classNamed: #MauiWorld) current registry			register: (Smalltalk classNamed: #MauiCollectionMorph)			forAny: self ]! !MagmaCollectionReader subclass: #MagmaCollectionFilteredReader	instanceVariableNames: 'segments localAdditionsSegment'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCollectionFilteredReader commentStamp: 'cmm 2/17/2008 11:06' prior: 0!A MagmaCollectionFilteredReader is the result of using a where: expression with more than one clause.  This requires more work for the software to keep track of the segment map.!!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/14/2008 10:37'!adjustLastKnownSize: anInteger 	(segments notEmpty and: [ segments last atEnd ]) ifTrue: [ segments last adjustLastKnownSize: anInteger ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 18:35'!getNextSegmentAndLoadIf: oneArgBlock	"Generate the next segment and, if oneArgBlock valued with it answers true, load objects into it too."	| toRefresh |	toRefresh := segments 		ifEmpty: 			[ (MagmaCollectionReaderSegment new)				startIndex: 1 ;				trunkStart: 1 ;				yourself ]		ifNotEmpty: [ segments last nextSegment ].	self 		refreshSegment: toRefresh		loadObjects: (oneArgBlock value: toRefresh).	"Return nil unless a new segment was created."	^ (segments isEmpty or: [ segments last ~= toRefresh ]) ifTrue: [ segments add: toRefresh ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 22:08'!localAdditionsSegment	^ localAdditionsSegment! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 1/22/2015 19:22'!maTransientVariables 	^ super maTransientVariables, #('segments' 'localAdditionsSegment')! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 15:39'!merge: oneArgBlock at: hashKey advance: anInteger 	| containingSegment |	containingSegment := self segmentSpanningKey: hashKey.	containingSegment ifNil: [ ^ self ].	oneArgBlock value: containingSegment.	containingSegment advanceEnd: anInteger.	self 		segmentsAfter: containingSegment		do: [ : eachSegment | eachSegment advanceStart: anInteger ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/14/2008 16:33'!mergeChangesSorted	self resetSegmentRanges.	super mergeChangesSorted! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 22:05'!mergeChangesUnsorted	"I am not sorted.  My segment is populated with the desired segment, my segments are populated.  Put my collections changes at the beginning, fixing up my subsequent segments as necessary."	localAdditionsSegment ifNil: [ self mergeChangesUnsortedAdditions ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/18/2008 17:26'!mergeChangesUnsortedAdditions	"I am not sorted.  My segment is populated with the desired segment, my segments are populated.  Put my collections changes at the beginning, fixing up my subsequent segments as necessary."	collection changes additionsDo: 		[ : eachObject : eachHashes | 		(expression qualifyingHashesOf: eachObject) do: 			[ : eachAttributeAndHash | 			localAdditionsSegment ifNil: 				[ segments addFirst: (localAdditionsSegment := MagmaCollectionReaderSegment new						startIndex: 1 ;						endIndex: 0 ;						trunk: trunk ;						yourself) ].			localAdditionsSegment				addObject: eachAttributeAndHash value -> eachObject ;				advanceEnd: 1.			self 				segmentsAfter: localAdditionsSegment				do: [ : each | each advanceStart: 1 ] ] ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/14/2008 10:37'!resetSegmentRanges	"Before each merge of local changes, my segments must be reset to indicate the page index ranges as they exist in the repository, otherwise, multiple page retrieves would continue to modify the index ranges when changes were merged (incorrectly).  My lastKnownSize must also be reset."	| totalMerged |	totalMerged := 0.	segments withIndexDo: 		[ : each : index | 		each = segments last ifTrue: [ totalMerged := each mergedCount ].		each			startIndex: (index - 1) * pageSize + 1 ;			endIndex: each startIndex + pageSize - 1 ;			resetMergedCount ].	self adjustLastKnownSize: totalMerged! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 18:32'!segmentContaining: anInteger 	"My expression is complex, an object at anInteger is being requested.  If I have previously loaded the segment containing anInteger, switch to it immediately from my cached 'segments'.  Otherwise, keep getting the next segment until we have the requested index."	| desiredSegment |	^ segments 		maDetect: [ : each | each includesIndex: anInteger ]		ifFound: 			[ : foundSegment | 			self 				refreshSegment: foundSegment				loadObjects: true.			foundSegment ]		ifNone: 			[ 			[ desiredSegment := self getNextSegmentAndLoadIf: 				[ : nextSeg | 				nextSeg endIndex isNil or: [ nextSeg includesIndex: anInteger ] ].			desiredSegment isNil or: [ (desiredSegment includesIndex: anInteger) or: [ desiredSegment atEnd ] ] ] whileFalse.			desiredSegment ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/17/2008 18:28'!segmentSpanningKey: anInteger 	^ segments 		detect: 			[ : each | 			(each isFitted and: [ anInteger <= each highestKey ]) or: [ each atEnd ] ]		ifNone: 			[ "If we didn't find the spanning segment, and we're not at the end, then lets move forward toward the end until we do.."			| desiredSegment |			[ desiredSegment := self getNextSegmentAndLoadIf: [ : nextSeg | false ].			desiredSegment isNil or: [ anInteger <= desiredSegment highestKey or: [ desiredSegment atEnd ] ] ] whileFalse.			(desiredSegment notNil and: [ anInteger <= desiredSegment highestKey ]) ifTrue: [ desiredSegment ] ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/14/2008 10:38'!segmentsAfter: aMagmaCollectionReaderSegment do: aBlock 	| foundIt |	foundIt := false.	segments do: 		[ : each | 		foundIt ifTrue: [ aBlock value: each ].		each = aMagmaCollectionReaderSegment ifTrue: [ foundIt := true ] ]! !!MagmaCollectionFilteredReader methodsFor: 'private' stamp: 'cmm 2/14/2008 10:36'!trunk: aMaQueryTrunk 	super trunk: aMaQueryTrunk.	segments do: [ : each | each trunk: aMaQueryTrunk ]! !!MagmaCollectionFilteredReader methodsFor: 'initialize-release' stamp: 'cmm 2/14/2008 13:09'!initialize	super initialize.	self initializeSegments! !!MagmaCollectionFilteredReader methodsFor: 'initialize-release' stamp: 'cmm 2/17/2008 22:04'!initializeSegments	super initializeSegments.	segments := OrderedCollection new.	localAdditionsSegment := nil! !!MagmaCollectionFilteredReader methodsFor: 'testing' stamp: 'cmm 2/17/2008 21:22'!isFiltered	"Multiple conditions used in a #where: requires server-level filtering, which is slower than MagmaCollectionOptimizedReader's.  Answer whether my expression could not be optimized."	^ true! !!MagmaCollectionFilteredReader methodsFor: 'testing' stamp: 'cmm 2/14/2008 10:35'!knowsSize	^ segments notEmpty and: [segments last atEnd]! !!MagmaCollectionFilteredReader methodsFor: 'accessing' stamp: 'cmm 2/17/2008 18:27'!lastKnownSize	| didLoad |	didLoad := false.	[ segments isEmpty or: [ segments last atEnd not ] ] whileTrue: 		[ self getNextSegmentAndLoadIf: [ : nextSeg | false ].		didLoad := true ].	didLoad ifTrue: [ collection isNewCollection ifFalse: [ self mergeChanges ] ].	^ segments last lastKnownSize! !MagmaCollectionReader subclass: #MagmaCollectionOptimizedReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 12/9/2014 14:44'!asFilteredReader	^ MagmaCollectionFilteredReader new		collection: collection ;		expression: expression ;		yourself! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/22/2009 18:46'!getSegmentContaining: anInteger withObjects: aBoolean 	| answer numberOfUncommitted pageStartIndex expandedPageSize |	numberOfUncommitted := self numberOfUncommittedInRange.	pageStartIndex := self isDescending 		ifTrue: 			[ "we're reversed, so as they populate their list and send at: 1, at: 2, at: 3, etc., it will cause a page-load every time, killing performance.  So invert the page-direction to backward rather than forward."			anInteger - (numberOfUncommitted max: pageSize - 1) max: 1 ]		ifFalse: [ anInteger - numberOfUncommitted max: 1 ].	"But we must also account for expanding the page in both directions of indexInteger by the numberOfUncommitted, so we can properly integrate the non-committeds."	expandedPageSize := self pageSize max: 2 * numberOfUncommitted.	answer := MagmaCollectionReaderSegment new		startIndex: pageStartIndex ;		trunkStart: pageStartIndex ;		yourself.	self 		refreshSegment: answer		loadObjects: aBoolean		pageSize: expandedPageSize.	^ (answer lastKnownSize = 0 or: [ answer includesIndex: pageStartIndex ]) ifTrue: [ answer ]! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/18/2008 23:50'!merge: oneArgBlock at: hashKey advance: anInteger 	| containingSegment |	containingSegment := self segmentSpanningKey: hashKey.	containingSegment 		ifNil: 			[ hashKey < segment lowestKey 				ifTrue: [ segment advanceStart: 1 ]				ifFalse: 					[ "We already know it doesn't span hashKey, but if it is beyond, then increment the lastKnownsize."					hashKey > segment highestKey ifTrue: [ segment advanceLastKnownSize: anInteger ] ] ]		ifNotNil: 			[ oneArgBlock value: containingSegment.			segment advanceEnd: anInteger ]! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/20/2008 10:18'!mergeChangesSorted	super mergeChangesSorted.	self mergeRemoved! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/20/2008 16:00'!mergeRemoved	collection changes removedDo: 		[ : eachObject : eachHashes | 		(expression qualifyingHashesOf: eachObject) do: 			[ : each | 			each value < segment lowestKey 				ifTrue: [ segment advanceStart: -1 ]				ifFalse: 					[ "The server already excluded removed from the result, and is accounted for everywhere except the lastKnownSize.  No need to retreat the endIndex.."					"segment advanceEnd: -1"					segment advanceLastKnownSize: -1 ] ] ]! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/17/2008 11:54'!numberOfUncommittedInRange	"This is used to modify the startingAt: of a page-access.  We slide the page left as many in-range as have been inserted prior to my current first key in the page so we can know whether those uncommitted keys should be merged into the resulting segment.  After sliding over, those uncommitted keys will either be part of the *middle* of the segment or not.  If they are still left of it then we must not merge them (unless the startIndex is 1, in which case we know we are at the beginning and so we can merge them).  Otherwise, if they are left of it but the startIndex is >1, we must not merge them (trim them) because the next-lower key on disk may still be higher than them."	| count indexPosition |	count := 0.	indexPosition := collection indexes indexOf: (collection indexNamed: expression attribute) .	collection changes additionsDo:		[ : eachObject : eachHashes |		count := count + 			((eachHashes at: indexPosition) count: 				[ : each | each between: expression lowKey and: expression highKey ]) ].	^ count! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/17/2008 15:11'!segmentContaining: anInteger 	"My expression is a single clause, therefore the server can immediately give me the segment containing anInteger.  But we must adjust the index being asked for according to the uncommitted adds that have occurred."	anInteger < 1 ifTrue: [ MagmaUserError signal: 'out of bounds' ].	^ (self isLoaded and: [ segment includesIndex: anInteger ]) 		ifTrue: [ segment ]		ifFalse: 			[ self 				getSegmentContaining: anInteger				withObjects: true ]! !!MagmaCollectionOptimizedReader methodsFor: 'private' stamp: 'cmm 2/20/2008 10:18'!segmentSpanningKey: anInteger 	"My expression is a single clause.  Answer my own segment if it spans anInteger, otherwise nil.  	If it doesn't span anInteger, but is at the beginning (trunkStart=1) then it is possible the user has inserted an uncomitted before the first committed, in which case we want to merge that.	Likewise, if the segment is butted up against the end of the persistent collection but the user has added a new object whose key is beyond the persistent end, answer my segment because it is mergeable."	^ ((segment includesKey: anInteger) 		or: [ (segment trunkStart = 1 and: [ anInteger < segment lowestKey ]) 		or: [ anInteger > segment highestKey and: [ segment atEndForOptimized ] ] ]) 		ifTrue: [ segment ]! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 4/18/2013 09:59'!cachedObjectAfter: anObject self maMarked: 'delete'.	self expression isClause ifFalse: [ ^ super cachedObjectAfter: anObject ].	^ (self segmentObjects		at: (self indexOfCachedObject: anObject) + 1		ifAbsent: [ nil ]) value! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 7/24/2014 13:21'!cachedObjectAfterKey: anObject 	| index |	index := self lastIndexOfCachedObjectAtOrBeforeKey: anObject.	^ index isZero ifFalse:		[ (self segmentObjects			at: index + 1			ifAbsent: [ ^ nil ]) value ]! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 7/12/2013 14:07'!cachedObjectAtKey: anObject 	^ (self segmentObjects		at: (self indexOfCachedObjectAtKey: anObject)		ifAbsent: [ ^ nil ]) value! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 4/18/2013 10:25'!cachedObjectBefore: anObject self maMarked: 'delete'.	self expression isClause ifFalse: [ ^ super cachedObjectBefore: anObject ].	^ (self segmentObjects		at: (self indexOfCachedObject: anObject) - 1		ifAbsent: [ nil ]) value! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 7/24/2014 13:23'!cachedObjectBeforeKey: anObject 	^ (self segmentObjects		at: (self firstIndexOfCachedObjectAtOrAfterKey: anObject) - 1		ifAbsent: [ ^ nil ]) value! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 7/24/2014 13:23'!firstIndexOfCachedObjectAtOrAfterKey: anObject 	"anObject is the key.  Answer its indexed position within the receivers colllection of cached objects or the index of the object with the next higher key."	| index hash |	index := self collection indexNamed: expression attribute.	hash := index indexHashForIndexObject: anObject.	^ self segmentObjects		ifEmpty: [ 0 ]		ifNotEmpty:			[ | nearestIndex |			nearestIndex := self segmentObjects findNearbyBinaryIndex:				[ : testedObject | | hashOfTested |				hashOfTested := testedObject key.				hash - hashOfTested ].			"findNearby gives the next *lower* index rather than the next higher, so unless anObject exists, we need the next one."			(nearestIndex				between: 1				and: self segmentObjects size)				ifTrue:					[ (self segmentObjects at: nearestIndex) key < hash						ifTrue: [ nearestIndex + 1 ]						ifFalse:							[ "In the face of duplicate keys walk backward to ensure we get the first."							[ nearestIndex > 1 and: [ (self segmentObjects at: nearestIndex - 1) key = hash ] ] whileTrue: [ nearestIndex := nearestIndex - 1 ].							nearestIndex ] ]				ifFalse: [ 0 ] ]! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 9/13/2012 17:32'!indexOfCachedObject: anObject 	self expression isClause ifFalse: [ ^ super indexOfCachedObject: anObject ].	^ self indexOfCachedObjectAtKey: ((self collection indexNamed: expression attribute) indexObjectFor: anObject)! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 11/20/2012 21:49'!indexOfCachedObjectAtKey: anObject 	| index hash |	index := self collection indexNamed: expression attribute.	hash := index indexHashForIndexObject: anObject.	^ self segmentObjects		findBinaryIndex:			[ : testedObject | hash - testedObject key ]		ifNone: [ 0 ]! !!MagmaCollectionOptimizedReader methodsFor: 'cached object access' stamp: 'cmm 7/24/2014 13:19'!lastIndexOfCachedObjectAtOrBeforeKey: anObject 	"anObject is the key.  It must already be IN RANGE of the receivers cached objects.  Answer the index of in my segmentObjects whose key is NOT AFTER anObject; e.g., at or before anObject.  In the case where there are multiple instances with key anObject, answer the index of the last one."	| index hash |	index := self collection indexNamed: expression attribute.	hash := index indexHashForIndexObject: anObject.	^ self segmentObjects		ifEmpty: [ 0 ]		ifNotEmpty:			[ | nearestIndex |			nearestIndex := self segmentObjects findNearbyBinaryIndex:				[ : testedObject | hash - testedObject key ].			(nearestIndex				between: 1				and: self segmentObjects size)				ifTrue:					[ [ nearestIndex < self segmentObjects size and: [ (self segmentObjects at: nearestIndex + 1) key = hash ] ] whileTrue: [ nearestIndex := nearestIndex + 1 ].					nearestIndex ]				ifFalse: [ 0 ] ]! !!MagmaCollectionOptimizedReader methodsFor: 'accessing' stamp: 'cmm 2/19/2008 10:24'!lastKnownSize	self isLoaded ifFalse: 		[ segment := self 			getSegmentContaining: 1			withObjects: true.		(segment notNil and: [ collection isNewCollection not ]) ifTrue: [ self mergeChanges ] ].	^ segment 		ifNil: [ 0 ]		ifNotNil: [ segment lastKnownSize ]! !MaObject subclass: #MagmaLargeCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 7/6/2006 22:39'!addAll: aCollection	aCollection do: [ : each | self add: each ].	^ aCollection! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 3/15/2005 23:09'!anyOne	^ self detect: [ : each | true ]! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 7/23/2011 14:19'!enumerationPageSize	"For enumeration, larger page-sizes make sense (vs. end-user browsing, where smaller page sizes of 50 make more sense), especially when throughput is more important than latency."	^ 1000! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 1/1/2008 17:22'!lastKnownSize	^ self size! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 8/12/2007 20:44'!occurrencesOf: anObject 	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:14'!size	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:05'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum := 0.	self do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].	^ sum! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 7/16/2006 14:27'!do: oneArgBlock 	self 		slowlyDo: oneArgBlock		pageBoundariesDo: [  ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!errorNotFound: anObject	MagmaUserError signal: 'Object is not in the collection.'! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:12'!maDo: aBlock while: conditionBlock	conditionBlock value ifFalse: [ ^ self ].	self do:		[ : each |		aBlock value: each.		conditionBlock value ifFalse: [ ^ self ] ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!reject: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:element | (aBlock value: element) == false]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/7/2011 11:35'!segmentsDo: oneArgBlock 	"Unlike other slowlyDo: methods, this method does not lock me, so while you can get a large 'sampling', if the collection is changed while I'm enumerating, there's no guarantee you'll reach every element."	| segment done index nextSignalTime |	done := false.	index := 1.	nextSignalTime := Time millisecondClockValue + 5000.	[ done ] whileFalse: 		[ segment := self 			segmentFromIndex: index			pageSize: self enumerationPageSize.		oneArgBlock value: segment.		Time millisecondClockValue > nextSignalTime ifTrue: 			[ MagmaNotification signal: (index - 1) printString , ' objects enumerated.'.			nextSignalTime := Time millisecondClockValue + 5000 ].		index := index + segment actualPageSize.		done := segment atEnd ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 7/22/2011 10:58'!slowlyDo: oneArgBlock pageBoundariesDo: aBlock 	"Unlike other enumeration methods, this method does not lock me, so while you can get a large 'sampling', if the collection is changed while I'm enumerating, there's no guarantee you'll reach every element."	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'brp 9/27/2011 07:00'!withIndexDo: elementAndIndexBlock 	| x |	x := 0.	self do: 		[ : each | 		elementAndIndexBlock 			value: each			value: (x := x + 1) ]! !!MagmaLargeCollection methodsFor: 'converting' stamp: 'brp 7/5/2005 10:05'!asArray	| all |	all := OrderedCollection new: self size.	self do: [ :each | all add: each ].	^ all asArray! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/12/2010 13:48'!ifEmpty: aBlock	"Evaluate the block if I'm empty"	self isEmpty ifTrue: [ ^ aBlock value ].	^ self! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 15:22'!ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	^ self isEmpty ifTrue: emptyBlock ifFalse: [notEmptyBlock valueWithPossibleArgument: self]! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 15:23'!ifNotEmpty: aBlock	"Evaluate the given block unless the receiver is empty.      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	^self isEmpty ifFalse: [aBlock valueWithPossibleArgument: self].! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 8/12/2007 20:44'!includes: anObject	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 4/5/2012 20:02'!isCollection	^ true! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 6/20/2011 18:08'!isEmpty	^ self lastKnownSize = 0! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 8/31/2010 22:25'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self isEmpty! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/15/2005 23:26'!notEmpty	^self isEmpty not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaLargeCollection class	instanceVariableNames: ''!!MagmaLargeCollection class methodsFor: 'as yet unclassified' stamp: 'cmm 4/5/2012 19:39'!withAll: aCollection	^ self new addAll: aCollection! !MagmaLargeCollection subclass: #MagmaCoreLargeCollection	instanceVariableNames: 'session changes'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCoreLargeCollection methodsFor: 'testing' stamp: 'cmm 3/17/2005 21:14'!canIndex: anObject	^ false! !!MagmaCoreLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 11:23'!isNewCollection	^ changes isNewCollection! !!MagmaCoreLargeCollection methodsFor: 'testing' stamp: 'cmm 3/28/2005 16:01'!maAllowsWriteBarrier 	"My changes are tracked through the MagmaLargeCollectionChanges mechanism."	^ false! !!MagmaCoreLargeCollection methodsFor: 'testing' stamp: 'cmm 7/22/2011 11:12'!maIsLargeCollection	"This method should be renamed, #maIsCoreLargeCollection."	^ true! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 3/17/2005 20:57'!changes	^ changes! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 5/6/2013 20:58'!changesClass	^ MagmaCollectionChanges! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 8/5/2011 13:27'!maTransientVariables 	"Large-collection changes are processed separately in the server, therefore they are stored separately in the commit-package, therefore, we mark them transient."	^ #( 'session' 'changes' )! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 3/17/2005 21:29'!maWantsPostMaterialization	"Needed to initialize my changes."	^ true! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 4/29/2005 12:51'!segmentFromIndex: startIndex pageSize: anInteger	"Answer a MaCollectionSegment."	^ self		segmentFromIndex: startIndex		pageSize: anInteger		using: (session ifNotNil: [session resetReadStrategy])! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 7/30/2006 13:55'!segmentFromIndex: startIndex pageSize: anInteger using: aMaReadStrategy 	"Answer a MaCollectionSegment."	^ self isNewCollection 		ifTrue: [ changes localSegment ]		ifFalse: 			[ session 				upTo: anInteger				objectsIn: self				fromIndex: startIndex				using: aMaReadStrategy ]! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:25'!session	^ session! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:25'!session: aMagmaSession	session := aMagmaSession! !!MagmaCoreLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:26'!setOid: anInteger	changes collectionOid: anInteger! !!MagmaCoreLargeCollection methodsFor: 'indexes' stamp: 'cmm 3/16/2005 13:59'!indexesDo: aBlock	"Some large-collections do not require indexes.  Do nothing by default."! !!MagmaCoreLargeCollection methodsFor: 'initialize' stamp: 'cmm 5/6/2013 21:01'!initialize	super initialize.	self initializeChangesUsing: self.	changes beNewCollection! !!MagmaCoreLargeCollection methodsFor: 'initialize' stamp: 'cmm 5/6/2013 21:00'!initializeChangesUsing: proxyOrMagmaCollection 	changes := self changesClass collection: proxyOrMagmaCollection! !!MagmaCoreLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 6/4/2007 10:09'!slowlyDo: oneArgBlock pageBoundariesDo: aBlock 	"Unlike other slowlyDo: methods, this method does not lock me, so while you can get a large 'sampling', if the collection is changed while I'm enumerating, there's no guarantee you'll reach every element."	self isNewCollection ifFalse: 		[ changes additionsDo: [ : eachObject : eachHashes | oneArgBlock value: eachObject ] ].	self segmentsDo: 		[ : each | 		each objects do: [ : eachObject | (changes hasRemoved: eachObject) ifFalse: [ oneArgBlock value: eachObject ] ].		aBlock value ]! !!MagmaCoreLargeCollection methodsFor: '*magma-server' stamp: 'cmm 8/12/2007 20:43'!implementationClass	self subclassResponsibility! !!MagmaCoreLargeCollection methodsFor: '*magma-server' stamp: 'cmm 3/16/2005 12:53'!newManagerUsing: aMagmaSession	self subclassResponsibility! !MagmaCoreLargeCollection subclass: #MagmaCollection	instanceVariableNames: 'indexes descriptions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaCollection commentStamp: 'cmm 5/28/2007 21:01' prior: 0!My 'descriptions', are a parallel OrderedCollection of MagmaIndexDescriptions to the indexes.  This is provided for the server so it doesn't have to have the MagmaCollectionIndex hierarchy loaded.  The server is concerned only with the Magma domain, not user-domain classes.!!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 2/1/2016 16:29'!add: anObject 	"Note that although a MagmaCollection can hold the same object more than once, it can only do so via separate commits."	changes		add: anObject		at: (indexes collect: [ : each | each indexHashesFor: anObject ]).	self changed: #added.	^ anObject! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 7/31/2002 00:15'!canAdd: anObject	^self canIndex: anObject! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 4/15/2005 16:18'!remove: anObject	changes		remove: anObject		at: (indexes collect: [ :each | each indexHashesFor: anObject ]).	self changed: #removed.	^ anObject! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 8/22/2012 20:47'!removeAll: aCollection 	aCollection do: [ : each | self remove: each ].	^ aCollection! !!MagmaCollection methodsFor: 'advanced' stamp: 'cmm 2/1/2016 16:29'!add: anObject alsoAt: indexableObject 	"anObject is known to NOT be committed as a member of this collection.  Ensure anObject is added to the receiver but use indexableObject to supply the index values to point to anObject in my indices.  Like #add:, anObject may only be added once per commit.	Note:  If both anObject and the receiver are already persistent in the repository, AND anObject is already a member of this collection, it will be added again.  It is the users responsibility to avoid this by using #index:alsoAt:."	changes		add: anObject		alsoAt: (indexes collect: [ : each | each indexHashesFor: indexableObject ])! !!MagmaCollection methodsFor: 'advanced' stamp: 'cmm 12/5/2014 14:29'!index: anObject alsoAt: indexableObject 	"anObject is an object known to be in this collection.  Now use indexableObject to supply its additional index values to point to anObject in my indices.	Note:  If anObjectis not a member of this collection, but is persistent elsewhere in the repository AND the receiver is persistent, then anObject will NOT be added as a member of the collection even though it would be indexed at values of indexableObject.  That is an abnormal situation the user is responsible to avoid this by using #add:alsoAt:, if necessary."	(session notNil and: [ session isPersistent: anObject ])		ifTrue:			[ indexes do:				[ : eachIndex | changes					add: (session oidFor: anObject)					at: (eachIndex indexHashesFor: indexableObject)					toIndexForAttribute: eachIndex attribute ] ]		ifFalse:			[ self				add: anObject				alsoAt: indexableObject ]! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 9/28/2008 13:44'!addIndex: aMagmaCollectionIndex 	(self hasIndexNamed: aMagmaCollectionIndex attribute) ifTrue: 		[ MagmaUserError signal: 'You already have an index on ' , aMagmaCollectionIndex attribute ].	self isNewCollection ifFalse: [ self lock ].	indexes add: aMagmaCollectionIndex.	aMagmaCollectionIndex asDescription in: 		[ : desc | 		changes addIndex: desc.		descriptions add: desc ]! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 2/22/2004 19:21'!canIndex: anObject	^indexes allSatisfy: [ :each | each canIndex: anObject ]! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 5/31/2005 13:31'!hasIndexNamed: attributeSymbol	^ indexes anySatisfy: [ : each | each attribute = attributeSymbol ]! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 2/1/2005 22:49'!indexNamed: attributeSymbol	^indexes		detect: [ :each | each attribute = attributeSymbol ]		ifNone: [ MagmaUserError signal: attributeSymbol , ' is not an indexed attribute' ]! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 6/23/2007 17:08'!removeIndexNamed: attributeSymbol 	self lock.	changes removeIndexNamed: attributeSymbol.	indexes remove: (indexes detect: [ : each | each attribute = attributeSymbol ]).	descriptions remove: (descriptions detect: [ : each | each attribute = attributeSymbol ])! !!MagmaCollection methodsFor: 'converting' stamp: 'cmm 10/1/2006 23:35'!asArray: anInteger	| answer x size |	answer := Array new: (size := (self size min: anInteger)).	x := 1.	self		maDo: [ : each | answer at: x put: each. x := x + 1 ]		while: [ x <= size ].	^ answer! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 11/8/2006 00:10'!beNotPersistent	changes beNotPersistent ! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 11/15/2008 17:39'!buildIndexes: aCollection ignoring: objectOidsAlreadyIndexed 	"aCollection of MaIndexDefinitions."	MagmaNotification signal: 'About to build ' , aCollection size printString , ' indexes.'.	session begin.	self segmentsDo: 		[ : each | 		[ each objects do: 			[ : eachObject | 			| oid |			oid := session oidFor: eachObject.			(MaOidCalculator isOidForNewObject: oid) ifTrue: [ MagmaSoftwareError signal: 'expected a persistent object' ].			(objectOidsAlreadyIndexed includes: oid) ifFalse: 				[ aCollection do: 					[ : eachIndex | 					changes 						add: oid						at: (eachIndex indexHashesFor: eachObject)						toIndexForAttribute: eachIndex attribute ] ] ].		session commitAndBegin ] 			on: MagmaCommitConflictError			do: 				[ : err | 				changes resetNewIndexValues.				err retry ] ].	[ session commit ] 		on: MagmaCommitConflictError		do: [ : err | err retry ].	self commitUnlock.	MagmaNotification signal: 'Indexes built.'! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:44'!commitUnlock	[ session commit: [ self unlock ] ]		on: MagmaCommitError		do:			[ :error |			error messageText:				error messageText,				'Abnormal condition.  The enumeration completed, but your session was unable to unlock the collection.  No one can update the collection until it is unlocked.  ' ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 8/6/2006 20:55'!getTrunk: aMaTerm 	^ session 		getTrunkFor: self		expression: aMaTerm! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/18/2002 15:05'!indexes	^indexes! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 10/16/2006 11:08'!load: aMagmaCollection from: aMagmaCollectionReader makeDistinct: aBoolean 	"reset aMagmaCollection changes only to set isNewCollection false, because that really means 'is local collection', and we need it to go to the server for its contents.."	session 		load: aMagmaCollection		from: aMagmaCollectionReader		makeDistinct: aBoolean.	aMagmaCollection changes reset.	changes additionsDo: 		[ : eachObject : eachHash | 		(aMagmaCollectionReader expression evaluate: eachObject) ifTrue: [ aMagmaCollection add: eachObject ] ].	changes removedDo: 		[ : eachObject : eachHash | 		(aMagmaCollectionReader expression evaluate: eachObject) ifTrue: [ aMagmaCollection remove: eachObject ] ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:21'!lock	changes setLocked: true! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/30/2006 10:45'!refreshSegment: aMagmaCollectionReaderSegment where: aMaTerm pageSize: anInteger using: aMaReadStrategy loadObjects: aBoolean 	"Answer a MagmaCollectionSegment."	self isNewCollection 		ifTrue: 			[ changes 				refreshSegment: aMagmaCollectionReaderSegment				where: aMaTerm ]		ifFalse: 			[ "if refreshing the local 'segment' it will have its old page of objects, clear it out."			aMagmaCollectionReaderSegment initializeObjects.			session 				refreshSegment: aMagmaCollectionReaderSegment				of: self				where: aMaTerm				pageSize: anInteger				using: aMaReadStrategy				loadObjects: aBoolean ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 11/16/2004 23:09'!species	^ Bag! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:22'!unlock	changes setLocked: false! !!MagmaCollection methodsFor: 'enumerating' stamp: 'cmm 5/28/2007 21:19'!descriptionsDo: aBlock	descriptions do: aBlock! !!MagmaCollection methodsFor: 'enumerating' stamp: 'cmm 10/1/2004 14:43'!indexesDo: aBlock	indexes do: aBlock! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 7/26/2006 20:26'!fractionLoaded	^ self isNewCollection 		ifTrue: [ 1 ]		ifFalse: [ session fractionLoaded: self ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 9/28/2008 21:38'!locker	"Answer the MagmaClientConnection that has this collection locked or nil if it's not locked."	^ self isNewCollection ifFalse: [ session lockerOf: self ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 2/17/2008 11:09'!newReader	^ MagmaCollectionOptimizedReader new		collection: self ;		yourself! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 12/7/2004 13:44'!occurrencesOf: anObject	| newOccurrences |	newOccurrences := changes occurrencesOf: anObject.	(session isNil or:		[ (session isPersistent: anObject) not or: [ (session isPersistent: self) not ] ])			ifTrue:				[ ^newOccurrences ].	^(session		occurrencesOf: anObject		in: self) + newOccurrences! !!MagmaCollection methodsFor: 'accessing' stamp: 'brp 7/18/2006 20:11'!read: attributeSymbol	"Answers a MaLargeCollectionReader ordered on attributeSymbol"	^ self read: attributeSymbol descending: false! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 2/14/2008 13:13'!read: attributeSymbol descending: aBoolean 	"Answers a MaLargeCollectionReader ordered on attributeSymbol"	| index reader |	index := self indexNamed: attributeSymbol.	reader := self newReader.	reader 		readIndex: index		fromHash: index lowestPossibleKey		toHash: index highestPossibleKey.	reader descending: aBoolean.	^ reader! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:14'!size	^ session isNil		ifTrue:			[ changes deltaSize ]		ifFalse:			[ (session sizeOfLargeCollection: self) + changes deltaSize ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 7/23/2011 17:59'!stopLoading	self session ifNotNil:		[ : sess | sess stopLoading: self ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 2/14/2008 13:14'!where: aBlock 	| reader |	reader := self newReader.	aBlock value: reader.	^ reader normalize! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 8/8/2006 11:07'!where: aBlock distinct: makeDistinct sortBy: attributeSymbol descending: shouldDescend 	^ ((self where: aBlock)		sortBy: attributeSymbol makeDistinct: makeDistinct)		descending: shouldDescend ;		yourself! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 8/7/2006 22:06'!where: aBlock distinct: makeDistinct sortedBy: attributeSymbol descending: shouldDescend 	| answer |	answer := self 		where: aBlock		distinct: makeDistinct		sortBy: attributeSymbol		descending: shouldDescend.	[ answer sortComplete ] whileFalse: [ (Delay forMilliseconds: 400) wait ].	^ answer! !!MagmaCollection methodsFor: 'testing' stamp: 'cmm 12/7/2004 13:44'!includes: anObject	(changes includesObject: anObject) ifTrue: [ ^true ].	session isNil ifTrue: [ ^false ].	^(self occurrencesOf: anObject) > 0! !!MagmaCollection methodsFor: 'testing' stamp: 'cmm 9/28/2008 21:38'!isLocked	^ self locker notNil! !!MagmaCollection methodsFor: 'initializing' stamp: 'cmm 5/30/2007 22:38'!initialize	super initialize.	indexes := OrderedCollection new.	descriptions := OrderedCollection new! !!MagmaCollection methodsFor: 'validating' stamp: 'cmm 2/1/2005 23:48'!validateCanAdd: anObject	(self canIndex: anObject) ifFalse: [		MagmaUserError signal:			anObject printString , ' cannot be added to ' , self printString ,			' because it does not support all of the indexable attributes.' ]! !!MagmaCollection methodsFor: '*magma-server' stamp: 'cmm 7/12/2005 12:52'!implementationClass	^ MaHashIndex! !!MagmaCollection methodsFor: '*magma-server' stamp: 'cmm 3/17/2005 21:31'!newManagerUsing: aMaObjectRepository	^ (MagmaCollectionManager		collection: self		repository: aMaObjectRepository)			oidOfIndexesCollection: (aMaObjectRepository session oidFor: self indexes) ;			yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaCollection class	instanceVariableNames: ''!!MagmaCollection class methodsFor: 'initialize-release' stamp: 'cmm 12/28/2015 14:45'!initialize	Smalltalk hasMaui ifTrue:		[ (Smalltalk classNamed: #MauiWorld) current registry			register: (Smalltalk classNamed: #MauiCollectionMorph)			forAny: self ]! !MagmaCollection subclass: #MagmaSet	instanceVariableNames: 'equivalenceAttributes'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaSet commentStamp: 'cmm 4/11/2011 16:25' prior: 0!NOTE:  This class is deprecated.  Please migrate to the new MagmaDictionary.Implement simple Set functionality for MagmaCollections.!!MagmaSet methodsFor: 'add / remove' stamp: 'cmm 2/16/2015 20:35'!add: anObject 	(self includes: anObject)		ifTrue: [ MagmaDuplicateObjectInCollection signal: anObject printString , ' cannot be added to ' , self printString ]		ifFalse: [ super add: anObject ]! !!MagmaSet methodsFor: 'add / remove' stamp: 'cmm 7/30/2007 21:25'!remove: anObject 	^ (self equivalentOf: anObject) in: 		[ : equivalent | 		equivalent 			ifNotNil: [ super remove: equivalent ]			ifNil: 				[ MagmaEquivalentObjectNotInCollection signal: anObject printString , ' is not in ' , self printString ] ]! !!MagmaSet methodsFor: 'private' stamp: 'cmm 5/6/2013 20:58'!changesClass	^ MagmaSetChanges! !!MagmaSet methodsFor: 'private' stamp: 'cmm 7/19/2010 16:33'!newReader	^ MagmaSetReader new		collection: self ;		yourself! !!MagmaSet methodsFor: 'private' stamp: 'cmm 7/16/2010 15:27'!readerFor: anObject 	^ self where:		[ : rdr | | nextTerm attr |		attr := equivalenceAttributes first.		nextTerm := rdr			read: attr			at: (anObject perform: attr).		(equivalenceAttributes copyWithout: equivalenceAttributes first) do:			[ : each | nextTerm &				(rdr					read: each					at: (anObject perform: each)) ] ]! !!MagmaSet methodsFor: 'initializing' stamp: 'cmm 7/18/2006 21:41'!equivalenceAttributes: anArray 	"Optimize my searches for equivalence objects by specifying which of my indexes can be used to minimize the set of unique instances."	equivalenceAttributes := anArray! !!MagmaSet methodsFor: 'initializing' stamp: 'cmm 8/16/2006 22:29'!initialize	super initialize.	equivalenceAttributes := #()! !!MagmaSet methodsFor: 'testing' stamp: 'cmm 7/19/2010 16:08'!equivalentOf: anObject 	"Answer the object in me equivalent to anObject."	equivalenceAttributes isEmpty ifTrue: [ MagmaUserError signal: 'MagmaSets are not practical without at least one equivalenceAttribute defined.' ].	(changes objectEqualTo: anObject) ifNotNilDo: [ : obj | ^ obj ].	(changes removed includesKey: anObject) ifTrue: [ ^ nil ].	self isNewCollection ifTrue: [ ^ nil ].	(self canIndex: anObject) ifFalse: [ ^ nil ].	^ (self readerFor: anObject)		detect: [ : each | each = anObject ]		ifNone: [ nil ]! !!MagmaSet methodsFor: 'testing' stamp: 'cmm 7/12/2006 23:48'!includes: anObject 	^ (self equivalentOf: anObject) notNil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaSet class	instanceVariableNames: ''!!MagmaSet class methodsFor: 'create' stamp: 'cmm 7/18/2006 22:35'!equivalenceAttributes: anArray	"anArray specifies the attributes to optimize the lookup for equivalent objects."	^ self new		equivalenceAttributes: anArray ;		yourself! !!MagmaSet class methodsFor: 'private' stamp: 'cmm 7/17/2010 11:20'!indexOnHash	^ (MaIntegerIndex attribute: #hash32)		keySize: 32 ;		yourself! !MagmaSet subclass: #MagmaOldDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaCollections'!!MagmaOldDictionary commentStamp: 'cmm 7/16/2010 17:31' prior: 0!This is a MagmaCollection of MagmaDictionaryAssociations.  A MagmaDictionaryAssociations is the same as a regular association, except we can find it merely by its key.When a MagmaDictionaryAssociation is added, it is indexed by its #key.!!MagmaOldDictionary methodsFor: 'add / remove' stamp: 'apg 4/25/2005 14:42'!add: anAssociation	self validateCanAdd: anAssociation.	changes		add: anAssociation		at: (indexes collect: [ :each | each indexHashesFor: anAssociation key ]).	^ anAssociation! !!MagmaOldDictionary methodsFor: 'add / remove' stamp: 'cmm 7/16/2010 16:09'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new entry for key and set is value to anObject. Answer anObject."	(self scanFor: key)		ifNil:			[ self add:				(MagmaDictionaryAssociation					key: key					value: anObject) ]		ifNotNilDo: [ : assoc | assoc value: anObject ].	^ anObject! !!MagmaOldDictionary methodsFor: 'add / remove' stamp: 'cmm 7/15/2010 21:42'!remove: anAssociation	self shouldNotImplement! !!MagmaOldDictionary methodsFor: 'add / remove' stamp: 'apg 4/21/2005 17:21'!removeKey: key 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self removeKey: key ifAbsent: [self errorKeyNotFound]! !!MagmaOldDictionary methodsFor: 'add / remove' stamp: 'apg 4/25/2005 14:49'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	^ (self scanFor: key)		ifNil: [ aBlock value ]		ifNotNilDo: [ :assoc | self remove: assoc ]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:24'!associationAt: key 	^ self associationAt: key ifAbsent: [self errorKeyNotFound]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/25/2005 14:00'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^ (self scanFor: key) ifNil: [ aBlock value ]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:26'!associations	"Answer a Collection containing the receiver's associations."	| out |	out := WriteStream on: (Array new: self size).	self associationsDo: [:value | out nextPut: value].	^ out contents! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:26'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/25/2005 14:00'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	^ (self scanFor: key)			ifNil: [ aBlock value ] ifNotNilDo: [ :assoc | assoc value ]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:27'!at: key ifAbsentPut: aBlock 	"Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self at: key put: aBlock value]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:27'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. 	If it is present, answer the value of evaluating the given block 	with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'cmm 10/28/2011 15:54'!at: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock 	^ oneArgBlock value:		(self			at: anObject			ifAbsent: [ ^ zeroArgBlock value ])! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:27'!keyAtValue: value 	"Answer the key that is the external name for the argument, value. If 	there is none, answer nil."	^ self keyAtValue: value ifAbsent: [self errorValueNotFound]! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:28'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	Use =, not ==, so strings like 'this' can be found." 	self associationsDo: 		[ :association | value = association value ifTrue: [^association key] ].	^ exceptionBlock value! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:28'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := Set new: self size.	self keysDo: [ :key | aSet add: key ].	^ aSet! !!MagmaOldDictionary methodsFor: 'accessing' stamp: 'apg 4/21/2005 17:28'!values	"Answer a Collection containing the receiver's values."	| out |	out := WriteStream on: (Array new: self size).	self valuesDo: [ :value | out nextPut: value ].	^ out contents! !!MagmaOldDictionary methodsFor: 'enumerating' stamp: 'cmm 7/23/2010 10:20'!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value associations)."	self 		slowlyDo: aBlock		pageBoundariesDo: [  ]! !!MagmaOldDictionary methodsFor: 'enumerating' stamp: 'cmm 7/23/2010 10:17'!do: aBlock	self valuesDo: aBlock! !!MagmaOldDictionary methodsFor: 'enumerating' stamp: 'apg 4/21/2005 17:20'!keysAndValuesDo: aBlock	^ self associationsDo: [ :assoc | aBlock value: assoc key value: assoc value ].! !!MagmaOldDictionary methodsFor: 'enumerating' stamp: 'apg 4/21/2005 17:20'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [ :association | aBlock value: association key]! !!MagmaOldDictionary methodsFor: 'enumerating' stamp: 'apg 4/21/2005 17:21'!valuesDo: aBlock 	"Evaluate aBlock for each of the receiver's values."	self associationsDo: [ :association | aBlock value: association value ]! !!MagmaOldDictionary methodsFor: 'private' stamp: 'apg 4/21/2005 17:18'!errorKeyNotFound	self error: 'key not found'! !!MagmaOldDictionary methodsFor: 'private' stamp: 'apg 4/21/2005 17:18'!errorValueNotFound	self error: 'value not found'! !!MagmaOldDictionary methodsFor: 'private' stamp: 'cmm 7/16/2010 17:01'!scanFor: anObject 	"Answer the Association keyed by anObject or nil"	^ self equivalentOf: (MagmaDictionaryAssociation key: anObject)! !!MagmaOldDictionary methodsFor: 'testing' stamp: 'cmm 7/15/2010 21:40'!includes: anObject 	(changes includesObject: anObject) ifTrue: [ ^ true ].	session isNil ifTrue: [ ^ false ].	self do:		[ : each | each = anObject ifTrue: [ ^ true ] ].	^ false! !!MagmaOldDictionary methodsFor: 'testing' stamp: 'apg 4/21/2005 17:23'!includesAssociation: anAssociation	^ (self   		associationAt: anAssociation key		ifAbsent: [ ^ false ]) value = anAssociation value! !!MagmaOldDictionary methodsFor: 'testing' stamp: 'apg 4/21/2005 17:23'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."		self at: key ifAbsent: [^false].	^ true! !!MagmaOldDictionary methodsFor: 'validating' stamp: 'cmm 7/15/2010 21:37'!validateCanAdd: anAssociation 	anAssociation maIsAssociation ifFalse: [ MagmaUserError signal: 'When using #add: with a Dictionary, it must be an Association.' ].	(equivalenceAttributes allSatisfy:		[ : each | anAssociation key respondsTo: each ]) ifFalse: [ MagmaUserError signal: anAssociation printString , ' cannot be added to ' , self printString , ' because its key does not respond to all of the indexed attributes.' ].	(self canIndex: anAssociation key) ifFalse: [ MagmaUserError signal: anAssociation printString , ' cannot be added to ' , self printString , ' because its key does not support all' , ' of the indexable attributes.' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaOldDictionary class	instanceVariableNames: ''!!MagmaOldDictionary class methodsFor: 'create' stamp: 'cmm 7/16/2010 16:47'!equivalenceAttributes: anArray	self error: 'Only supported for MagmaSet''s, not MagmaDictionarys''s'! !!MagmaOldDictionary class methodsFor: 'create' stamp: 'cmm 7/17/2010 11:18'!new	^ super new		equivalenceAttributes: #(#hash32 ) ;		addIndex: self indexOnHash ;		yourself! !MagmaCollectionReader initialize!MagmaCollection initialize!