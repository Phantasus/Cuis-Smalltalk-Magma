MaObject subclass: #MaBasicReadStrategy	instanceVariableNames: 'minimumDepth isNew'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaBasicReadStrategy commentStamp: '<historical>' prior: 0!This class operates on the client and server.!!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 23:53'!beNew	"Be in a state that indicates I have changed and am different than my cached version on the server."	isNew := true! !!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 14:55'!beOld	"Indicate that I have been checked against my classDefinitions and all possible depthSpecifications have been converted to the required server format (id's instead of classes)."	isNew := false! !!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 23:53'!isNew	"Answer whether I have changed and now need to be cached in my session on the server."	^isNew! !!MaBasicReadStrategy methodsFor: 'copying' stamp: 'cmm 2/8/2005 23:03'!copyWithoutSpecifications	^ self copy! !!MaBasicReadStrategy methodsFor: 'private' stamp: 'cmm 8/8/2006 22:59'!initialize	super initialize.	isNew := true.	minimumDepth := 1! !!MaBasicReadStrategy methodsFor: 'accessing' stamp: 'cmm 4/7/2005 15:14'!isBasic	^ true! !!MaBasicReadStrategy methodsFor: 'accessing'!minimumDepth	^minimumDepth! !!MaBasicReadStrategy methodsFor: 'building' stamp: 'cmm 1/26/2005 00:02'!makeReadyForUseUsing: aMaClassIdManager	"nothing to do for MaBasicReadStrategy's."! !!MaBasicReadStrategy methodsFor: 'building' stamp: 'cmm 1/25/2005 23:52'!minimumDepth: anInteger	minimumDepth := anInteger.	self beNew! !!MaBasicReadStrategy methodsFor: '*magma-server' stamp: 'cmm 1/26/2005 17:28'!depthOfAttribute: attributeIndex onClassWithId: classId version: versionNumber	"Answer the delta-depth from the current depth to read.  This is distinct from my minimumDepth, which was used at the start of this graph-read."	^ 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaBasicReadStrategy class	instanceVariableNames: ''!!MaBasicReadStrategy class methodsFor: 'creation'!deep	^self minimumDepth: 99999! !!MaBasicReadStrategy class methodsFor: 'creation'!minimumDepth: anInteger	^self new minimumDepth: anInteger! !MaObject subclass: #MaChangedKeySpecification	instanceVariableNames: 'object attribute oldHashValues newHashValues'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaChangedKeySpecification methodsFor: 'accessing'!attribute	^attribute! !!MaChangedKeySpecification methodsFor: 'accessing' stamp: 'cmm 12/5/2002 17:54'!newHashValues	^newHashValues! !!MaChangedKeySpecification methodsFor: 'accessing'!object	^object! !!MaChangedKeySpecification methodsFor: 'accessing'!oid	^object! !!MaChangedKeySpecification methodsFor: 'accessing' stamp: 'cmm 12/5/2002 17:54'!oldHashValues	^oldHashValues! !!MaChangedKeySpecification methodsFor: 'private building'!attribute: aSymbol	attribute := aSymbol! !!MaChangedKeySpecification methodsFor: 'private building' stamp: 'cmm 12/5/2002 18:00'!newHashValues: anArray	newHashValues := anArray! !!MaChangedKeySpecification methodsFor: 'private building'!object: anObject	object := anObject! !!MaChangedKeySpecification methodsFor: 'private building' stamp: 'cmm 12/5/2002 18:00'!oldHashValues: anArray	oldHashValues := anArray! !!MaChangedKeySpecification methodsFor: 'building' stamp: 'cmm 11/19/2002 22:42'!serializeUsing: aMaObjectSerializer	object := aMaObjectSerializer oidFor: object! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaChangedKeySpecification class	instanceVariableNames: ''!!MaChangedKeySpecification class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:19'!object: anObject attribute: aSymbol oldHashValues: oldHashValueInteger newHashValues: newHashValueInteger	^self new		object: anObject ;		attribute: aSymbol ;		oldHashValues: oldHashValueInteger ;		newHashValues: newHashValueInteger ;		yourself! !MaObject subclass: #MaCommitPackage	instanceVariableNames: 'objects allLargeCollectionChanges'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaCommitPackage commentStamp: 'cmm 3/8/2005 09:41' prior: 0!This class represents all of the changes made from a single client for a single transaction.!!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 8/13/2007 21:58'!addLargeCollectionChanges: aMagmaLargeCollectionChanges	^ self allLargeCollectionChanges add: aMagmaLargeCollectionChanges! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 4/5/2005 21:38'!allLargeCollectionChanges	^ allLargeCollectionChanges ifNil: [ allLargeCollectionChanges := Set new ]! !!MaCommitPackage methodsFor: 'accessing'!objects	^objects! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 10/16/2006 12:34'!objects: aMaSerializedGraphBuffer	objects := aMaSerializedGraphBuffer! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 11/26/2012 16:46'!sizeself maMarked: 'delete'.	^objects size! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 8/19/2007 20:41'!addLargeCollectionChanges: aMaLargeCollectionChanges using: aMagmaSession	"Add a copy of the changes instead of the originals because each serialization mutates the changes from first-class objects into oids."	self addLargeCollectionChanges: aMaLargeCollectionChanges copyForSerialization.	"Make sure we get new objects that may only be referenced by a LargeCollection."	aMaLargeCollectionChanges		addNewAdditionsTo: self		using: aMagmaSession! !!MaCommitPackage methodsFor: 'building'!addObject: anObject	^objects add: anObject! !!MaCommitPackage methodsFor: 'building'!allLargeCollectionChanges: aSet	allLargeCollectionChanges := aSet! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 3/27/2005 20:52'!removeObject: anObject	objects		remove: anObject		ifAbsent: [ "no problem" ]! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 10/31/2018 15:53'!serializeObjectsUsing: aMagmaSession 	"Serialize my 'objects' into a MaSerializedGraphBuffer since the server does not deal with objects, just their buffers."	| mustReserialize serializer numberOfClassesBefore |	serializer := aMagmaSession serializer.	numberOfClassesBefore := serializer classIdManager numberOfClasses.	mustReserialize := false.		[ objects := serializer 		serializeGraph: objects		do: 			[ : each | 			"Determine if class definition of each has changed."			(serializer classIdManager hasClassDefinitionFor: each maSerializationClass) ifFalse: 				[ mustReserialize := true.				serializer classIdManager assimilateInImageDefinition: each maSerializationClass ].			(each maIsLargeCollection and: 				[ self allLargeCollectionChanges noneSatisfy: [ : eachChanges | eachChanges collectionOid = each changes collectionOid ] ]) ifTrue: 				[ mustReserialize := mustReserialize or: [ (aMagmaSession isMonitoringLargeCollection: each) not ].				aMagmaSession monitorLargeCollection: each ].			each isSymbol ifTrue: 				[ mustReserialize := (aMagmaSession definition symbols ifAbsentAdd: each) or: [mustReserialize] ].			each isMagmaId ifTrue: 				[ | canonicalizedId |				(aMagmaSession definition hasCanonicalizedMagmaId: each) ifFalse: [ mustReserialize := true ].				canonicalizedId := aMagmaSession definition ensureCanonicalizedMagmaId: each.				canonicalizedId ~~ each realObjectIfMutatingProxy ifTrue: 					[ "This only occurs when an application creates mulitple ForwardingProxy instances to remote objects in another repository.  We want every equivalent instance in the model replaced with THE canoncalized one in the RepositoryDefinition so node updates are seen by all."					serializer cleanObject: each.					each 						becomeForward: canonicalizedId						copyHash: false.					mustReserialize := true ] ] ] ] 		on: MaTraverseProxyNotification		do: 			[ : error | 			error proxy mutatingProxySession = aMagmaSession 				ifTrue: [ error resume ]				ifFalse: 					[ MagmaSoftwareError signal: 'You should only share copies, not the same instances, across sessions.' ] ].	self serializeLargeCollectionsChangesUsingCopyOf: serializer.	^ mustReserialize or: [ serializer classIdManager numberOfClasses > numberOfClassesBefore ]! !!MaCommitPackage methodsFor: 'enumerate' stamp: 'cmm 4/5/2005 21:39'!allLargeCollectionChangesDo: aBlock	allLargeCollectionChanges ifNotNil: [ allLargeCollectionChanges do: aBlock ]! !!MaCommitPackage methodsFor: 'enumerate' stamp: 'cmm 1/15/2007 15:35'!newIndexesDo: oneArgBlock	"For all largeCollections that have had one or more indexes added on this	transaction, evaluate oneArgBlock with the instance of MagmaCollectionChanges that hasAddedIndexes."	self allLargeCollectionChangesDo:		[ :eachChanges |		eachChanges hasAddedIndexes			ifTrue:				[ oneArgBlock value: eachChanges ] ]! !!MaCommitPackage methodsFor: 'enumerate'!newObjectsDo: aBlock	"This can only be used after the receiver has serialialized his objects	(via #serializeObjectsUsing:)."	| isRootBuffer |	"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."	isRootBuffer := true.	objects buffersDo:		[ :each |		isRootBuffer			ifTrue:				[ isRootBuffer := false ]			ifFalse:				[ (MaOidCalculator isOidForNewObject: each oid) ifTrue: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'enumerate' stamp: 'cmm 12/19/2002 23:25'!objectsDo: aBlock	objects isCollection		ifTrue:			[ objects do: aBlock ]		ifFalse:			[ | isRootBuffer |			"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."			isRootBuffer := true.			objects buffersDo:				[ :each |				isRootBuffer ifTrue: [ isRootBuffer := false ] ifFalse: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'enumerate'!persistentObjectsDo: aBlock	"This can only be used after the receiver has serialialized his objects	(via #serializeObjectsUsing:)."	| isRootBuffer |	"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."	isRootBuffer := true.	objects buffersDo:		[ :each |		isRootBuffer			ifTrue:				[ isRootBuffer := false ]			ifFalse:				[ (MaOidCalculator isOidForNewObject: each oid) ifFalse: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'enumerate' stamp: 'cmm 11/26/2002 22:14'!removedIndexesDo: twoArgBlock	"For all largeCollections that have had one or more indexes removed on this transaction, evaluate twoArgBlock.  The first argument is the collection (or oid of the collection if the receiver has serialized itself, the second is a collection of the indexes)."	self allLargeCollectionChangesDo:		[ :eachChanges |		eachChanges hasRemovedIndexes			ifTrue:				[ twoArgBlock					value: eachChanges collection					value: eachChanges removedIndexes ] ]! !!MaCommitPackage methodsFor: 'copying'!copyWithNewLargeCollectionChanges	^self copy		allLargeCollectionChanges: (self allLargeCollectionChanges collect: [ :each | each copy ])! !!MaCommitPackage methodsFor: 'testing'!hasNewIndexes	"Don't use conform: or detect: because it forces creation of a collection for	the new indexes."	self		allLargeCollectionChangesDo: [ :eachChanges | eachChanges hasAddedIndexes ifTrue: [ ^true ] ].	^false! !!MaCommitPackage methodsFor: 'testing' stamp: 'cmm 11/26/2002 22:18'!hasRemovedIndexes	self		allLargeCollectionChangesDo: [ :eachChanges | eachChanges hasRemovedIndexes ifTrue: [ ^true ] ].	^false! !!MaCommitPackage methodsFor: 'testing' stamp: 'cmm 1/18/2014 14:46'!includesObject: anObject	^ objects includes: anObject! !!MaCommitPackage methodsFor: 'private' stamp: 'cmm 11/14/2002 21:35'!serializeLargeCollectionsChangesUsingCopyOf: aMaObjectSerializer	"The objects are serialized, now serialize the allLargeCollectionChanges of	the receiver."	| copiedSerializer |	copiedSerializer := nil.	self allLargeCollectionChangesDo:		[ :eachChanges | 		copiedSerializer ifNil: [ copiedSerializer := aMaObjectSerializer copyWithNewBuffer ].		eachChanges serializeUsing: copiedSerializer ]! !!MaCommitPackage methodsFor: 'private' stamp: 'cmm 3/22/2010 18:25'!setSize: anInteger 	objects := MaIdentitySet new: anInteger! !!MaCommitPackage methodsFor: 'private' stamp: 'cmm 8/21/2008 17:37'!trimLargeCollectionChanges	self allLargeCollectionChanges: nil! !!MaCommitPackage methodsFor: '*magma-server' stamp: 'cmm 3/2/2013 11:29'!bytesConsumed	"This only works on the server when my objects are serialized CommitPackages."	^ objects bufferSize! !!MaCommitPackage methodsFor: '*magma-server' stamp: 'cmm 4/5/2005 21:34'!shouldServerRefresh	"Anytime a largeCollection domain object changes, the server should	refresh so we process all of the new large collections or their new	indexes."	^ allLargeCollectionChanges notNil	and: [ allLargeCollectionChanges anySatisfy: [ :each | each requiresServerRefresh ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCommitPackage class	instanceVariableNames: ''!!MaCommitPackage class methodsFor: 'creation'!new	"Don't have unnecessarily large physicalSize.  Keep the work on the client."	^self new: 8! !!MaCommitPackage class methodsFor: 'creation'!new: anInteger	^super new setSize: anInteger! !MaObject subclass: #MaRecoveryRecord	instanceVariableNames: 'byteArray'	classVariableNames: 'ReusableSha'	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRecoveryRecord commentStamp: 'cmm 7/15/2009 15:45' prior: 0!My instances are records that faciliate the automatic recovery of Magma files when the server was interrupted by an external event such as a power-outage or sysadmin killing of my VM.There are two types of recovery, forward and backward.  Backward recovery is necessary when a write operation only partially completed and files are in an inconsistent state.In this case, there are four types of changes that can occur to a file that must be tracked:	- the file was just created new (MaNewFileRecord), when recover we delete it.	- updating bytes within an existing file (MaBeforeImageRecord).  When we recover we put those bytes back.	- extending the length of a file with new bytes (MaFileGrowthRecord).  When we recover we truncate the file back to its original length.	- an existing file is deleted.  To handle this we simply don't delete the file until the entire apply has completed and flushed successfully.There are also two records which indicate the begin and end of the group of records for a single write operation.  My groupId associates all records for a particular write together.  Each of these records has a hash-checkSum calculated so that the recovery process can ensure the record was written wholly and correctly.All of this is contained completely within my own ByteArray with the following format (0-based positions):	--begin header--	0 : physicalSize (4-bytes)	4 : recordType (1 byte, high 4 bits reserved for future expansion bit, if necessary)	5 to: headerSize-1 : ... other fields implemented by my subclasses ...	--end header--	headerSize to: n-21 : my #record (variable data, if appropriate)	n-20 - checkSum (SHA1)!!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 16:47'!bodySize	"Subclasses override"	^ 0! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 14:21'!bufferPositionOfPhysicalSize	"This field is 3-bytes."	^ 0! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:37'!bufferPositionOfRecordType	^ 4! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!calculatedCheckSum	^ ReusableSha 		maHashMessage: byteArray		from: 1		to: self physicalSize - self checkSumSize! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSum: anInteger	^ byteArray		maUint: 160		at: self physicalSize - self checkSumSize		put: anInteger! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSumPosition	^ self physicalSize - self checkSumSize + 1! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSumSize	^ 20 "bytes"! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!ensureCanHold: numberOfBytes	byteArray size >= (self headerSize + numberOfBytes + self checkSumSize)		ifFalse:			[ | newByteArray |			newByteArray := ByteArray new: self headerSize + numberOfBytes + self checkSumSize.			newByteArray				replaceFrom: 1				to: byteArray size				with: byteArray				startingAt: 1.			byteArray := newByteArray ]! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 17:27'!headerSize	^ 5! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 7/31/2011 20:51'!physicalSize: anInteger 	byteArray		maUint: 32 "self class sizeOfPhysicalSizeField*4"		at: self bufferPositionOfPhysicalSize		put: anInteger! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 3/20/2009 18:15'!resetChecksum	"Calculate my checksum which is used during recovery to ensure my byteArray was written completely and correctly."	self checkSum: self calculatedCheckSum! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:22'!bufferSize	^ byteArray size! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:21'!byteArray	^ byteArray! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!checkSum	^ byteArray		maUint: 160		at: self checkSumPosition-1 "-1 to convert to 0-based"! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:17'!physicalSize	^ byteArray"		maUint: 32" "[self class sizeOfPhysicalSizeField * 8] once"		maUnsigned32At: self bufferPositionOfPhysicalSize +1! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 7/16/2005 18:34'!record	| startOfRecord |	startOfRecord := self headerSize+1 "because bufferPositionOfRecord is 0-based".	^ byteArray		copyFrom: startOfRecord		to: startOfRecord + self recordSize - 1! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 7/4/2005 22:53'!record: aByteArray	self		record: aByteArray		size: aByteArray size		startingAt: 1! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!record: aByteArray size: anInteger startingAt: startPos	self ensureCanHold: anInteger.	byteArray		replaceFrom: self headerSize+1		to: self headerSize + anInteger		with: aByteArray		startingAt: startPos.	self physicalSize: self headerSize + anInteger + self checkSumSize! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!recordSize	^ self physicalSize - self headerSize - self checkSumSize! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:18'!recordType	"record type indicates what kind of MaRecoveryRecord this is.  See the class-side hierarchy, #assignedRecordType methods for the values."	^ byteArray"		maUint: 8"		byteAt: self bufferPositionOfRecordType+1! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 6/3/2005 14:21'!byteArray: aByteArray	byteArray := aByteArray! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 9/21/2005 09:54'!initialize	super initialize.	byteArray := ByteArray new: self headerSize + self bodySize + self checkSumSize.	self isFixed ifTrue: [ self physicalSize: byteArray size ].	self recordType: self class assignedRecordType! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 7/5/2005 23:28'!recordType: anInteger	"record type indicates what kind of MaRecoveryRecord this is.  See the class-side hierarchy, #assignedRecordType methods for the values."	^ byteArray		maUint: 8		at: self bufferPositionOfRecordType		put: anInteger! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 5/27/2007 20:29'!hasValidCheckSum	^ self checkSumPosition > self headerSize and: [ self calculatedCheckSum = self checkSum ]! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 5/27/2007 20:54'!isApplyToFile	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isBeginApply	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:58'!isEndApply	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 15:52'!isFixed	^ true! !!MaRecoveryRecord methodsFor: 'copying' stamp: 'cmm 6/3/2005 14:33'!independentCopy	^ self copy		byteArray: (byteArray copyFrom: 1 to: self physicalSize) ;		yourself! !!MaRecoveryRecord methodsFor: 'printing' stamp: 'cmm 5/27/2007 20:32'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(physicalSize recordType)		on: aStream! !!MaRecoveryRecord methodsFor: '*magma-server' stamp: 'cmm 12/26/2009 13:16'!writeTo: applyFile 	self resetChecksum.	applyFile		next: self physicalSize			putAll: byteArray			startingAt: 1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaRecoveryRecord class	instanceVariableNames: ''!!MaRecoveryRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:54'!assignedRecordType	^ 0! !!MaRecoveryRecord class methodsFor: 'accessing' stamp: 'cmm 7/15/2009 17:15'!sizeOfPhysicalSizeField	"this field, in particular, has its size defined this way because of the potential dual-read required should the initial default read not be large enough."	^ 4! !!MaRecoveryRecord class methodsFor: 'create' stamp: 'cmm 6/5/2005 16:46'!byteArray: aByteArray	^ self new		byteArray: aByteArray ;		yourself! !!MaRecoveryRecord class methodsFor: 'create' stamp: 'cmm 6/5/2005 16:46'!new: anInteger	^ self byteArray: (ByteArray new: anInteger)! !!MaRecoveryRecord class methodsFor: 'class initialization' stamp: 'cmm 6/5/2005 13:38'!initialize	super initialize.	self initializeReusableSha ! !!MaRecoveryRecord class methodsFor: 'class initialization' stamp: 'cmm 6/3/2005 14:41'!initializeReusableSha	ReusableSha := SecureHashAlgorithm new! !MaRecoveryRecord subclass: #MaCommitLogRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaCommitLogRecord commentStamp: 'cmm 7/15/2009 15:43' prior: 0!These are the "after-images" which are written to the commitPackages file.	--begin header--	(see superclass)	5 to: 10:  commitNumber	11 to: 15:  timestamp, in seconds	16 to: 19:  branchCode	--end header--	-- begin record --	-- end record --	Last 20 bytes - SHA1 checkSum!!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:07'!branchCode	^ byteArray maUnsigned32At: self bufferPositionOfBranchCode + 1! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 6/19/2007 22:58'!branchCode: anInteger 	byteArray 		maUint: 32		at: self bufferPositionOfBranchCode		put: anInteger! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:07'!commitNumber	^ byteArray maUnsigned48At: self bufferPositionOfCommitNumber + 1! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 5/27/2007 20:09'!commitNumber: anInteger 	byteArray 		maUint: 48		at: self bufferPositionOfCommitNumber 		put: anInteger! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 7/15/2009 19:37'!headerSize	"super headerSize + size of commitNumber, timestamp and branchCode fields."	^ 20! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:07'!timestamp	"By storing the timestamp we can restore to a paritcular point-in-time."	^ DateAndTime fromSeconds: 		(byteArray maUnsigned40At: self bufferPositionOfTimestamp+1)	"DateAndTime fromSeconds: (2 raisedTo: 40)"! !!MaCommitLogRecord methodsFor: 'accessing' stamp: 'cmm 6/11/2007 20:02'!timestamp: aDateAndTime	"By storing the timestamp we can restore to a paritcular point-in-time."	^ byteArray 		maUint: 40  "DateAndTime fromSeconds: (2 raisedTo: 40)"		at: self bufferPositionOfTimestamp		put: aDateAndTime asSeconds! !!MaCommitLogRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:43'!bufferPositionOfBranchCode	^ 16! !!MaCommitLogRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:43'!bufferPositionOfCommitNumber	"This field is 6 bytes."	^ 5! !!MaCommitLogRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:43'!bufferPositionOfTimestamp	^ 11! !!MaCommitLogRecord methodsFor: 'testing' stamp: 'cmm 8/12/2008 16:33'!isFixed	^ false! !!MaCommitLogRecord methodsFor: 'printing' stamp: 'cmm 6/19/2007 22:58'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(commitNumber timestamp branchCode)		on: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCommitLogRecord class	instanceVariableNames: ''!!MaCommitLogRecord class methodsFor: 'accessing' stamp: 'cmm 7/8/2005 11:05'!assignedRecordType	^ 6! !MaObject subclass: #MaStorageForMagmaSession	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaStorageForMagmaSession commentStamp: 'cmm 1/15/2007 18:43' prior: 0!I represent a reference in the database to whatever current MagmaSession materializes me.  You may not reference other MagmaSessions in your model, only the session to which the model belongs.!WriteBarrier subclass: #MaTransaction	instanceVariableNames: 'readSet session largeCollectionChanges commitPackage potentialKeysChange ignoreModifiedSignals commitNumber dictionaryArrays'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaTransaction commentStamp: 'cmm 8/21/2008 13:26' prior: 0!This class is private.  Applications should use the transaction control provided on MagmaSession.!!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 12/1/2011 20:52'!add: anObject	"Handle special processing required by Dictionary's."	anObject addSelfToWriteBarrier: self! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 12/1/2011 21:09'!addHashedCollection: aHashedCollection 	super add: aHashedCollection.	super add: aHashedCollection array.	dictionaryArrays		at: aHashedCollection array		put: aHashedCollection! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 8/21/2012 21:14'!modified: anObject 	ignoreModifiedSignals ifFalse:		[ | obj |		obj := (anObject isArray and: [ dictionaryArrays includesKey: anObject ])			ifTrue: [ dictionaryArrays at: anObject ]			ifFalse: [ anObject ].		commitPackage addObject: obj ]! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 1/17/2013 20:19'!newBuilderForClass: aClass	^ MagmaWbClassBuilder		target: aClass 		barrier: self! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 7/14/2009 14:33'!suspendWriteBarrierModifiedsWhile: aBlock 	"Employ 'priorValue' to support nested suspendWriteBarrierModifiedsWhile: 's."	| priorValue |	priorValue := ignoreModifiedSignals.	ignoreModifiedSignals := true.	^ aBlock ensure: [ ignoreModifiedSignals := priorValue ]! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 5/22/2018 23:43'!useWriteBarrierOn: anObject 	^ anObject maAllowsWriteBarrier and: [ session allowWriteBarrier ]! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 3/27/2005 22:56'!validateWriteBarrier: aBoolean	"We can't allow them to stop using the writeBarrier in the middle of a transaction in which objects are already changed.."	aBoolean		ifFalse:			[ commitPackage objects notEmpty				ifTrue:					[ MagmaUserError signal: 'Cannot stop using writeBarrier in the middle of a transaction.' ] ]! !!MaTransaction methodsFor: 'private' stamp: 'cmm 8/21/2012 21:13'!addChangesFromReadSet	readSet keysAndValuesDo:		[ : eachCurrent : eachBuffer | | didChange | 		eachCurrent ifNotNil:			[ didChange := self				didChange: eachCurrent				from: eachBuffer.			didChange ifTrue: [ commitPackage addObject: eachCurrent ] ] ]! !!MaTransaction methodsFor: 'private' stamp: 'cmm 3/27/2005 17:02'!addLargeCollectionChangesTo: aMaCommitPackage	largeCollectionChanges do:		[ :each |		each hasChanges			ifTrue:				[ aMaCommitPackage					addLargeCollectionChanges: each					using: session ] ]! !!MaTransaction methodsFor: 'private' stamp: 'cmm 12/1/2011 21:03'!addNormalObject: anObject	"ugh"	super add: anObject! !!MaTransaction methodsFor: 'private' stamp: 'cmm 9/18/2008 17:18'!bufferFor: anObject ifAbsent: aBlock 	^ readSet 		at: anObject		ifAbsent: aBlock! !!MaTransaction methodsFor: 'private' stamp: 'cmm 5/25/2013 17:21'!bufferFor: anObject is: aMaObjectBuffer 	anObject isBehindWriteBarrier ifTrue: [ MagmaSoftwareError signal: 'should not add objects behind WB to the readSet!!' ].	readSet		at: anObject		put: aMaObjectBuffer trimByteArray! !!MaTransaction methodsFor: 'private' stamp: 'cmm 7/15/2008 14:58'!commitNumber	^ commitNumber ! !!MaTransaction methodsFor: 'private' stamp: 'cmm 7/15/2008 14:56'!commitNumber: anInteger	commitNumber := anInteger! !!MaTransaction methodsFor: 'private' stamp: 'cmm 7/10/2009 14:52'!commitPackage	^ commitPackage! !!MaTransaction methodsFor: 'private' stamp: 'cmm 7/10/2009 13:48'!modifiedObjects	"Answers the collection of objects already in the commitPackage.  When WriteBarrier is in use, many objects are added *as* they are changed, via my #modified: method."	^ commitPackage objects! !!MaTransaction methodsFor: 'private' stamp: 'cmm 9/25/2012 19:59'!resetNewLargeCollections	largeCollectionChanges := largeCollectionChanges reject:		[ : each | (MaOidCalculator isOidForNewObject: each collectionOid) and:			[ each collectionOid: nil.			true ] ]! !!MaTransaction methodsFor: 'private'!session: aMagmaSession	session := aMagmaSession! !!MaTransaction methodsFor: 'private' stamp: 'cmm 4/10/2005 18:00'!warnOfTruncationsIn: aCollection 	aCollection isEmptyOrNil 		ifFalse: 			[MagmaTruncationWarning 				signal: (String streamContents: 							[:stream | 							stream nextPutAll: 'Your definition of '.							(aCollection collect: [:each | each maOriginalClass name]) asSet do: 									[:each | 									stream										nextPutAll: each;										nextPutAll: ', '].							stream 								nextPutAll: 'are missing instance variables present in the repository-version.  If you proceed with this commit, information in one or more of these instances will be lost.'])]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 3/22/2010 18:24'!captureOldHashesFor: anObject 	largeCollectionChanges do: 		[ : eachChanges | 		(eachChanges collection canIndex: anObject) ifTrue: 			[ eachChanges collection indexesDo: 				[ : eachIndex | 				| oldKeys oldHashes |				oldKeys := potentialKeysChange 					at: anObject					ifAbsentPut: [ MaIdentityDictionary new ].				oldHashes := oldKeys 					at: eachIndex attribute					ifAbsentPut: [ OrderedCollection new ].				oldHashes add: { 						eachChanges.						eachIndex.						(eachIndex indexHashesFor: anObject)					 } ] ] ]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 11/12/2011 12:06'!markRead: anObject using: aMaObjectBuffer 	(session immutabilityStrategy		isImmutable: anObject		using: self) ifTrue: [ ^ anObject ].	anObject isImmutableInMagma ifTrue: [ ^ anObject ].	(self useWriteBarrierOn: anObject)		ifTrue:			[ anObject isBehindWriteBarrier ifFalse: [ self add: anObject ].			commitPackage removeObject: anObject ]		ifFalse:			[ self				bufferFor: anObject				is: aMaObjectBuffer ].	anObject maIsLargeCollection ifTrue:		[ self monitorLargeCollectionChanges: anObject changes.		anObject session: session ].	^ anObject! !!MaTransaction methodsFor: 'building' stamp: 'cmm 3/16/2005 12:43'!monitorLargeCollectionChanges: aMaLargeCollectionChanges	largeCollectionChanges add: aMaLargeCollectionChanges! !!MaTransaction methodsFor: 'building' stamp: 'brp 12/22/2005 18:32'!recordPotentialKeyChanges	potentialKeysChange keysAndValuesDo:		[ :eachObject :eachKeys |			eachKeys valuesDo: 				[ :eachHashes |					eachHashes do: 						[ :eachCio | "#( changes index, oldHash )"							self								recordPotentialKeyChangesFrom: eachCio last								of: eachObject								index: eachCio second								in: eachCio first ] ] ]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 8/2/2009 17:32'!recordPotentialKeyChangesFrom: oldHashValues of: anObject index: aMaIndexDefinition in: aMagmaCollectionChanges 	| newHashValues |	anObject ifNil: [ ^ self ].	newHashValues := aMaIndexDefinition indexHashesFor: anObject.	"If hash index value has changed."	(oldHashValues maConsistsOf: newHashValues) ifFalse: 		[ | common |		common := oldHashValues intersection: newHashValues.		aMagmaCollectionChanges 			move: anObject			from: (oldHashValues copyWithoutAll: common)			to: (newHashValues copyWithoutAll: common)			forIndexedAttribute: aMaIndexDefinition attribute ]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 11/23/2008 17:24'!remove: anObject 	super remove: anObject.	readSet 		removeKey: anObject		ifAbsent: 			[ "do nothing"			 ]! !!MaTransaction methodsFor: 'accessing' stamp: 'cmm 4/5/2005 21:31'!changedObjects	| preservedCommitPackage answer |	"this method must be non-destructive to the my commitPackage because it may be requested again."	preservedCommitPackage := commitPackage copyWithNewLargeCollectionChanges.  "It should actually be ok to share its 'objects'."	self		addChangesFromReadSet ;  "another potential truncation warning"		recordPotentialKeyChanges ;		addLargeCollectionChangesTo: commitPackage.	answer := commitPackage.	commitPackage := preservedCommitPackage.	^ answer! !!MaTransaction methodsFor: 'accessing' stamp: 'cmm 1/19/2012 20:18'!commitPackageCountByClass	^ (commitPackage objects asArray collect: [ : each | each maOriginalClass ]) asBag sortedCounts! !!MaTransaction methodsFor: 'accessing'!largeCollectionChanges	^largeCollectionChanges! !!MaTransaction methodsFor: 'accessing' stamp: 'cmm 5/8/2013 22:00'!readSetCountByClass	^ (readSet keys collect:		[ : each | (each maIsMutatingProxy and: [ each maRealObjectIsReified ])			ifTrue: [ each maOriginalClass ]			ifFalse: [ each class ] ]) asBag sortedCounts! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 6/23/2013 15:07'!cleanUpWriteBarrier	self resetCommitPackage.	WeakArray removeWeakDependent: builders! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 12/1/2011 20:59'!initialize	super initialize.	readSet := MaObjectSerializerPreferences newWeakIdentityKeyDictionary.	largeCollectionChanges := WeakSet new.	self resetCommitPackage.	ignoreModifiedSignals := false.	"Conveniently initialized to avoid nil check in code."	commitNumber := 0.	dictionaryArrays := MaObjectSerializerPreferences newWeakIdentityKeyDictionary! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 6/27/2013 09:49'!installWriteBarrierUsing: aMagmaSession	"Remove and re-add all objects to move them from the readSet into a WriteBarrier."	| changedObjects |	WeakArray addWeakDependent: builders.	changedObjects := self changedObjects.	self writeBarrierStatusChangedFor: aMagmaSession.	changedObjects objects do: [ : each | self modified: each ]! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 3/22/2010 18:24'!resetCommitPackage	commitPackage := MaCommitPackage new.	"potentialKeyChanges are only ever part of a single commit-package, so reset those too."	potentialKeysChange := MaIdentityDictionary new! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 6/23/2013 15:07'!writeBarrierStatusChangedFor: aMagmaSession 	"Enumerate all persistent objects and put them appropriately either into my writeBarrier or readSet."	aMagmaSession serializer objectsDo:		[ : each | | buffer |		buffer := aMagmaSession bufferFor: each.		self			 remove: each ;						markRead: each			using: buffer ]! !!MaTransaction methodsFor: 'testing' stamp: 'cmm 2/17/2014 15:56'!didChange: anObject 	"Answer whether anObject has changed for this transaction."	(session immutabilityStrategy		isImmutable: anObject		using: self) ifTrue: [ ^ false ].	anObject isImmutableInMagma ifTrue: [ ^ false ].	^ anObject isBehindWriteBarrier		ifTrue: [ commitPackage includesObject: anObject ]		ifFalse:			[ "Under very heavy loads, its possible for a client to get disconnected during a long series of reads.  One of those reads could be in the middle of a materialization (maEstablishPointerReferencesFor:using:.  But since this happens before the call to #markRead:using:, it isn't in the readSet yet!!)"			self				didChange: anObject				from: (readSet at: anObject ifAbsent: [ ^ false ]) ]! !!MaTransaction methodsFor: 'testing' stamp: 'cmm 5/6/2013 20:23'!didChange: anObject from: aMaObjectBuffer 	"Answer whether anObject has changed for this transaction."	^ aMaObjectBuffer 		isDifferent: anObject realObjectIfMutatingProxy		using: session serializer! !!MaTransaction methodsFor: 'testing' stamp: 'cmm 10/12/2009 13:17'!isMonitoring: aMagmaLargeCollectionChanges	^ largeCollectionChanges includes: aMagmaLargeCollectionChanges! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 3/7/2011 20:17'!ensureOldHashesCapturedFor: anObject 	"What we need to do here is capture the before-keys of any object which, potentially belonging to a MagmaCollection, potentially changing its key by way of its instVars being changed so that we may, in modified: actually determine whether we should record the changed-key in my commitPackage."	(potentialKeysChange includesKey: anObject yourself) ifTrue: [ ^ self ].	self captureOldHashesFor: anObject yourself! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 5/3/2005 12:56'!ensureOldHashesCleanedFor: anObject	"What we need to do here is capture the before-keys of any object which, potentially belonging to a MagmaCollection, potentially changing its key by way of its instVars being changed so that we may, in modified: actually determine whether we should record the changed-key in my commitPackage."	potentialKeysChange 		removeKey: anObject		ifAbsent: [ "do nothing" ]! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 5/22/2018 23:37'!finalizeOids	builders finalizeValues.	dictionaryArrays finalizeValues.	readSet finalizeValues! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 1/10/2014 16:46'!restore	"restore all changed objects to their state as read from the repository."	largeCollectionChanges do: [ : each | each reset ].	self suspendWriteBarrierModifiedsWhile: 		[ readSet keysAndValuesDo: 			[ : eachOriginal : eachBackup | 			eachBackup				refresh: eachOriginal realObjectIfMutatingProxy				using: session				includingLocal: true ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaTransaction class	instanceVariableNames: ''!!MaTransaction class methodsFor: 'creation'!session: aMagmaSession	^self new session: aMagmaSession! !MaObject subclass: #MaTransactionLogEntry	instanceVariableNames: 'id result challengingEntries serverNotifications'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaTransactionLogEntry commentStamp: 'cmm 7/24/2007 12:04' prior: 0!A MaTransactionLogEntry maintains information about a single MagmaSession client's refresh state.Instance Variables	challengingEntries:  an OrderedCollection of aMaCommitLogEntry's submitted by other clients.  The next time my client commits, none of the committed objects can be included in any of the other MaCommitLogEntry.  Additionally, all of each other MaCommitLogEntry's #committed objects will need to be refreshed by my client.	id:  anInteger identifying my client-session.	needsToRefresh:  When my client performs a read operation, this boolean is also included to indicate whether it should perform an abort.  (Note:  This may be soon optimised out).	result:  My MaRefreshViewResult or MaCommitResult.	serverNotifications:  A Dictionary of the notifications that my client should respond to.!!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:58'!connection	^ result connection! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 5/14/2005 17:46'!id	^ id! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 5/14/2005 17:46'!id: anInteger	id := anInteger! !!MaTransactionLogEntry methodsFor: 'accessing'!result	^result! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 8/15/2008 15:04'!sessionId	^ result ifNotNil: [ result sessionId ]! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:58'!startTime	^ result startTime! !!MaTransactionLogEntry methodsFor: 'initialize-release' stamp: 'cmm 3/25/2013 20:43'!initialize	"of MaTransactionLogEntries or MaCommitLogEntries that challenge me."	super initialize.	self		initializeResult ;		initializeChallengers ;		initializeServerNotifications! !!MaTransactionLogEntry methodsFor: 'initialize-release' stamp: 'cmm 3/25/2013 21:09'!initializeChallengers	challengingEntries := OrderedCollection new.	self connection ifNotNil: [ : conn | conn resetChallengingBytes ]! !!MaTransactionLogEntry methodsFor: 'initialize-release'!initializeResult	result := MaRefreshViewResult new! !!MaTransactionLogEntry methodsFor: 'initialize-release' stamp: 'cmm 5/19/2004 00:20'!initializeServerNotifications	serverNotifications := Dictionary new! !!MaTransactionLogEntry methodsFor: 'testing'!isCommitEntry	^false! !!MaTransactionLogEntry methodsFor: 'testing' stamp: 'cmm 3/3/2002 19:00'!isForSameSessionAs: aMaTransactionLogEntry	^self connection == aMaTransactionLogEntry connection! !!MaTransactionLogEntry methodsFor: 'testing' stamp: 'cmm 10/16/2006 00:29'!isSystem	"Answer whether I am for the servers session."	^ result isSystem! !!MaTransactionLogEntry methodsFor: 'printing' stamp: 'cmm 11/24/2008 17:22'!maPrintAbbreviatedOn: aStream 	aStream		maPrint: result userId ;		maPrint: '(' ;		maPrint: self sessionId ;		maPrint: ') '! !!MaTransactionLogEntry methodsFor: 'recovery' stamp: 'cmm 12/30/2008 21:09'!postTrimmedCopy	"We do this for performance.  We no longer need these fields, and we're about to serialize the receiver."	challengingEntries := nil.	result := result trimmedCopy! !!MaTransactionLogEntry methodsFor: 'recovery' stamp: 'cmm 7/8/2005 16:10'!trimmedCopy	"Make a copy without things needed merely to applyToCache: so that serialization to the commitPackages recovery file will be quicker."	^ self copy postTrimmedCopy! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 3/25/2013 20:41'!addChallengingEntry: aMaCommitLogEntry	challengingEntries add: aMaCommitLogEntry.	self connection addChallengingBytes: aMaCommitLogEntry bytesConsumed! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 9/27/2014 10:02'!bytesConsumed	"When I'm removed from the TransactionLog, how many bytes will be recovered from my 'commitPackage'.  Since only MaCommitLogEntry's have them, 0."	^ challengingEntries		ifNil: [ 0 ]		ifNotNil:			[ challengingEntries				inject: 0				into:					[ : sum : each | sum + each bytesConsumed ] ]! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 3/6/2013 10:44'!challengingBytes	^ challengingEntries		inject: 0		into: [ : sum : each | sum + each bytesConsumed ]! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/15/2004 16:58'!connection: aMagmaClientConnection	result connection: aMagmaClientConnection! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 7/11/2005 15:40'!ensureWillCall: specialOidsName at: oidInteger	(serverNotifications		at: specialOidsName  "see MaObjectRepository>>#initializeSpecialOidsList"		ifAbsentPut: [ Set new ]) add: oidInteger! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 8/12/2014 19:08'!hasExcessiveChallengers	^ challengingEntries size >= self connection maximumNumberOfChallengers or:		[ | lastAccess |		lastAccess := self connection lastAccess.		lastAccess notNil and: [ (Time millisecondsSince: lastAccess) > 1800000 "30 minutes" ] ]! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/15/2004 16:56'!recordAllChangedObjects	"Record all of the objects that the client will need to refresh."	challengingEntries do: [ :each | result addToBeRefreshed: each committed ]! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 7/11/2005 15:40'!recordChangesToSpecialObjectsIn: aMaCommitLogEntry using: aMaTransactionLog	aMaTransactionLog specialOidsDo:		[ : eachOid : eachKey |		(aMaCommitLogEntry hasCommitted: eachOid)			ifTrue:				[ aMaCommitLogEntry noteDidCommitSpecialOid.				self					ensureWillCall: eachKey					at: eachOid ] ]! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/19/2004 22:43'!renewServerNotifications	| answer |	answer := serverNotifications.	serverNotifications notEmpty ifTrue: [ self initializeServerNotifications ].	^ answer! !!MaTransactionLogEntry methodsFor: '*magma-server' stamp: 'cmm 3/23/2015 14:24'!resetSocketStreamBuffer	| lifecycle |	result connection maClientConnection ifNil: [ ^ self ].	lifecycle := result connection requestLifecycle.	lifecycle ifNotNil: [ lifecycle critical: [ lifecycle socketStream resetBuffers ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaTransactionLogEntry class	instanceVariableNames: ''!!MaTransactionLogEntry class methodsFor: 'creation' stamp: 'cmm 5/14/2005 17:48'!id: anInteger connection: aMagmaClientConnection	^ self new 		id: anInteger ;		connection: aMagmaClientConnection ;		yourself! !MaTransactionLogEntry subclass: #MaCommitLogEntry	instanceVariableNames: 'commitPackage committed didCommitSpecialOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaCommitLogEntry commentStamp: 'cmm 7/24/2007 12:08' prior: 0!A MaCommitLogEntry is the entry used when my client is in a transaction.  I contain extra information about my clients commit.Instance Variables	commitPackage : A MaCommitPackage containing the objects of the commit.	committed : A Dictionary of the individual MaObjectBuffers that were part of the commit, keyed by their oid.	didCommitSpecialOid : A Boolean indicator of whether the class-definitions Dictionary object was part of the commit.	magmaArrayCommits : Instances of MagmaArray that were committed.  They require special processing.!!MaCommitLogEntry methodsFor: 'accessing' stamp: 'cmm 10/14/2008 18:16'!commitNumber	^ result commitNumber! !!MaCommitLogEntry methodsFor: 'accessing' stamp: 'cmm 5/9/2005 21:24'!commitPackage	^ commitPackage! !!MaCommitLogEntry methodsFor: 'private'!committed	^committed! !!MaCommitLogEntry methodsFor: 'initializing' stamp: 'cmm 5/20/2004 21:36'!initialize	super initialize.	committed := Dictionary new.	didCommitSpecialOid := false! !!MaCommitLogEntry methodsFor: 'initializing'!initializeResult	result := MaCommitResult new! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 9/26/2014 17:59'!bytesConsumed	^ super bytesConsumed +		(commitPackage			ifNil: [ 0 ]			ifNotNil: [ commitPackage bytesConsumed ])! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 8/27/2008 20:29'!commitNumber: anInteger 	commitPackage objectsDo: [ : each | each commitNumber: anInteger ].	result commitNumber: anInteger! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/9/2005 21:24'!commitPackage: aMaCommitPackage	commitPackage := aMaCommitPackage! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 1/3/2014 14:44'!determineResultFor: aMaCommitPackage using: aMaObjectRepository 	self				recordLargeCollectionConflictsWith: aMaCommitPackage		using: aMaObjectRepository ;				recordObjectConflictsIn: aMaCommitPackage		using: aMaObjectRepository.	^ result! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/20/2004 21:39'!didCommitSpecialOid	^ didCommitSpecialOid! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/15/2004 16:57'!failResultWith: aMagmaClientConnection on: oidInteger	result :=		result asFailedResult			recordObjectConflictWith: aMagmaClientConnection			on: oidInteger! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/15/2004 16:52'!hasCommitted: oidInteger	^ committed includesKey: oidInteger! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/8/2012 14:32'!hasDifferentRepresentationOf: aMaObjectBuffer 	| myBuffer |	myBuffer := committed		at: aMaObjectBuffer oid		ifAbsent: [ ^ false ].	^ (myBuffer equivalentTo: aMaObjectBuffer) not! !!MaCommitLogEntry methodsFor: '*magma-server'!isCommitEntry	^true! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 2/13/2008 11:58'!link	self		linkObjectModel ;		linkMagmaArrays! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/6/2013 12:32'!linkMagmaArrays	| oidMap |	oidMap := result permanentOids.	commitPackage allLargeCollectionChangesDo:		[ : eachChanges | eachChanges isForMagmaArray ifTrue:			[ eachChanges additionsDo:				[ : eachIndex : eachOid | (MaOidCalculator isOidForNewObject: eachOid) ifTrue:					[ "replace the temp oid with the permanent one."					eachChanges						add:							(oidMap								at: eachOid								ifAbsent: [ MagmaInvalidReference signal: 'Invalid reference, an object may not change during serialization.' ])						at: eachIndex ] ] ] ]! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/30/2014 10:56'!linkObjectModel	| oidMap |	oidMap := result permanentOids.	commitPackage objectsDo:		[ : eachBuffer | eachBuffer isPointers ifTrue:			[ eachBuffer instVarsDoWithIndex:				[ : oid : index | (MaOidCalculator isOidForNewObject: oid) ifTrue:					[ "replace the temp oid with the permanent one."					eachBuffer						maInstVarAt: index						put:							(oidMap								at: oid								ifAbsent:									[ MagmaInvalidReference										referencingBuffer: eachBuffer										oidOfMissingBuffer: oid										signal: 'Invalid reference, an object may not change during serialization.' ]) ] ] ] ].	commitPackage allLargeCollectionChangesDo:		[ : each | each isNewCollection ifTrue:			[ | permanentOid |			permanentOid := oidMap				at: each collectionOid				ifAbsent: [ MagmaSoftwareError signal: 'expected to find permanent oid for new collection ' , each collectionOid printString ].			each collectionOid: permanentOid ] ]! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/20/2004 21:38'!noteDidCommitSpecialOid	didCommitSpecialOid := true! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 10/26/2006 15:10'!recordLargeCollectionConflictsWith: aMaCommitPackage using: aMaObjectRepository 	aMaCommitPackage allLargeCollectionChangesDo: 		[ : eachChanges | 		eachChanges isNewCollection ifFalse: 			[ | collectionManager |			collectionManager := aMaObjectRepository collectionManagerFor: eachChanges collectionOid.			collectionManager 				recordGeneralConflictsWith: eachChanges				in: self.			challengingEntries do: 				[ : eachEntry | 				collectionManager 					recordConflictsBetween: eachChanges					and: eachEntry					in: self ] ] ]! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 1/7/2014 22:18'!recordObjectConflictsIn: aMaCommitPackage using: aMaObjectRepository	"Go through everyone who has challenged me.  Determine if they have a same changed oid that I have.  Also fail if a new instance of a class is being added and shouldn't be."	aMaCommitPackage persistentObjectsDo:		[ : eachObjectBuffer | challengingEntries do:			[ : eachEntry | ((aMaObjectRepository filer canPossiblyConflict: eachObjectBuffer) and: [ eachEntry hasDifferentRepresentationOf: eachObjectBuffer ]) ifTrue:				[ self					failResultWith: eachEntry connection					on: eachObjectBuffer oid ] ] ]! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 1/9/2014 14:59'!recordUsing: aMaObjectRepository 	"Record my successful commit in the places that need to know."	commitPackage objectsDo:		[ : eachBuffer | (result newObjectBuffers includesKey: eachBuffer oid) ifFalse:			[ committed				at: eachBuffer oid				put: eachBuffer copyWithSameBuffer ].		self			refreshIfCountersOrStat: eachBuffer			using: aMaObjectRepository ].	result changedObjectBuffers: committed! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 1/9/2014 14:58'!refreshIfCountersOrStat: aMaObjectBuffer using: aMaObjectRepository 	(aMaObjectBuffer classId = MagmaClassIdManager magmaCounterClassId or: [ aMaObjectRepository filer magmaStatClassIds includes: aMaObjectBuffer classId ]) ifTrue:		[ result toBeRefreshed			at: aMaObjectBuffer oid			put: aMaObjectBuffer copyWithSameBuffer ]! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 5/30/2005 22:19'!registerUsing: aMaObjectRepository	"Register all new objects by assigning them their permanentOids."	| map |	map := Dictionary new: 100.	commitPackage newObjectsDo:		[ : eachBuffer |		eachBuffer oid: 			(map				at: eachBuffer oid				put: aMaObjectRepository getNextOid).		result recordNewObjectBuffer: eachBuffer copyWithSameBuffer ].	result permanentOids: map! !!MaCommitLogEntry methodsFor: '*magma-server' stamp: 'cmm 1/8/2014 17:43'!shouldServerRefresh	^ didCommitSpecialOid or: [ commitPackage shouldServerRefresh ]! !!MaCommitLogEntry methodsFor: '*magma-server-MagmaArray-support' stamp: 'cmm 2/13/2008 13:32'!hasChangesToMagmaArray: oidInteger 	^ (self magmaArrayChangesAt: oidInteger) notNil! !!MaCommitLogEntry methodsFor: '*magma-server-MagmaArray-support' stamp: 'cmm 2/13/2008 13:32'!magmaArrayChangesAt: oidInteger 	commitPackage allLargeCollectionChangesDo: 		[ : each | 		each collectionOid = oidInteger ifTrue: [ ^ each ] ].	^ nil! !MaBufferPositionMap subclass: #MagmaBufferPositionMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaBufferPositionMap commentStamp: 'cmm 8/27/2008 18:43' prior: 0!Magma adds additional attributes useful for an ODBMS.	#commitNumber!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaBufferPositionMap class	instanceVariableNames: ''!!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/1/2011 13:05'!bufferPositionOfByteCodesPlusTrailerSize	^ 26! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/10/2010 15:51'!bufferPositionOfClassVersion	"Magma adds 12 additional bytes."	^ 28! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/10/2010 15:51'!bufferPositionOfCommitNumber	"Bumping over the classVersion for FixedObjectBuffers."	^ 16! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/1/2011 13:06'!bufferPositionOfMethodHeader	^ 22! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/1/2011 14:56'!headerSize	"The standard record has 18 bytes of header.  Magma replaces portion of the header with the following:		commitNumber - 6 bytes		filler - 6 bytes		classVersion - 2 bytes"	^ 30! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/4/2011 21:32'!headerSizeForCompiledMethodBuffer	^ 34! !!MagmaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/27/2008 20:53'!indexPosition	"Reserve the 0-based particular slot for this attribute map."	^ 1! !MaClassIdManager subclass: #MagmaClassIdManager	instanceVariableNames: 'largeCollectionIds'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaClassIdManager commentStamp: 'cmm 6/28/2004 15:04' prior: 0!The purpose of this class is to keep track of which classes are persistent.!!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/15/2004 12:40'!assimilateInImageDefinition: aClass	aClass isMeta ifTrue: [ MagmaSoftwareError signal: 'Metaclass instances are not stored here.' ].	self addClassDefinition: (self inImageDefinition: aClass)! !!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/1/2004 15:19'!handleClassModification: aClass using: aMaObjectSerializer	self refreshInImageDefinition: aClass! !!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 9/6/2012 11:03'!handleClassRename: aRenamedEvent 	"aRenamedEvent's item has just been renamed."	aRenamedEvent isRenamed ifFalse: [ ^ self ].	self		renameClass: aRenamedEvent item		to: aRenamedEvent newName! !!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 9/6/2012 17:55'!renameClass: aClass to: newName 	"Class name changed, so did hash, so rehash."	idsByClass rehash.	inImageDefinitions rehash.	(self includesIdForClass: aClass) ifFalse: [ ^ self ].	(self inImageDefinition: aClass) in:		[ : renamedClassDefinition | renamedClassDefinition beKnownAs: newName ].	(self classDefinitions at: (self idForClass: aClass)) do:		[ : each | each beKnownAs: newName ]! !!MagmaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/20/2007 11:52'!idForClass: aClass ifAbsent: aBlock 	^ aClass = MagmaCounter 		ifTrue: [ self class magmaCounterClassId ]		ifFalse: 			[ super 				idForClass: aClass				ifAbsent: aBlock ]! !!MagmaClassIdManager methodsFor: 'accessing' stamp: 'cmm 3/8/2007 00:28'!largeCollectionIdsDo: aBlock 	largeCollectionIds ifNil: 		[ largeCollectionIds := OrderedCollection new.		self class largeCollectionClasses do: 			[ : each | | id |			(self includesIdForClass: each) 				ifTrue: [ largeCollectionIds add: (self idForClass: each) ] ] ].	largeCollectionIds do: aBlock! !!MagmaClassIdManager methodsFor: 'private' stamp: 'cmm 7/14/2010 14:29'!legacyClassMap	^ ({99 -> MagmaCounter} , super legacyClassMap) sort: [ : a : b | a key < b key ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaClassIdManager class	instanceVariableNames: ''!!MagmaClassIdManager class methodsFor: 'as yet unclassified' stamp: 'cmm 7/23/2011 14:07'!largeCollectionClasses	^ MagmaCoreLargeCollection allSubclasses! !!MagmaClassIdManager class methodsFor: 'as yet unclassified' stamp: 'cmm 7/20/2007 11:53'!minimumClasses	^ super minimumClasses, { MagmaCounter }! !!MagmaClassIdManager class methodsFor: 'accessing' stamp: 'cmm 7/24/2007 23:00'!magmaCounterClassId	"MagmaCounters get special treatment because they cannot cause a commit-conflict.  To easily support this, we check for a special class-id."	^ 99! !MaMinimalObject subclass: #MagmaForwardingProxy	instanceVariableNames: 'magmaId oid session cachedObject'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaForwardingProxy commentStamp: 'cmm 7/6/2009 20:28' prior: 0!I refer to an object in the repository indicated by my 'magmaId'.  You send me a message and I'll signal my session to try to connect if necessary and forward the message on to the real object in that repository.!!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 4/11/2009 16:53'!= anObject 	^ (anObject maIsForwardingProxy and: [ self fpRemoteMagmaId notNil or: [ anObject fpRemoteMagmaId notNil ] ]) 		ifTrue: 			[ (self == anObject or: 				[ self fpRemoteMagmaId = anObject fpRemoteMagmaId and: [ self fpRemoteOid = anObject fpRemoteOid ] ]) or: [ self realObject = anObject realObject ] ]		ifFalse: [ self realObject = anObject realObject ]! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 6/9/2010 13:34'!hash	^ self realObject hash! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 4/8/2005 15:20'!isImmutableInMagma 	"There is absolutely no reason to subject yourself to the danger of trying to point this to a different object.  Just create a new one via #asMagmaForwardingProxy."	^ true! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 12/8/2010 14:03'!isInMagma	^ session notNil! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/13/2005 17:15'!maIsForwardingProxy	^ true! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 7/5/2009 20:00'!maOriginalClass	"Serialization wants to know this."	^ self class! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 4/27/2014 20:48'!maRealObjectIsReified	^ cachedObject notNil! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/16/2005 23:52'!maRequiresOwnBuffer	^ true! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 7/5/2009 19:58'!respondsTo: aSymbol 	"Serialization wants to know whether I #respondsTo: aSymbol."	^ (self class canUnderstand: aSymbol) or: [ self realObject respondsTo: aSymbol ]! !!MagmaForwardingProxy methodsFor: 'converting' stamp: 'cmm 7/14/2008 17:58'!asMagmaForwardingProxy	^ self! !!MagmaForwardingProxy methodsFor: 'accessing'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0 ! !!MagmaForwardingProxy methodsFor: 'accessing' stamp: 'cmm 12/25/2002 00:44'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	"Access beyond fixed variables."	<primitive: 73>	self primitiveFailed! !!MagmaForwardingProxy methodsFor: 'accessing' stamp: 'cmm 8/10/2011 16:28'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^nil error: 'primitive failed updating object'! !!MagmaForwardingProxy methodsFor: 'initialize-release' stamp: 'cmm 11/18/2009 13:41'!cachedObject: anObject 	anObject maIsForwardingProxy ifTrue: 		[ MaError signal: 'ForwardingProxy should not reference a ForwardingProxy.' ].	cachedObject := anObject.	anObject magmaSession ifNotNilDo: 		[ : sess | 		oid := sess oidFor: anObject.		magmaId := sess magmaId veryDeepCopy	"so we don't share the same object between two repositories." ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/13/2005 16:21'!doesNotUnderstand: aMessage	^ self		forward: aMessage		to: self realObject! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 10/22/2010 20:26'!forward: aMessage to: anObject 	"Intercept any MagmaSessionRequests signaled within the boundaries of anObject's domain and let its own session handle them."	^ [ aMessage sendTo: anObject ]		on: MagmaSessionRequest		do: [ : notification | notification handleAndResumeUsing: self remoteSession ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 4/11/2009 17:26'!fpRemoteMagmaId	"Answers the MagmaId of the repository which my realObject belongs."	"The only time my magmaId should be nil is if a non-persistent object is sent #asMagmaForwardingProxy."	^ magmaId! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 4/11/2009 16:51'!fpRemoteMagmaId: aMagmaId	magmaId := aMagmaId! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 4/11/2009 16:53'!fpRemoteOid	"Answers the oid of the repository which my realObject belongs."	"The only time my oid should be nil is if a non-persistent object is sent #asMagmaForwardingProxy."	^ oid! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 17:36'!name	^ self doesNotUnderstand: (Message selector: #name)! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 12/8/2010 23:09'!realObject	^ cachedObject ifNil:		[ | existing |		existing := [ self remoteSession			ifNil: [ MagmaEnvironmentError signal: 'Could not create a session to remote object.' ]			ifNotNilDo:				[ : sess | sess					objectWithOid: self fpRemoteOid					ifAbsent: [ MagmaGarbageCollectedObject signal: 'This object has been dereferenced and subsequently garbage collected.' ] ] ]			on: MagmaUserRequiredNotification			do:				[ : noti | noti resume:					(MagmaUser id:						(self magmaSession							ifNil: [ 'auto-created session to materialize ' , self fpRemoteOid asString ]							ifNotNilDo:								[ : sess | sess userId ifNil: [ 'reconnected session' ] ])) ].		self remoteSession magmaId = magmaId ifFalse: [ MagmaEnvironmentError signal: 'Wrong db for remote object.' ].		existing maIsForwardingProxy ifTrue: [ MagmaSoftwareError signal: 'A ForwardingProxy should not reference a ForwardingProxy.' ].		cachedObject := existing ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 7/24/2018 22:20'!remoteSession	"This is the session which my realObject is retrieved from."	^ session ifNil:		[ session := magmaId ifNotNil:			[ self magmaSession				ifNil: [ magmaId findSession ]				ifNotNil:					[ : sess | (sess preferredLocationFor: magmaId)						ifNil: [ magmaId findSession ]						ifNotNil: [ : loc | loc newSession ] ] ] ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 13:02'!size	^ self doesNotUnderstand: (Message selector: #size)! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 11/9/2014 12:34'!slotAt: index 	"Access the nth slot of an object.  Use the instVarAt: primitive for speed with fixed, non-variable objects."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 11/10/2014 10:27'!slotAt: anInteger put: anObject	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables, followed by the indexed variables.	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 21:57'!value	^ self doesNotUnderstand: (Message selector: #value)! !!MagmaForwardingProxy methodsFor: 'serialization' stamp: 'cmm 8/11/2012 15:00'!ensureReferencePopulated	magmaId ifNil: 		[ cachedObject magmaSession 			ifNil: 				[ MagmaUserError signal: 'Remote object must be persistent before remote reference to them can be calculated.' ]			ifNotNilDo: 				[ : sess | 				"Copy the target object's magmaId, so we don't share instances between sessions.  MagmaCommitPackage will ensureCanonicalizedMagmaId:."				magmaId := sess magmaId veryDeepCopy.				magmaId ifNil: [ MagmaSoftwareError signal: 'Expected session to have definition' ].				oid := sess oidFor: cachedObject ].		(MaOidCalculator isOidForNewObject: oid) ifTrue: 			[ MagmaSoftwareError signal: 'Expected cachedObject to be persistent at this point.' ] ]! !!MagmaForwardingProxy methodsFor: 'serialization' stamp: 'cmm 8/5/2011 13:27'!maTransientVariables 	^ #( 'session' 'cachedObject' )! !!MagmaForwardingProxy methodsFor: 'serialization' stamp: 'cmm 3/9/2009 20:21'!maWantsPreSerialization	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaForwardingProxy class	instanceVariableNames: ''!!MagmaForwardingProxy class methodsFor: 'create' stamp: 'cmm 11/18/2009 14:37'!for: anObject 	"Create a new forwarding-proxy for anObject.  Any messages sent to the proxy will be forwarded on to anObject and the answer returned.  This way, models may continue to run with or without a repository, but with the same Magma-aware code-base."	^ self new		cachedObject: anObject realObject ";		yourself"  "do not include yourself this time, it forwards it to anObject!!"! !MaObject subclass: #MagmaLargeCollectionChanges	instanceVariableNames: 'collectionOid changes isNewCollection collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaLargeCollectionChanges methodsFor: 'override' stamp: 'cmm 3/18/2005 13:29'!add: anObject at: indexOrKey	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'override' stamp: 'cmm 3/18/2005 14:00'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 6/22/2009 15:09'!added	"On the client, answers an IdentityDictionary whose key is the object to be added, value is a collection of its calculated hashIndex values.  On the server, the key is the oid of the object, not the object itself."	^ changes		at: #added		ifAbsentPut: [ MaIdentityDictionary new ]! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 6/22/2009 14:38'!added: anIdentityDictionary 	changes 		at: #added		put: anIdentityDictionary! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!additionsDo: twoArgBlock	"The first argument is each object that has been added during the current	transaction, the second is a collection of hash-index values for each index."	self hasAdditions ifFalse: [ ^self ].	self added keysAndValuesDo: twoArgBlock! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!changes: aDictionary	changes := aDictionary! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!collection	^ collection! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collection: aMagmaLargeCollection	collection := aMagmaLargeCollection! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collectionOid	^collectionOid! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collectionOid: anInteger	collectionOid := anInteger! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:56'!hasAdditions	^(changes includesKey: #added) and: [ self added notEmpty ]! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 7/16/2010 17:11'!objectEqualTo: anObject 	"Answer the object equal to anObject, or nil if none."	^ self hasAdditions ifTrue:		[ (self added			associationAt: anObject			ifAbsent: [ nil ]) ifNotNilDo:			[ : assoc | assoc key ] ]! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'brp 4/6/2005 21:18'!removedDo: twoArgBlock	"The base class does not support removals, so do nothing."! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 8/6/2006 22:07'!session	^ collection session! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/16/2005 14:54'!beNewCollection	isNewCollection := true! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/17/2005 21:48'!initialize	super initialize.	self reset! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 8/5/2011 13:27'!maTransientVariables 	^ #( 'collection' )! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/16/2005 15:11'!reset	changes := Dictionary new.	isNewCollection := false! !!MagmaLargeCollectionChanges methodsFor: 'copying' stamp: 'cmm 3/28/2005 22:30'!copyForSerialization	| newChanges |	newChanges := changes species new.	changes keysAndValuesDo:		[ :eachKey :eachValue |		newChanges			at: eachKey			put: eachValue copy ].	^self copy changes: newChanges! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/17/2005 23:10'!hasAddedIndexes	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/17/2005 22:01'!hasChanges	^ self isNewCollection or: [ self hasAdditions ]! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'brp 4/6/2005 20:50'!hasRemoved	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/18/2005 11:02'!hasRemovedIndexes	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 7/16/2010 15:43'!includesObject: anObject 	^ self hasAdditions and: [ self added includesKey: anObject ]! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/20/2005 20:57'!isForMagmaArray	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/16/2005 15:10'!isNewCollection	^isNewCollection! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 11/7/2006 23:52'!isNotPersistent	"see subclass comment"	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 9/24/2009 10:53'!validate	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'reading' stamp: 'cmm 7/30/2006 13:55'!localSegment	"Populate a segment from the uncommitted changes."	| matching |	matching := OrderedCollection new.	self additionsDo: [ : object : hashes | matching add: object ].	^ MagmaCollectionSegment new		lastKnownSize: matching size ;		objects: matching ;		startIndex: 1 ;		yourself! !!MagmaLargeCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/18/2005 13:42'!serializeAddedUsing: aMaObjectSerializer	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/17/2005 22:04'!serializeUsing: aMaObjectSerializer	self serializeAddedUsing: aMaObjectSerializer! !!MagmaLargeCollectionChanges methodsFor: '*magma-server' stamp: 'cmm 10/26/2006 17:02'!requiresServerRefresh	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaLargeCollectionChanges class	instanceVariableNames: ''!!MagmaLargeCollectionChanges class methodsFor: 'create' stamp: 'cmm 3/17/2005 21:42'!collection: aMagmaCollection	^self new collection: aMagmaCollection! !MagmaLargeCollectionChanges subclass: #MagmaArrayChanges	instanceVariableNames: 'maxIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 8/31/2010 23:16'!add: anObject at: indexInteger 	maxIndex := maxIndex max: indexInteger.	self added		at: indexInteger		put: anObject! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 3/18/2005 14:02'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self additionsDo:		[ : eachIndex : eachObject |		(aMagmaSession isPersistent: eachObject) ifFalse: [ aMaCommitPackage addObject: eachObject ] ]! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 3/24/2005 17:36'!at: anIndex ifAbsent: aBlock	self hasAdditions ifFalse: [ ^ aBlock value ].	^ self added		at: anIndex		ifAbsent: aBlock! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 7/30/2006 14:10'!localSegment	"Populate a segment from the uncommitted changes."	| matching |	matching := OrderedCollection new.	self additionsDo: [ : index : object | matching add: object ].	^ MagmaCollectionSegment new		lastKnownSize: matching size ;		objects: matching ;		startIndex: 1 ;		yourself! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 8/31/2010 23:19'!maxIndex	^ maxIndex! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 8/31/2010 23:17'!reset	super reset.	maxIndex := 0! !!MagmaArrayChanges methodsFor: 'testing' stamp: 'cmm 3/20/2005 20:57'!isForMagmaArray	^ true! !!MagmaArrayChanges methodsFor: 'testing' stamp: 'cmm 9/24/2009 10:53'!validate	self additionsDo: 		[ : index : eachObject | 		index > 0 ifFalse: 			[ MagmaUserError signal: 'Cannot add to a MagmaArray at position ' , index asString ] ]! !!MagmaArrayChanges methodsFor: 'serializing' stamp: 'cmm 3/18/2005 13:47'!serializeAddedUsing: aMaObjectSerializer	| added |	self hasAdditions ifFalse: [ ^self ].	(added := self added) keysAndValuesDo: 		[ : eachIndex : eachObject |		added			at: eachIndex			put: (aMaObjectSerializer oidFor: eachObject) ]! !MagmaLargeCollectionChanges subclass: #MagmaCollectionChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaCollectionChanges commentStamp: '<historical>' prior: 0!This is a private class.  Applications should have no need to use this class directly.!!MagmaCollectionChanges methodsFor: 'overriding' stamp: 'cmm 12/5/2014 16:55'!add: anObject alsoAt: hashIndexValues 	| removed |	((removed := self removed) includesKey: anObject)		ifTrue: [ removed removeKey: anObject ]		ifFalse:			[ self added				at: anObject				ifPresent:					[ : existingHashValues | existingHashValues						with: hashIndexValues						do: [ : eachExisting : eachAdditional | eachExisting addAll: eachAdditional ] ]				ifAbsentPut: [ hashIndexValues ] ]! !!MagmaCollectionChanges methodsFor: 'overriding' stamp: 'cmm 3/16/2005 11:32'!add: anObject at: hashIndexValuesOrArrayIndex	| removed |	((removed := self removed) includesKey: anObject)		ifTrue:			[ removed removeKey: anObject ]		ifFalse:			[ self added				at: anObject				put: hashIndexValuesOrArrayIndex ]! !!MagmaCollectionChanges methodsFor: 'overriding' stamp: 'cmm 3/18/2005 14:01'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self additionsDo:		[ :eachObject :eachHashIndexValues |		(aMagmaSession isPersistent: eachObject) ifFalse: [ aMaCommitPackage addObject: eachObject ] ]! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 12/18/2014 17:14'!add: oid at: indexHashValues toIndexForAttribute: aSymbol 	(self newIndexValues 		at: aSymbol		ifAbsentPut: [ OrderedCollection new: 1 ]) add: 			(Association 				key: indexHashValues				value: oid)! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 12/20/2010 14:56'!addIndex: aMagmaIndexDescription 	self addedIndexes add: aMagmaIndexDescription.	self appendIndexValuesFor: (collection indexNamed: aMagmaIndexDescription attribute)! !!MagmaCollectionChanges methodsFor: 'added indexes'!addedIndexes	^changes		at: #addedIndexes		ifAbsentPut: [ OrderedCollection new ]! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 4/21/2002 23:10'!newIndexValues	"A dictionary of Dictionarys, (attribute Symbol -> (key->oid)...) used to	populate all new indexes being built in this transaction."	^changes		at: #newIndexValues		ifAbsentPut: [ Dictionary new ]! !!MagmaCollectionChanges methodsFor: 'added indexes'!newIndexValuesDo: aBlock	self hasNewIndexValues ifFalse: [ ^self ].	self newIndexValues do: aBlock! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 6/4/2007 10:16'!resetNewIndexValues	^ changes removeKey: #newIndexValues! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 12/9/2002 20:21'!appendIndexValuesFor: aMaIndexDefinition	"An index has been added.  Since the server processes all added and removed indexes prior to all added and removed objects, we need to make sure additions and removals have hash-index values for all indexes."	self additionsDo:		[ :eachObject :eachCollection |		eachCollection add: (aMaIndexDefinition indexHashesFor: eachObject) ].	self removedDo:		[ :eachObject :eachCollection |		eachCollection add: (aMaIndexDefinition indexHashesFor: eachObject) ]! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 11/7/2006 23:58'!beNotPersistent	"see isNotPersistent for explanation."	^ changes 		at: #notPersistent		put: nil! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 11/7/2006 23:51'!isNotPersistent	"private - Not mutually exclusive with #isNewCollection, isPersistent indicates I am referenced by the persistent model.  I can gain a 'permanent oid' and still not be referenced by the persistent model when I am a result set of a query that required one of the 'luxury' features like distinctness or sorting by a different attribute.  See MagmaSession>>#load:from:makeDistinct:."	^ changes includesKey: #notPersistent! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 2/18/2008 17:28'!refreshSegment: aMagmaCollectionReaderSegment where: aMaTerm 	aMagmaCollectionReaderSegment initializeObjects.	self additionsDo: 		[ : eachObject : eachHashes | 		"To be consistent with persistent readers, for each condition which satisfies the expression, the object is included."		(aMaTerm qualifyingHashesOf: eachObject) do: 			[ : eachAttributeAndHash | 			aMagmaCollectionReaderSegment addObject: eachAttributeAndHash value -> eachObject ] ].	aMagmaCollectionReaderSegment		startIndex: 1 ;		endIndex: aMagmaCollectionReaderSegment objects size ;		lastKnownSize: aMagmaCollectionReaderSegment objects size! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 12/7/2004 13:47'!removeIndexValuesFor: aMaIndexDefinition	"An index is being removed.  We need to make sure we remove	the hash index values to the objects that have already been added or	removed from the receiver."	| position |	position := collection indexes indexOf: aMaIndexDefinition.	self additionsDo: [ :eachObject :eachCollection | eachCollection removeAt: position ].	self removedDo: [ :eachObject :eachCollection | eachCollection removeAt: position ]! !!MagmaCollectionChanges methodsFor: 'changed keys'!changedKeySpecificationsDo: oneArgBlock	self hasChangedKeys ifFalse: [ ^self ].	self changedKeys do: oneArgBlock! !!MagmaCollectionChanges methodsFor: 'changed keys' stamp: 'cmm 12/18/2014 17:14'!changedKeys	"answer an OrderedCollection of MaChangedKeySpecification's."	^changes		at: #changedKeys		ifAbsentPut: [ OrderedCollection new: 1 ]! !!MagmaCollectionChanges methodsFor: 'accessing' stamp: 'cmm 10/26/2010 19:36'!deltaSize	^ self added size - self removed size! !!MagmaCollectionChanges methodsFor: 'accessing'!occurrencesOf: anObject	| numberAdded numberRemoved |	numberAdded := 0.	self additionsDo:		[ :eachObject :eachHashIndexValues |		eachObject = anObject ifTrue: [ numberAdded := numberAdded + 1 ] ].	numberRemoved := 0.	self removedDo:		[ :eachObject :eachHashIndexValues |		eachObject = anObject ifTrue: [ numberRemoved := numberRemoved + 1 ] ].	^numberAdded - numberRemoved! !!MagmaCollectionChanges methodsFor: 'testing'!hasAddedIndexes	^(changes includesKey: #addedIndexes) and: [ self addedIndexes notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing'!hasChangedKeys	^(changes includesKey: #changedKeys) and: [ self changedKeys notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 7/7/2008 22:11'!hasChanges	^ super hasChanges		or: [ self hasChangedKeys		or: [ self hasLockSpecified		or: [ self hasAddedIndexes		or: [ self hasNewIndexValues		or: [ self hasRemoved		or: [ self hasRemovedIndexes ] ] ] ] ] ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 8/21/2002 16:44'!hasLockSpecified	^changes includesKey: #lock! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 8/22/2002 14:00'!hasNewIndexValues	^changes includesKey: #newIndexValues! !!MagmaCollectionChanges methodsFor: 'testing'!hasRemoved	^(changes includesKey: #removed) and: [ self removed notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing'!hasRemovedIndexes	^(changes includesKey: #removedIndexes) and: [ self removedIndexes notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 10/27/2002 21:34'!isLocked	^(changes includesKey: #lock) and: [ changes at: #lock ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 9/24/2009 13:04'!validate	self additionsDo: 		[ : eachObject : indexHashes | 		(indexHashes anySatisfy: [ : eachArr | eachArr anySatisfy: [ : eachHash | eachHash < 0 ] ]) ifTrue: 			[ MagmaUserError signal: indexHashes asString , ' is not a valid index hash (may not be negative).' ] ]! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 7/30/2006 21:51'!hasRemoved: anObject	^ self hasRemoved and: [self removed includesKey: anObject]! !!MagmaCollectionChanges methodsFor: 'removed'!remove: anObject at: hashIndexesCollection	| added |	((added := self added) includesKey: anObject)		ifTrue:			[ added removeKey: anObject ]		ifFalse:			[ self removed				at: anObject				put: hashIndexesCollection ]! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 3/22/2010 18:24'!removed	"Answer the dictionary of objects that have been removed in the local client, but not yet committed to the repository."	^ changes		at: #removed		ifAbsentPut: [ MaIdentityDictionary new ]! !!MagmaCollectionChanges methodsFor: 'removed'!removedDo: twoArgBlock	"The first argument is each object that has been added during the current	transaction, the second is a collection of hash-index values for each index."	self hasRemoved ifFalse: [ ^self ].	self removed keysAndValuesDo: twoArgBlock! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 8/6/2006 22:07'!removedOids	^ self hasRemoved 		ifTrue: [ self removed keys collect: [ : each | self session oidFor: each ] ]		ifFalse: 			[ #() ]! !!MagmaCollectionChanges methodsFor: 'building' stamp: 'cmm 12/7/2002 12:18'!move: anObject from: oldHashValues to: newHashValues forIndexedAttribute: aSymbol	self changedKeys		add: (			MaChangedKeySpecification				object: anObject				attribute: aSymbol				oldHashValues: oldHashValues				newHashValues: newHashValues)! !!MagmaCollectionChanges methodsFor: 'building' stamp: 'cmm 8/22/2002 12:16'!setLocked: aBoolean	self hasLockSpecified		ifTrue:			[ self isLocked ~= aBoolean				ifTrue:					[ changes removeKey: #lock ] ]		ifFalse:			[ changes				at: #lock				put: aBoolean ]! !!MagmaCollectionChanges methodsFor: 'removed indexes' stamp: 'cmm 6/20/2009 10:48'!removeIndexNamed: attributeSymbol 	self removeIndexValuesFor: (collection indexNamed: attributeSymbol).	self hasAddedIndexes 		ifTrue: 			[ self addedIndexes 				maDetect: [ : each | each attribute = attributeSymbol ]				ifFound: [ : foundIndex | self addedIndexes remove: foundIndex ]				ifNone: [ self removedIndexes add: attributeSymbol ] ]		ifFalse: [ self removedIndexes add: attributeSymbol ]! !!MagmaCollectionChanges methodsFor: 'removed indexes'!removedIndexes	^changes		at: #removedIndexes		ifAbsentPut: [ OrderedCollection new ]! !!MagmaCollectionChanges methodsFor: 'removed indexes'!removedIndexesDo: oneArgBlock	self hasRemovedIndexes ifFalse: [ ^self ].	self removedIndexes do: oneArgBlock! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 6/22/2009 14:47'!serializeAddedUsing: aMaObjectSerializer 	| added newAdded |	self hasAdditions ifFalse: [ ^ self ].	added := self added.	newAdded := added maOriginalClass new.	added keysAndValuesDo: 		[ : eachObject : eachHashIndexValues | 		newAdded 			at: (aMaObjectSerializer oidFor: eachObject)			put: eachHashIndexValues ].	self added: newAdded! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 11/19/2002 22:39'!serializeChangedIndexValuesUsing: aMaObjectSerializer	self changedKeySpecificationsDo: [ :eachSpec | eachSpec serializeUsing: aMaObjectSerializer ]! !!MagmaCollectionChanges methodsFor: 'serializing'!serializeRemovedUsing: aMaObjectSerializer	| removed |	self hasRemoved ifFalse: [ ^self ].	(removed := self removed) copy keysAndValuesDo:		[ :eachObject :eachHashIndexValues |		removed			at: (aMaObjectSerializer oidFor: eachObject)			put: eachHashIndexValues;			removeKey: eachObject ]! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 6/1/2007 12:36'!serializeUsing: aMaObjectSerializer 	super serializeUsing: aMaObjectSerializer.	self		serializeRemovedUsing: aMaObjectSerializer ;		serializeChangedIndexValuesUsing: aMaObjectSerializer! !!MagmaCollectionChanges methodsFor: '*magma-server' stamp: 'cmm 11/6/2006 22:39'!requiresServerRefresh	^ self hasAddedIndexes or: [ self hasRemovedIndexes ]! !MaMutatingProxy subclass: #MagmaMutatingProxy	instanceVariableNames: 'session oid realObject'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 10/25/2010 13:27'!= object 	"The only way to answer correctly is for the fully-materialized objects to tell you.  However, if object is the same object as me, it would be true.  Getting two separate mutating-proxies for the same object is possible when a storage-object refers to a persistent object (i.e., MaCompiledMethodStorage>>'className')."	self == object ifTrue: [ ^ true ].	^ object maIsMutatingProxy		ifTrue:			[ (self maRealObjectIsReified and: [ object maRealObjectIsReified ])				ifTrue: [ self realObjectIfMutatingProxy = object realObjectIfMutatingProxy ]				ifFalse:					[ (self mutatingProxySession magmaId = object mutatingProxySession magmaId and: [ self maOid = object maOid ]) or: [ self realObjectIfMutatingProxy = object ] ] ]		ifFalse: [ self realObjectIfMutatingProxy = object ]! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 5/22/2013 16:27'!compareSafely: anObject 	^ false! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 4/28/2013 16:12'!isLiteral	^ self realObjectIfMutatingProxy isLiteral! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 5/5/2013 16:17'!maIsLargeCollection	^ self realObjectIfMutatingProxy maIsLargeCollection! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 12/9/2010 21:55'!maRealObjectIsReified	^ realObject ~~ nil! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 5/7/2013 18:40'!maRequiresOwnBuffer	^ self maRealObjectIsReified and: [ self realObjectIfMutatingProxy maRequiresOwnBuffer ]! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 5/22/2013 16:43'!shouldFollowOutboundPointers	^ true! !!MagmaMutatingProxy methodsFor: 'private' stamp: 'cmm 3/20/2015 15:15'!doesNotUnderstand: aMessage	| theReal | theReal := self realObjectIfMutatingProxy realObject.	aMessage lookupClass: theReal class.	^ aMessage sendTo: theReal! !!MagmaMutatingProxy methodsFor: 'private' stamp: 'cmm 3/22/2013 16:07'!fixSession	"It shouldn't happen, but if session's become nil'd out (maybe due to a becomeForward: nil), then this will attempt to restore it."	session ifNil:		[ realObject magmaSession ifNotNil:			[ : sess | session := sess.			session addProxy: self ] ]! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 5/22/2013 17:13'!instVarAt: instVarIndex 	"Overriding for speed, to avoid having to go through #doesNotUnderstand:."	^ MagmaPreferences debugProxies		ifTrue: [ self primInstVarAt: instVarIndex ]		ifFalse: [ self realObjectIfMutatingProxy instVarAt: instVarIndex ]! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 10/25/2010 12:58'!instVarAt: instVarIndex put: anObject 	"Overriding for speed, to avoid having to go through #doesNotUnderstand:."	^ self realObjectIfMutatingProxy		instVarAt: instVarIndex		put: anObject! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 7/14/2008 16:30'!maOid	^ oid! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 7/14/2008 16:30'!maOid: anInteger 	oid := anInteger! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 4/23/2013 17:08'!maOriginalClass	"This is called by maSelectPreMadeObjectBufferFrom:, so overriding for speed, to avoid having to go through DNU."	^ self realObjectIfMutatingProxy maOriginalClass! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 3/26/2013 09:05'!magmaOid	^ oid! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 2/3/2013 11:49'!magmaSession	"Answer the connected MagmaSession that the receiver was retrieved in.  If I am not an object retrieved from any session, answer nil."	^ session ifNil: [ realObject magmaSession ]! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:16'!mutatingProxySession	"This has such an ugly name so as not to conflict with other API named #session, to which I need to invoke my doesNotUnderstand: logic."	^session! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:20'!mutatingProxySession: aMagmaSession	session := aMagmaSession! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 5/22/2013 17:08'!primInstVarAt: instVarIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: instVarIndex - self class instSize! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 7/23/2013 13:02'!quickMagmaSession	"Answer the connected MagmaSession that the receiver was retrieved in.  If I am not an object retrieved from any session, answer nil."	^ session! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 8/28/2013 20:05'!realObjectIfMutatingProxy	"The hideous selector is to make sure to avoid any chance of name-space collision with objects that I may need to represent.  I want my client to get the messages, not handle them myself."	^  realObject ifNil:		[ | sess theReal | "Reference session in a temp just in case realObjectFor: might cause the thisContexts receiver to be becomed:, at which point 'session' refers to the 1st instVar of the object becomed to."		sess := session.		theReal := session realObjectFor: oid.		self maIsMutatingProxy ifTrue: [ realObject := theReal ].		sess preferences signalProxyMaterializations ifTrue: [ MagmaProxyMaterialization signalMaterializedObject: realObject ].		theReal ]! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 3/22/2013 16:15'!setRealObjectTo: anObject	realObject := anObject.	session addProxy: self! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 11/10/2014 10:30'!slotAt: instVarIndex put: anObject 	"Overriding for speed, to avoid having to go through #doesNotUnderstand:."	^ self realObjectIfMutatingProxy		slotAt: instVarIndex		put: anObject! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 11/22/2016 14:39'!yourself	"Short-cut to the object, rather than going through doesNotUnderstand:."	^ [ self realObjectIfMutatingProxy ] ensure:		[ session ifNotNil: [ session statistics houseCleaningTimeHistory addValue: (Time millisecondsToRun: [ session bulkBecomeProxies ]) ] ]! !!MagmaMutatingProxy methodsFor: 'debugging' stamp: 'cmm 5/22/2013 17:08'!outboundPointersDo: aBlock"do aBlock for every object I point to, exactly how the garbage collector would. Adapted from PointerFinder >> #followObject:"	aBlock value: self class.	1 to: self class instSize do: [:i | aBlock value: (self primInstVarAt: i)]! !!MagmaMutatingProxy methodsFor: 'printing' stamp: 'cmm 10/25/2010 12:58'!printOn: aStream 	MagmaPreferences debugProxies 		ifTrue: 			[ super printOn: aStream.			aStream				maPrint: $( ;				maPrint: oid ;				maPrint: '/' ;				maPrint: session id ;				maPrint: ')' ]		ifFalse: [ self realObjectIfMutatingProxy printOn: aStream ]! !!MagmaMutatingProxy methodsFor: 'commenting'!whyNoHash	"Because we don't want to allow the receiver to ever be added to a hashed	collection.  We want it to mutate and then be added, otherwise we'd have to	know which hashed collections to rehash once the receiver was mutated."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaMutatingProxy class	instanceVariableNames: ''!!MagmaMutatingProxy class methodsFor: 'creation' stamp: 'cmm 7/14/2008 16:30'!session: aMagmaSession oid: anInteger 	^ self new		mutatingProxySession: aMagmaSession ;		maOid: anInteger	"no yourself because it causes materialization of the proxy!!"! !MaOidManager subclass: #MagmaOidManager	instanceVariableNames: 'newObjects newOids statistics'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaOidManager commentStamp: 'cmm 6/21/2004 00:20' prior: 0!Because removeKey: is so slow in Squeak, I keep track of which ones are newObjects.  That way, when we return from a commit, replacement of temp to permanent oids is much faster.!!MagmaOidManager methodsFor: 'private' stamp: 'cmm 9/4/2012 16:42'!cleanObject: anObject 	super cleanObject: anObject.	newObjects		removeKey:			(newOids				removeKey: anObject				ifAbsent: [ ^ self ])		ifAbsent: [  ]! !!MagmaOidManager methodsFor: 'private' stamp: 'cmm 8/6/2013 14:07'!getNextOid	| ans |	^ (MaOidCalculator isOidForNewObject: (ans := super getNextOid))		ifTrue: [ ans ]		ifFalse: [ MagmaUserError signal: 'Cannot support more than about 4M objects in a single commit.' ]! !!MagmaOidManager methodsFor: 'private' stamp: 'cmm 8/3/2009 20:44'!validateNextOid	(MaOidCalculator isOidForNewObject: nextOid) ifFalse: 		[ MagmaUserError signal: 'Magma cannot add more than 4-million new objects at once.' ]! !!MagmaOidManager methodsFor: 'initialize-release' stamp: 'cmm 6/22/2016 19:56'!finalizeOids	super finalizeOids.	newOids finalizeValues: true.	newObjects class isAutoCleaning 		ifTrue: [ newObjects finalizeValues ]		ifFalse: [ newObjects := newObjects reject: [ : each | each isNil ] ]! !!MagmaOidManager methodsFor: 'initialize-release' stamp: 'sig 9/24/2007 09:41'!initializeNewObjects	newObjects := MagmaPreferences weakValueDictionaryClass new! !!MagmaOidManager methodsFor: 'initialize-release' stamp: 'cmm 4/25/2010 21:45'!initializeNewOids	newOids := MaObjectSerializerPreferences newWeakIdentityKeyDictionary! !!MagmaOidManager methodsFor: 'initialize-release' stamp: 'cmm 4/20/2005 22:23'!reset	super reset.	self resetNewObjects! !!MagmaOidManager methodsFor: 'initialize-release' stamp: 'cmm 4/20/2005 22:23'!resetNewObjects	"This is needed because we only have 2 million new-object oids.  If we didn't do this, the nextOid counter continues to increase to its ceiling."	self		initializeNewObjects ;		initializeNewOids ;		resetNextOid	! !!MagmaOidManager methodsFor: 'accessing' stamp: 'cmm 4/22/2013 13:33'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^MaOidCalculator		objectWithOid: anInteger		ifNone:			[ (MaOidCalculator isOidForNewObject: anInteger)				ifTrue:					[ newObjects						at: anInteger						ifPresent:							[ :obj |							obj 								ifNil: [ aBlock value ] 								ifNotNil: [ oneArgBlock value: obj ] ]						ifAbsent: aBlock ]				ifFalse:					[ objects						at: anInteger						ifPresent:							[ :obj |							obj   "oid key marked to be cleaned"								ifNil: [ aBlock value ]								ifNotNil: [ oneArgBlock value: obj ] ]						ifAbsent: aBlock ] ]! !!MagmaOidManager methodsFor: 'accessing' stamp: 'cmm 5/7/2013 10:28'!oidFor: anObject ifAbsent: aBlock 	^ anObject maIsMutatingProxy		ifTrue: [ anObject maOid ]		ifFalse:			[ anObject maRequiresOwnBuffer				ifTrue:					[ newOids						at: anObject						ifPresent:							[ : oid | oid								ifNil: aBlock								ifNotNil: [ oid ] ]						ifAbsent:							[ super								oidFor: anObject								ifAbsent: aBlock ] ]				ifFalse:					[ super						oidFor: anObject						ifAbsent: aBlock ] ]! !!MagmaOidManager methodsFor: 'accessing' stamp: 'cmm 5/6/2013 17:25'!oidOf: anObject is: anInteger 	^ (MaOidCalculator isOidForNewObject: anInteger)		ifTrue:			[ newObjects				at: anInteger				put: anObject.			newOids				at: anObject				put: anInteger ]		ifFalse:			[ super				oidOf: anObject				is: anInteger.			(anObject maIsMutatingProxy and: [ anObject maRealObjectIsReified ]) ifTrue:				[ oids					at: anObject realObjectIfMutatingProxy					put: anInteger ] ]! !!MagmaOidManager methodsFor: 'copying' stamp: 'cmm 4/20/2005 22:16'!postIndependentCopy	super postIndependentCopy.	newObjects := newObjects copy.	newOids := newOids copy! !!MagmaOidManager methodsFor: 'stats' stamp: 'cmm 5/7/2008 16:28'!statistics	^ statistics! !!MagmaOidManager methodsFor: 'stats' stamp: 'cmm 5/7/2008 15:54'!statistics: MaSerializationStat 	statistics := MaSerializationStat! !!MagmaOidManager methodsFor: 'stats' stamp: 'cmm 5/7/2008 16:28'!useStatisticsFrom: anotherOidManager 	statistics := anotherOidManager statistics! !MaClientServerRequest subclass: #MagmaRepositoryRequest	instanceVariableNames: 'sessionId console repositoryController failedLocation'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaRepositoryRequest commentStamp: 'cmm 1/25/2003 17:56' prior: 0!Superclass for all Magma request objects.!!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 2/27/2009 15:59'!failedLocation: aMagmaRemoteLocation 	failedLocation := aMagmaRemoteLocation! !!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 3/8/2009 15:21'!prepareToSubmitFor: aMagmaSession 	self sessionId: aMagmaSession id! !!MagmaRepositoryRequest methodsFor: 'accessing'!sessionId	^sessionId! !!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 11/5/2008 16:10'!sessionId: aUuid 	self requiresConnection ifTrue: [ aUuid ifNil: [ MagmaSoftwareError signal ] ].	sessionId := aUuid! !!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 6/17/2009 10:08'!waitCursor	^ MagmaPreferences waitCursor! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 8/20/2014 14:47'!isBegin	^ false! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 2/5/2009 20:16'!isConnect	^ false! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 9/21/2008 21:02'!isDisconnect	^ false! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 3/1/2009 12:02'!isWriteRequest	^ false! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 12/31/2002 15:26'!requiresConnection	^true! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:54'!timesToRetry	^ 2! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/13/2008 20:38'!console	^ console! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:27'!console: aMagmaServerConsole 	console := aMagmaServerConsole.	repositoryController := aMagmaServerConsole controller! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 12/30/2008 12:27'!isPrimary	"Answer whether I thisLocation is the primary server of a multi-server node.  If a single-server, answer false."	^ self restoreMode not and: [ self node isBackedUp ]! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 3/4/2009 15:31'!isSecondary	^ console isSecondary! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:32'!node	^ repositoryController node! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:24'!nodeCheck	"If I am a read-request sent to a primary, or a commit-request sent to a secondary, it's a red-flag to check on node-availability.  Check the node it *should* be going to.  If it is truly unavailable then update my MagmaNode accordingly and then #ensureCorrectNodeConfiguration.  If it is still available, then perhaps it is a client-issue, signal a MagmaWrongServerError to cause the client to reset its own configuration."	"Optional subclass override."	! !!MagmaRepositoryRequest methodsFor: '*magma-server'!process	"Any persistent objects returned by this should be materialized only by the sessions	serializer, not the repositoryLink's serializer because the sessions serializer is what	works with the transaction to mark it read so changes can be detected."	self subclassResponsibility! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 10/28/2008 11:28'!recoveryManager	^ self repository recoveryManager ! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:07'!repository	^ repositoryController repository! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 7/5/2004 11:57'!repositoryController: aMagmaRepositoryController	repositoryController := aMagmaRepositoryController! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:33'!restoreMode	^ repositoryController restoreMode! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:30'!session	^ repositoryController session! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 4/23/2018 14:28'!shouldBePrimary	"This request should only run on the primary server.  If I am in restoreMode (not the primary) then ping the primary to see whether it is still there.  If it isn't, take over, otherwise signal a MagmaWrongServerError back to the client."	self isSecondary ifTrue: 		[ 		[ self node pingPrimary.		MagmaWrongServerError new			correctServer: self node primaryLocation ;			signal ] 			on: NetworkError			do: 				[ : netErr | 				console ifNotNil: 					[ "Wait briefly for any further MaWriteRequests to arrive over the network, THEY must be processed before the NodeUpdate if they are present."										[ | writeRequests serverSocket |					(Delay forMilliseconds: 1800) wait.					writeRequests := OrderedCollection new.					serverSocket := self serverSocket.					serverSocket requestQueue removeAllSuchThat: 						[ : eachLifecycle | 						| requestObject |						requestObject := console server materializeRequest: eachLifecycle requestByteArray.						requestObject isWriteRequest 							ifTrue: 								[ MagmaNotification signal: 'Found a WriteRequest in teh queue!!'.								eachLifecycle requestObject: requestObject.								serverSocket dequeueRequest: eachLifecycle.								writeRequests add: eachLifecycle.								true ]							ifFalse: [ false ] ].					writeRequests := writeRequests asSortedCollection: 						[ : a : b | 						a commitLogRecord commitNumber < b commitLogRecord commitNumber ].					writeRequests do: [ : each | serverSocket processRequest: each ] ] 						on: Error						do: 							[ : err | 							MaClientServerPreferences debug 								ifTrue: [ err pass ]								ifFalse: 									[ "Ok, let's be extra aggressive in not letting server crash.  If one request generates an unexpected error, just log it and discard, but still process subsequent requests."									Smalltalk 										logError: err description										inContext: err signalerContext										to: 'SqueakDebug.log' ] ] ].				MagmaNodeUpdate new					remove: self node primaryLocation ;					setPrimary: console thisLocation ;					processUsing: console ] ]! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 3/6/2009 10:05'!shouldBeSecondary	"This request should only run on the secondary server.  If I am not in restoreMode (the primary) then ping the primary to see whether it is still there.  If it isn't, take over, otherwise signal a MagmaWrongServerError back to the client."	| session |	self isPrimary ifTrue: 		[ (failedLocation isNil or: [ (self node secondaryLocations includes: failedLocation) not ]) ifTrue: 			[ MagmaWrongServerError new				correctServer: self node anySecondaryLocation ;				signal ].		session := self node sessionFor: failedLocation.		console removeSecondaryLocation: failedLocation.		[ session beWarmBackupFor: self thisLocation ] 			on: NetworkError			do: 				[ : err | 				"It really is down, don't do anything."				 ] ]! !!MagmaRepositoryRequest methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 13:34'!thisLocation	^ console ifNotNil: [ console thisLocation ]! !MagmaRepositoryRequest subclass: #MaAbortTransactionRequest	instanceVariableNames: 'additionalBuffers'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaAbortTransactionRequest methodsFor: 'accessing' stamp: 'cmm 7/10/2009 13:49'!additionalBuffers: anArray	additionalBuffers := anArray! !!MaAbortTransactionRequest methodsFor: 'accessing' stamp: 'cmm 12/5/2012 10:05'!timesToRetry	^ 0! !!MaAbortTransactionRequest methodsFor: '*magma-server' stamp: 'cmm 11/15/2008 14:07'!nodeCheck	self shouldBePrimary! !!MaAbortTransactionRequest methodsFor: '*magma-server' stamp: 'cmm 7/10/2009 14:55'!process	| refreshViewResult |	refreshViewResult := self repository abortTransactionFor: sessionId.	refreshViewResult addToBeRefreshedWithoutOverwriting: 		(self repository 			refreshAll: additionalBuffers			for: sessionId).	^ refreshViewResult! !MagmaRepositoryRequest subclass: #MaAbstractReadRequest	instanceVariableNames: 'readStrategy requiredProgress'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaAbstractReadRequest methodsFor: 'building' stamp: 'cmm 3/8/2009 15:21'!prepareToSubmitFor: aMagmaSession 	super prepareToSubmitFor: aMagmaSession.	requiredProgress := aMagmaSession requiredProgress! !!MaAbstractReadRequest methodsFor: 'building' stamp: 'cmm 6/4/2006 20:11'!readStrategy	^ readStrategy ! !!MaAbstractReadRequest methodsFor: 'building' stamp: 'cmm 9/1/2003 23:25'!readStrategy: aMaReadStrategy	readStrategy := aMaReadStrategy! !!MaAbstractReadRequest methodsFor: 'accessing' stamp: 'cmm 3/8/2009 14:25'!requiredProgress	^requiredProgress! !!MaAbstractReadRequest methodsFor: 'accessing' stamp: 'cmm 12/4/2012 22:15'!timesToRetry	^ 3! !!MaAbstractReadRequest methodsFor: 'accessing' stamp: 'cmm 6/17/2009 09:50'!waitCursor	^ MagmaPreferences readCursor! !!MaAbstractReadRequest methodsFor: '*magma-server' stamp: 'cmm 3/8/2009 15:10'!nodeCheck	requiredProgress isInteger ifFalse: 		[ MagmaSoftwareError signal: 'requiredProgress must be an Integer, not a ' , requiredProgress class name ].	repositoryController commitNumber < requiredProgress ifTrue: [ MagmaReadServerTooFarBehind signal ].	self shouldBeSecondary! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAbstractReadRequest class	instanceVariableNames: ''!!MaAbstractReadRequest class methodsFor: 'as yet unclassified' stamp: 'cmm 10/12/2015 15:08'!initializeDefaultSound	defaultSound := ((FMSound new		 addEnvelope:			(VolumeEnvelope				points: {0 @ 1.0. 1 @ 1.0}				loopStart: 1				loopEnd: 1) ;			 yourself)		setPitch: 840.0		dur: 0.1		loudness: 0.25)! !MaAbstractReadRequest subclass: #MaAnchorRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaAnchorRequest commentStamp: 'cmm 1/25/2003 17:59' prior: 0!I'm the request used when you ask for the root.  The "real" root is actually an instance of MaRootAnchor, which references your root (this provides service via the standard commit mechanism).!!MaAnchorRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:09'!process	^ self repository		readAnchorFor: sessionId		using: readStrategy! !MagmaRepositoryRequest subclass: #MaCommitLogRecordRequest	instanceVariableNames: 'startingCommitNumber endingCommitNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaCommitLogRecordRequest methodsFor: 'accessing' stamp: 'cmm 3/15/2009 19:35'!endingCommitNumber: anInteger	endingCommitNumber := anInteger! !!MaCommitLogRecordRequest methodsFor: 'accessing' stamp: 'cmm 8/12/2008 21:43'!startingCommitNumber: anInteger	startingCommitNumber := anInteger! !!MaCommitLogRecordRequest methodsFor: 'accessing' stamp: 'cmm 6/17/2009 10:07'!waitCursor	^ MagmaPreferences readCursor! !!MaCommitLogRecordRequest methodsFor: 'testing' stamp: 'cmm 10/14/2008 16:39'!requiresConnection	^ false! !!MaCommitLogRecordRequest methodsFor: '*magma-server' stamp: 'cmm 3/15/2009 19:37'!process	^ endingCommitNumber 		ifNil: [ self repository commitRecordsFrom: startingCommitNumber ]		ifNotNil: 			[ self repository 				commitRecordsFrom: startingCommitNumber				to: endingCommitNumber ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCommitLogRecordRequest class	instanceVariableNames: ''!!MaCommitLogRecordRequest class methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 16:05'!initializeDefaultSound	defaultSound := ((FMSound new		 addEnvelope:			(VolumeEnvelope				points: {0 @ 1.0. 1 @ 1.0}				loopStart: 1				loopEnd: 1) ;			 yourself)		setPitch: 210.0		dur: 0.1		loudness: 1.0 ;		modulation: 2 ratio: 0.5)! !MagmaRepositoryRequest subclass: #MaCommitRequest	instanceVariableNames: 'package beginAnother'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaCommitRequest commentStamp: 'cmm 1/25/2003 17:55' prior: 0!I am the request object sent to a Magma server that commits changes to the database.!!MaCommitRequest methodsFor: 'building' stamp: 'cmm 4/21/2003 17:04'!beginAnother: aBoolean	beginAnother := aBoolean! !!MaCommitRequest methodsFor: 'building'!package: aMaCommitPackage	package := aMaCommitPackage! !!MaCommitRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:54'!timesToRetry	^ 0! !!MaCommitRequest methodsFor: 'accessing' stamp: 'cmm 6/17/2009 10:07'!waitCursor	^ MagmaPreferences writeCursor! !!MaCommitRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 19:12'!nodeCheck	self shouldBePrimary ! !!MaCommitRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 19:22'!process	| nodeUpdates answer |	answer := 	[ self repository 		submitAll: package		for: sessionId		beginAnother: beginAnother ] 		on: MagmaNodeUpdate		do: 			[ : update | 			nodeUpdates := nodeUpdates ifNil: [ OrderedCollection new ].			nodeUpdates add: update.			update resume ].	nodeUpdates ifNotNil: 		[ "this commit refreshes my sessions view"		self session commit: [ nodeUpdates do: [ : each | each applyTo: repositoryController node ] ] ].	^ answer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCommitRequest class	instanceVariableNames: ''!!MaCommitRequest class methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 15:15'!initializeDefaultSound	defaultSound := ((FMSound new		 addEnvelope:			(VolumeEnvelope				points: {0 @ 1.0. 1 @ 1.0}				loopStart: 1				loopEnd: 1) ;			 yourself)		setPitch: 420.0		dur: 0.1		loudness: 0.25)! !MagmaRepositoryRequest subclass: #MaDownloadCodeRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaDownloadCodeRequest methodsFor: 'testing' stamp: 'cmm 12/31/2002 15:26'!requiresConnection	^false! !!MaDownloadCodeRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 19:24'!nodeCheck	self shouldBeSecondary! !!MaDownloadCodeRequest methodsFor: '*magma-server' stamp: 'cmm 10/26/2004 21:54'!process	^ repositoryController codeBaseByteArray! !MagmaRepositoryRequest subclass: #MaGetMcLockerRequest	instanceVariableNames: 'mcOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaGetMcLockerRequest methodsFor: 'accessing' stamp: 'cmm 9/28/2008 20:54'!mcOid: anInteger	"The oid of the MagmaCollection."	mcOid := anInteger! !!MaGetMcLockerRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 19:33'!nodeCheck	self shouldBePrimary ! !!MaGetMcLockerRequest methodsFor: '*magma-server' stamp: 'cmm 6/23/2009 10:15'!process	^ (self repository 		collectionManagerFor: mcOid		ifAbsent: 			[ MagmaEnvironmentError signal: 'Error, no largeCollectoinManager for that collection found.' ]) lockedBy! !MaAbstractReadRequest subclass: #MaLargeCollectionSegmentRequest	instanceVariableNames: 'quantity collectionOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/4/2006 20:11'!collectionOid	^ collectionOid! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:50'!collectionOid: anInteger	collectionOid := anInteger! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/4/2006 20:11'!quantity	^ quantity! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing'!quantity: anInteger	quantity := anInteger! !MagmaRepositoryRequest subclass: #MaLargeCollectionSizeRequest	instanceVariableNames: 'collectionOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaLargeCollectionSizeRequest methodsFor: 'building'!collectionOid: anInteger	collectionOid := anInteger! !!MaLargeCollectionSizeRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 23:30'!nodeCheck	self shouldBeSecondary! !!MaLargeCollectionSizeRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:29'!process	^ self repository sizeOfLargeCollection: collectionOid! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLargeCollectionSizeRequest class	instanceVariableNames: ''!!MaLargeCollectionSizeRequest class methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 15:24'!initializeDefaultSound	defaultSound := ((FMSound new		 addEnvelope:			(VolumeEnvelope				points: {0 @ 1.0. 1 @ 1.0}				loopStart: 1				loopEnd: 1) ;			 yourself)		setPitch: 840.0		dur: 0.1		loudness: 0.25)! !MaLargeCollectionSizeRequest subclass: #MaKeyIntervalInfoRequest	instanceVariableNames: 'attribute lowKey highKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaKeyIntervalInfoRequest commentStamp: '<historical>' prior: 0!This request is used to get sizes of sub-magmacollections, either with or withoutindex.!!MaKeyIntervalInfoRequest methodsFor: 'building'!attribute: aSymbol	attribute := aSymbol! !!MaKeyIntervalInfoRequest methodsFor: 'building'!highKey: anInteger	highKey := anInteger! !!MaKeyIntervalInfoRequest methodsFor: 'building'!lowKey: anInteger	lowKey := anInteger! !!MaKeyIntervalInfoRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:31'!process	^ self repository		numberOfEntriesFrom: lowKey		to: highKey		inLargeCollection: collectionOid		on: attribute! !MagmaRepositoryRequest subclass: #MaLoadFromReaderRequest	instanceVariableNames: 'commitPackage expression sourceCollectionOid distinct'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 10/16/2006 12:15'!commitPackage: aMaCommitPackage	commitPackage := aMaCommitPackage! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/2/2006 23:43'!distinct: aBoolean	distinct := aBoolean! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/3/2006 12:55'!expression: aMagmaCollectionReader	expression := aMagmaCollectionReader! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:51'!sourceCollectionOid: anInteger	sourceCollectionOid := anInteger! !!MaLoadFromReaderRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:55'!timesToRetry	"Don't retry these; the chance of a duplicate load process is just not worth it."	^ 0! !!MaLoadFromReaderRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 23:31'!nodeCheck	self shouldBePrimary! !!MaLoadFromReaderRequest methodsFor: '*magma-server' stamp: 'cmm 10/16/2006 21:01'!process	^ self repository 		registerAndLoad: commitPackage 		using: expression		from: sourceCollectionOid		forSession: sessionId		distinct: distinct! !MagmaRepositoryRequest subclass: #MaLoadProgressRequest	instanceVariableNames: 'collectionOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaLoadProgressRequest methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:59'!collectionOid	^collectionOid! !!MaLoadProgressRequest methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:59'!collectionOid: anInteger	collectionOid := anInteger! !!MaLoadProgressRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 23:31'!nodeCheck	self shouldBePrimary ! !!MaLoadProgressRequest methodsFor: '*magma-server' stamp: 'cmm 11/16/2008 23:32'!process	^ (self repository collectionManagerFor: collectionOid) loadProgress! !MagmaRepositoryRequest subclass: #MaPrimitiveAttributesRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaPrimitiveAttributesRequest methodsFor: 'testing' stamp: 'cmm 10/22/2008 16:34'!requiresConnection	^ false! !!MaPrimitiveAttributesRequest methodsFor: '*magma-server' stamp: 'cmm 6/30/2009 16:56'!process	^ self repository primitiveAttributes		at: #oidCount			put: repositoryController oidCount ;		at: #isFullBackupRunning			put: repositoryController isFullBackupRunning ;		yourself! !MagmaRepositoryRequest subclass: #MaRawBufferRequest	instanceVariableNames: 'oid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRawBufferRequest methodsFor: 'as yet unclassified' stamp: 'cmm 3/14/2009 15:20'!oid: anInteger 	oid := anInteger! !!MaRawBufferRequest methodsFor: 'as yet unclassified' stamp: 'cmm 3/14/2009 15:21'!requiresConnection	^ false! !!MaRawBufferRequest methodsFor: '*magma-server' stamp: 'cmm 12/30/2015 23:49'!process	(MaOidCalculator isOidForUserObject: oid) ifFalse: [ MagmaUserError signal: oid asString, ' is not an oid of a persistent user-object.' ].	repositoryController ensureOpen.	^ self repository filer bufferFor: oid! !MaAbstractReadRequest subclass: #MaReadMultipleRequest	instanceVariableNames: 'oids'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaReadMultipleRequest methodsFor: 'accessing' stamp: 'cmm 2/11/2008 16:21'!oids: aCollection	oids := aCollection! !!MaReadMultipleRequest methodsFor: '*magma-server' stamp: 'cmm 8/21/2014 15:41'!nodeCheck	"This request is used to catch-up clients which have been disconnected.  If, while disconnected, the Node configuration changed, they will have an outdated view of the node until they can get reconnected and caught up.	Therefore, allow this request to be issued by the primary servers.	This fixes the stack-overflow issue which could occur under that circumstance."! !!MaReadMultipleRequest methodsFor: '*magma-server' stamp: 'cmm 2/11/2008 17:23'!process	^ self repository 		refreshAll: oids		for: sessionId! !MaAbstractReadRequest subclass: #MaReadRequest	instanceVariableNames: 'oid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaReadRequest commentStamp: 'cmm 1/25/2003 17:58' prior: 0!I'm a request to a Magma server for a bunch of needed object buffers, due to proxy materialization or whatever.!!MaReadRequest methodsFor: 'building'!oid: anInteger	oid := anInteger! !!MaReadRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:11'!process	^ self repository		read: oid		for: sessionId		using: readStrategy! !MagmaRepositoryRequest subclass: #MaReaderTrunkRequest	instanceVariableNames: 'collectionOid expression'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaReaderTrunkRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 18:34'!collectionOid: aMaTerm	collectionOid := aMaTerm! !!MaReaderTrunkRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 18:33'!expression: aMaTerm	expression := aMaTerm! !!MaReaderTrunkRequest methodsFor: '*magma-server' stamp: 'cmm 11/17/2008 09:32'!nodeCheck	self shouldBeSecondary! !!MaReaderTrunkRequest methodsFor: '*magma-server' stamp: 'cmm 8/6/2006 18:29'!process	^ self repository 		getTrunkFor: collectionOid		expression: expression! !MagmaRepositoryRequest subclass: #MaRefreshRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRefreshRequest methodsFor: 'overriding' stamp: 'cmm 1/8/2009 18:35'!nodeCheck	self shouldBePrimary! !!MaRefreshRequest methodsFor: 'accessing' stamp: 'cmm 12/5/2012 10:07'!timesToRetry	^ 0! !!MaRefreshRequest methodsFor: '*magma-server' stamp: 'cmm 1/8/2009 19:02'!process	^ self repository renewTransactionEntryFor: sessionId! !MaLargeCollectionSegmentRequest subclass: #MaRefreshSegmentRequest	instanceVariableNames: 'segment expression loadObjects exceptions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 21:24'!exceptions	^exceptions! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 22:32'!exceptions: aSet	exceptions := aSet! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!expression	^expression! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!expression: aMaTerm	expression := aMaTerm! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 7/29/2006 18:23'!loadObjects	^loadObjects! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 7/29/2006 18:23'!loadObjects: aBoolean	loadObjects := aBoolean! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!segment	^segment! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!segment: aMagmaCollectionSegment	segment := aMagmaCollectionSegment! !!MaRefreshSegmentRequest methodsFor: '*magma-server' stamp: 'cmm 6/4/2006 20:12'!process	^ self repository refreshSegmentIn: self! !MagmaRepositoryRequest subclass: #MaRemoveSecondaryLocationRequest	instanceVariableNames: 'locationToRemove'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRemoveSecondaryLocationRequest methodsFor: 'accessing' stamp: 'cmm 3/4/2009 15:47'!locationToRemove: anObject	locationToRemove := anObject! !!MaRemoveSecondaryLocationRequest methodsFor: 'testing' stamp: 'cmm 3/4/2009 15:50'!requiresConnection	^ false! !!MaRemoveSecondaryLocationRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:55'!timesToRetry	^ 0! !!MaRemoveSecondaryLocationRequest methodsFor: '*magma-server' stamp: 'cmm 3/4/2009 15:49'!nodeCheck	self isPrimary ifFalse: 		[ MagmaUserError signal: 'This request may only be sent to the primary server.' ]! !!MaRemoveSecondaryLocationRequest methodsFor: '*magma-server' stamp: 'cmm 3/4/2009 15:48'!process	console ifNil: 		[ MagmaUserError signal: 'This operation is only applicable to secondary servers in a multi-server HA Node configuration.' ].	console removeSecondaryLocation: locationToRemove.	^ true! !MagmaRepositoryRequest subclass: #MaRepositoryConnectionRequest	instanceVariableNames: 'userId magmaVersion commitNumber uuid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRepositoryConnectionRequest methodsFor: 'building' stamp: 'cmm 11/18/2008 13:49'!commitNumber: anInteger	commitNumber := anInteger! !!MaRepositoryConnectionRequest methodsFor: 'building' stamp: 'cmm 12/30/2002 23:20'!magmaVersion: anInteger	magmaVersion := anInteger! !!MaRepositoryConnectionRequest methodsFor: 'building'!userId: aString	userId := aString! !!MaRepositoryConnectionRequest methodsFor: 'building' stamp: 'cmm 12/18/2008 17:16'!uuid: aUuid	uuid := aUuid! !!MaRepositoryConnectionRequest methodsFor: 'testing' stamp: 'cmm 2/25/2009 11:04'!isConnect	^ true! !!MaRepositoryConnectionRequest methodsFor: 'testing' stamp: 'cmm 12/31/2002 15:27'!requiresConnection	^false! !!MaRepositoryConnectionRequest methodsFor: 'testing' stamp: 'cmm 12/5/2012 10:08'!timesToRetry	^ 0! !!MaRepositoryConnectionRequest methodsFor: '*magma-server' stamp: 'cmm 12/29/2012 11:35'!nodeCheck	failedLocation ifNotNil: [ console removeSecondaryLocation: failedLocation ]! !!MaRepositoryConnectionRequest methodsFor: '*magma-server' stamp: 'cmm 2/18/2012 12:10'!process	MagmaSession magmaVersion = magmaVersion ifFalse: 		[ MagmaUserError signal: 'This server is running Magma version ' , MagmaSession magmaVersion printString , '.  You may not connect with version ' , magmaVersion printString , ' of the client code.  You may be able to install the code using browseCode.' ].	uuid ifNotNil: 		[ repositoryController magmaId uuid = uuid ifFalse: 			[ MagmaUnconnectableSessionError signal: 'Cannot connect because the repository has been replaced.  Please connect a new session.' ] ].	commitNumber > 0 ifTrue: 		[ repositoryController commitNumber < commitNumber ifTrue: 			[ MagmaWrongCommitNumber signal: 'Cannot connect this session because the repository has been restored to an earlier state.  Please connect a new session.' ] ].	^ repositoryController 		newSessionFor: self		sessionId: sessionId! !!MaRepositoryConnectionRequest methodsFor: '*magma-server' stamp: 'cmm 9/21/2008 15:24'!userId	^ userId! !MagmaRepositoryRequest subclass: #MaRepositoryDisconnectRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRepositoryDisconnectRequest methodsFor: 'testing' stamp: 'cmm 9/21/2008 21:02'!isDisconnect	^ true! !!MaRepositoryDisconnectRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:55'!timesToRetry	"Can't connect to disconnect?  Don't retry that."	^ 0! !!MaRepositoryDisconnectRequest methodsFor: 'testing' stamp: 'cmm 11/24/2009 21:22'!wantsResponse	^ false! !!MaRepositoryDisconnectRequest methodsFor: '*magma-server' stamp: 'cmm 5/14/2005 18:15'!process	self repository removeSessionFor: sessionId.	^ nil! !MagmaRepositoryRequest subclass: #MaSaveAndExitImageRequest	instanceVariableNames: 'save exit'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaSaveAndExitImageRequest commentStamp: 'cmm 7/15/2008 17:22' prior: 0!This request supports management of headless servers.!!MaSaveAndExitImageRequest methodsFor: 'accessing' stamp: 'cmm 12/21/2008 15:38'!exit: aBoolean	exit := aBoolean! !!MaSaveAndExitImageRequest methodsFor: 'accessing' stamp: 'cmm 12/21/2008 15:38'!save: aBoolean	save := aBoolean! !!MaSaveAndExitImageRequest methodsFor: 'testing' stamp: 'cmm 7/15/2008 17:22'!requiresConnection	^ false! !!MaSaveAndExitImageRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:55'!timesToRetry	^ 0! !!MaSaveAndExitImageRequest methodsFor: '*magma-server' stamp: 'cmm 3/12/2009 22:03'!process	"Just like selecting it from the World menu.  shutdown process has responsibility to do it cleanly."	repositoryController 		serverSave: save		andExit: exit.	^ true! !MaLargeCollectionSegmentRequest subclass: #MaSegmentByIndexRequest	instanceVariableNames: 'lowIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaSegmentByIndexRequest methodsFor: 'building'!lowIndex: anInteger	lowIndex := anInteger! !!MaSegmentByIndexRequest methodsFor: '*magma-server' stamp: 'brp 6/14/2006 10:50'!process	^ self repository		upTo: quantity		oidsFromIndex: lowIndex		inLargeCollection: collectionOid		using: readStrategy		forSession: sessionId! !MagmaRepositoryRequest subclass: #MaServerPerformRequest	instanceVariableNames: 'selector arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaServerPerformRequest methodsFor: 'access' stamp: 'cmm 9/6/2007 21:32'!arguments: anArray	arguments := anArray! !!MaServerPerformRequest methodsFor: 'access' stamp: 'cmm 9/6/2007 21:32'!selector: selectorSymbol	selector := selectorSymbol! !!MaServerPerformRequest methodsFor: 'testing' stamp: 'cmm 2/22/2011 15:12'!requiresConnection	^ false! !!MaServerPerformRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry 	"Too risky to auto-retry, the operation may not be idempotent."	^ 0! !!MaServerPerformRequest methodsFor: '*magma-server' stamp: 'cmm 9/6/2007 21:33'!process	^ repositoryController 		perform: selector		withArguments: arguments! !MagmaRepositoryRequest subclass: #MaTransactionRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaTransactionRequest methodsFor: 'testing' stamp: 'cmm 8/20/2014 14:47'!isBegin	^ true! !!MaTransactionRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	"A retry here on a timeout would result in a guaranteed error once the original bytes made it, so don't retry."	^ 0! !!MaTransactionRequest methodsFor: '*magma-server' stamp: 'cmm 11/17/2008 09:33'!nodeCheck	self shouldBePrimary! !!MaTransactionRequest methodsFor: '*magma-server' stamp: 'cmm 12/17/2002 11:13'!process	^repositoryController newTransactionFor: sessionId! !MaCommitLogRecordRequest subclass: #MaWarmBackupUpdateRequest	instanceVariableNames: 'requestingLocation'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaWarmBackupUpdateRequest methodsFor: 'accessing' stamp: 'cmm 10/14/2008 17:26'!requestingLocation: aMagmaRemoteLocation	"Set with the location of the warm-backup requesting the records."	requestingLocation := aMagmaRemoteLocation! !!MaWarmBackupUpdateRequest methodsFor: '*magma-server' stamp: 'cmm 12/29/2008 13:50'!ensureNoWarmBackupNode	^ (repositoryController node locations includes: requestingLocation) ifTrue: 		[ repositoryController session commit: [ repositoryController node removeLocation: requestingLocation ] ]! !!MaWarmBackupUpdateRequest methodsFor: '*magma-server' stamp: 'cmm 8/18/2009 12:44'!ensureWarmBackupNode	requestingLocation isReachable ifFalse: 		[ MagmaEnvironmentError signal: requestingLocation asString , ' could not be made a warm backup because it is not reachable from ' , self thisLocation asString ].	(repositoryController node locations includes: requestingLocation) ifFalse: 		[ "Note, the following commit also fires-off an (async) WriteRequest to this newly-joined secondary."		repositoryController session commit: [ repositoryController node addLocation: requestingLocation ] ]! !!MaWarmBackupUpdateRequest methodsFor: '*magma-server' stamp: 'cmm 12/29/2008 13:54'!process	| answer doneIndicator |	doneIndicator := true.	answer := super process.	answer 		ifEmpty: [ self ensureWarmBackupNode ]		ifNotEmpty: 			[ "Sending back some commit-records, but did we make it to the end?  If so, we can add as a warm-backup right now."			answer last commitNumber = repositoryController commitNumber 				ifTrue: [ self ensureWarmBackupNode ]				ifFalse: 					[ self ensureNoWarmBackupNode.					doneIndicator := false ] ].	^ answer -> doneIndicator! !MagmaRepositoryRequest subclass: #MaWriteRequest	instanceVariableNames: 'commitLogRecord'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaWriteRequest methodsFor: 'accessing' stamp: 'cmm 3/2/2009 15:11'!commitLogRecord	^ commitLogRecord! !!MaWriteRequest methodsFor: 'accessing' stamp: 'cmm 10/28/2008 11:15'!commitLogRecord: aMaCommitLogRecord	commitLogRecord := aMaCommitLogRecord! !!MaWriteRequest methodsFor: 'accessing' stamp: 'cmm 6/17/2009 10:07'!waitCursor	^ MagmaPreferences writeCursor! !!MaWriteRequest methodsFor: 'testing' stamp: 'cmm 3/1/2009 12:02'!isWriteRequest	^ true! !!MaWriteRequest methodsFor: 'testing' stamp: 'cmm 12/29/2008 19:27'!requiresConnection	^ false! !!MaWriteRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MaWriteRequest methodsFor: 'testing' stamp: 'cmm 11/13/2008 10:30'!wantsResponse	^ false! !!MaWriteRequest methodsFor: '*magma-server' stamp: 'cmm 9/24/2014 10:54'!process	| commitLogEntry |	self restoreMode ifFalse: [ " MagmaEnvironmentError signal: 'Only repositories in restoreMode are updated in this way.' "		"Not signaling an error because, after a #takeOverAsPrimary, there will be unavoidable extranneous WriteRequests left-over in the queue.  It's easier just to ignore them for the test cases.  Also, WriteRequests are never checked for a response anyway, the sender of a WriteREquest would never know there was an error."		^ nil ].	commitLogEntry := self recoveryManager materializeCommitLogEntryIn: commitLogRecord.	[ "Fix:  #write:logged:commitLogRecord: can lead to #applyCommitRecords:, which must be flush-atomic.  Must not use commitCritical except inside a flushCritical to avoid potential deadlocks with #flushCacheSoon."	self repository flushCritical: 		[ self repository commitCritical:			[ self repository				write: commitLogEntry				logged: true				commitLogRecord: commitLogRecord ] ].	self session advanceWith: commitLogEntry ]		on: MagmaWrongCommitNumber		do:			[ : err | "console ensureCorrectNodeConfiguration"  "<-- probably overkill"			err expectedCommitNumber < commitLogRecord commitNumber				ifTrue:					[ "Gap fill"					repositoryController						catch: console thisLocation						upTo: repositoryController node primaryLocation ]				ifFalse: [ MagmaNotification signal: 'Received commitNumber ' , commitLogRecord commitNumber asString , ' but need ' , err expectedCommitNumber asString ] ]! !MagmaRepositoryRequest subclass: #MagmaBeWarmBackupRequest	instanceVariableNames: 'primaryLocation'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaBeWarmBackupRequest methodsFor: 'initializing' stamp: 'cmm 2/27/2009 15:13'!primaryLocation: aMagmaRemoteLocation 	primaryLocation := aMagmaRemoteLocation! !!MagmaBeWarmBackupRequest methodsFor: 'testing' stamp: 'cmm 2/27/2009 15:14'!requiresConnection	^ false! !!MagmaBeWarmBackupRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaBeWarmBackupRequest methodsFor: 'testing' stamp: 'cmm 2/27/2009 15:14'!wantsResponse	^ false! !!MagmaBeWarmBackupRequest methodsFor: '*magma-server' stamp: 'cmm 2/27/2009 15:35'!nodeCheck	self shouldBeSecondary ! !!MagmaBeWarmBackupRequest methodsFor: '*magma-server' stamp: 'cmm 12/4/2009 15:05'!process	console ifNil: 		[ MagmaEnvironmentError signal: 'MagmaServerConsole required for ' , self class name ].	primaryLocation isLocal ifTrue: 		[ MagmaUserError signal: 'Warm-backup of a locally-used repository is not supported.' ].	console beWarmBackupFor: primaryLocation! !MagmaRepositoryRequest subclass: #MagmaConnectionsRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaConnectionsRequest methodsFor: 'as yet unclassified' stamp: 'cmm 7/31/2013 09:58'!process	^ self repository connectionsList! !!MagmaConnectionsRequest methodsFor: 'as yet unclassified' stamp: 'cmm 3/24/2013 17:11'!requiresConnection	^ false! !MagmaRepositoryRequest subclass: #MagmaEnsureCorrectNodeConfiguration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaEnsureCorrectNodeConfiguration methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaEnsureCorrectNodeConfiguration methodsFor: 'testing' stamp: 'cmm 11/22/2009 22:26'!wantsResponse	^ false! !!MagmaEnsureCorrectNodeConfiguration methodsFor: '*magma-server' stamp: 'cmm 11/14/2008 14:38'!process	console ensureCorrectNodeConfiguration.	^ nil! !MagmaRepositoryRequest subclass: #MagmaFullBackupRequest	instanceVariableNames: 'serverPath'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaFullBackupRequest methodsFor: 'testing' stamp: 'cmm 12/30/2008 14:02'!requiresConnection	^ false! !!MagmaFullBackupRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaFullBackupRequest methodsFor: 'accessing' stamp: 'cmm 12/18/2008 15:26'!serverPath: aString 	"Set the server path to backup to."	serverPath := aString! !!MagmaFullBackupRequest methodsFor: '*magma-server' stamp: 'cmm 3/31/2010 17:53'!process	^ serverPath 		ifNil: [ repositoryController fullBackup ]		ifNotNil: [ repositoryController fullBackupToServerPath: serverPath ]! !MagmaRepositoryRequest subclass: #MagmaIdRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaIdRequest methodsFor: 'testing' stamp: 'cmm 7/15/2008 17:00'!requiresConnection	"Although a connection is not required, the session must have been *previously* connected.  This is used for a session reconnection, we must ensure it is connecting to the same repository."	^ false! !!MagmaIdRequest methodsFor: '*magma-server' stamp: 'cmm 1/14/2005 16:05'!process	^ repositoryController magmaId! !MagmaRepositoryRequest subclass: #MagmaNoteUnreachableServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaNoteUnreachableServer methodsFor: 'testing' stamp: 'cmm 3/6/2009 10:26'!requiresConnection	^ false! !!MagmaNoteUnreachableServer methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaNoteUnreachableServer methodsFor: '*magma-server' stamp: 'cmm 11/22/2008 17:44'!nodeCheck	self shouldBePrimary! !!MagmaNoteUnreachableServer methodsFor: '*magma-server' stamp: 'cmm 3/1/2009 17:30'!process	"My #shouldBePrimary method has already ensured I'm the primary."	^ nil! !MagmaRepositoryRequest subclass: #MagmaPathNameRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaPathNameRequest methodsFor: 'testing' stamp: 'cmm 9/19/2004 22:58'!requiresConnection	^ false! !!MagmaPathNameRequest methodsFor: '*magma-server' stamp: 'cmm 9/24/2004 15:13'!process	^ repositoryController pathName! !MagmaRepositoryRequest subclass: #MagmaReleaseReaderRequest	instanceVariableNames: 'collectionOid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaReleaseReaderRequest methodsFor: 'accessing' stamp: 'cmm 1/5/2010 13:43'!collectionOid: anInteger	collectionOid := anInteger! !!MagmaReleaseReaderRequest methodsFor: 'testing' stamp: 'cmm 1/5/2010 14:25'!wantsResponse	^ false! !!MagmaReleaseReaderRequest methodsFor: '*magma-server' stamp: 'cmm 1/5/2010 13:52'!process	(self repository 		collectionManagerFor: collectionOid		ifAbsent: [ nil ]) ifNotNilDo: [ : aMagmaCollectionManager | aMagmaCollectionManager wantsReleased: true ]! !MagmaRepositoryRequest subclass: #MagmaRequestSwapPrimaryDutyRequest	instanceVariableNames: 'newPrimary'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaRequestSwapPrimaryDutyRequest methodsFor: 'testing' stamp: 'cmm 3/3/2009 21:38'!requiresConnection	^ false! !!MagmaRequestSwapPrimaryDutyRequest methodsFor: 'testing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaRequestSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 11/23/2009 13:04'!nodeCheck	console ifNil: 		[ MagmaUserError signal: self class name , ' only applies when the repository is deployed on-line, with at least two servers forming a HA node.' ].	console restoreMode ifFalse: [ MagmaUserError signal: 'Repository is not a warm-backup.' ].	"Obtain the latest-possible view of the node."	repositoryController session abort.	(self node includesServerAt: self thisLocation) ifFalse: 		[ MagmaEnvironmentError signal: 'Node should include the secondary requesting primary duty.' ].	self shouldBeSecondary! !!MagmaRequestSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 3/8/2009 17:58'!process	| lastCommits sess |	sess := self node primarySession disconnect.	lastCommits := sess 		relinquishPrimaryDutyTo: self thisLocation		atCommitNumber: repositoryController commitNumber + 1		branchCode: repositoryController branchCode.	"Not using #commitRestore because I don't see that we need a new branchCode."	self repository		applyCommitRecords: lastCommits ;		restoreMode: false.	^ true! !!MagmaRequestSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 3/3/2009 20:32'!shouldBeSecondary	"Never ping anything else when receiving a swap request, if the administrator has the wrong server, the jig is up."	self isSecondary not ifTrue: 		[ MagmaWrongServerError new			correctServer: self node primaryLocation ;			signal: self printString , ' should be sent to a secondary server of multi-server nodes.' ]! !MaObject subclass: #MagmaServerResult	instanceVariableNames: 'serverNotifications'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaServerResult methodsFor: 'testing' stamp: 'cmm 1/28/2005 00:14'!hasServerNotifications	^ serverNotifications isEmptyOrNil not! !!MagmaServerResult methodsFor: 'testing' stamp: 'cmm 1/28/2005 00:15'!isMagmaServerResult	^ true! !!MagmaServerResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 14:23'!postTrimmedCopy	serverNotifications := nil! !!MagmaServerResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 14:23'!trimmedCopy	^ self copy postTrimmedCopy! !!MagmaServerResult methodsFor: 'printing' stamp: 'cmm 7/25/2013 10:08'!printDetailsOn: aStream	"This message normally shouldn't be sent to anything but a FailedCommiitResult, but I have seen it happen."! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 21:53'!serverNotifications	^ serverNotifications! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 21:54'!serverNotifications: aDictionary	serverNotifications := aDictionary! !MagmaServerResult subclass: #MaReadResult	instanceVariableNames: 'byteArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaReadResult methodsFor: 'accessing' stamp: 'cmm 12/16/2002 21:18'!byteArray	^byteArray! !!MaReadResult methodsFor: 'private' stamp: 'cmm 12/17/2002 00:49'!byteArray: aByteArray	byteArray := aByteArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaReadResult class	instanceVariableNames: ''!!MaReadResult class methodsFor: 'as yet unclassified' stamp: 'cmm 12/16/2002 21:18'!byteArray: aByteArray	^self new byteArray: aByteArray; yourself! !MagmaServerResult subclass: #MaRefreshViewResult	instanceVariableNames: 'connection toBeRefreshed isSystem commitNumber oidCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MaRefreshViewResult commentStamp: 'cmm 7/15/2008 14:44' prior: 0!A MaRefreshViewResult is the result object returned to the client upon crossing a transaction boundary where no transaction was present; i.e., not in a transaction, then doing an begin or abort.Instance Variables	connection : The MagmaClientConnection object identifying my client.	isSystem : A Boolean indicating whether my client is the one used by the repository-controller.	toBeRefreshed : The Dictionary of objects accumulated from other clients transactions that now need to be refreshed by my client.  It is the latest individual MaObjectBuffers keyed by their oid.	commitNumber : The number of commits made to the persistent model.!!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:44'!commitNumber	^commitNumber! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:45'!commitNumber: anInteger	commitNumber := anInteger! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 10/16/2006 00:29'!isSystem	"Answer whether I am for the results session."	^ isSystem! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 12/22/2008 13:21'!oidCount	"The number of oids allocated by this repository.  The total number of objects ever committed, even if some have since been garbage-collected."	^ oidCount! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 12/22/2008 13:22'!oidCount: anInteger	"The number of oids allocated by this repository.  The total number of objects ever committed, even if some have since been garbage-collected."	oidCount := anInteger! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:52'!permanentOids	^nil! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 8/15/2008 15:05'!sessionId	^ self connection ifNotNilDo: [ : conn | conn sessionId ]! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 8/15/2008 15:07'!userId	^ self connection ifNotNilDo: [ : conn | conn userId ]! !!MaRefreshViewResult methodsFor: 'initializing' stamp: 'cmm 7/16/2002 21:25'!connection	^connection! !!MaRefreshViewResult methodsFor: 'initializing' stamp: 'cmm 6/20/2004 20:32'!initialize	super initialize.	self toBeRefreshed: (Dictionary new: 50)! !!MaRefreshViewResult methodsFor: 'building' stamp: 'cmm 10/16/2006 00:28'!connection: aMagmaClientConnection	connection := aMagmaClientConnection.	isSystem := aMagmaClientConnection isSystem! !!MaRefreshViewResult methodsFor: 'building' stamp: 'cmm 10/8/2004 16:52'!toBeRefreshed: aDictionary	toBeRefreshed := aDictionary! !!MaRefreshViewResult methodsFor: 'private' stamp: 'cmm 3/9/2014 21:27'!populateConflictingObjectsFromOidsUsing: aMaObjectSerializer	"MagmaNoTransactionError will only have a MaRefreshViewResult."! !!MaRefreshViewResult methodsFor: 'copying' stamp: 'cmm 9/26/2008 10:05'!postTrimmedCopy	super postTrimmedCopy.	connection := connection trimmedCopy.	toBeRefreshed := nil! !!MaRefreshViewResult methodsFor: 'actions' stamp: 'cmm 1/10/2014 16:50'!refresh: aMagmaSession includingLocal: aBoolean	aMagmaSession		refreshChangedObjects: toBeRefreshed includingLocal: aBoolean ;		commitNumber: commitNumber ;		oidCount: oidCount! !!MaRefreshViewResult methodsFor: '*magma-server' stamp: 'cmm 7/24/2007 11:59'!addToBeRefreshed: aDictionary 	"aDictionary the containing the MaObjectBuffers that were committed by other sessions, keyed by their oid."	"We use addAll: so that oids are replaced by subsequent updates."	toBeRefreshed addAll: aDictionary! !!MaRefreshViewResult methodsFor: '*magma-server' stamp: 'cmm 7/11/2014 14:06'!addToBeRefreshedWithoutOverwriting: anArray 	"anArray of MaSerializedGraphBuffers was read from the repository files, but we want to keep the recent updates already in 'toBeRefreshed', which were from other user updates.	Also, the toBeRefreshed is expected to be a Dictionary of MaObjectBuffers, make it so."	anArray do: 		[ : eachSerializedGraphBuffer | 		eachSerializedGraphBuffer buffersDo: 			[ : eachBuffer | 			(toBeRefreshed includesKey: eachBuffer oid) ifFalse: 				[ toBeRefreshed 					at: eachBuffer oid					put: eachBuffer independentCopy ] ] ]! !!MaRefreshViewResult methodsFor: '*magma-server' stamp: 'cmm 12/30/2013 21:06'!toBeRefreshed	^ toBeRefreshed! !MagmaServerResult subclass: #MagmaLargeCollectionSegment	instanceVariableNames: 'objects lastKnownSize startIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaLargeCollectionSegment commentStamp: 'cmm 12/1/2004 21:44' prior: 0!I represent a "page" of objects in a MagmaCollection.!!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:02'!actualPageSize	^ self endIndex - startIndex + 1! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 11/2/2010 15:49'!at: anInteger ifAbsent: aBlock 	^ objects		at: anInteger - startIndex + 1		ifAbsent: [ ^ aBlock value ]! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	self subclassResponsibility ! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 7/20/2006 00:21'!lastKnownSize	^ lastKnownSize! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 7/20/2006 00:22'!lastKnownSize: anInteger	lastKnownSize := anInteger! !!MagmaLargeCollectionSegment methodsFor: 'accessing'!objects	^objects! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 3/22/2005 10:20'!startIndex	"Answers the logical index within the range of indices applicable to my Readers specified range."	^ startIndex! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 5/31/2006 12:35'!addObject: anObject	objects add: anObject! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 4/17/2005 22:11'!objects: aSequenceableCollection	objects := aSequenceableCollection! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 6/4/2006 16:48'!startIndex: anInteger	"Set the index position within the result set."	startIndex := anInteger! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 6/5/2006 23:25'!atEnd	self subclassResponsibility! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 2/17/2008 17:12'!includesIndex: anInteger 	"Answer whether logical anInteger-index falls within the range of indices currently covered by me."	^ self endIndex notNil and: 		[ anInteger 			between: startIndex			and: self endIndex ]! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 11/2/2010 15:54'!includesObject: anObject 	^ objects anySatisfy: [ : each | each = anObject ]! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 4/15/2005 10:05'!isEmpty	^ objects isEmpty! !!MagmaLargeCollectionSegment methodsFor: 'initialize-release' stamp: 'cmm 6/4/2006 20:53'!initialize	super initialize.	self initializeObjects! !!MagmaLargeCollectionSegment methodsFor: 'initialize-release' stamp: 'cmm 6/4/2006 20:53'!initializeObjects	objects := OrderedCollection new! !!MagmaLargeCollectionSegment methodsFor: 'printing' stamp: 'cmm 7/29/2006 18:13'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	aStream		space ;		maPrint: startIndex ;		maPrint: '..' ;		maPrint: self endIndex ! !!MagmaLargeCollectionSegment methodsFor: '*magma-server-private' stamp: 'cmm 2/18/2008 21:33'!collectBuffers: sessionId from: aMaObjectRepository using: aMaReadStrategy 	| readStrategy |	readStrategy := aMaObjectRepository 		ensureReadStrategy: aMaReadStrategy		forSession: sessionId.	self objects withIndexDo: 		[ : eachHashAndOid : n | 		eachHashAndOid isVariableBinding 			ifTrue: 				[ eachHashAndOid value: (aMaObjectRepository 						byteArrayAt: eachHashAndOid value						using: readStrategy) ]			ifFalse: 				[ "For member index accesses, there are no extra hash keys, so don't waste the bandwidth."				self objects 					at: n					put: 						(aMaObjectRepository 							byteArrayAt: eachHashAndOid "really just the oid"							using: readStrategy) ] ]! !MagmaLargeCollectionSegment subclass: #MagmaCollectionReaderSegment	instanceVariableNames: 'endIndex trunkStart trunkEnd trunk lowestKey highestKey mergedCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaCollectionReaderSegment commentStamp: 'cmm 2/15/2008 09:52' prior: 0!MagmaCollectionReaders may have access to thousands of objects, so it is necessary to only represent a page at a time.endIndex - Readers are accessible by #at:, my endIndex represents the index of the last element in this segment.highestKey - the Integer key of the last element in this segment.mergedCount - a positive Integer representing the number of objects added.  Number of objects removed is not indicated by this, they are indicated instead by decrements of the endIndex.trunk - The MaQueryTrunk for the expression.  The "trunk" represents all of the indexes and the key-ranges that must be enumerated to test all objects potentially valid for my readers expression.trunkEnd:  The ending Integer index position within the trunk this segment represents.trunkStart:  The starting Integer index position within the trunk this segment represents.!!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 15:44'!adjustLastKnownSize: anInteger 	self lastKnownSize ifNotNil: [ self lastKnownSize: self lastKnownSize - anInteger ]! !!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 2/17/2008 16:00'!advanceLastKnownSize: anInteger 	lastKnownSize ifNotNil: [ self lastKnownSize: lastKnownSize + anInteger ]! !!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 2/17/2008 21:55'!initialize	super initialize.	lowestKey := 0.	highestKey := 1 bitShift: 4096.	self resetMergedCount! !!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 09:56'!resetMergedCount	mergedCount := 0! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 2/18/2008 12:59'!advanceEnd: count 	endIndex := endIndex + count.	mergedCount := mergedCount + count.	self advanceLastKnownSize: count! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/29/2006 09:55'!advanceStart: count	startIndex := startIndex + count.	self advanceEnd: count! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/13/2009 18:07'!nextSegment	"In an empty MagmaCollection, we can't have any real segments, just one with no trunkEnd, so no need to try to get the 'next' one until we get our first valid one."	^ self isFitted 		ifTrue: 			[ self maOriginalClass new				startIndex: endIndex + 1 ;				trunkStart: trunkEnd + 1 ;				trunk: trunk ;				yourself ]		ifFalse: [ self ]! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 11/10/2014 10:30'!refreshFrom: anotherMagmaCollectionReaderSegment 	"I prefer this to become:.."	1 		to: self class instSize		do: 			[ : n | 			self 				slotAt: n				put: (anotherMagmaCollectionReaderSegment slotAt: n) ]! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 10/26/2010 20:12'!sortObjects: sortBlock 	objects sort: sortBlock! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 11/2/2010 15:49'!at: anInteger ifAbsent: aBlock 	^ (objects 		at: anInteger - startIndex + 1		ifAbsent: [ ^ aBlock value ]) value! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	"Answer the index within the large-collection or reader of the last element in the receivers objects collection."	^ endIndex! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex: anInteger	endIndex := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/7/2006 23:25'!highestKey	^highestKey! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/7/2006 23:25'!highestKey: anInteger	highestKey := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 2/16/2008 17:24'!lowestKey	^lowestKey! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 2/16/2008 17:24'!lowestKey: anInteger	lowestKey := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/29/2006 09:55'!mergedCount	^ mergedCount! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/5/2006 23:38'!trunk	^ trunk ! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/5/2006 23:38'!trunk: aMaQueryTrunk	trunk := aMaQueryTrunk! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 8/13/2007 23:50'!trunkEnd: anInteger 	"The query trunk can be accessed by logical index position.  Set the end position within the trunk of this segment."	trunkEnd := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:33'!trunkStart	"The query trunk can be accessed by logical index position.  Answer the start position within the trunk of this segment."	^ trunkStart! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:31'!trunkStart: anInteger 	"of the query trunk"	trunkStart := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 7/20/2006 00:29'!atEnd	"Answer whether I contain the last element that satisfies the original expression."	^ trunkEnd isNil "empty" 	or: [ lastKnownSize notNil ]! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 2/19/2008 22:25'!atEndForOptimized	"Answer whether I contain the last element that satisfies the original expression.  The implementation is different for Optmized vs. Filtered Readers, this is for the optimized."	^ trunkEnd + mergedCount >= lastKnownSize! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 2/16/2008 20:00'!includesKey: anInteger 	^ anInteger 		between: lowestKey		and: highestKey! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 2/18/2008 17:08'!includesObject: anObject 	^ objects anySatisfy: [ : each | each value = anObject ]! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 7/10/2006 23:30'!isFitted	"Answer whether I've been loaded with a valid range by the server."	^ trunkEnd notNil! !!MagmaCollectionReaderSegment methodsFor: 'printing' stamp: 'cmm 8/20/2007 21:44'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	lastKnownSize ifNotNil: 		[ aStream			maPrint: ' of ' ;			maPrint: lastKnownSize ].	aStream		maPrint: ' | ' ;		maPrint: mergedCount! !MagmaLargeCollectionSegment subclass: #MagmaCollectionSegment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaCollectionSegment methodsFor: 'testing' stamp: 'cmm 6/6/2006 00:05'!atEnd	^ self endIndex = lastKnownSize! !!MagmaCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	^ startIndex + objects size - 1! !MagmaRepositoryRequest subclass: #MagmaServerStatisticsRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaServerStatisticsRequest commentStamp: 'cmm 5/6/2008 13:26' prior: 0!Requests the console statistics from the server.!!MagmaServerStatisticsRequest methodsFor: 'testing' stamp: 'cmm 5/6/2008 14:01'!requiresConnection	^ false! !!MagmaServerStatisticsRequest methodsFor: '*magma-server' stamp: 'cmm 5/7/2008 17:22'!process	^ repositoryController serverStatistics! !MagmaCollectionChanges subclass: #MagmaSetChanges	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaSetChanges methodsFor: 'accessing' stamp: 'brp 5/30/2008 15:49'!added	"On the client, answers an Dictionary whose key is the object to be added, value is a collection of its calculated hashIndex values.  On the server, the key is the oid of the object, not the object itself."	^ changes		at: #added		ifAbsentPut: [ Dictionary new ]! !!MagmaSetChanges methodsFor: 'accessing' stamp: 'brp 5/30/2008 15:50'!removed	"Answer the dictionary of objects that have been removed in the local client, but not yet committed to the repository."	^ changes		at: #removed		ifAbsentPut: [ Dictionary new ]! !SOLHashFrame subclass: #MagmaSolHashFrame	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaSolHashFrame methodsFor: 'overriding' stamp: 'cmm 4/21/2011 20:50'!advance	"next will almost always be a proxy, so we avoid the DNU cost with this override."	prev := curr.	curr := next.	next := next ifNotNil: [ next realObjectIfMutatingProxy next ]! !!MagmaSolHashFrame methodsFor: 'overriding' stamp: 'cmm 4/21/2011 20:49'!set: aSOLHashNode	"next will almost always be a proxy, so we avoid the DNU cost with this override."	prev := aSOLHashNode.	curr := prev next.	next := curr ifNotNil: [ curr realObjectIfMutatingProxy next ]! !SOLHashSegment subclass: #MagmaSolHashSegment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaSolHashSegment methodsFor: 'private' stamp: 'cmm 4/8/2014 22:29'!bucketAt: bucketNum put: anObject 	"Return whatever (SOLHashSegment, SOLHashNode, or nil) is in pointers at the index corresponding to bucketNum."	(pointers maIsLargeCollection not and: [ 1 + (bucketNum bitAnd: owner segMask) > self maxPointers ]) ifTrue: [ self convertToMagmaArray ].	^ super		bucketAt: bucketNum		put: anObject! !!MagmaSolHashSegment methodsFor: 'private' stamp: 'cmm 4/23/2011 15:02'!convertToMagmaArray	| oldPointers |	oldPointers := pointers.	pointers := MagmaArray new		 pageSize: 1 ;		 yourself.	oldPointers withIndexDo:		[ : each : x | pointers			at: x			put: each ]! !!MagmaSolHashSegment methodsFor: 'private' stamp: 'cmm 4/8/2014 22:34'!maxPointers	^ 1000! !MagmaRepositoryRequest subclass: #MagmaSwapPrimaryDutyRequest	instanceVariableNames: 'newPrimary commitNumber branchCode'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaSwapPrimaryDutyRequest methodsFor: 'accessing' stamp: 'cmm 12/29/2008 16:41'!branchCode: anInteger 	branchCode := anInteger! !!MagmaSwapPrimaryDutyRequest methodsFor: 'accessing' stamp: 'cmm 12/29/2008 15:01'!commitNumber: anInteger	commitNumber := anInteger! !!MagmaSwapPrimaryDutyRequest methodsFor: 'accessing' stamp: 'cmm 3/3/2009 20:31'!newPrimary: aMagmaRemoteLocation	newPrimary := aMagmaRemoteLocation! !!MagmaSwapPrimaryDutyRequest methodsFor: 'accessing' stamp: 'cmm 9/24/2012 16:56'!timesToRetry	^ 0! !!MagmaSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 3/3/2009 21:38'!nodeCheck	self shouldBePrimary! !!MagmaSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 12/29/2008 16:41'!process	^ repositoryController 		executeSwapWith: newPrimary		commitNumber: commitNumber		branchCode: branchCode! !!MagmaSwapPrimaryDutyRequest methodsFor: '*magma-server' stamp: 'cmm 3/3/2009 21:38'!requiresConnection	^ false! !WBClassBuilder subclass: #MagmaWbClassBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private'!!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2011 16:55'!addPrimitiveOverride: methodSelector 	| mb |	mb := WBMethodBuilder		selector: methodSelector		class: class		fields: Array empty.	mb		 generateSignature ;		 generateTemporaryDeclarations ;		 generateCallSuperSendingToArgs: #realObjectIfMutatingProxy ;		 generateReturn.	class		compileSilently: mb streamContents		classified: 'overriding'! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 5/30/2018 22:00'!fieldsWrittenToBySelector: selectorSymbol 	| allInstVarNames transientFieldNumbers |	"#maDirtyAdd: is a low-level method used for safe materialization of HashedCollections, do not signal modified at that time."	selectorSymbol = #maDirtyAdd: ifTrue: [ ^Array empty ].	allInstVarNames := self targetClass allInstVarNames.	transientFieldNumbers := self targetClass basicNew maTransientVariables collect:		[ : eachVarName | allInstVarNames indexOf: eachVarName ].	^ (super fieldsWrittenToBySelector: selectorSymbol) reject:		[ : eachFieldNumber | transientFieldNumbers includes: eachFieldNumber ]! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 11/11/2016 14:39'!installMagmaOverrides	class		compileSilently:'maOriginalClass	^ self class superclass'		classified: 'accessing'.	class		compileSilently:'xxxClass	^ self class superclass'		classified: 'accessing'.	class class		compileSilently:'theNonWriteBarrierClass	^ self superclass'		classified: 'accessing'.! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 6/12/2012 22:40'!installOverrides	super installOverrides.	self		 installMagmaOverrides ;		 installPrimitiveOverrides! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 5/30/2018 22:50'!installPrimitiveOverrides	"Override all primitive methods which take an argument to be sure not to send it a MagmaMutatingProxy."	"skip ones already overridden elsewhere."	| skip |	skip := #(#at:put: #instVarAt:put:).	class allSuperclassesDo:		[ : eachClass | eachClass methodDictionary do:			[ : eachMethod | ((skip includes: eachMethod selector) not and:				[ eachMethod primitive > 0 and:					[ eachMethod selector isUnary not and: [ (class theNonWriteBarrierClass methodDictionary includesKey: eachMethod selector) not ] ] ]) ifTrue: [ self addPrimitiveOverride: eachMethod selector ] ] ]! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/10/2005 19:55'!migrateFromTarget: oldSuperclass to: newSuperclass	| oldClass |self halt.	oldClass := class.	"Was the immediate WriteBarrier superclass modified (or was it a superclass of that)?"	(oldClass superclass == newSuperclass)		ifTrue:			[ oldClass superclass: oldSuperclass.			class := self createSubclassOf: newSuperclass.			class updateInstancesFrom: oldClass ]		ifFalse:			[ "Although my class refers to the proper superclass, it must be rebuilt because its format has changed and must now be updated."			class := self createSubclassOf: oldClass superclass.			ClassBuilder new mutate: oldClass to: class"			self				updateInstancesOf: oldClass				to:  class" ]! !MaRecoveryRecord initialize!