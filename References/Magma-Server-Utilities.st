MaObject subclass: #MagmaCompressor	instanceVariableNames: 'inputController referencedCollections referencedClasses sourceLocation outputFiler upgradeBlock process'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Utilities'!!MagmaCompressor commentStamp: 'cmm 8/29/2002 22:35' prior: 0!I garbage collect a Magma repository and output a smaller file by eliminating buffers no longer referenced from the root buffer.I always create a new object file, but if you use compressAndRename, I'll rename the source files to 'old...' so you can get with using the compressed repository right away.If you don't want me to rename, just use #compressTo:.Oh, and I'm not meant to work while the files are on-line.  For that, use:	yourRepositoryController garbageCollect(Note:  a potential strategy for on-line GC would be to set a boolean flag indicating to the filer not to reuse buffers made available through grown objects, but rather to always add to the end.  During this time, a background thread can start reading from the root and build a new copy of the 'memory' map (the MaIntervalCollection).  Once it has accounted for every byte in the real memory map, we know the real one can be replaced with this new one.  Do a quick write of the new memory map and you're done!!)!!MagmaCompressor methodsFor: 'compress' stamp: 'cmm 2/9/2013 16:52'!close	inputController ifNotNil: [ inputController close ]! !!MagmaCompressor methodsFor: 'compress' stamp: 'cmm 5/2/2013 14:51'!compressTo: outputLocation 	| shouldCloseInput location objectCount sizeMsg |	location := outputLocation asMagmaLocalLocation.	shouldCloseInput := inputController isNil.	inputController ifNil: [ self openInput ].	objectCount := self		 createOutput: location ;		 copyPrimitiveAttributes ;		 writeGraphs.	self		 ensureNoOidReuse ;		 copyMagmaCollections.	self postCompress.	outputFiler close.	sizeMsg := objectCount asString , ' objects transferred to the compressed repository.'.	process description:		(shouldCloseInput			ifTrue:				[ self close.				'Done.  ' , sizeMsg , '  All repositories closed.' ]			ifFalse: [ 'Done.  ' , sizeMsg , '  Input repository left open.' ])! !!MagmaCompressor methodsFor: 'compress' stamp: 'cmm 10/20/2014 20:30'!forkCanoncalizeSymbolsAndCompressTo: outputLocation 	process := MaClientProcess doBlock:		[ | traverser oidsBySymbol oidConversions |		process			 name: 'canoncalizeSymbolsAndCompressTo: ' , outputLocation ;			 unitsVerbPhrase: ' objects traversed' ;			 description: 'Collecting oid-collections by Symbol...' ;			 priority: Processor userSchedulingPriority.		self guessTaskSize.		traverser := MagmaFileTraverser for: sourceLocation.		oidsBySymbol := Dictionary new.		traverser anchorGraphDo:			[ : eachBuffer | process advance.			(eachBuffer classId = 11 and: [ (MaOidCalculator isOidForNewObject: eachBuffer oid) not ]) ifTrue:				[ (oidsBySymbol					at: eachBuffer asString					ifAbsentPut: [ OrderedCollection new ]) add: eachBuffer oid ] ].		process			 description: traverser objectCount asString , ' objects in the database.' ;			 unitsCompleted: 0 ;			 taskSize: traverser objectCount.		"Interesting to see all the Symbols in the db and how many occurrences of each we had."		oidsBySymbol := oidsBySymbol reject:			[ : eachColl | eachColl size = 1 or:				[ eachColl anySatisfy:					[ : eachOid | MaOidCalculator isOidForNewObject: eachOid ] ] ].		oidsBySymbol do:			[ : each | each sort ].		oidsBySymbol explore.		oidConversions := Dictionary new.		oidsBySymbol keysAndValuesDo:			[ : eachSymbol : eachOids | eachOids size > 1 ifTrue:				[ eachOids withIndexDo:					[ : oid : index | index > 1 ifTrue:						[ oidConversions							at: oid							put: eachOids first ] ] ] ]."I'm not sure why we need this.  Try removing it?"		sourceLocation detachFromNode.		"Now do a second pass where we replace all references to the Symbols to the canonicalized one."		self upgradeBlock:			[ : eachBuffer | eachBuffer isPointers				ifTrue:					[ eachBuffer instVarsDoWithIndex:						[ : eachReferencedOid : index | oidConversions							at: eachReferencedOid							ifPresent:								[ : canonicalizedOid | eachBuffer									maInstVarAt: index									put: canonicalizedOid ]							ifAbsent: [  ] ] ]				ifFalse: [ eachBuffer ] ].		self compressTo: outputLocation ].	process		 resume ;		 yourself! !!MagmaCompressor methodsFor: 'compress' stamp: 'cmm 9/14/2016 16:54'!forkCompressTo: outputLocation 	^ process := (MaClientProcess doBlock: [ self compressTo: outputLocation ])		 priority: Processor userBackgroundPriority ;		 resume! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/2/2013 14:37'!copyMagmaCollections	process		 description: 'Copying MagmaCollection files...' ;		 unitsVerbPhrase: 'files copied' ;		 unitsCompleted: 0 ;		 taskSize: referencedCollections size.	referencedCollections do:		[ : eachOid | | sourceManager |		process advance.		sourceManager := inputController repository collectionManagerFor: eachOid.		sourceManager filenames do:			[ : eachMcFilename | (MaAtomicFileStream fileNamed: (inputController directory fullNameFor: eachMcFilename)) physicalFilenamesDo:				[ : eachPhysicalName | inputController directory					maCopyFileNamed: eachPhysicalName					toDirectory: outputFiler directory ] ] ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 3/4/2009 12:45'!copyPrimitiveAttributes	| inputFiler |	inputFiler := inputController repository filer.	inputController requestCritical: 		[ outputFiler primitiveAttributeAddressesMap keysAndValuesDo: 			[ : eachKey : eachValue | 			eachKey isSymbol ifTrue: 				[ outputFiler 					perform: (eachKey , ':') asSymbol					with: (inputFiler perform: eachKey) ] ] ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/2/2013 14:20'!createOutput: aMagmaLocalLocation 	process description: 'Creating output repository at ' , aMagmaLocalLocation pathName.	outputFiler := MaObjectFiler create: aMagmaLocalLocation directory! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/27/2007 16:36'!ensureNoOidReuse	"We can never allow an oid to be reused.  Once an object is created and persisted, its oid must be forever consumed.  Even if that object is later dereferenced, its oid will never be reused.  This is necessary to properly support universal-identity which is essential for MagmaForwardingProxys."	"determine the next oid to be used in our inputController."	| nextOid |	nextOid := inputController repository filer getNextOid.	"Force our output controller to allocate up to the current oid."	outputFiler getNextOid < nextOid ifTrue: 		[ outputFiler 			index: nextOid - 1			at: 0 ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/2/2013 14:36'!guessTaskSize	process		 unitsCompleted: 0 ;		 taskSize: sourceLocation oidCount! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 3/29/2007 16:30'!markClassReferenced: aMaObjectBuffer 	| classIdManager |	classIdManager := inputController session serializer classIdManager.	(classIdManager 		definitionForClassId: aMaObjectBuffer classId		version: aMaObjectBuffer classVersion) 		withAllSuperclassDefinitionsDo: 			[ : eachClassDefinition | 			referencedClasses add: eachClassDefinition id ].	"If a class-reference, be sure to get the referenced class itself."	(aMaObjectBuffer classId = (classIdManager idForClass: MaClassReference))		ifTrue:			[ | indexOfId classReferenceDefinition |			classReferenceDefinition :=				classIdManager					definitionForClassId: aMaObjectBuffer classId					version: aMaObjectBuffer classVersion.			"Get the index of the 'id' variable."			indexOfId := classReferenceDefinition allInstVarNames indexOf: 'id'.			indexOfId = 0 ifTrue: [ MagmaSoftwareError signal: 'Expected ''id'' variable.' ].			(classIdManager 				definitionForClassId:					(inputController session						objectWithOid: (aMaObjectBuffer maInstVarAt: indexOfId)						ifAbsent: [ MagmaSoftwareError signal: 'Expected an to find an id' ])				version: 1) 				withAllSuperclassDefinitionsDo: 					[ : eachClassDefinition | 					referencedClasses add: eachClassDefinition id ] ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 8/22/2002 21:09'!markCollectionReferenced: oidInteger	referencedCollections add: oidInteger! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 8/7/2011 21:27'!openInput	inputController := MagmaRepositoryController openedOn: sourceLocation ! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 8/12/2010 22:27'!postCompress	"Overridable by upgrading subclasses like MagmaUpgrader."! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/4/2013 15:02'!writeGraphs	| inputTraverser |	inputTraverser := MagmaFileTraverser repositoryController: inputController.	process knowsTaskSize ifFalse: [ self guessTaskSize ].	process		 description: 'Copying object graph...' ;		 unitsVerbPhrase: 'objects traversed'.	inputTraverser anchorGraphDo:		[ : eachBuffer | process advance.		process stopped ifFalse:			[ self markClassReferenced: eachBuffer.			(inputController isClassIdForLargeCollection: eachBuffer classId) ifTrue: [ self markCollectionReferenced: eachBuffer oid ].			(MaOidCalculator isOidForUserObject: eachBuffer oid) ifTrue:				[ outputFiler										write: (self upgrade: eachBuffer)					index: true ;					 filesDo: [ : eachFile : eachFileId | eachFile maCommit ] ] ] ].	^ inputTraverser objectCount! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'cmm 5/4/2013 15:02'!initialize	super initialize.	referencedClasses := Set new.	referencedCollections := Set new.	upgradeBlock := [ : eachBuffer | eachBuffer ].	process := MaClientProcess new! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'kph 10/5/2006 06:36'!sourceLocation: location	sourceLocation := location! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'cmm 8/5/2011 16:08'!upgradeBlock: oneArgBlock 	"Specify a block which accepts each MaObjectBuffer in the repository as an argument.  The value of the block will be written to the new compressed repository.  Useful for upgrading to new buffer-formats."	upgradeBlock := oneArgBlock! !!MagmaCompressor methodsFor: 'printing' stamp: 'cmm 2/9/2013 16:49'!maPrintAbbreviatedOn: aStream	sourceLocation maPrintAbbreviatedOn: aStream! !!MagmaCompressor methodsFor: 'override' stamp: 'cmm 3/2/2013 11:15'!mauiDefaultView 	^ 'Main'! !!MagmaCompressor methodsFor: 'override' stamp: 'cmm 8/6/2011 17:18'!upgrade: aMaObjectBuffer 	^ upgradeBlock value: aMaObjectBuffer ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaCompressor class	instanceVariableNames: ''!!MagmaCompressor class methodsFor: 'creation' stamp: 'cmm 1/18/2007 23:58'!source: pathStringOrMagmaLocalLocation	^ self new sourceLocation: pathStringOrMagmaLocalLocation asMagmaLocalLocation! !MaObject subclass: #MagmaFileTraverser	instanceVariableNames: 'repositoryController oidsVisited graphBuffer directory objectCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Utilities'!!MagmaFileTraverser commentStamp: 'cmm 8/5/2002 21:45' prior: 0!I walk the object buffers of an open Magma file and execute a Block for each buffer.I'm useful for the Magma garbage collection function, the compression function and for general purpose information gathering about what's in the repository.!!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 4/30/2013 21:56'!anchorGraphDo: aBlock 	| shouldClose |	objectCount := 0.	shouldClose := false.	repositoryController ifNil:		[ shouldClose := true.		self open ].	[ self		graphFrom: (repositoryController requestCritical: [ self repository filer anchorOid ])		do: aBlock ] ensure:		[ shouldClose ifTrue: [ self close ] ]! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 4/30/2013 21:57'!graphFrom: oid do: aBlock	"Value aBlock against every buffer in the receivers file."	| readStrategy shouldClose |	shouldClose := false.	objectCount := 0.	repositoryController ifNil: [ shouldClose := true. self open ].	readStrategy := MaBasicReadStrategy minimumDepth: 0.	MagmaNotification signal: 'Beginning traversal of ', oid printString, ' of ', directory pathName.	graphBuffer := MaSerializedGraphBuffer new: 1000.	[ self initializeOidsVisited.	self		graphFrom: oid		do: aBlock		using: readStrategy ]		ensure:			[ shouldClose ifTrue: [ self close ].			self deleteOidsVisited ].	MagmaNotification signal: 'Traversal of ', oid printString, ' of ', directory pathName, ' complete.'! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 3/8/2014 11:42'!traceAllPathsToAllOf: collectionOfOids	"Answer a collection of Array's, where each Array is the path of oids, from the root, to each object in collectionOfOids."	| set | set := collectionOfOids asSet.	^ self traceAllWhere: [ : each | set includes: each oid]! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 3/8/2014 11:35'!traceAllWhere: aBlock 	"Answer a the paths of buffers that value true for aBlock.  Each element is an ordered-collection of buffers where the last one satisfies aBlock."	^ Array streamContents:		[ : stream | self anchorGraphDo:			[ : each | (aBlock value: each) ifTrue: [ stream nextPut: graphBuffer buffers ] ] ]! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 5/3/2014 14:38'!traceAnyPathTo: oidInteger	"Answer a collection of MaObjectBuffers representing the path to oidInteger."	^ self traceAnyWhere: [ : each | each oid = oidInteger ]! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 3/8/2014 11:39'!traceAnyWhere: aBlock 	"Answer a path of buffers from the root to the buffer that values true for aBlock. The path is an ordered-collection of buffers where the last one satisfies aBlock."	self anchorGraphDo:		[ : each | (aBlock value: each) ifTrue: [ ^ graphBuffer buffers ] ]! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 8/21/2002 00:24'!close	repositoryController ifNotNil:		[ repositoryController requestCritical: [ repositoryController close ] ]! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/24/2004 16:15'!deleteOidsVisited	oidsVisited ifNotNil: [ oidsVisited close ].	directory deleteFileNamed: self tempOidsVisitedFilename! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 4/11/2009 17:07'!directory: aFileDirectory	directory := aFileDirectory! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 8/7/2011 16:31'!graphBuffer	^ graphBuffer! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 4/30/2013 21:57'!graphFrom: oidInteger do: oneArgBlock using: aMaReadStrategy 	| buffer indexPosition |	(MaOidCalculator isOidForUserObject: oidInteger) ifFalse: [ ^ self ].	indexPosition := MaOidCalculator indexPositionForOid: oidInteger.	(oidsVisited 		at: indexPosition		ifAbsent: [ 0 ]) = 0 ifFalse: [ ^ self ].	objectCount := objectCount + 1.	oidsVisited 		at: indexPosition		put: oidInteger.	repositoryController requestCritical: 		[ buffer := self repository filer 			appendObject: oidInteger			into: graphBuffer ].	oneArgBlock value: buffer.	buffer 		graphDo: oneArgBlock		using: aMaReadStrategy		for: self.	graphBuffer decreaseBufferSizeBy: buffer physicalSize! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 10/26/2006 14:43'!graphFromLargeCollection: oidInteger do: oneArgBlock using: aMaReadStrategy	| fileIndex |	fileIndex := (repositoryController 		requestCritical: 			[ repositoryController repository collectionManagerFor: oidInteger ]) memberIndex.	MagmaNotification signal: 'beginning enumeration of ', fileIndex size printString, ' objects in MagmaCollection ', oidInteger printString.	fileIndex		do: oneArgBlock		for: self		using: aMaReadStrategy.	MagmaNotification signal: 'MagmaCollection enumeration complete:  ', oidInteger printString! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 5/2/2005 12:04'!graphFromPointers: aMaObjectBuffer do: oneArgBlock using: aMaReadStrategy	"aMaObjectBuffer isPointers must be true to get here."	aMaObjectBuffer instVarsDoWithIndex:		[ :eachOid :index |		self			graphFrom: eachOid			do: oneArgBlock			using: aMaReadStrategy ]! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 7/12/2005 23:43'!initializeOidsVisited	oidsVisited ifNotNil: [ self deleteOidsVisited ].	oidsVisited := 		MaLargeArrayOfNumbers			createNamed: self tempOidsVisitedFilename			bitSize: MaObjectFiler maxDbSize! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 10/26/2006 18:40'!isForLargeCollection: aMaFixedObjectBuffer	^ repositoryController isClassIdForLargeCollection: aMaFixedObjectBuffer classId! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 4/11/2009 17:05'!open	repositoryController := MagmaRepositoryController openedOn: (MagmaLocalLocation path: directory pathName)! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 8/13/2002 23:29'!repository	^repositoryController repository! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/24/2004 15:54'!repositoryController: aMagmaRepositoryController	repositoryController := aMagmaRepositoryController.	directory := aMagmaRepositoryController directory! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/26/2004 21:30'!tempOidsVisitedFilename	^ repositoryController directory fullNameFor: 'oidsVisited.tmp'! !!MagmaFileTraverser methodsFor: 'initialize-release' stamp: 'cmm 4/30/2013 21:56'!initialize	super initialize.	objectCount := 0! !!MagmaFileTraverser methodsFor: 'accessing' stamp: 'cmm 4/30/2013 21:58'!objectCount	"The number of objects traversed by the receiver during the last graph traversal operation."	^ objectCount! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaFileTraverser class	instanceVariableNames: ''!!MagmaFileTraverser class methodsFor: 'creation' stamp: 'cmm 4/11/2009 17:07'!for: pathStringOrMagmaLocalLocation	^ self new 		directory: (pathStringOrMagmaLocalLocation asMagmaLocalLocation directory)		yourself! !!MagmaFileTraverser class methodsFor: 'creation' stamp: 'cmm 8/15/2002 22:52'!repositoryController: aMagmaRepositoryController	^self new repositoryController: aMagmaRepositoryController! !