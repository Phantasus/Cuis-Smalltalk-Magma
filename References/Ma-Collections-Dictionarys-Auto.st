MaDictionary subclass: #MaAutoWeakDictionary	instanceVariableNames: 'list preInitializedAssoc'	classVariableNames: 'IsSupported'	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakDictionary commentStamp: 'Igor.Stasenko 5/12/2010 19:07' prior: 0!I am a basic class for dictionaries which holding either keys or values weakly.I can auto-clean myself after garbage collection.I am using a special kind of associations , which appropriate for fast cleanup.I am not removing an existing association objects physically, but rather marking them as empty,so they can be reused later, when you want to add some more key/value pairs!!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 22:30'!associationAt: key ifAbsent: aBlock 		^ (array at: (self keyHash:key)) maFindKey: key ifAbsent: aBlock! !!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 18:33'!at: key	| index asc |	index := self keyHash: key.	asc := (array at: index) maFindKey: key.	(asc isNil or: [ asc isFree ]) ifTrue: [ ^ self errorKeyNotFound: key ].	^ asc value! !!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 18:32'!at: key ifAbsent: aBlock	| index asc |	index := self keyHash: key.	asc := (array at: index) maFindKey: key.	(asc isNil or: [ asc isFree ]) ifTrue: [ ^ aBlock value ].	^ asc value! !!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 18:37'!at: key ifAbsentPut: aBlock	| index asc val |	index := self keyHash: key.		asc := (array at: index) maFindKey: key.		asc ifNil: [ ^ self atIndex: index insertKey: key value: aBlock value ].	asc isFree ifFalse: [ ^ asc value ].	val := aBlock value.	asc		finList: list; 		key: key; 		value: val.	tally := tally +1.	self checkForOverflow.	^ val! !!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 18:28'!at: key put: value	| index asc |	index := self keyHash: key.		asc := (array at: index) maFindKey: key.	asc ifNil: [ ^ self atIndex: index insertKey: key value: value ].	asc isFree ifFalse: [ asc value: value. ^ value ].	" fill the free association "		asc		finList: list; 		key: key; 		value: value.	tally := tally +1.	self checkForOverflow.	^ value! !!MaAutoWeakDictionary methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 22:18'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| bucket val |		bucket := (array at: (self keyHash: key)) maFindKey: key ifAbsent: [ ^ aBlock value ].	"we're not deleting the association, just clearing it out"	val := bucket value.	bucket clear.	tally := tally - 1. 	self checkForUnderflow.	^ val! !!MaAutoWeakDictionary methodsFor: 'enumerating' stamp: 'Igor.Stasenko 11/8/2010 00:05'!associationsDo: aBlock	self finalizeValues. "make sure we're clean before iterating"	array do: [ :b |		b ifNotNil: [ b do: aBlock ]	].! !!MaAutoWeakDictionary methodsFor: 'private' stamp: 'Igor.Stasenko 9/24/2010 17:33'!atIndex: index insertKey: key value: value	| newb |	newb := preInitializedAssoc shallowCopy key: key value: value next: (array at: index).	array at: index put: newb.	tally := tally + 1.	self checkForOverflow.	^ value	! !!MaAutoWeakDictionary methodsFor: 'private' stamp: 'Igor.Stasenko 5/12/2010 22:00'!rehash: newSize	| newArray index |	"rehash"	newArray := Array new: newSize.	array do: [ :b | | next |		next := b.		[ next notNil ] whileTrue: [  | nn |			nn := next next.			"skip over free associations"			next isFree ifFalse: [				index := self keyHash: next key size: newSize.				next next: (newArray at: index).				newArray at: index put: next.			].			next := nn]	].	array := newArray.! !!MaAutoWeakDictionary methodsFor: 'finalization' stamp: 'Igor.Stasenko 5/12/2010 23:59'!finalizeValues		| asc |		asc := list swapWithNil.	[ asc notNil ] whileTrue: [ | next |		next := asc finNext.		asc clear.		tally := tally - 1.		asc := next.	].! !!MaAutoWeakDictionary methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 17:30'!initialize	super initialize.	list := WeakFinalizationList new.	preInitializedAssoc := self associationClass new finList: list.! !!MaAutoWeakDictionary methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 17:39'!initialize: sz	super initialize: sz.	list := WeakFinalizationList new.	preInitializedAssoc := self associationClass new finList: list.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAutoWeakDictionary class	instanceVariableNames: ''!!MaAutoWeakDictionary class methodsFor: 'testing' stamp: 'cmm 7/18/2010 19:43'!determineIfSupported	"Answer whether this image can support auto-cleaning weak dictionary's.  This requires Igor's finalization enhancement produced in Q1/2010."	| weakFinalizationListClass weakFinalizerItem list item |	weakFinalizationListClass := Smalltalk classNamed: #WeakFinalizationList.	weakFinalizerItem := Smalltalk classNamed: #WeakFinalizerItem.	weakFinalizationListClass ifNil: [ ^ false ].	weakFinalizerItem ifNil: [ ^ false ].	list := weakFinalizationListClass new.	item := (Smalltalk classNamed: #WeakFinalizerItem) new		list: list		object: Object new		executor: nil.	list first isNil ifFalse: [ ^ false ].	item object notNil ifFalse: [ ^ false ].	Smalltalk garbageCollect.	item object isNil ifFalse: [ ^ false ].	list first == item ifFalse: [ ^ false ].	list first next == nil ifFalse: [ ^ false ].	^ true! !!MaAutoWeakDictionary class methodsFor: 'testing' stamp: 'cmm 6/14/2010 22:26'!isAutoCleaning	"Type-check.  Answer whether I am an auto-cleaning type of Dictionary.  Makers of instances may need to check their instances on startup.."	^ true! !!MaAutoWeakDictionary class methodsFor: 'testing' stamp: 'cmm 6/14/2010 22:24'!supportsAutoCleaning	"Answer whether this image can support auto-cleaning weak dictionary's.  This requires Igor's finalization enhancement produced in Q1/2010."	^ IsSupported ifNil: [ IsSupported := self determineIfSupported ]! !!MaAutoWeakDictionary class methodsFor: 'initialize-release' stamp: 'cmm 6/14/2010 22:15'!initialize	super initialize.	Smalltalk addToStartUpList: self! !!MaAutoWeakDictionary class methodsFor: 'initialize-release' stamp: 'cmm 6/14/2010 22:16'!startUp: resuming	"Reset the IsSupported bit because we don't know whether this VM supports it or not."	IsSupported := nil! !MaAutoWeakDictionary subclass: #MaAutoIdentityKeyWeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoIdentityKeyWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 22:42'!associationClass	^ MaAutoIdentityKeyWeakValueAssociation! !!MaAutoIdentityKeyWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 22:44'!keyHash: key	^ (key identityHash \\ array size) + 1! !!MaAutoIdentityKeyWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/13/2010 07:58'!keyHash: key size: aSize	^ (key identityHash \\ aSize) + 1! !MaAutoWeakDictionary subclass: #MaAutoWeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 21:00'!associationClass	^ MaAutoWeakKeyAssociation! !!MaAutoWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/24/2010 19:26'!finalizeValues		| asc |		self class supportsAutoCleaning ifFalse: [		"do the hard way, scan whole dictionary"		array do: [:e |			asc := e.			[ asc notNil ] whileTrue: [ | next |				next := asc next.				asc key ifNil: [ asc clear. tally := tally - 1 ].				asc := next ]		].		^ self.	].	asc := list swapWithNil.	[ asc notNil ] whileTrue: [ | next |		next := asc finNext.		asc clear.		tally := tally - 1.		asc := next.	].! !!MaAutoWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 11/8/2010 00:33'!includesKey: aKey	aKey ifNil: [ ^ false ].	^ super includesKey: aKey! !MaAutoWeakKeyDictionary subclass: #MaAutoWeakIdentityKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 21:16'!associationClass	^ MaAutoWeakIdentityKeyAssociation! !!MaAutoWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 22:44'!keyHash: key	^ (key identityHash \\ array size) + 1! !!MaAutoWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/13/2010 07:55'!keyHash: key size: aSize	^ (key identityHash \\ aSize) + 1! !MaAutoWeakDictionary subclass: #MaAutoWeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 21:15'!associationClass	^MaAutoWeakValueAssociation! !Object weakSubclass: #MaWeakAssociation	instanceVariableNames: 'finList finNext next'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaWeakAssociation commentStamp: 'Igor.Stasenko 5/12/2010 21:02' prior: 0!I am an abstact basic class for associations which holding either key or value weakly!!MaWeakAssociation methodsFor: 'comparing and hashing' stamp: 'Igor.Stasenko 5/12/2010 20:48'!= anObject	"my instances should not be used in dictionaries as keys"	^ self == anObject! !!MaWeakAssociation methodsFor: 'comparing and hashing' stamp: 'Igor.Stasenko 5/12/2010 20:39'!compareKey: aKey	"answer true if my key matching given aKey"	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'comparing and hashing' stamp: 'Igor.Stasenko 5/12/2010 20:48'!hash	"my instances should not be used in dictionaries as keys"	^ self identityHash! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:55'!clear	finNext := finList := nil.	self key: nil; value: nil! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:39'!finList	^ finList! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:39'!finList: aList	finList := aList! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 19:05'!finNext	^ finNext! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:52'!key	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:40'!key: aKey	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:52'!next	^ next! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:52'!next: aNext	next := aNext! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:52'!value	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:40'!value: anObject	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'bucket iterations' stamp: 'Igor.Stasenko 5/12/2010 18:58'!do: aBlock	finList ifNotNil: [ aBlock value: self ].	next ifNotNil: [ next do: aBlock ]! !!MaWeakAssociation methodsFor: 'bucket iterations' stamp: 'Igor.Stasenko 11/8/2010 00:16'!maFindKey: aKey 	"find an association with given key,	- answer nil, if key not found	- answer free association if key not found and there is a free association found in list	- if key found, answer it "	| nxt free |		free := nil.	nxt := self.	[ nxt notNil ] whileTrue: [		nxt isFree ifTrue: [ free := nxt ] ifFalse: [			(nxt compareKey: aKey) ifTrue: [ ^ nxt ]			].		free ifNil: [ nxt := nxt next ] ifNotNil: [ nxt := nxt skipFree ].	].	^ free! !!MaWeakAssociation methodsFor: 'bucket iterations' stamp: 'Igor.Stasenko 5/12/2010 22:16'!maFindKey: aKey ifAbsent: aBlock	"find an association with given key,	or free association, found during scanning, or nil"	| nxt |		nxt := self.	[ nxt notNil ] whileTrue: [		nxt finList ifNotNil: [ (nxt compareKey: aKey) ifTrue: [ ^ nxt ]].		nxt := nxt next	].	^ aBlock value! !!MaWeakAssociation methodsFor: 'bucket iterations' stamp: 'Igor.Stasenko 5/12/2010 22:13'!maFindKey: aKey ifAbsent: aBlock ifFree: aBlockFree	"find an association with given key,	or free association, found during scanning, or nil"	| nxt free |		free := nil.	nxt := self.	[ nxt notNil ] whileTrue: [		nxt finList ifNil: [ free := nxt ] ifNotNil: [			(nxt compareKey: aKey) ifTrue: [ ^ nxt ]			].		nxt := nxt next	].	^ free ifNil: aBlock ifNotNil: [ aBlockFree value: free ]! !!MaWeakAssociation methodsFor: 'bucket iterations' stamp: 'Igor.Stasenko 11/8/2010 00:10'!skipFree	| n |	n := next.	[ n notNil and: [ n isFree ] ] whileTrue: [ n := n next ].	^ next := n.	! !!MaWeakAssociation methodsFor: 'testing' stamp: 'Igor.Stasenko 5/12/2010 20:29'!isFree	^ finList == nil! !!MaWeakAssociation methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/12/2010 18:49'!key: key value: value next: next finList: aList	self subclassResponsibility ! !!MaWeakAssociation methodsFor: 'printing' stamp: 'Igor.Stasenko 5/12/2010 21:54'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaWeakAssociation class	instanceVariableNames: ''!!MaWeakAssociation class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 18:56'!key: key value: value next: next finList: aList	^ (self basicNew: 1) key: key value: value next: next finList: aList! !!MaWeakAssociation class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 18:48'!new	^ self basicNew: 1! !MaWeakAssociation weakSubclass: #MaAutoWeakKeyAssociation	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakKeyAssociation methodsFor: 'comparing and hashing' stamp: 'Igor.Stasenko 5/12/2010 20:44'!compareKey: aKey	"answer true if my key matching given aKey"	^ (self basicAt: 1) = aKey! !!MaAutoWeakKeyAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:53'!key	^ self basicAt: 1! !!MaAutoWeakKeyAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:44'!key: aKey	self basicAt: 1 put: aKey! !!MaAutoWeakKeyAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 18:53'!value	^ value! !!MaAutoWeakKeyAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 20:43'!value: aValue	value := aValue! !!MaAutoWeakKeyAssociation methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 17:32'!key: key value: aValue next: aNext	self basicAt: 1 put: key.	value := aValue.	next := aNext! !!MaAutoWeakKeyAssociation methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/12/2010 18:50'!key: key value: aValue next: aNext finList: aList	self basicAt: 1 put: key.	value := aValue.	finList := aList.	next := aNext! !MaAutoWeakKeyAssociation weakSubclass: #MaAutoWeakIdentityKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakIdentityKeyAssociation methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 21:03'!compareKey: aKey	"answer true if my key matching given aKey"	^ (self basicAt: 1) == aKey! !MaWeakAssociation weakSubclass: #MaAutoWeakValueAssociation	instanceVariableNames: 'key'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoWeakValueAssociation methodsFor: 'comparing and hashing' stamp: 'Igor.Stasenko 5/12/2010 21:13'!compareKey: aKey	"answer true if my key matching given aKey"	^ key = aKey! !!MaAutoWeakValueAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 21:13'!key	^ key! !!MaAutoWeakValueAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 21:13'!key: aKey	key := aKey! !!MaAutoWeakValueAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 21:12'!value	^ self basicAt: 1! !!MaAutoWeakValueAssociation methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/12/2010 21:13'!value: anObject	self basicAt: 1 put: anObject! !!MaAutoWeakValueAssociation methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 17:32'!key: aKey value: aValue next: aNext	key := aKey.	self basicAt: 1 put: aValue.	next := aNext! !!MaAutoWeakValueAssociation methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/12/2010 21:12'!key: aKey value: aValue next: aNext finList: aList	key := aKey.	self basicAt: 1 put: aValue.	finList := aList.	next := aNext! !MaAutoWeakValueAssociation weakSubclass: #MaAutoIdentityKeyWeakValueAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys-Auto'!!MaAutoIdentityKeyWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/12/2010 22:41'!compareKey: aKey	"answer true if my key matching given aKey"	^ key == aKey! !MaAutoWeakDictionary initialize!