MagmaCoreLargeCollection subclass: #MagmaArray	instanceVariableNames: 'segment pageSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaArray'!!MagmaArray commentStamp: 'cmm 9/10/2009 21:26' prior: 0!I can be used like a normal Array to reference billions of objects, at a cost of 6-bytes of disk-space per object pointer, and only consume memory for one "page" at a time (defined by #pageSize).I do not have to be pre-allocated.  You can use at:put: to any size up to the limit.  Once I grow, I don't shrink.!!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/18/2010 19:46'!add: anObject 	"Put anObject at my next-higher size.  Warning:  Only use this method if you have exclusive access to the receiver."	^ self		at: self lastKnownSize + 1		put: anObject! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/13/2005 15:18'!at: anIndex	^ self		at: anIndex		ifAbsent: [ self error: 'index out of range' ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 11/5/2010 15:15'!at: anInteger ifAbsent: aBlock 	^ changes		at: anInteger		ifAbsent:			[ (self isLoaded and: [ segment includesIndex: anInteger ])				ifTrue:					[ segment						at: anInteger						ifAbsent: aBlock ]				ifFalse:					[ | size |					size := self lastKnownSize.					self isNewCollection						ifTrue:							[ anInteger < size								ifTrue: [ nil ]								ifFalse: aBlock ]						ifFalse:							[ self loadFromIndex: anInteger.							(segment includesIndex: anInteger)								ifTrue:									[ segment										at: anInteger										ifAbsent: aBlock ]								ifFalse:									[ anInteger < size										ifTrue: [ nil ]										ifFalse: aBlock ] ] ] ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/18/2005 13:21'!at: anInteger put: anObject	changes		add: anObject		at: anInteger.	^ anObject! !!MagmaArray methodsFor: 'accessing' stamp: 'NicolasPetton 12/7/2011 16:44'!first	^self at: 1! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 12/7/2011 22:07'!last	^self at: self lastKnownSize! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/30/2006 20:06'!lastKnownSize	^ segment 		ifNil: [ self size ]		ifNotNil: [ segment lastKnownSize max: changes maxIndex ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:30'!pageSize	^ pageSize! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:30'!pageSize: anInteger	pageSize := anInteger! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/30/2006 20:07'!refresh	segment := nil! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:15'!size	^ session isNil		ifTrue:			[ changes maxIndex ]		ifFalse:			[ (session sizeOfLargeCollection: self) max: changes maxIndex ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/12/2005 17:24'!species	^ OrderedCollection! !!MagmaArray methodsFor: 'private' stamp: 'cmm 5/6/2013 21:17'!changesClass	^ MagmaArrayChanges! !!MagmaArray methodsFor: 'private' stamp: 'cmm 3/21/2005 12:36'!isLoaded	^ segment notNil! !!MagmaArray methodsFor: 'private' stamp: 'cmm 5/1/2005 16:43'!loadFromIndex: indexInteger	segment :=		self			segmentFromIndex: indexInteger			pageSize: pageSize			using: (session ifNotNil: [ session resetReadStrategy ])! !!MagmaArray methodsFor: 'private' stamp: 'cmm 3/19/2005 11:25'!maTransientVariables 	"Large-collection changes are processed separately in the server, therefore they are stored separately in the commit-package, therefore, we mark them transient."	^ super maTransientVariables, #( 'segment' )! !!MagmaArray methodsFor: 'enumerate' stamp: 'cmm 7/30/2006 19:39'!do: aBlock 	1 		to: self size		do: [ : x | aBlock value: (self at: x) ]! !!MagmaArray methodsFor: 'enumerate' stamp: 'cmm 9/10/2009 21:28'!reverseDo: aBlock 	self size 		to: 1		by: -1		do: [ : x | aBlock value: (self at: x) ]! !!MagmaArray methodsFor: 'do not use' stamp: 'cmm 3/21/2005 12:37'!includes: anObject	"This should not be used because, being large and non-indexed, would be a performance drain.  If you need this, you should probably use a regular MagmaCollection."	self shouldNotImplement! !!MagmaArray methodsFor: 'do not use' stamp: 'cmm 3/21/2005 12:38'!occurrencesOf: anObject	"This should not be used because, being large and non-indexed, would be a performance drain.  If you need this, you should probably use a regular MagmaCollection."	self shouldNotImplement! !!MagmaArray methodsFor: 'initialize' stamp: 'cmm 3/22/2005 12:40'!initialize	super initialize.	self pageSize: 125! !!MagmaArray methodsFor: '*magma-server' stamp: 'cmm 7/12/2005 12:52'!implementationClass	^ MaLargeArrayOfNumbers! !!MagmaArray methodsFor: '*magma-server' stamp: 'cmm 3/17/2005 21:33'!newManagerUsing: aMaObjectRepository	^ MagmaArrayManager		collection: self		repository: aMaObjectRepository! !MagmaLargeCollection subclass: #MagmaDictionary	instanceVariableNames: 'table'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaArray'!!MagmaDictionary commentStamp: 'cmm 4/14/2011 14:07' prior: 0!A MagmaDictionary is just like a regular Dictionary except it can be very large; billions.It utilizes a MagmaSolHashTable to map hash values to Associations.IMPORTANT:  To maximize performance, MagmaSolHashTable is not thread-safe, therefore neither is MagmaDictionary.!!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/13/2011 23:04'!associationAt: key ifAbsent: aBlock 	table		at: (self hashFor: key)		do:			[ : eachAssociation | eachAssociation value key = key ifTrue: [ ^ eachAssociation value ] ].	^ aBlock value! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/13/2011 23:09'!associationAt: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock 	^ oneArgBlock value:		(self			associationAt: anObject			ifAbsent: [ ^ zeroArgBlock value ])! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/11/2011 14:21'!at: key 	"Answer the value associated with the key."	^ self		at: key		ifAbsent: [ self errorKeyNotFound: key ]! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/13/2011 23:06'!at: key ifAbsent: aBlock 	^ (self		associationAt: key		ifAbsent: [ ^ aBlock value ]) value! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/14/2011 17:32'!at: keyObject ifAbsentPut: aBlock 	"Answer the object at keyObject, if it isn't found, add the value of aBlock at keyObject and answer it.  IMPORTANT:  Do not nest calls to this method."	| hash assoc |	assoc := table		at: (hash := self hashFor: keyObject)		ifAbsentAdd:			[ MagmaDictionaryAssociation				key: keyObject				value: aBlock value ].	"assoc was either found or just created.  If it was found, it might be for a different keyObject (but with the same hash).  Do the right thing."	^ (assoc key = keyObject		ifTrue: [ assoc ]		ifFalse:			[ table				add:					(MagmaDictionaryAssociation						key: keyObject						value: aBlock value )				at: hash ]) value! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/11/2011 15:05'!at: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock 	^ oneArgBlock value:		(self			at: anObject			ifAbsent: [ ^ zeroArgBlock value ])! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 10/2/2014 17:25'!at: anObject ifPresent: oneArgBlock ifAbsentPut: zeroArgBlock 	^ self		at: anObject		ifPresent: oneArgBlock		ifAbsent:			[ self				at: anObject				put: zeroArgBlock value ]! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/11/2011 15:16'!at: keyObject put: valueObject 	"Add valueObject at keyObject.  If there is already an object at an equivalent to keyObject, replace it with each of keyObject and valueObject."	| hash assoc |	assoc := table		at: (hash := self hashFor: keyObject)		ifAbsentAdd:			[ MagmaDictionaryAssociation				key: keyObject				value: valueObject ].	"assoc was either found or just created.  If it was found, it might be for a different keyObject (but with the same hash).  Do the right thing."	^ (assoc key = keyObject		ifTrue:			[ assoc				 key: keyObject ;				 value: valueObject ;				 yourself ]		ifFalse:			[ table				add:					(MagmaDictionaryAssociation						key: keyObject						value: valueObject)				at: hash ]) value! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/24/2013 22:03'!errorKeyNotFound: key	"Signal KeyNotFound error"	^(KeyNotFound key: key) signal! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/11/2011 14:36'!lastKnownSize	^ self size! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 7/22/2011 11:09'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| tally |	tally := 0.	self do: [:each | anObject = each ifTrue: [tally := tally + 1]].	^tally! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/24/2013 22:03'!removeKey: key 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self		removeKey: key		ifAbsent: [ self errorKeyNotFound: key ]! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/25/2013 14:28'!removeKey: keyObject ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in the receiver, answer the result of evaluating aBlock. Otherwise, answer the value externally named by key."	^ (table		remove:			(MagmaDictionaryAssociation				key: keyObject				value: nil)		at: (self hashFor: keyObject)		ifAbsent: [ ^ aBlock value ]) value! !!MagmaDictionary methodsFor: 'access' stamp: 'cmm 4/11/2011 14:36'!size	^ table size! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 9/11/2012 14:36'!associations	^ Array streamContents:		[ : stream | self associationsDo:			[ : each | stream nextPut: each ] ]! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:37'!associationsDo: aBlock 	"Value aBlock with each of my Associations."	self		slowlyDo: aBlock		pageBoundariesDo: [  ]! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:41'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."	| newCollection |	newCollection := self class new.	self associationsDo:		[ : each | newCollection			at: each key			put: (aBlock value: each value) ].	^ newCollection! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:37'!do: aBlock	self valuesDo: aBlock! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 10/28/2011 16:37'!keys	^ Array streamContents:		[ : stream | self keysDo:			[ : each | stream nextPut: each ] ]! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:39'!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc key value: assoc value].! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:37'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association key]! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:40'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a new dictionary, only those associations for which aBlock evaluates to true."	| newCollection |	newCollection := self class new.	self associationsDo:		[ : each | (aBlock value: each value) ifTrue:			[ newCollection				at: each key				put: each value ] ].	^ newCollection! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 15:37'!slowlyDo: oneArgBlock pageBoundariesDo: aBlock 	"Enumerate all Associations of the receiver, value oneArgBlock with each association."	| count |	count := 0.	table do:		[ : eachAssociation | oneArgBlock value: eachAssociation.		count := count + 1.		count \\ self enumerationPageSize = 0 ifTrue: [ aBlock value ] ]! !!MagmaDictionary methodsFor: 'enumerating (slow)' stamp: 'cmm 7/23/2011 14:37'!valuesDo: aBlock 	"Evaluate aBlock for each of the receiver's values."	self associationsDo: [:association | aBlock value: association value]! !!MagmaDictionary methodsFor: 'private' stamp: 'cmm 4/11/2011 17:30'!hashFor: anObject	| hugeNumber validHash |	validHash := 0.	hugeNumber := anObject hash.	[ hugeNumber > 0 ] whileTrue: 		[ validHash := validHash bitXor: (hugeNumber bitAnd: (1 bitShift: table keyBits)-1).		hugeNumber := hugeNumber bitShift: -28 ].	^ validHash! !!MagmaDictionary methodsFor: 'testing' stamp: 'cmm 7/22/2011 11:10'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:each | each = anObject]! !!MagmaDictionary methodsFor: 'testing' stamp: 'cmm 4/11/2011 15:17'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	self at: key ifAbsent: [^false].	^true! !!MagmaDictionary methodsFor: 'testing' stamp: 'cmm 4/11/2011 15:17'!isEmpty	^ self size = 0! !!MagmaDictionary methodsFor: 'testing' stamp: 'cmm 4/11/2011 15:17'!notEmpty	^ self isEmpty not! !!MagmaDictionary methodsFor: 'initialize-release' stamp: 'cmm 4/14/2011 12:21'!initialize	super initialize.	table := MagmaSolHashTable new! !MagmaLargeCollection subclass: #MagmaHashTable	instanceVariableNames: 'table index'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaArray'!!MagmaHashTable commentStamp: 'cmm 4/11/2011 17:07' prior: 0!A MagmaHashTable is similar to a MagmaCollection except:	- It can only query a range of one indexed attribute using #from:to:do:.	- It can't randomly access via #at: like a regular indexed MagmaCollectionReader. 	- Access is much faster.!!MagmaHashTable methodsFor: 'access' stamp: 'cmm 4/25/2011 09:57'!add: anObject 	(index indexHashesFor: anObject) do:		[ : each | table			add: anObject			at: each ].	^ anObject! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 10/26/2012 14:36'!allAt: keyObject 	^ Array streamContents:		[ : stream | self			at: keyObject			do: [ : each | stream nextPut: each ] ]! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 12/26/2011 13:11'!at: keyObject do: oneArgBlock 	table		at: (index indexHashForIndexObject: keyObject)		do:			[ : eachSolHashNode | | obj |			obj := eachSolHashNode value.			(obj realObjectIfMutatingProxy perform: index attribute) = keyObject ifTrue: [ oneArgBlock value: obj ] ]! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 1/4/2012 15:57'!from: fromKey to: toKey do: oneArgBlock 	| endHash |	endHash := index indexHashForIndexObject: toKey.	table		from: (index indexHashForIndexObject: fromKey)		do: [ : eachSOLHashNode | oneArgBlock value: eachSOLHashNode value ]		until: [ : eachSOLHashNode | eachSOLHashNode key > endHash ]! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 4/13/2011 14:55'!isEmpty	^ self size = 0! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 4/13/2011 14:55'!notEmpty	^ self isEmpty not! !!MagmaHashTable methodsFor: 'access' stamp: 'cmm 4/13/2011 14:55'!size	^ table size! !!MagmaHashTable methodsFor: 'private' stamp: 'cmm 12/26/2011 13:15'!indexObjectFor: anObject	^ anObject realObjectIfMutatingProxy perform: index attribute realObjectIfMutatingProxy! !!MagmaHashTable methodsFor: 'initialize' stamp: 'cmm 4/13/2011 11:40'!setIndex: aMagmaCollectionIndex 	index := aMagmaCollectionIndex.	table := MagmaSolHashTable		loadFactor: 4		segBits: 28		keyBits: aMagmaCollectionIndex keySize! !!MagmaHashTable methodsFor: 'enumeration' stamp: 'cmm 10/26/2012 14:39'!slowlyDo: oneArgBlock pageBoundariesDo: aBlock 	"Enumerate all objects of the receiver, value oneArgBlock with each object."	| count |	count := 0.	table do:		[ : each | oneArgBlock value: each.		count := count + 1.		count \\ self enumerationPageSize = 0 ifTrue: [ aBlock value ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaHashTable class	instanceVariableNames: ''!!MagmaHashTable class methodsFor: 'create' stamp: 'cmm 4/11/2011 10:16'!index: aMagmaCollectionIndex 	^ self new		 setIndex: aMagmaCollectionIndex ;		 yourself! !MaObject subclass: #MagmaPreallocatedDictionary	instanceVariableNames: 'array tally maxBuckets collisions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaArray'!!MagmaPreallocatedDictionary methodsFor: 'initialize-release' stamp: 'cmm 11/6/2010 20:02'!allocation: numberOfSlots 	numberOfSlots copy == numberOfSlots copy ifFalse: [ MagmaUserError signal: 'Max pre-allocation allowed is ' , SmallInteger maxVal asString ].	maxBuckets := numberOfSlots.	array := MagmaArray new		"		at: numberOfSlots		put: nil ;"		 pageSize: 1 ;		 yourself! !!MagmaPreallocatedDictionary methodsFor: 'initialize-release' stamp: 'cmm 10/13/2014 20:55'!initialize	super initialize.	tally := MagmaCounter new.	collisions := 0! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/6/2010 19:06'!associationAt: key ifAbsent: aBlock 	| bucket |	bucket := self bucketAt: (self keyHash: key).	^ bucket		ifNil: aBlock		ifNotNil: [ (bucket findKeyOrNil: key) ifNil: aBlock ]! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 3/12/2011 14:56'!associationAt: key ifPresent: presentBlock ifAbsent: absentBlock 	"This method can help reduce the number of accesses to the receiver."	| bucket |	bucket := self bucketAt: (self keyHash: key).	^ bucket		ifNil: absentBlock		ifNotNil:			[ (bucket findKeyOrNil: key)				ifNil: absentBlock				ifNotNilDo:					[ : assoc | presentBlock value: assoc ] ]! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/2/2010 13:51'!associationClass	^ MaAssociation! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 10/13/2014 20:56'!atIndex: index insertKey: key value: value	| currentBucket newBucket |	currentBucket := self bucketAt: index.	currentBucket ifNotNil: [ collisions := collisions + 1 ].	newBucket := self associationClass key: key value: value next: (currentBucket).	array at: index put: newBucket.	tally increment: 1.	^ value! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/21/2014 13:47'!bucketAt: anInteger 	| answer |	answer := array		at: anInteger		ifAbsent: [ nil ]."	array refresh."	^ answer! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/2/2010 15:23'!errorKeyNotFound: key	"Signal KeyNotFound error"	^(KeyNotFound key: key) signal! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/6/2010 19:13'!keyHash: key	^ (key hash \\ maxBuckets) + 1! !!MagmaPreallocatedDictionary methodsFor: 'private' stamp: 'cmm 11/6/2010 18:52'!maxBuckets	^ maxBuckets! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 11/2/2010 15:22'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound: key]! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 11/6/2010 18:27'!at: key ifAbsent: aBlock	| bucket |	bucket := self bucketAt: (self keyHash: key).	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [^ bucket value]. bucket := bucket next ].	^ aBlock value! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 11/21/2014 13:46'!at: key ifAbsentPut: aBlock 	| index bucket |	index := self keyHash: key.	"Don't use bucketAt: because we may need to put the value of aBlock."	bucket := array		at: index		ifAbsent: [ nil ].	[ bucket notNil ] whileTrue:		[ bucket key = key ifTrue:			[ "array refresh."			^ bucket value ].		bucket := bucket next ].	^ self		atIndex: index		insertKey: key		value: aBlock value! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 10/28/2011 15:51'!at: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock 	^ oneArgBlock value:		(self			at: anObject			ifAbsent: [ ^ zeroArgBlock value ])! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 10/2/2014 17:25'!at: anObject ifPresent: oneArgBlock ifAbsentPut: zeroArgBlock 	^ self		at: anObject		ifPresent: oneArgBlock		ifAbsent:			[ self				at: anObject				put: zeroArgBlock value ]! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 11/21/2014 13:47'!at: key put: value 	| index bucket |	index := self keyHash: key.	"Don't use bucketAt: because we may need to call #atIndex:  insertKey:  value:, which will just look it up again."	bucket := array 		at: index		ifAbsent: [ nil ].	[ bucket notNil ] whileTrue:		[ bucket key = key ifTrue:			[ bucket value: value.			"Restock this persistent bucket into the MagmaArray's changes so that subsquent access will find it there, and ensure it doesn't get GC'd before commit."			array				at: index				put: bucket"; refresh".			^ value ].		bucket := bucket next ].	^ self		atIndex: index		insertKey: key		value: value! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 3/12/2011 23:13'!collisions	"Answer the number of collisions this Dictionary currently suffers."	^ collisions! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 11/2/2010 16:06'!lastKnownSize	^ self size! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 10/13/2014 20:57'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index bucket next |	index := self keyHash: key.	bucket := self bucketAt: index.	bucket ifNil: [ ^ aBlock value ].	bucket key = key ifTrue:		[ | nxt |		tally decrement: 1.		array			at: index			put: (nxt := bucket next).		nxt ifNotNil: [ collisions := collisions - 1 ].		^ bucket value ].	[ (next := bucket next) notNil ] whileTrue:		[ next key = key ifTrue:			[ tally decrement: 1.			bucket next: next next.			collisions := collisions - 1.			^ next value ].		bucket := next ].	^ aBlock value! !!MagmaPreallocatedDictionary methodsFor: 'access' stamp: 'cmm 10/13/2014 21:02'!size	^ tally value! !!MagmaPreallocatedDictionary methodsFor: 'do not use' stamp: 'cmm 11/2/2010 13:02'!copy	"The challenge with copying a MagmaFastDictionary is that it would require copying of all of the association objects, which cannot be done efficiently."	self shouldNotImplement! !!MagmaPreallocatedDictionary methodsFor: 'testing' stamp: 'cmm 11/2/2010 13:56'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	self at: key ifAbsent: [^false].	^true! !!MagmaPreallocatedDictionary methodsFor: 'testing' stamp: 'cmm 11/9/2010 11:54'!isEmpty	^ self size = 0! !!MagmaPreallocatedDictionary methodsFor: 'testing' stamp: 'cmm 11/9/2010 11:54'!notEmpty	^ self isEmpty not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaPreallocatedDictionary class	instanceVariableNames: ''!!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 4/23/2011 13:45'!new	^ self new67M! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 4/23/2011 13:52'!new134M	"Create a Preallocated dictionary with up to 134M slots.  BEWARE:  This will cause up to 805M of disk space to be allocated upon commit."	^ self newAllocation: 134217757 "Probably prime"! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 4/23/2011 13:51'!new1B	"Create a Preallocated dictionary with up to 1B slots.  BEWARE:  This will cause up to 7GB of disk-space to be allocated upon commit."	^ self newAllocation: 1073741789 "Probably prime"! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 4/23/2011 13:51'!new268M	"Create a Preallocated dictionary with up to 268M slots.  BEWARE:  This will cause up to  1.61G of disk space to be allocated upon commit."	^ self newAllocation: 268435399 "Probably prime"! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 4/23/2011 13:51'!new67M	"Create a Preallocated dictionary with up to 67M slots.  BEWARE:  This will cause up to  402.65M of disk space to be allocated upon commit."	^ self newAllocation: 67108879 "67M, prime"! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 11/30/2010 13:58'!new: allocation	MagmaUserError signal: 'Please use #newAllocation:'! !!MagmaPreallocatedDictionary class methodsFor: 'instance creation' stamp: 'cmm 11/2/2010 14:10'!newAllocation: numberOfSlots 	^ super new		 allocation: numberOfSlots ;		 yourself! !SOLHashTable subclass: #MagmaSolHashTable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-MagmaArray'!!MagmaSolHashTable commentStamp: 'cmm 4/11/2011 10:33' prior: 0!A MagmaSolHashTable extends Tom Rushworth's SOLHashTable to substitute the internal Array with a MagmaArray.  This allows very large segBits.Instance Variables!!MagmaSolHashTable methodsFor: 'overriding' stamp: 'cmm 4/23/2011 12:08'!hashSegmentClass	^ MagmaSolHashSegment ! !!MagmaSolHashTable methodsFor: 'overriding' stamp: 'cmm 4/21/2011 20:47'!initializeFrame	frame := MagmaSolHashFrame new! !!MagmaSolHashTable methodsFor: 'overriding' stamp: 'cmm 5/30/2018 20:15'!newPointersCollection	"This will be converted to a MagmaArray if/when an access takes it past this size."	^ OrderedCollection new: 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaSolHashTable class	instanceVariableNames: ''!!MagmaSolHashTable class methodsFor: 'overriding' stamp: 'cmm 4/13/2011 21:57'!defaultLoadFactor	"MagmaArray's excel at being large, and we should optimize for fast access.  This is better than 3 because it means that dummy elements only take up 8.3% more of the total space, and better than 1 because that would be one dummy for every real node, which is just too much space overhead.  2 seems to be the best balance."	^ 2! !!MagmaSolHashTable class methodsFor: 'overriding' stamp: 'cmm 4/10/2011 19:49'!defaultSegBits	"A MagmaArray with up to  268435456 buckets would take up roughly 1.61G on disk.  That would be a good size before creating a new one."	^ 28! !