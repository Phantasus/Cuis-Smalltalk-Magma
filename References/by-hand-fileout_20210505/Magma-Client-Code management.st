MCRepository subclass: #MCMagmaRepository	instanceVariableNames: 'session location'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Code management'!!MCMagmaRepository methodsFor: 'accessing' stamp: 'cmm 3/6/2011 16:46'!allPackageNames	^ self mcModel allPackageNames! !!MCMagmaRepository methodsFor: 'accessing' stamp: 'cmm 4/25/2011 08:14'!removeVersion: aMCVersionOrConfiguration 	^ self mcModel ifNotNil:		[ : mcmodel | mcmodel removeVersion: aMCVersionOrConfiguration ]! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 4/23/2011 14:40'!basicStoreVersion: aMCVersionOrConfiguration 	self ensureConnectedSession commit: [ self mcModel storeVersion: aMCVersionOrConfiguration ].	aMCVersionOrConfiguration postStoreCleanUpFor: self! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 3/6/2011 20:20'!description	^ location description! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 3/5/2011 18:32'!includesVersionNamed: aMCVersionName	^ self ensureConnectedSession mcModel includesVersionNamed: aMCVersionName asMCVersionName! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 3/6/2011 16:59'!refresh	self ensureConnectedSession refresh! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 3/6/2011 16:32'!versionNamed: aMCVersionName	^ self mcModel versionNamed: aMCVersionName! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 3/6/2011 12:06'!versionNamesForPackageNamed: aString	"Answer a collection of MCVersionNames whose Package is named aString."	^ self mcModel versionNamesForPackageNamed: aString! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 2/26/2011 23:17'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ self mcModel		versionWithInfo: aVersionInfo		ifAbsent: errorBlock! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 4/25/2011 08:08'!wasRemoved	session disconnectAndClose! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 5/23/2011 14:47'!cleanUp	session ifNotNil:		[ session disconnectAndClose.		session := nil ]! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 2/15/2005 14:21'!codeBase	^ self ensureConnectedSession codeBase! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 12/1/2015 16:39'!copyAllFrom: aMCRepository 	"Copy all MCVersions from aMCRepository to the receiver."	session timeoutSeconds: 300.	super copyAllFrom: aMCRepository.	self trim! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 3/14/2011 18:11'!ensureConnectedSession	session ifNil: [ session := location findSession ].	[ session		 readStrategy: MaReadStrategy new ;		 ensureConnected ]		on: MagmaUserRequiredNotification		do:			[ : request | request resume: (MagmaUser id: 'mc user') ].	^ session! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 1/30/2005 18:44'!location: aMagmaLocation	location := aMagmaLocation! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 2/26/2011 16:31'!mcModel	^ self codeBase mcModel! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 3/14/2011 22:32'!possiblyNewerVersionsOfAnyOf: versionNames 	"Answer a collection of MCVersionNames which might be newer versions of the versions identified by versionNames."	^ versionNames		inject: OrderedCollection new		into:			[ : coll : eachVersionName | | eachPackageName eachVersions |			eachPackageName := eachVersionName packageName.			(eachVersions := self mcModel versionsForPackageNamed: eachPackageName).			(eachVersions size - 25 max: 1) to: eachVersions size do:				[ : n | |eachInSelf|				eachInSelf:=(eachVersions at: n) versionName.				(eachInSelf versionNumber > eachVersionName versionNumber or:					[ eachInSelf versionNumber = eachVersionName versionNumber and: [ eachInSelf author ~= eachVersionName author ] ]) ifTrue: [ coll add: eachInSelf ] ].			coll ]! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 11/27/2011 17:39'!trim	session stubOutMissingVersions.	"MCRepositoryGroup flushAllCaches"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MCMagmaRepository class	instanceVariableNames: ''!!MCMagmaRepository class methodsFor: 'configuring' stamp: 'cmm 10/29/2013 20:33'!creationTemplate	^ self name, '	host: ''localhost''	port: 32501"or delete the above and uncomment the following:""', self name, ' path: fullOrRelativePathString"'! !!MCMagmaRepository class methodsFor: 'configuring' stamp: 'cmm 3/6/2011 20:07'!description	^ 'Magma'! !!MCMagmaRepository class methodsFor: 'configuring' stamp: 'cmm 3/7/2011 13:34'!fillInTheBlankRequest	^ 'Magma Location:'! !!MCMagmaRepository class methodsFor: 'configuring' stamp: 'cmm 10/27/2004 12:19'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCMagmaRepository class methodsFor: 'create' stamp: 'cmm 1/30/2005 18:45'!host: hostName port: anInteger	^ self location:		(MagmaRemoteLocation			host: hostName			port: anInteger)! !!MCMagmaRepository class methodsFor: 'create' stamp: 'cmm 1/31/2005 23:49'!location: aMagmaLocation	^ self new		location: aMagmaLocation ;		yourself! !!MCMagmaRepository class methodsFor: 'create' stamp: 'cmm 1/30/2005 18:46'!path: aString	^ self location: (MagmaLocalLocation path: aString)! !!MCMagmaRepository class methodsFor: 'testing' stamp: 'cmm 4/22/2011 16:40'!supportsConfigurations	^ true! !MaObject subclass: #MagmaRepositoryCodeBase	instanceVariableNames: 'changeSets classes mcModel'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Code management'!!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 2/14/2005 13:47'!browseChangeSetNamed: nameString	"Opens a code-file browser on the change-set named nameString."	FileContentsBrowser browseStream: (self changeSetNamed: nameString)! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:12'!changeSetNamed: aString	^ changeSets		at: aString		ifAbsent: [ MagmaUserError signal: 'No change set named ', aString, ' found here.' ].! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 11/9/2004 12:25'!changeSetNames	changeSets keys asSortedCollection! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:52'!fileInChangeSetNamed: nameString	| stream |	stream := self changeSetNamed: nameString.	stream reset.	ChangeSorter		newChangesFromStream: stream		named: nameString! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:44'!fileOutChangeSet: aChangeSet	| stream |	stream := ReadWriteStream on: String new.	aChangeSet fileOutOn: stream.	stream position: 0.	changeSets		at: aChangeSet name		put: stream! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:14'!installChangeSets	changeSets keysDo: [ :eachKey | self fileInChangeSetNamed: eachKey ]! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 2/14/2005 13:42'!browseClassNamed: nameSymbol	"Opens a code-file browser on the class named nameSymbol."	FileContentsBrowser browseStream: (self classNamed: nameSymbol)! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:17'!classNamed: aSymbol	^ classes		at: aSymbol		ifAbsent: [ MagmaUserError signal: 'No class named ', aSymbol, ' found here.' ].! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 11/9/2004 12:25'!classNames	^ classes keys asSortedCollection! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:17'!fileInClassNamed: nameString	| stream |	stream := self classNamed: nameString.	stream reset.	stream fileInAnnouncing: 'loading class ', nameString, ' from Magma database.'! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:44'!fileOutClass: aClass	| stream |	stream := ReadWriteStream on: String new.	aClass fileOutOn: stream.	stream position: 0.	classes		at: aClass name		put: stream! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:18'!installClasses	classes keysDo: [ :eachKey | self fileInClassNamed: eachKey ]! !!MagmaRepositoryCodeBase methodsFor: 'initialize-release' stamp: 'cmm 3/6/2011 22:00'!initialize	super initialize.	changeSets := Dictionary new.	classes := Dictionary new! !!MagmaRepositoryCodeBase methodsFor: 'monticello' stamp: 'cmm 3/6/2011 22:00'!mcModel	^ mcModel ifNil: [ mcModel := McModel new ]! !Object subclass: #McModel	instanceVariableNames: 'packages objects missingVersions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Code management'!!McModel commentStamp: 'cmm 9/1/2015 16:48' prior: 0!A McModel is a large, object-oriented model of MC code elements.  Unlike MC repositories, which duplicate all definitions of each MCVersion, a McModel canonicalizes the definitions, so there is only one copy of that method from 2002 shared across all MCVersions..#historyOf: aMCDefinition provides the full method-history for that method across all MCVersions, with ability to install any of them.  #originOf: aMCDefinition allows the version notes for any method or class definition to be readily obtained.Monticello provides no physical implementation of its model -- it is strictly logical.  For example, MCPackage does not physically reference its collection of MCVersions.  It only knows its name and only by methods looking at MCRepository's can the versions be determined.Therefore, rather than implement an entire object model that wraps the MC objects to provide the physical relationships, McModel instead establishes all relationships via one large MagmaDictionary referenced by its 'objects' instance-variable.  This dictionary is used to track a variety of relationships:	"All versions for a package name"	packageName -> MagmaArray of MCVersions	"For canonicalized Infos"	{#info. aMCVersionInfo} -> aMCVersionInfo	"Versions by id (UUID)"	uuid id -> aMCVersion	"Versions by versionName, Configurations by name."	versionName -> aMCVersion or aMCConfiguration	"For canonicalized Definitions."	{#definition. aMCDefinition} -> aMCDefinition	"History of a particular definition"	MCDefinition description -> OC of MCDefinitions	"oldest-known version to refer to a particular def"	{#origin. aMCDefinition} -> aMCVersion!!McModel methodsFor: 'private' stamp: 'cmm 11/7/2018 14:38'!addConfiguration: aMCConfiguration 	| versionName packageName |	versionName := aMCConfiguration versionName.	packageName := aMCConfiguration versionName packageName.	versionName = packageName ifTrue: [ MaUserError signal: 'Invalid name for MCConfiguration.' ].	objects		at: versionName		ifPresent:			[ : found | (found realObjectIfMutatingProxy isKindOf: MCVersion) ifTrue: [ MaUserError signal: 'Names of Configurations may not coincide with names of Versions.' ] ]		ifAbsent: [  ].	objects		at: packageName		ifPresent:			[ : found | (found realObjectIfMutatingProxy isKindOf: MCVersion) ifTrue: [ MaUserError signal: 'Names of Configurations may not coincide with names of Packages.' ] ]		ifAbsent: [  ].	objects				at: versionName		put: aMCConfiguration ;				at: packageName		put: (Array with: aMCConfiguration).	"Not actually a MCPackage, we only need to store the name, to satisfy #allPackageNames."	packages		at: packageName		put: nil! !!McModel methodsFor: 'private' stamp: 'cmm 3/12/2011 15:09'!addInfo: aMCVersionInfo 	objects		at: {#info. aMCVersionInfo}		put: aMCVersionInfo! !!McModel methodsFor: 'private' stamp: 'cmm 3/14/2011 22:24'!addVersion: aMCVersion 	"Reference aMCVersion by several different access keys."	(objects				at: aMCVersion id		put: aMCVersion ;				at: aMCVersion versionName		put: aMCVersion ;				at: aMCVersion packageName		ifAbsentPut: [ self newVersionsCollection ]) add: aMCVersion! !!McModel methodsFor: 'private' stamp: 'cmm 3/9/2011 18:08'!adjustMissingVersions: aMCVersionInfo 	"aMCVersion is being added, make sure it isn't marked as missing and check for presence of its ancestors."	missingVersions		remove: aMCVersionInfo		ifAbsent: [ "don't want it." ].	aMCVersionInfo ancestors do:		[ : eachAncestor | self			versionWithInfo: eachAncestor			ifAbsent: [ missingVersions add: eachAncestor ] ]! !!McModel methodsFor: 'private' stamp: 'cmm 11/27/2011 17:27'!ancestorDefinitionsOf: aMCVersion 	"Obtain the definitions of the immediate ancestors of aMCVersion and put them into a Dictionary.  This is used to improve the performance of canonicalizedDefinitionsFor:."	| defs |	defs := Dictionary new.	aMCVersion info ancestors do:		[ : eachAncestor | (self versionWithInfo: eachAncestor) ifNotNil:			[ : eachAncestorVersion | eachAncestorVersion definitions do:				[ : eachMcDefinition | defs					at: eachMcDefinition					put: eachMcDefinition ] ] ].	^ defs! !!McModel methodsFor: 'private' stamp: 'cmm 11/20/2013 15:24'!canonicalizedDefinition: aMCDefinition of: aMCVersion 	"Find or create a canonicalized definitions for aMCVersion."	| existing |	existing := objects		at: {#definition. 			aMCDefinition}		ifAbsent:			[ existing := aMCDefinition ensureHistoricalEntryIn: self.			objects				at: {#definition. 					aMCDefinition}				put: existing ].	self		checkAndRecordOriginOf: existing		for: aMCVersion.	^ existing! !!McModel methodsFor: 'private' stamp: 'cmm 11/20/2013 15:21'!canonicalizedDefinitionsFor: aMCVersion 	"Find or create a canonicalized definitions for aMCVersion."	| canonicalizedDefs ancestorDefs |	canonicalizedDefs := OrderedCollection new: aMCVersion definitions size.	ancestorDefs := self ancestorDefinitionsOf: aMCVersion.	aMCVersion definitions do:		[ : each | canonicalizedDefs add:			(ancestorDefs				at: each				ifAbsent:					[ self						canonicalizedDefinition: each						of: aMCVersion ]) ].	^ canonicalizedDefs! !!McModel methodsFor: 'private' stamp: 'cmm 3/8/2011 19:07'!canonicalizedPackageFor: aMCVersion 	"Find or create a canonicalized MCPackage for aMCVersion. "	^ packages		at: aMCVersion package name		ifAbsentPut: [ aMCVersion package ]! !!McModel methodsFor: 'private' stamp: 'cmm 3/15/2011 14:45'!checkAndRecordOriginOf: aMCDefinition for: aMCVersion 	"Record the most-ancestral (e.g. oldest)-known origin of aMCDefinition, or as aMCVersion if there is no known origin."	| originKey currentOrigin |	originKey := {#origin. aMCDefinition}.	currentOrigin := objects		associationAt: originKey		ifAbsent: [ nil ].	currentOrigin		ifNil:			[ objects				at: originKey				put: aMCVersion ]		ifNotNil:			[ currentOrigin value:				(self					olderOf: aMCVersion					and: currentOrigin value) ]! !!McModel methodsFor: 'private' stamp: 'cmm 11/20/2013 15:23'!ensureHistoricalEntry: aMCDefinition 	| entries |	entries := objects		at: aMCDefinition description		ifAbsentPut: [ OrderedCollection new ].	^ (entries includes: aMCDefinition) ifFalse: [ entries add: aMCDefinition ]! !!McModel methodsFor: 'private' stamp: 'cmm 3/12/2011 15:08'!infoAssociationFor: aMCVersionInfo ifPresent: foundBlock ifAbsent: absentBlock 	^ objects		associationAt: {#info. aMCVersionInfo}		ifPresent: foundBlock		ifAbsent: absentBlock! !!McModel methodsFor: 'private' stamp: 'cmm 3/14/2011 22:24'!newVersionsCollection	^ MagmaArray new		 pageSize: 25 ;		 yourself! !!McModel methodsFor: 'private' stamp: 'cmm 4/16/2011 17:14'!olderOf: firstVersion and: secondVersion 	"Answer whichever version, the first or second, is the older one.  Choose the one with the smaller versionNumber or earlierDate."	^ firstVersion versionNumber < secondVersion versionNumber		ifTrue: [ firstVersion ]		ifFalse:			[ secondVersion versionNumber < firstVersion versionNumber				ifTrue: [ secondVersion ]				ifFalse:					[ firstVersion dateAndTime < secondVersion dateAndTime						ifTrue: [ firstVersion ]						ifFalse: [ secondVersion ] ] ]! !!McModel methodsFor: 'private' stamp: 'cmm 4/25/2011 08:15'!primRemoveConfiguration: aMCConfiguration 	| versionName packageName |	versionName := aMCConfiguration versionName.	packageName := aMCConfiguration versionName packageName.	objects				removeKey: versionName		ifAbsent: [  ] ;				removeKey: packageName		ifAbsent: [  ].	packages		removeKey: packageName		ifAbsent: [  ].	^ aMCConfiguration! !!McModel methodsFor: 'private' stamp: 'cmm 4/25/2011 08:15'!primRemoveVersion: aMCVersion 	objects		removeKey: aMCVersion id		ifAbsent: [ "whatever." ].	objects		removeKey: aMCVersion versionName		ifAbsent: [  ].	(objects		at: aMCVersion packageName		ifAbsent: [  ]) ifNotNil:		[ : vers | vers			remove: aMCVersion			ifAbsent: [  ] ].	^ aMCVersion! !!McModel methodsFor: 'packages' stamp: 'cmm 3/6/2011 16:45'!allPackageNames	^ packages keys! !!McModel methodsFor: 'packages' stamp: 'cmm 3/5/2011 18:28'!packageNamed: aString	^ self packages at: aString! !!McModel methodsFor: 'packages' stamp: 'cmm 3/5/2011 18:27'!packages	^ packages! !!McModel methodsFor: 'initialize-release' stamp: 'cmm 4/23/2011 14:22'!favorDiskSpace	"This option is about half as fast as the #favorSpeed option, but does not take up any more disk space than necessary."	(objects isNil or: [ objects isEmpty ]) ifFalse: [ MagmaUserError signal: 'This option can only be set on a new, empty codeBase.' ].	objects := MagmaDictionary new! !!McModel methodsFor: 'initialize-release' stamp: 'cmm 4/23/2011 14:22'!favorSpeed	"Use this option to employ a MagmaPreallocatedDictionary for canonicalization of all MCDefinitions, which takes up several hundred mega-bytes of disk space."	(objects isNil or: [ objects isEmpty ]) ifFalse: [ MagmaUserError signal: 'This option can only be set on a new, empty codeBase.' ].	objects := MagmaPreallocatedDictionary new! !!McModel methodsFor: 'initialize-release' stamp: 'cmm 4/23/2011 14:06'!initialize	super initialize.	"Everyone says, 'disk space is cheap', so default to speed."	self favorSpeed..	packages := Dictionary new.	missingVersions := Set new! !!McModel methodsFor: 'versions' stamp: 'cmm 2/26/2011 13:28'!includesVersion: aMCVersion 	^ objects includesKey: aMCVersion id! !!McModel methodsFor: 'versions' stamp: 'cmm 3/5/2011 18:34'!includesVersionNamed: aString	^ objects includesKey: aString asMCVersionName! !!McModel methodsFor: 'versions' stamp: 'cmm 3/10/2011 13:40'!missingVersions	"Missing ancestor verisons of versions in this repository."	^ missingVersions! !!McModel methodsFor: 'versions' stamp: 'cmm 10/7/2013 17:03'!versionNamed: aString	"Answer the MCVersion or MCConfiguration with name matching aString."	^ objects		at: aString asMCVersionName		ifAbsent: [ nil ]! !!McModel methodsFor: 'versions' stamp: 'cmm 3/6/2011 12:48'!versionNamesForPackageNamed: aString 	^ (self versionsForPackageNamed: aString) collect:		[ : each | each versionName ]! !!McModel methodsFor: 'versions' stamp: 'cmm 2/26/2011 12:48'!versionWithInfo: aVersionInfo 	^ self		versionWithInfo: aVersionInfo		ifAbsent: [  ]! !!McModel methodsFor: 'versions' stamp: 'cmm 3/7/2011 11:18'!versionWithInfo: aVersionInfo ifAbsent: errorBlock 	^ objects		at: aVersionInfo id		ifPresent: [ : ver | ver ]		ifAbsent: errorBlock! !!McModel methodsFor: 'versions' stamp: 'cmm 3/6/2011 12:48'!versionsForPackageNamed: aString 	^ objects		at: aString		ifAbsent: [ Array empty ]! !!McModel methodsFor: 'testing' stamp: 'cmm 4/23/2011 14:02'!isEmpty	"Answer whether I have any versions loaded."	^ objects isEmpty! !!McModel methodsFor: 'definitions' stamp: 'cmm 3/8/2011 19:04'!originOf: aMCDefinition 	"Answer the MCVersion object which aMCDefinition was originally committed."	^ objects		at: {#origin. aMCDefinition}		ifAbsent: [ nil ]! !!McModel methodsFor: 'definitions' stamp: 'cmm 11/27/2016 16:13'!revisionsOf: aMCDefinition 	"Answer a Collection of the versions of aMCDefinition."	^ (objects		at: aMCDefinition description		ifAbsent: [ Array empty ]) sort: [ : a : b | a dateAndTime > b dateAndTime ]! !!McModel methodsFor: 'building' stamp: 'cmm 4/25/2011 08:15'!removeVersion: aMCVersionOrConfiguration	^ aMCVersionOrConfiguration removeFrom: self! !!McModel methodsFor: 'building' stamp: 'cmm 10/7/2013 14:48'!storeVersion: aMCVersionOrConfiguration	aMCVersionOrConfiguration storeInto: self! !