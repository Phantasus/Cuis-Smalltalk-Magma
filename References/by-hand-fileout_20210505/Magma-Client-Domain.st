MaObject subclass: #MagmaId	instanceVariableNames: 'uuid name description contact node'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaId methodsFor: 'testing' stamp: 'cmm 7/6/2009 21:20'!= aMagmaId 	self == aMagmaId ifTrue: [ ^ true ].	aMagmaId maOriginalClass = self maOriginalClass ifFalse: [ ^ false ].	^ uuid = aMagmaId uuid! !!MagmaId methodsFor: 'testing' stamp: 'cmm 1/16/2005 22:24'!hash	^ uuid hash! !!MagmaId methodsFor: 'testing' stamp: 'cmm 7/6/2009 21:21'!isMagmaId	^ true! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:34'!contact	"If having trouble connecting to this repository."	^ contact! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 5/2/2005 22:00'!contact: aString	"Specify information on how to contact the person who maintains this repository."	contact := aString! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:34'!description	"About this repository."	^ description! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:35'!description: aString	"A description of this repository."	description := aString! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 10/30/2008 13:05'!location	"The last known primaryLocation of this repository."	^ node primaryLocation! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 10/30/2008 13:27'!name	"How people refer to this repository."	^ name ifNil: [ self uuid printString ]! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:36'!name: aString	name := aString! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 10/30/2008 13:12'!node	^node! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 10/30/2008 13:13'!node: aMagmaNode	node := aMagmaNode! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 12/26/2011 16:07'!resetNode	self node: MagmaNode new! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 10:35'!uuid	^ uuid! !!MagmaId methodsFor: 'session' stamp: 'cmm 7/3/2012 21:26'!findSession	"Look in this image for a session with this MagmaId.  If it exists, answer it, else find new session to my primaryLocation."	^ MagmaSession connectedSessions		detect:			[ : each | each magmaId = self ]		ifNone:			[ MagmaSession allClientInstances				detect: [ : each | each magmaId = self ]				ifNone:					[ | foundSession |					self location ifNil: [ MagmaEnvironmentError signal: 'No location specified for remote repository.' ].					foundSession := self location findSession.					(foundSession magmaId notNil and: [ foundSession magmaId ~= self ]) ifTrue: [ MagmaEnvironmentError signal: self name , ' is no longer at ' , self location asString ].					foundSession ] ]! !!MagmaId methodsFor: 'initialize-release' stamp: 'cmm 5/30/2013 11:13'!initialize	super initialize.	uuid := UUID new.	name := uuid asString.	node := MagmaNode new! !!MagmaId methodsFor: 'printing' stamp: 'cmm 11/3/2008 10:46'!maPrintAbbreviatedOn: aStream 	aStream		maPrint: self name ;		maPrint: '@' ;		maPrint: self node! !MaObject subclass: #MagmaLocation	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaLocation commentStamp: 'cmm 1/13/2005 10:43' prior: 0!I provide an objectified link to a Magma repository, local or remote, to use when you don't want to bother with its location details.!!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 3/24/2013 17:43'!connectionWithId: aUUID 	^ self connections		detect: [ : each | each sessionId = aUUID ]		ifNone: [ nil ]! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 3/24/2013 17:40'!connections	^ self newAdminSession connections! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 10/24/2004 23:30'!description	^ String streamContents: [ : stream | self maPrintAbbreviatedOn: stream ]! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 9/15/2004 21:55'!name	^ name! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 9/15/2004 21:55'!name: anObject	"Set the value of name"	name := anObject! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 2/12/2012 15:32'!sessionClass	^ MagmaSession! !!MagmaLocation methodsFor: 'session' stamp: 'cmm 7/24/2018 20:37'!findSession	"If there is already a session in the image for this location, use it, otherwise make a new one."	^ MagmaSession connectedSessions		detect: [ : each | each location = self ]		ifNone:			[ (MagmaSession allClientInstances select:				[ : each | each location = self ])				ifEmpty: [ self newSession ]				ifNotEmpty: [ : candidates | candidates atRandom ] ]! !!MagmaLocation methodsFor: 'session' stamp: 'cmm 9/22/2009 20:37'!newAdminSession	^ self newSession! !!MagmaLocation methodsFor: 'session' stamp: 'cmm 1/13/2005 22:43'!newSession	self subclassResponsibility! !!MagmaLocation methodsFor: 'testing' stamp: 'cmm 9/23/2004 14:41'!isLocal	^ false! !!MagmaLocation methodsFor: 'factory' stamp: 'cmm 11/5/2008 21:30'!newServerLink	self subclassResponsibility ! !MagmaLocation subclass: #MagmaLocalLocation	instanceVariableNames: 'path'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 7/16/2007 21:38'!= aMagmaLocalLocation 	aMagmaLocalLocation maOriginalClass = self species ifFalse: [ ^ false ].	^ aMagmaLocalLocation pathName = self pathName! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 7/16/2007 21:38'!hash	^ self pathName hash! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 9/23/2004 14:41'!isLocal	^ true! !!MagmaLocalLocation methodsFor: 'converting' stamp: 'cmm 1/17/2007 23:09'!asMagmaLocalLocation	^ self! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 20:25'!base	^FileDirectory default  ! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'cmm 1/18/2007 21:05'!directory	"It's not obvious, but this actually supports fully-qualified paths or relative paths.		(FileDirectory default on: 'c:\temp') inspect.		(FileDirectory default on: 'magma') inspect	"	^  FileDirectory on: (self base fullNameFor: path) ! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 4/27/2007 02:52'!fileNames^ self directory fileNames! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'cmm 9/24/2004 12:28'!path	^ path! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'cmm 9/24/2004 12:28'!path: aString	path := aString! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 14:39'!pathName^ self directory pathName! !!MagmaLocalLocation methodsFor: 'printing' stamp: 'cmm 10/11/2010 17:23'!maPrintAbbreviatedOn: aStream 	aStream		maPrint: 'magma:' ;		nextPutAll: path! !!MagmaLocalLocation methodsFor: 'session' stamp: 'kph 10/4/2006 14:46'!newSession  ^self sessionClass openLocal: self	 ! !!MagmaLocalLocation methodsFor: '*magma-server-private' stamp: 'cmm 7/10/2015 15:46'!addLogDaemonTo: aZipArchive as: appDbDirName	aZipArchive		addDeflateString: '#!!/bin/bashexec 2>&1exec setuidgid magma multilog t ./main' squeakToLinux		as: appDbDirName! !!MagmaLocalLocation methodsFor: '*magma-server-private' stamp: 'cmm 7/16/2015 19:37'!addReadMeTo: aZipArchive as: appDbDirName 	aZipArchive		addDeflateString: 'To access the unzipped scripts, execute permissions must be granted.  In a terminal:	chmod u+x setPerms	./setPermsIf this server has not been configured to run Magma, run configsys:	./configsysThe system must be rebooted so that svscan will be started.  After rebooting, return to the ~/work/magma/myDb directoryIf the model is the output of a backup, then it is a warm-backup of the original.  If you want it to run the copy independently of the original, you need to run detach:	./detachFinally, install this Magma DB as a daemontools service:	./configdbserviceThe DB will start immediately and stay running, and restart automatically after server reboots or even if the VM or system crashes.To stop the database gracefully, use daemontools svc command:	sudo svc -d /service/myDb.' squeakToLinux		as: appDbDirName! !!MagmaLocalLocation methodsFor: '*magma-server-private' stamp: 'cmm 8/3/2015 13:06'!printStatusOn: aStream 	^ [ 'Connection successful, commit #:  ' , self newAdminSession remoteCommitNumber asString ]		on: Error		do: [ : err | 'FAILED:  ' , err messageText ]! !!MagmaLocalLocation methodsFor: '*magma-server-private' stamp: 'cmm 7/16/2015 21:52'!writeSetPermsScript	FileStream		fileNamed: 'setPerms'		do:			[ : stream | stream				 lineEndConvention: #lf ;				truncate: 0 ;				 maPrint: '#!!/bin/bashAPPNAME=`basename $PWD`echo strip public access from the entire directorychmod -R o-rwx ../$APPNAMEecho grant access to user magma if this is not the first db on this instancesudo chgrp -R --quiet magma ../$APPNAMEecho grant rwx permission to the linux scripts' ;				 lf ; maPrint: 'chmod 770'.			MagmaServerConsole linuxScriptSelectors , {'log/run'} do:				[ : each | stream					 space ;					 maPrint: each ] ]! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 7/1/2007 13:52'!commitLogDirectory	^ FileDirectory on: (self directory fullNameFor: MaRecoveryManager commitLogDirectoryName)! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 5/2/2013 13:30'!newCompressor	^ MagmaCompressor source: self! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 11/5/2008 21:36'!newServerLink	^ MagmaSession newLocalLinkFor: (MagmaRepositoryController openedOn: self)! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 5/2/2013 14:08'!oidCount	^ self controllerDo:		[ : controller | controller oidCount ]! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 5/2/2013 10:26'!repositoryVersion	| filer |	^ [ filer := MaObjectFiler open: self directory.	filer version ] ensure:		[ filer ifNotNil: [ filer close ] ]! !!MagmaLocalLocation methodsFor: '*magma-server-accessing' stamp: 'cmm 3/10/2009 19:59'!seedDirectory	"The initial copy of the repository, to which commit.n.log files may be loaded to advance it forward."	^ FileDirectory on: (self directory fullNameFor: 'seed')! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 7/10/2013 20:45'!commitRestore	| cont |	[ cont := MagmaRepositoryController open: self.	cont restoreMode ifTrue: [ cont commitRestore ] ] ensure:		[ cont ifNotNil: [ cont close ] ]! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 5/2/2013 14:08'!controllerDo: oneArgBlock 	| controller |	^ [ controller := MagmaRepositoryController open: self.	oneArgBlock value: controller ] ensure:		[ controller ifNotNil: [ controller close ] ]! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 11/22/2010 20:41'!delete	"Delete the files at my location."	self isMagmaRepository 		ifTrue: 			[ MagmaDeleteWarning signal: 'The Magma database at ' , self pathName , ' is about to be deleted.'.			self directory recursiveDelete ]		ifFalse: 			[ MagmaNotification signal: 'There is no Magma repository at ' , self pathName ]! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 7/8/2015 12:53'!deploy	self deployExcluding: #('commits' 'seed' 'supervise')! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 7/14/2018 18:02'!deployExcluding: toExclude	"I am the 'model' directory of some app dir in 'magma'.  Create a zip file of the app dir and its model, and all necessary scripts to start and manage the server under daemontools."	| archive appDbDir appName | appDbDir := self directory containingDirectory.	appName := appDbDir localName.	self isMagmaRepository ifFalse: [ MagmaUserError signal: self asString , ' does not appear to be a Magma repository.' ].	self isPotentiallyOpen ifTrue: [ MagmaUserError signal: 'Will not create a deployment archive on potentially-open DB.' ].	"Remove public rw access from files in zip."	ZipFileConstants classPool at: #DefaultFilePermissions put: 2r1000000110110000.	archive := ZipArchive new.	Cursor write showWhile:		[ | archiveFilename appDbDirName |		appDbDirName := 'work/magma/', appDbDir localName, '/'.		MagmaServerConsole exportLinuxScripts.		self writeSetPermsScript.  		archive 			addFile: 'setPerms' as: appDbDirName, 'setPerms' ;			addFile: 'squeak.conf' as: appDbDirName, 'squeak.conf'.		(appDbDir fileExists: 'port')			ifTrue: [archive addFile: (appDbDir fullNameFor: 'port') as: 'port' ]			ifFalse: [archive addString: (UIManager default request: 'What port # do you want for the port file?')  as: appDbDirName, 'port'].		self addReadMeTo: archive as: appDbDirName, 'README'; addLogDaemonTo: archive as: appDbDirName, 'log/run'.		"Zip linux scripts (w/ corresponding .st files), server image and changes, port file."		MagmaServerConsole linuxScriptSelectors , MagmaServerConsole stScriptNames , #('server.image' 'server.changes') do:			[ : each | (FileDirectory default fileExists: each asString)				ifTrue:					[ archive						addFile: each asString						as:							appDbDirName,								(appDbDir									maNameFor: each asString									relativeTo: appDbDir) ]				ifFalse: [ MaSoftwareError signal ] ].		"Zip the Spur VM"		{'cogspurlinuxht'. Smalltalk sourcesName asDirectoryEntry name. 'SqueakSSL'} do:			[ : each | archive				addDirectoryTree: FileDirectory default / each				relativeTo: FileDirectory default				as: appDbDirName ].		"Zip this model directory."		archive			addDirectoryTree: self directory			relativeTo: appDbDir			as: appDbDirName			if: [ : entriesArray | entriesArray noneSatisfy: [ : eachEntry | toExclude includes: eachEntry name ] ].		"Actually write the zip."		archive writeToFileNamed: (archiveFilename := appName , '.zip') ]! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 7/16/2015 22:00'!detachFromNode	"Normally sent to location of a local backup.  Resets it's node so it can be used independently."	| sess |	sess := self newSession		 connectAs: 'resetNode' ;		 yourself.	sess repositoryController restoreMode ifTrue: [ sess repositoryController commitRestore ].	[ sess resetNode ] ensure: [ sess disconnectAndClose ].	MagmaNotification signal: self maAbbreviatedString , ' is now detached.  Commit-log files from the original repository can no longer be used to roll it forward.'! !!MagmaLocalLocation methodsFor: '*magma-server-actions' stamp: 'cmm 5/2/2013 14:06'!filerDo: oneArgBlock 	| filer |	^ [ filer := MaObjectFiler open: self directory.	oneArgBlock value: filer ] ensure:		[ filer ifNotNil: [ filer close ] ]! !!MagmaLocalLocation methodsFor: '*magma-server-testing' stamp: 'cmm 11/22/2010 20:41'!isMagmaRepository	^ self directory exists and: [ self directory fileExists: MaObjectFiler objectsPhysicalFilename ]! !!MagmaLocalLocation methodsFor: '*magma-server-testing' stamp: 'cmm 6/24/2015 14:03'!isPotentiallyOpen	^ self directory fileExists: MagmaRepositoryController openIndicatorFilename! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaLocalLocation class	instanceVariableNames: ''!!MagmaLocalLocation class methodsFor: 'create' stamp: 'kph 10/4/2006 13:35'!default	"This method is for Seaside."	self maMarked: 'otherPackageSupport'.	^ self path: 'magma'! !!MagmaLocalLocation class methodsFor: 'create' stamp: 'cmm 1/17/2007 21:49'!path: fullOrRelativePathString	^ self new		path: fullOrRelativePathString ; 		yourself! !!MagmaLocalLocation class methodsFor: 'validate' stamp: 'cmm 5/2/2013 12:58'!verifyIsVersion: versionNumber 	self repositoryVersion = versionNumber ifFalse: [ MagmaUserError signal: 'Repository is not already version ' , versionNumber asString ]! !MaObject subclass: #MagmaNode	instanceVariableNames: 'locations sessions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaNode commentStamp: 'cmm 10/30/2008 17:30' prior: 0!A MagmaNode is a set of running Magma servers supporting one repository, one primary and one or more warm backups.  Typically, these servers would be connected with fast networking, so the backups can have a chance to get into a "synchronized" state, a state where the primary is sending the commitPackages in real-time.		-- replace MagmaSession>>'link' with this..? --Goals:  	- An equivalent MagmaNode is answered by any server in the node, which describes the servers in the node and their current role.	- The MagmaNode is delivered as part of the session connection process.	- Normally, MagmaSessions will send all commit requests other than commits to one of the warm-backup links, however..	- ..MagmaSessions may #submit: any request to any of the links in the node.  Internally, if the request is sent to the "wrong" link: 		- a commit request sent to a warm backup		- a read request sent to the primary	..then Magma will do the following:		1) the server that received the erroneous request will answer a MaErroneousRequest with a new MagmaNode		2) the private MagmaSession behavior will pre-interrogate every response with #isErroneousRequest (maybe via normal #on:do: error handling)		3) The MaErroneousRequest includes a new MagmaNode indicating the new cluster configuration.		4) the MagmaSession now replaces its 'node' and resubmits the request to the correct server.	- It is also possible the server went down, the client will get a NetworkError.  When this occurs, the client then asks the first primary to #takeOverAsPrimary.The MagmaNode is transmitted as a 'domain object' from server to client.  Its 'links' is transient and lazily initialized from its 'locations'.Magma will ensure it is sent to the correct node (even in case it changed) and adjust their Node if necessary.Messages sent to link in MagmaSession:	#submit: aMagmaRepositoryRequest	#location	#isConnected	#protocolEstablished	#disconnect	#stat:	#timeoutSeconds	#timeoutSeconds:	#compressThreshold	#compressThreshold:	#linkInformation	#repositoryController	#isLocal	#host!!MagmaNode methodsFor: 'updating' stamp: 'cmm 12/21/2012 14:59'!addLocation: aMagmaRemoteLocation 	self removeLocation: aMagmaRemoteLocation.	locations := locations copyWith: aMagmaRemoteLocation! !!MagmaNode methodsFor: 'updating' stamp: 'cmm 10/9/2009 16:46'!primaryLocation: aMagmaLocation 	(locations notEmpty and: [ locations first = aMagmaLocation ]) ifTrue: [ ^ self ].	locations := locations copyWithout: aMagmaLocation.	"Local connections are used only exclusively."	locations := aMagmaLocation isLocal 		ifTrue: 			[ {  aMagmaLocation  } ]		ifFalse: 			[ {  aMagmaLocation  } , (locations reject: [ : each | each isLocal ]) ]! !!MagmaNode methodsFor: 'updating' stamp: 'cmm 11/5/2008 21:12'!removeLocation: aMagmaRemoteLocation 	| session |	locations := locations copyWithout: aMagmaRemoteLocation.	session := self sessions 		removeKey: aMagmaRemoteLocation		ifAbsent: [ nil ].	session ifNotNil: [ session disconnect ]! !!MagmaNode methodsFor: 'updating' stamp: 'cmm 11/3/2008 12:16'!removePrimaryLocation	^ self removeLocation: self primaryLocation! !!MagmaNode methodsFor: 'updating' stamp: 'cmm 12/29/2008 16:01'!swapWithPrimary: secondaryLocation 	(self secondaryLocations includes: secondaryLocation) ifFalse: 		[ MagmaUserError signal: 'Swap function only available with warm-backups.' ].	locations 		swap: 1		with: (locations indexOf: secondaryLocation)! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/14/2008 12:36'!anySecondaryLocation	"Answer one of my warm backup locations at random.  Some installations may have multiple warm backups equally accessible, so clients don't care which one they connect to.  This method provides those applications convenience of not having to specify one of the warm backups explicitly, although they can (#see secondaryLocation:)"	^ self secondaryLocations atRandom! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 12/29/2008 20:05'!firstSecondaryLocation	^ locations size > 1 		ifTrue: [ locations at: 2 ]		ifFalse: [ nil ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 12/29/2008 20:05'!firstSecondarySession	^ self firstSecondaryLocation ifNotNilDo: [ : sl | self sessionFor: sl ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/22/2008 18:04'!locationMatching: aMaServerLocation 	"There are locations at two levels, the Magma level and the Ma Client Server level.  The Magma-level (an instance of MagmaRemoteLocation) references an instance of the Ma client server's location (a MaServerLocation)."	^ locations 		detect: [ : each | each serverLocation = aMaServerLocation ]		ifNone: [ nil ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/3/2008 12:26'!locations	^ locations! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/16/2008 16:47'!nextPrimaryLocation	"The first is always the primary.  The second is always the next primary.  When the first fails, it is removed and the second becomes the first, the primary."	^ self locations size > 1 ifTrue: [ self locations second ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 3/20/2015 16:59'!primaryLocation	"Had to use this temporary or else Spur fails in HA test-case 4, Swap Primary Duty because it thinks locations is the first inst-var of the Proxy.  Weird!!"|locs| locs:=locations.	^ locs notEmpty ifTrue: [ locs first ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/3/2008 11:58'!primarySession	^ self primaryLocation ifNotNil: [ self sessionFor: self primaryLocation ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/6/2008 13:42'!secondaryLocations	^ locations size > 1 		ifTrue: 			[ locations 				copyFrom: 2				to: locations size ]		ifFalse: [ Array new ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 11/6/2008 13:42'!secondaryLocationsDo: oneArgBlock 	| locCopy |	locCopy := locations copy.	"in case user wants to remove them"	2 		to: locCopy size		do: [ : n | oneArgBlock value: (locCopy 				at: n				ifAbsent: [ ^ self ]) ]! !!MagmaNode methodsFor: 'accessing' stamp: 'cmm 3/14/2009 12:35'!sessionFor: aMagmaRemoteLocation 	"In dealing with the servers of a node, it is necessary to lazily-initialize and cache MagmaSessions on account of how expensive they are to create."	^ self sessions 		at: aMagmaRemoteLocation		ifAbsentPut: 			[ | answer |			answer := aMagmaRemoteLocation newAdminSession.			answer user: (MagmaUser id: (String streamContents: 						[ : stream | 						stream maPrint: 'Admin-Session to '.						aMagmaRemoteLocation maPrintAbbreviatedOn: stream ])).			answer ]! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 6/30/2009 11:08'!includesSecondary: aMagmaRemoteLocation 	self secondaryLocationsDo: [ : each | each = aMagmaRemoteLocation ifTrue: [ ^ true ] ].	^ false! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 11/2/2008 10:04'!includesServerAt: aMagmaRemoteLocation	^ locations includes: aMagmaRemoteLocation! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 11/3/2008 18:24'!isBackedUp	"Answer whether I have any warm backups ready to take over."	^ locations size > 1! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 11/3/2008 12:24'!isEmpty	^ locations isEmpty! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 10/9/2009 16:49'!isLocal	^ self primaryLocation isLocal! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 11/18/2008 12:52'!ping: aMagmaRemoteLocation 	"Answer the commitNumber of the primary repository, if it can be.  Otherwise, signal an error (probably NetworkError)."	^ (self locations includes: aMagmaRemoteLocation) 		ifTrue: [ (self sessionFor: aMagmaRemoteLocation) remoteCommitNumber ]		ifFalse: 			[ MagmaSoftwareError signal: aMagmaRemoteLocation printString , ' is not part of ' ]! !!MagmaNode methodsFor: 'testing' stamp: 'cmm 11/14/2008 14:15'!pingPrimary	"Answer the commitNumber of the primary repository, if it can be.  Otherwise, signal an error (probably NetworkError)."	^ self ping: self primaryLocation! !!MagmaNode methodsFor: 'initialize-release' stamp: 'cmm 10/12/2011 20:14'!initialize	super initialize.	self reset! !!MagmaNode methodsFor: 'initialize-release' stamp: 'cmm 10/12/2011 20:14'!reset	locations := Array new! !!MagmaNode methodsFor: 'private' stamp: 'cmm 10/22/2008 10:52'!locationsDo: aBlock 	locations do: aBlock! !!MagmaNode methodsFor: 'private' stamp: 'cmm 8/5/2011 13:28'!maTransientVariables	^ #('sessions')! !!MagmaNode methodsFor: 'private' stamp: 'cmm 11/3/2008 19:55'!sessions	^ sessions ifNil: [ sessions := Dictionary new ]! !!MagmaNode methodsFor: 'printing' stamp: 'cmm 11/13/2008 14:14'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	locations do: 		[ : each | 		aStream maPrint: each.		each == locations last ifFalse: [ aStream maPrint: ', ' ] ]! !!MagmaNode methodsFor: 'copying' stamp: 'cmm 11/18/2009 13:38'!veryDeepInner: aDeepCopier 	super veryDeepInner: aDeepCopier.	locations := locations veryDeepCopyWith: aDeepCopier.	"Let this node establish his own sessions."	sessions := nil! !MagmaLocation subclass: #MagmaRemoteLocation	instanceVariableNames: 'location'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaRemoteLocation commentStamp: 'cmm 7/5/2008 14:42' prior: 0!A MaServerLocation simply encapsulates the host and port information to access a Magma server, allowing the receiver to serve as a 'bookmark' to a Magma server resource.!!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 12/30/2008 13:06'!= aMagmaRemoteLocation 	aMagmaRemoteLocation maOriginalClass = self maOriginalClass ifFalse: [ ^ false ].	^ self serverLocation = aMagmaRemoteLocation serverLocation! !!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 12/30/2008 13:09'!hash	^ self serverLocation hash! !!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 3/12/2009 16:07'!isLocalHost	^ location isLocalHost ! !!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 6/30/2009 10:56'!isReachable	"Answer whether the host specified by my location can be reached on the port."	^ location isReachable! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 7/5/2008 14:56'!host	"The TCP/IP hostname of the host hosting this Magma repository."	^ location host! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 7/5/2008 14:43'!hostAddress	"Answer the ByteArray representation of my hosts ip address."	^ location hostAddress! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 7/5/2008 14:56'!port	"The TCP/IP port the remote Magma repository is expected to be listening."	^ location port! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 11/6/2008 14:12'!serverLocation	^ location! !!MagmaRemoteLocation methodsFor: 'printing' stamp: 'cmm 9/6/2012 20:47'!maPrintAbbreviatedOn: aStream 	aStream maPrint: 'magma://'.	location maPrintAbbreviatedOn: aStream! !!MagmaRemoteLocation methodsFor: 'printing' stamp: 'cmm 9/6/2012 20:47'!printOn: aStream 	self maPrintAbbreviatedOn: aStream! !!MagmaRemoteLocation methodsFor: 'maui-support' stamp: 'cmm 9/11/2012 16:29'!mauiDefaultColumns	^ #(host port)! !!MagmaRemoteLocation methodsFor: 'maui-support' stamp: 'cmm 9/11/2012 16:31'!mauiSortableColumns	^ #(#host #port )! !!MagmaRemoteLocation methodsFor: 'factory' stamp: 'cmm 3/8/2009 12:33'!newAdminSession	"Answer a session that does not fail over to any backup.  These sessions are used for communicating between the servers of a node themselves."	^ self newSession		allowFailover: false ;		yourself! !!MagmaRemoteLocation methodsFor: 'factory' stamp: 'cmm 1/7/2009 01:08'!newServerLink	^ (MaNetworkServerLink location: location) protocol: MagmaSession protocol! !!MagmaRemoteLocation methodsFor: 'factory' stamp: 'cmm 7/15/2008 22:16'!newSession	| answer |	answer := self sessionClass 		host: self host		port: self port.	"Try to help the user in case they don't remember to turn this off on a localhost connection."	self isLocalHost ifTrue: [ answer useCompression: false ].	^ answer! !!MagmaRemoteLocation methodsFor: 'initialize-release' stamp: 'cmm 7/5/2008 14:12'!setLocation: aMaServerLocation	location := aMaServerLocation! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaRemoteLocation class	instanceVariableNames: ''!!MagmaRemoteLocation class methodsFor: 'create' stamp: 'cmm 7/5/2008 14:14'!default	"For Seaside support."	self maMarked: 'otherPackageSupport'.	^ self 		host: 'localhost'		port: 51969! !!MagmaRemoteLocation class methodsFor: 'create' stamp: 'cmm 7/5/2008 15:23'!host: hostName port: portInteger 	^ self location: 		(MaServerLocation 			host: hostName			port: portInteger)! !!MagmaRemoteLocation class methodsFor: 'create' stamp: 'cmm 7/5/2008 15:22'!location: aMaServerLocation 	^ self new		setLocation: aMaServerLocation ;		yourself! !MaObject subclass: #MagmaUser	instanceVariableNames: 'id'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Domain'!!MagmaUser methodsFor: 'initialize' stamp: 'cmm 1/15/2005 16:37'!id	^ id! !!MagmaUser methodsFor: 'initialize' stamp: 'cmm 1/15/2005 16:37'!id: aString	id := aString! !!MagmaUser methodsFor: 'printing' stamp: 'cmm 1/17/2005 21:59'!maPrintAbbreviatedOn: aStream	self maPrintAttribute: #id on: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaUser class	instanceVariableNames: ''!!MagmaUser class methodsFor: 'create' stamp: 'cmm 1/15/2005 16:37'!id: aString	^ self new id: aString; yourself! !