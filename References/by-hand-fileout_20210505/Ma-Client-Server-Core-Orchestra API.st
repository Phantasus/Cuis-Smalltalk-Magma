MaObject subclass: #MaNetworkOrchestra	instanceVariableNames: 'name players firstPort cores startBlock launchProcess guard imageTimestamp prepareImageSelector onePlayerImage protocol timeoutSeconds'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Orchestra API'!!MaNetworkOrchestra commentStamp: 'cmm 9/18/2013 15:22' prior: 0!About:A MaNetworkOrchestra is an object which lets you divide a large task among multiple CPU cores.  The current running process is forked into into two or more separate image instances running in parallel and working on different parts of the same large task.Setup:To use it, create and set up the Orchestra object with the desired number of Players.  Then send #launch to the Orchestra.  For example:	(MaNetworkOrchestra name: 'one-big-task')		maxCores: 4 "<--- Keep up to 4 player images running simultaneously." ;		playerNamed: 'subtask1' playerName doAndQuit: [ "perform subtask1" ] ;		playerNamed: 'subtask2' playerName doAndQuit: [ "perform subtask2" ] ;		playerNamed: 'subtask3' playerName doAndQuit: [ "perform subtask3" ] ;		playerNamed: 'subtask4' playerName doAndQuit: [ "perform subtask4" ] ;		playerNamed: 'subtask5' playerName doAndQuit: [ "perform subtask5" ] ;		playerNamed: 'subtask6' playerName doAndQuit: [ "perform subtask6" ] ;		launch#launch causes the originating image to be saved under the Orchestra's #name (to preserve the original launching image and assume the role of "conductor") and then proceeds to launch additional copies of itself, one for each Player defined in the Orchestra.  The conductor is then able to send #remotePerform: requests to any player for purposes of initiating the task, reporting status, or shutting down.The above use convenience method to create a generic Player instance for brevity of the example.  In fact, highly customized Players can be created and added via the #addPlayer: message.  See references to this class for custom examples employed by my test-cases.Resource Management:The Orchestra specifies how many players to keep running simultaneously by its #maxCores.  The running conductor pings its players every second.  As player images complete their task and exit the image, the ping fails and a "core" slot frees up in the Orchestra., whereupon it will launch the next defined Player and monitor it.TestCases as a complex Example:The Ma-Client-Server-Tester packages themselves serve as another example of using an Orchestra:  to test the CS functionality of this package, we need two client images and one server image for a total of three Player images.  The conductor sends requests to the server image such as "start your server", "shutdown your server" and messages to the clients such as "connect to the server at: port123" or, "send this remotePerform request to the server", etc.!!MaNetworkOrchestra methodsFor: 'core-management' stamp: 'cmm 2/25/2013 17:33'!addCores: anInteger	"Increase the number of cores used to process by anInteger.  Will result in the immediate launching of new players."	guard critical: [self maxCores: cores size+anInteger ]! !!MaNetworkOrchestra methodsFor: 'core-management' stamp: 'cmm 1/8/2013 20:24'!cores	"My execution slots -- simply an Array with each element containing the MaNetworkPlayer running in that slot.  If not enough players are remaining to fill all slots, some slots will be nil."	^ cores! !!MaNetworkOrchestra methodsFor: 'core-management' stamp: 'cmm 7/18/2013 15:59'!maxCores: anInteger 	"Limit the number of simultaneously launched images to anInteger.  An unlimited number of players may be added to the orchestra, but only the specified number will be running at a time.  Remaining players are launched as the initial ones exit.	This parameter can be changed even after the Orchestra is already running."	guard critical:		[ cores := cores			ifNil: [ Array new: anInteger ]			ifNotNil:				[ anInteger > cores size					ifTrue: [ cores , (Array new: anInteger - cores size) ]					ifFalse:						[ anInteger < cores size							ifTrue:								[ cores									copyFrom: 1									to: anInteger ]							ifFalse: [ cores ] ] ] ]! !!MaNetworkOrchestra methodsFor: 'core-management' stamp: 'cmm 2/25/2013 17:34'!removeCores: anInteger	"Decrease the number of cores used to process by anInteger.  Already-running players are unaffected, when they finish new players will not launch until cores area available."	guard critical: [self maxCores: cores size-anInteger ]! !!MaNetworkOrchestra methodsFor: 'player setup' stamp: 'cmm 9/17/2013 14:18'!addPlayer: aMaNetworkPlayer 	players add: aMaNetworkPlayer.	aMaNetworkPlayer setOrchestra: self.	^ aMaNetworkPlayer! !!MaNetworkOrchestra methodsFor: 'player setup' stamp: 'cmm 9/17/2013 15:38'!playerNamed: aString do: aBlock	^ self addPlayer: ((MaNetworkPlayer name: aString) doBlock: aBlock)! !!MaNetworkOrchestra methodsFor: 'player setup' stamp: 'cmm 9/18/2013 15:04'!playerNamed: aString do: aBlock andQuit: shouldQuit 	self		playerNamed: aString		do: aBlock		snapshot: false		andQuit: true! !!MaNetworkOrchestra methodsFor: 'player setup' stamp: 'cmm 9/17/2013 15:39'!playerNamed: aString do: aBlock snapshot: shouldSave andQuit: shouldQuit 	self		playerNamed: aString		do:			[ aBlock value.			Smalltalk				snapshot: shouldSave				andQuit: shouldQuit ]! !!MaNetworkOrchestra methodsFor: 'player setup' stamp: 'cmm 9/18/2013 15:05'!playerNamed: aString doAndQuit: aBlock	self		playerNamed: aString		do: aBlock		andQuit: true! !!MaNetworkOrchestra methodsFor: 'private' stamp: 'cmm 4/4/2014 10:47'!allCoresFinished	^ guard critical: [ cores allSatisfy: [ : each | each isNil ] ]! !!MaNetworkOrchestra methodsFor: 'private' stamp: 'cmm 1/1/2013 15:30'!conductorImageEntry	^ FileDirectory default		entryAt: self conductorImageName		ifAbsent: [  ]! !!MaNetworkOrchestra methodsFor: 'private' stamp: 'cmm 9/12/2013 20:12'!imageTimestamp	"The DateAndTime of the last save of this image.  Used to determine whether new images need to be created."	^ imageTimestamp! !!MaNetworkOrchestra methodsFor: 'private' stamp: 'cmm 4/4/2014 10:44'!recoverFinishedCores	guard critical:		[ cores withIndexDo:			[ : each : x | each ifNotNil:				[ (each isVariableBinding not and: [ each isReady not ]) ifTrue:					[ each disconnect.					cores						at: x						put: nil ] ] ] ]! !!MaNetworkOrchestra methodsFor: 'private' stamp: 'cmm 4/4/2014 10:45'!waitForAvailableCore	| availableCore |	[ availableCore := guard critical: [ cores indexOf: nil ].	availableCore = 0 ] whileTrue:		[ (Delay forSeconds: 2) wait.  "Balance between cost of making connections and wait-time to launch next batch of available cores."		self recoverFinishedCores ].	^ availableCore! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 1/6/2013 16:59'!conductorImageName	^ self name , '-conductor.image'! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 12/31/2012 18:48'!deleteImages	players do:		[ : each | each deleteImage ]! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 1/2/2013 15:04'!isConductorImage	| entry |	entry := self conductorImageEntry.	^ entry notNil and: [ Smalltalk imageEntry = entry ]! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 10/29/2013 15:01'!onePlayerImage	"Whether a separate image and changes file should be copied for each player instance.  Might be useful if images are wish to save image state before they exit, so that state will be present next time."	^ onePlayerImage! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 10/29/2013 14:47'!onePlayerImage: aBoolean	"Whether a separate image and changes file should be copied for each player instance.  Might be useful if images are wish to save image state before they exit, so that state will be present next time."	onePlayerImage := aBoolean! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 4/14/2014 22:14'!prepareImageSelector	"The selector on my class which should be used to create the image.  It should be one of:		#createImage -- Create the image from the launching image, replacing any old images for prior players (with the same filename).  This is necessary to pass different arguments to player images each time, like the mode argument to MagmaDataRepair (#check, #count, #identify, #repair, etc.).		#ensureImage -- Create the image only if it doesn't already exist.		#ensureUpToDateImage -- Create the image if it doesn't exist or if it is older than this image."	^ prepareImageSelector! !!MaNetworkOrchestra methodsFor: 'images' stamp: 'cmm 4/14/2014 22:15'!prepareImageSelector: selectorSymbol	prepareImageSelector := selectorSymbol! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 10/28/2013 10:56'!firstPort 	"The starting port number my players will use to listen for requests from the conductor."	^ firstPort! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 10/28/2013 10:57'!firstPort: anInteger 	"Set the starting port number my players will use to listen for requests from the conductor."	firstPort := anInteger! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 1/6/2013 16:54'!name	"The name of this orchestra which is used to prefix the image names of the orchestra image."	^ name ifNil: [ Smalltalk imageEntry localFileName ]! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 1/1/2013 11:20'!name: aString 	"The name of this orchestra which is used to prefix the image names of the individual players."	name := aString! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 9/23/2013 21:31'!protocol	"An array of the classes of objects that will be passed between conductor and players."	^ protocol ifNil: [ { MaRemotePerformRequest } ]! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 9/17/2013 15:10'!protocol: anArray 	"An array of the classes of objects that will be passed between conductor and players."	protocol := anArray! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 1/9/2013 15:16'!startBlock	"The block of code to run immediately upon launch, after becoming the conductor but before launching any players."	^ startBlock! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 1/9/2013 15:16'!startBlock: aBlock 	"The block of code to run immediately upon launch, after becoming the conductor but before launching any players."	startBlock := aBlock! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 3/15/2015 13:16'!timeoutSeconds	^ timeoutSeconds ifNil: [ 600 ]! !!MaNetworkOrchestra methodsFor: 'accessing' stamp: 'cmm 9/17/2013 16:29'!timeoutSeconds: anInteger 	timeoutSeconds := anInteger! !!MaNetworkOrchestra methodsFor: 'player access' stamp: 'cmm 12/31/2012 21:35'!homePlayer	"Answer the player which is meant to run in this image memory."	^ players		detect: [ : each | each isHome ]		ifNone: [ nil ]! !!MaNetworkOrchestra methodsFor: 'player access' stamp: 'cmm 1/1/2013 13:59'!playerNamed: aString 	^ players		detect: [ : each | each name = aString ]		ifNone: [ nil ]! !!MaNetworkOrchestra methodsFor: 'player access' stamp: 'cmm 1/3/2013 10:06'!players	^ players! !!MaNetworkOrchestra methodsFor: 'player access' stamp: 'cmm 1/6/2013 19:42'!removePlayer: aMaNetworkPlayer 	players		 remove: aMaNetworkPlayer ;		 changed! !!MaNetworkOrchestra methodsFor: 'initialize-release' stamp: 'cmm 3/15/2015 15:12'!initialize	super initialize.	players := OrderedCollection new.	firstPort := 44441.	guard := Mutex new.	prepareImageSelector := #createImage.	onePlayerImage := true.	self maxCores: 4! !!MaNetworkOrchestra methodsFor: 'start / stop' stamp: 'cmm 1/5/2016 16:53'!launch	"Players treat first command-line args as a port number, not a script."	players ifEmpty: [ MaClientServerUserError signal: 'No players.  Launching is useless.' ].	"Allow multiple parameters, don't assume a .st file input."	Preferences readDocumentAtStartup: false.	MCFileBasedRepository flushAllCaches.	Smalltalk saveAs: self conductorImageName.	imageTimestamp := Smalltalk imageEntry modificationTime.	"v------ Players continue here -----v"	self isConductorImage ifTrue:		[ startBlock value.		"fork it to allow UI control so that the conductor image itself can be a user-console which can interactively display status of currently running players even though not all players have yet been launched."		onePlayerImage ifTrue: [ players anyOne prepareImage ].		launchProcess := [ players withIndexDo:			[ : each : index | | availableCore |			availableCore := self waitForAvailableCore.			guard critical:				[ cores					at: availableCore					put: #notReady -> each ].			each initializeLink: firstPort + availableCore - 1.			onePlayerImage ifFalse: [ each prepareImage ].			[ each				 launch ;				 waitForReady.			guard critical:				[ cores					at: each port - firstPort + 1					put: each ] ] newProcess name: 'launching ', each name; resume ] ] newProcess			 name: name , ' conductor' ;			 resume ].	"Players, start your servers and go!!"	self homePlayer ifNotNil:		[ : hp | hp go ]! !!MaNetworkOrchestra methodsFor: 'start / stop' stamp: 'cmm 11/5/2013 16:38'!shutDownPlayers	 players do:		[ : each | [ each			remotePerform: #snapshot:andQuit:			withArguments: {false. true}.		each disconnect ]			on: NetworkError			do: [ : err | "ignore it" ] ]! !!MaNetworkOrchestra methodsFor: 'status' stamp: 'cmm 4/4/2014 10:49'!waitForAllPlayersReady	"Block until all players report ready."	| numberReady maxThatCanBeReady |	maxThatCanBeReady := guard critical: [ cores size min: players size ].	[ (Delay forSeconds: 5) wait.	numberReady := guard critical:		[ cores count:			[ : each | each notNil and:				[ each isVariableBinding not and: [ each value isReady ] ] ] ].	numberReady >= maxThatCanBeReady ] whileFalse! !!MaNetworkOrchestra methodsFor: 'status' stamp: 'cmm 4/4/2014 10:48'!waitForAllPlayersUnready	"Block until no players report ready."	[ self		 recoverFinishedCores ;		 allCoresFinished ] whileFalse: [ (Delay forSeconds: 2) wait ]! !!MaNetworkOrchestra methodsFor: 'status' stamp: 'cmm 4/4/2014 10:39'!waitForAnyPlayerReady	"Block until any player reports ready."	[ guard critical:		[ cores anySatisfy:			[ : each | each notNil and:				[ each isVariableBinding not and: [ each isReady ] ] ] ] ] whileFalse: [ (Delay forSeconds: 2) wait ]! !!MaNetworkOrchestra methodsFor: 'status' stamp: 'cmm 4/4/2014 10:31'!waitForTaskComplete	"First, we can simply wait for the launchProcess to terminate."	[ launchProcess notNil and: [ launchProcess isTerminated not ] ] whileTrue: [ (Delay forSeconds: 1) wait ].	"Now wait for remaining players to finish up."	self waitForAllPlayersUnready! !!MaNetworkOrchestra methodsFor: '*magma-tester' stamp: 'cmm 1/3/2013 13:21'!pushClass: aClass	players do: [ : each | each pushClass: aClass ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaNetworkOrchestra class	instanceVariableNames: ''!!MaNetworkOrchestra class methodsFor: 'instance creation' stamp: 'cmm 7/14/2013 19:04'!name: aString 	^ self new		 name: aString ;		 yourself! !!MaNetworkOrchestra class methodsFor: 'linux-scripts' stamp: 'cmm 7/24/2015 15:21'!orchestraTest	^ 'spur mt-spur orchestraTest.st $1 $2' ->		[ Smalltalk runAndQuit:			[ : numberOfTasks : numberOfCores | MaNetworkOrchestra				orchestraTest: numberOfTasks asInteger				cores: numberOfCores asInteger ] ]! !!MaNetworkOrchestra class methodsFor: 'test' stamp: 'cmm 7/24/2015 15:53'!orchestraTest: numberOfTasks cores: numberOfCores 	| orch |	orch := (MaNetworkOrchestra name: 'orcchestraTest')		 maxCores: numberOfCores asInteger ;		 yourself.	1		to: numberOfTasks		do:			[ : n | orch				playerNamed: 'player', n asString				do: [ Smalltalk runAndQuit: [ (Delay forSeconds: (1 to: 10) atRandom) wait ] ] ].	orch launch.	orch isConductorImage ifTrue: [ orch waitForTaskComplete ]! !MaObject subclass: #MaNetworkPlayer	instanceVariableNames: 'name orchestra link server doBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Orchestra API'!!MaNetworkPlayer commentStamp: 'cmm 9/18/2013 20:34' prior: 0!Each Player of an Orchestra run in its own image, leveraging the multi-core CPU's.  These MaNetworkPlayer instances are objects which exist in both images images, and use client-server communication between the instance in the conductor (the client) and the instance in the corresponding player image (server) to interrogate status or send commands.!!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 10/29/2013 14:54'!baseName	^ orchestra name , '-' ,		(orchestra onePlayerImage			ifTrue: [ 'player' ]			ifFalse: [ name ])! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 12/31/2012 18:56'!changesEntry	^ FileDirectory entryAt: self changesName! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 1/7/2013 17:58'!changesName	^ self baseName, '.changes'! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 1/2/2013 15:07'!createImage	self deleteImage.	MaNotification signal: 'copying ' , (FileDirectory default localNameFor: Smalltalk imageName) , ' to ' , self imageName.	FileDirectory default				putFile: Smalltalk imageEntry readStream		named: self imageName ;				putFile: Smalltalk changesEntry readStream		named: self changesName! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 4/24/2014 19:31'!deleteImage	MaNotification signal: 'deleting ' , self imageName.	FileDirectory default		 deleteFileNamed: self imageName ;		 deleteFileNamed: self changesName! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 10/29/2013 15:26'!ensureImage	self imageEntry ifNil: [ self createImage ]! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 10/29/2013 15:25'!ensureUpToDateImage	| imageEntry |	imageEntry := self imageEntry.	(imageEntry isNil or: [ orchestra imageTimestamp > imageEntry modificationTime ]) ifTrue: [ self createImage ]! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 1/1/2013 15:36'!imageEntry	^ FileDirectory default		entryAt: self imageName		ifAbsent: [ nil ]! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 1/7/2013 17:58'!imageName	^ self baseName, '.image'! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 10/31/2013 17:57'!isHome	"Answer whether this player is the one that runs in this image."	^ name = (Smalltalk argumentAt: 2)! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 10/29/2013 15:00'!prepareImage	self perform: orchestra prepareImageSelector! !!MaNetworkPlayer methodsFor: 'private' stamp: 'cmm 3/15/2015 13:00'!server	^ server ifNil:		[ "Set a high timeout to try to avoid the 'port already in use' error.  The socket-accept is at a higher priority.  It will wait up to that long to establish a connection but if the image has already exited, it will fail fast even with this long timeout."		server := (MaNetworkRequestServer protocol: orchestra protocol)			 timeoutSeconds: 600 ;			 yourself ]! !!MaNetworkPlayer methodsFor: 'server side' stamp: 'cmm 12/23/2014 22:04'!conductorKnowsImReady	">=2 one for the 'connect' request plus one for the 'ping' request.  See #isReady."	^ self server console statistics timeToSendResponsesHistory summary count >= 2! !!MaNetworkPlayer methodsFor: 'server side' stamp: 'cmm 7/14/2013 20:45'!ensureServerStarted	self server isRunning ifFalse: [ self server processOn: self port ]! !!MaNetworkPlayer methodsFor: 'server side' stamp: 'cmm 4/3/2014 17:22'!go	| started ready |	self ensureServerStarted.	started := Time millisecondClockValue.	[ (ready := self conductorKnowsImReady) or: [ (Time millisecondsSince: started) > 30000 ] ] whileFalse: [ (Delay forMilliseconds: 100) wait ].	ready		ifTrue: [ doBlock value ]		ifFalse: [ MaEnvironmentError signal: 'Conductor never connected.' ]! !!MaNetworkPlayer methodsFor: 'server side' stamp: 'cmm 2/6/2009 14:02'!isRunning	^ server notNil and: [ server isRunning ]! !!MaNetworkPlayer methodsFor: 'server side' stamp: 'cmm 1/2/2013 21:36'!stop	server shutdown! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 1/17/2009 16:08'!disconnect	link disconnect! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 9/15/2013 17:05'!isReady	"Client-side message -- answer whether the remote player is ready to receive requests."	^ link ping! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 9/1/2015 16:46'!launch	"Launch players minimized.  Use the fully-qualified path to the vm, specify memory and iconic, then the image name with two args:  the port and the name of this Player in single-quotes.  Finally, append output to .log and .err files."	| displayType | displayType := Smalltalk isHeadless ifTrue: [ 'none' ] ifFalse: [ 'X11 -iconic' ].	OSProcess command: Smalltalk vmFileName, ' -vm display=', displayType, ' ' , self imageName, ' ', self port asString, ' ''', name , ''' > ' , name , '.log 2>' , name , '.err &'! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 9/18/2013 20:37'!remotePerform: selectorSymbol 	"Perform selectorSymbol on my server's processor in my player image."	^ self		remotePerform: selectorSymbol		withArguments: Array empty! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 1/3/2013 12:45'!remotePerform: selectorSymbol with: argument 	^ self		remotePerform: selectorSymbol		withArguments: {argument}! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 9/18/2013 20:39'!remotePerform: selectorSymbol withArguments: anArray	"Perform selectorSymbol on my server's processor in my player image.  The classes of all arguments must be part of the protocol."	^ self submit:		(MaRemotePerformRequest new			 selector: selectorSymbol ;			 arguments: anArray)! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 1/2/2003 14:46'!submit: aMaNetworkTestPlayerRequest	| result |	result := link submit: aMaNetworkTestPlayerRequest.	result maIsException 		ifTrue: [ result class signal: result messageText ]		ifFalse: [ ^result ]! !!MaNetworkPlayer methodsFor: 'client side' stamp: 'cmm 9/15/2013 16:42'!waitForReady	"After sending #launch, it takes a couple of seconds for the image to launch and the server to start.  Wait here until it's ready."	[ self isReady ] whileFalse:		[ MaClientServerNotification signal: 'Waiting for ' , self name , ' player to start.'.		(Delay forSeconds: 1) wait ]! !!MaNetworkPlayer methodsFor: 'setup' stamp: 'cmm 9/10/2013 20:48'!doBlock: aBlock 	doBlock := aBlock! !!MaNetworkPlayer methodsFor: 'setup' stamp: 'cmm 11/5/2013 16:26'!name: aString	"Do not allow single-quotes in the name because it must be used as a command-line argument."	name := aString copyWithout: $'! !!MaNetworkPlayer methodsFor: 'setup' stamp: 'cmm 10/16/2002 17:04'!timeoutSeconds: anInteger	link timeoutSeconds: anInteger! !!MaNetworkPlayer methodsFor: 'initialize-release' stamp: 'cmm 10/29/2013 15:36'!initializeLink: port	link := (MaNetworkServerLink port: port)		protocol: orchestra protocol ;		timeoutSeconds: orchestra timeoutSeconds ;		yourself.	link ping ifTrue: [ MaClientServerEnvironmentError signal: port asString, ' appears to already be in use.' ]! !!MaNetworkPlayer methodsFor: 'initialize-release' stamp: 'cmm 2/6/2009 15:50'!server: aMaNetworkRequestServer 	server := aMaNetworkRequestServer! !!MaNetworkPlayer methodsFor: 'initialize-release' stamp: 'cmm 9/17/2013 15:50'!setOrchestra: aMaNetworkOrchestra 	orchestra := aMaNetworkOrchestra! !!MaNetworkPlayer methodsFor: 'printing' stamp: 'cmm 4/2/2013 13:29'!maPrintAbbreviatedOn: aStream 	self		maPrintAttributes: #(#name )		on: aStream! !!MaNetworkPlayer methodsFor: 'access' stamp: 'cmm 5/22/2002 10:21'!name	^name! !!MaNetworkPlayer methodsFor: 'access' stamp: 'cmm 1/1/2013 11:19'!orchestra	^ orchestra! !!MaNetworkPlayer methodsFor: 'access' stamp: 'cmm 10/12/2013 18:24'!port	"The TCP/IP port through which my conductor communicates with me."	^ link		ifNil: [ (Smalltalk argumentAt: 1) asInteger ]		ifNotNil: [ link port ]! !!MaNetworkPlayer methodsFor: 'access' stamp: 'cmm 1/3/2013 12:31'!timeoutSeconds	^ link timeoutSeconds! !!MaNetworkPlayer methodsFor: '*magma-tester' stamp: 'cmm 5/22/2002 17:32'!pushClass: aClass	| stream |	stream := ReadWriteStream on: String new.	aClass		fileOutOn: stream		moveSource: false		toFile: 0.	^self pushCode: stream! !!MaNetworkPlayer methodsFor: '*magma-tester' stamp: 'cmm 1/3/2013 12:45'!pushCode: aPositionableStream 	^ self		remotePerform: #loadCodeFrom:		with: aPositionableStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaNetworkPlayer class	instanceVariableNames: ''!!MaNetworkPlayer class methodsFor: 'instance creation' stamp: 'cmm 7/14/2013 18:57'!name: aString 	^ self new		 name: aString ;		 yourself! !