MaObject subclass: #MaAtomicFileStream	instanceVariableNames: 'filename fileStreams sizes guard uncommittedSize position writers pool'	classVariableNames: 'MaxPhysicalFileSize'	poolDictionaries: ''	category: 'Magma-Server-File'!!MaAtomicFileStream commentStamp: 'cmm 3/5/2009 16:44' prior: 0!This class emulates a StandardFileStream except doesn't actually write contents to disk until you send #maCommit.  Instead, it caches the written contents to a collection of MaAtomicFileWriters.Also, the latest additional feature is that it can be of unlimited size, it reads and writes its multiple physical 'fileStreams' depending on what the file-position requested is.!!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 10/22/2014 14:02'!addPhysicalFile	sizes add: 0.	^ (StandardFileStream newFileNamed: self nextName) in: 		[ : stream | 		(stream isNil or: [stream closed]) ifTrue: [ MagmaEnvironmentError signal: 'file did not open' ].		stream binary.		fileStreams add: stream ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 3/7/2011 19:51'!deleteFrom: fileIndex 	"Delete the particular index of my file numbered fileIndex.  This is used when truncating."	fileIndex		to: fileStreams size		do: [ : n | FileDirectory deleteFilePath: (self nameFor: n) ].	fileStreams := fileStreams		copyFrom: 1		to: fileIndex - 1! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 5/23/2007 23:16'!maxPhysicalFileSize	^ MaxPhysicalFileSize! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/20/2007 16:13'!nameFor: fileIndex 	"The name of the file numbered fileIndex."	^ (FileDirectory default splitNameVersionExtensionFor: filename) in: 		[ : nameNumberAndExtension | 		String streamContents: 			[ : stream | 			stream				maPrint: nameNumberAndExtension first ;				nextPut: $. ;				maPrint: fileIndex.			nameNumberAndExtension last ifNotEmpty: 				[ stream					nextPut: $. ;					maPrint: nameNumberAndExtension last ] ] ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/11/2007 23:03'!nextName	^ self nameFor: fileStreams size+1! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/11/2007 22:47'!physicalFlush	^ fileStreams do: [ : each | each closed ifFalse: [ each flush ] ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 9/11/2010 12:16'!physicallyWrite: numberOfBytes bytesFromPosition: bufferPosition of: aByteArray atFilePosition: filePosition 	guard critical: 		[ self 			streamAt: filePosition			withRelativePositionDo: 				[ : fileStream : relativePos | 				self renewAccess: fileStream.				fileStream 					maWrite: aByteArray size					bytesFromPosition: 1					of: aByteArray					atFilePosition: relativePos ]			ifNone: 				[ "filePosition is beyond the end of the last file, so we know we will write either the last file or a new file,"				| streamToWrite positionOfLastFileStream |				streamToWrite := (sizes isEmpty or: [ aByteArray size + sizes last > self maxPhysicalFileSize ]) 					ifTrue: [ self addPhysicalFile ]					ifFalse: [ fileStreams last ].				self renewAccess: streamToWrite.				positionOfLastFileStream := self committedSize - sizes last.				streamToWrite 					maWrite: numberOfBytes					bytesFromPosition: 1					of: aByteArray					atFilePosition: filePosition - positionOfLastFileStream.				sizes 					at: sizes size					put: fileStreams last size ] ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/28/2007 19:08'!renewAccess: aPhysicalStream	pool renewAccess: aPhysicalStream! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/20/2007 14:10'!streamAt: filePosition withRelativePositionDo: twoArgBlock ifNone: aBlock 	"Value twoArgBlock with the fileStream that contains filePosition, and the relative position within that fileStream that matches filePosition."	^ self 		streamIndexAt: filePosition		withRelativePositionDo: 			[ : index : relativePosition | 			twoArgBlock 				value: (fileStreams at: index)				value: relativePosition ]		ifNone: aBlock! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 4/20/2007 16:07'!streamIndexAt: filePosition withRelativePositionDo: twoArgBlock ifNone: aBlock	"Value twoArgBlock with the index of the fileStream that contains filePosition, and the relative position within that fileStream that matches filePosition."	| runningSize |	runningSize := 0.	sizes withIndexDo: 		[ : eachSize : index | 		filePosition < (runningSize + eachSize) ifTrue: 			[ | relativePosition |			relativePosition := filePosition - runningSize.			^ twoArgBlock 				value: index				value: relativePosition ].		runningSize := runningSize + eachSize ].	"filePosition is Beyond end of last fileStream."	^ aBlock value! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 3/7/2011 19:52'!truncateStreams: filePosition 	| startingFileNumber fileStreamToTruncate |	guard critical: 		[ self 			streamIndexAt: filePosition			withRelativePositionDo: 				[ : index : relativePosition | 				startingFileNumber := relativePosition = 0 					ifTrue: [ index ]					ifFalse: [ index + 1 ].				fileStreamToTruncate := fileStreams at: index.				self renewAccess: fileStreamToTruncate.				fileStreamToTruncate					truncate: relativePosition ;					close ;					open				"close and open to get around bug; see http://lists.squeakfoundation.org/pipermail/squeak-dev/2005-June/092041.html" ]			ifNone: 				[ "do nothing"				 ].		startingFileNumber ifNotNil: [self deleteFrom: startingFileNumber ] ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 6/23/2007 15:57'!truncateWriters: filePosition 	| toBeRemoved |	guard critical: 		[ uncommittedSize := uncommittedSize min: filePosition.		toBeRemoved := OrderedCollection new.	"Not sure if I can remove from a BTree while enumerating it.."		writers 			from: filePosition			to: 999999999999999999999			do: 				[ : each | 				(each coversFilePosition: filePosition) ifTrue: [ toBeRemoved add: each ] ].		toBeRemoved do: [ : each | writers removeKey: each endFilePos ] ]! !!MaAtomicFileStream methodsFor: 'private' stamp: 'cmm 6/22/2009 21:38'!writerAt: filePosition 	writers 		from: filePosition		do: [ : each | ^ (each coversFilePosition: filePosition) ifTrue: [ each ] ].	^ nil! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 4/23/2007 00:39'!baseName	^ FileDirectory baseNameFor: self localName! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 4/11/2007 23:05'!committedSize	^ sizes 		inject: 0		into: [ : sum : each | sum + each ]! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 6/4/2007 08:53'!deletePhysicalFiles	self directory in: [ : dir | self physicalFilenamesDo: [ : each | dir deleteFileNamed: each ] ]! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 4/23/2007 00:39'!extension	^ FileDirectory extensionFor: self localName! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 12/24/2012 10:47'!guard: aBlock	^ guard critical: aBlock! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 4/23/2007 00:30'!localName	^ (FileDirectory on: (FileDirectory dirPathFor: filename)) localNameFor: filename! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 4/28/2007 18:23'!numberOfPhysicalFiles	^ sizes size! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 6/4/2007 08:41'!physicalFilenamesDo: oneArgBlock 	"Value oneArgBlock with the names of my physical files."	self directory in: 		[ : dir | 		dir entries do: 			[ : each | 			| eachParts |			eachParts := dir splitNameVersionExtensionFor: each name.			each name = (dir localNameFor: (self nameFor: eachParts second)) ifTrue: 				[ "version"				oneArgBlock value: each name ] ] ]! !!MaAtomicFileStream methodsFor: 'accessing' stamp: 'cmm 7/13/2005 15:02'!writersDo: aBlock	writers do: aBlock! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/26/2007 22:59'!close	self isPhysical ifTrue: 		[ self maCommit.		fileStreams copy withIndexDo: 			[ : each : x | 			pool close: each.			"We're going in order, so removeFirst works."			fileStreams removeFirst.			sizes removeFirst ] ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/28/2007 19:44'!closed	"Answer whether I have a file-handle allocated from the operating system."	^ self isPhysical not or: 		[ self isPhysical and: [ fileStreams allSatisfy: [ : each | each closed ] ] ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:22'!directory	^ FileDirectory forFileName: filename! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 5/24/2006 21:50'!filename	^ filename! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/11/2007 22:44'!flush	"API compatibility with StandardFileStream.  Write all of my writers and force an unconditional flush of each file."	self maCommit.	guard critical: [ self physicalFlush ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/28/2007 19:08'!maRead: someNumber bytesFromPosition: bufferPosition of: aByteArray atFilePosition: filePosition 	| writer numberOfBytesRead |	^ guard critical: 		[ (writer := self writerAt: filePosition) 			ifNil: 				[ numberOfBytesRead := self 					streamAt: filePosition					withRelativePositionDo: 						[ : physicalStream : relativePosition | 						self renewAccess: physicalStream.						physicalStream 							maRead: someNumber							bytesFromPosition: bufferPosition							of: aByteArray							atFilePosition: relativePosition ]					ifNone: [ 0 ].				position := filePosition + numberOfBytesRead.				numberOfBytesRead ]			ifNotNil: 				[ numberOfBytesRead := someNumber min: writer byteArray size.				aByteArray 					replaceFrom: bufferPosition					to: bufferPosition + numberOfBytesRead - 1					with: writer byteArray					startingAt: 1.				position := filePosition + numberOfBytesRead.				numberOfBytesRead ] ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/29/2007 21:48'!maWrite: numberOfBytes bytesFromPosition: bufferPosition of: byteArray atFilePosition: filePosition 	| writer |	writer := MaAtomicFileWriter 		file: self		filePos: filePosition		byteArray: (byteArray 				copyFrom: bufferPosition				to: bufferPosition + numberOfBytes - 1).	guard critical: 		[ writers 			at: writer endFilePos			put: writer.		uncommittedSize := uncommittedSize max: filePosition + numberOfBytes.		position := filePosition + numberOfBytes ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 2/13/2008 17:22'!next: n into: aByteArray startingAt: startIndex 	"This method is only called when the initial read of an object did not fit within the #trackSize."	| writer |	guard critical: 		[ (writer := self writerAt: position) 			ifNil: 				[ self 					streamAt: position					withRelativePositionDo: 						[ : physicalStream : relativePosition | 						self renewAccess: physicalStream.						physicalStream 							next: n							into: aByteArray							startingAt: startIndex ]					ifNone: [ MaSoftwareError signal: 'unexpected EOF - ' , position printString ] ]			ifNotNil: 				[ aByteArray 					replaceFrom: startIndex					to: startIndex + (n min: writer byteArray size) - 1					with: writer byteArray					startingAt: position - writer filePos + 1 ].		position := position + n ]! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 7/7/2005 22:17'!next: numberOfBytes putAll: aByteArray startingAt: startPos	"This isn't needed for Magma, and I don't feel like implementing it right now.  Better to just give an explicit error than get it wrong."	self error: 'not supported'! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 7/7/2005 12:51'!size	^ self committedSize max: uncommittedSize! !!MaAtomicFileStream methodsFor: 'filestream api' stamp: 'cmm 4/10/2007 21:27'!truncate: filePosition 	self		truncateStreams: filePosition ;		truncateWriters: filePosition! !!MaAtomicFileStream methodsFor: '*magma-server-file' stamp: 'cmm 6/23/2007 16:01'!currentRecordFor: aMaAtomicFileWriter 	| answer |	answer := ByteArray new: aMaAtomicFileWriter byteArray size.	guard critical: 		[ self 			streamAt: aMaAtomicFileWriter filePos			withRelativePositionDo: 				[ : physicalStream : relativePos | 				self renewAccess: physicalStream.				physicalStream 					maRead: answer size					bytesFromPosition: 1					of: answer					atFilePosition: relativePos ]			ifNone: 				[ MagmaSoftwareError signal: 'expected physical data at ' , aMaAtomicFileWriter filePos asString ] ].	^ answer! !!MaAtomicFileStream methodsFor: 'testing' stamp: 'cmm 9/28/2008 23:03'!exists	| fd |	fd := FileDirectory on: (FileDirectory dirPathFor: filename).	^ fd fileExists: self baseName , '.1.' , self extension! !!MaAtomicFileStream methodsFor: 'testing' stamp: 'cmm 7/11/2005 22:04'!isNew	^ self isPhysical not! !!MaAtomicFileStream methodsFor: 'testing' stamp: 'cmm 4/9/2007 23:59'!isPhysical	^ fileStreams notEmpty! !!MaAtomicFileStream methodsFor: 'testing' stamp: 'cmm 10/22/2006 15:01'!maIsTransactional	^ true! !!MaAtomicFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:28'!filename: aString	filename := aString! !!MaAtomicFileStream methodsFor: 'initialize-release' stamp: 'cmm 9/23/2008 14:26'!initialize	super initialize.	self initializeWriters.	position := 0.	guard := Mutex new.	"To make code simple, everyone gets a default pool, which is just a pool of one, me."	pool := MaFileStreamPool maxSize: 1.	fileStreams := OrderedCollection new.	sizes := OrderedCollection new! !!MaAtomicFileStream methodsFor: 'initialize-release' stamp: 'cmm 10/22/2014 14:01'!initializeStreamsAndSizes	"Determine which streams are available in the current directory and their sizes."	| fd baseName extension matchingEntries |	fd := FileDirectory on: (FileDirectory dirPathFor: filename).	baseName := self baseName.	extension := self extension.	"Gather up the entries for my filename and extension."	matchingEntries := fd entries select:		[ : eachEntry | | eachNameVersionAndExtension |		eachNameVersionAndExtension := fd splitNameVersionExtensionFor: eachEntry name.		eachNameVersionAndExtension first = baseName and: [ eachNameVersionAndExtension last = extension ] ].	"Then sort them by the file-number (second dot-delimited field)"	matchingEntries := matchingEntries asSortedCollection:		[ : a : b | | nameVersionAndExtensionA nameVersionAndExtensionB |		nameVersionAndExtensionA := fd splitNameVersionExtensionFor: a name.		nameVersionAndExtensionB := fd splitNameVersionExtensionFor: b name.		(nameVersionAndExtensionA at: 2) < (nameVersionAndExtensionB at: 2) ].	"Now load my fileStreams and sizes with these correctly-ordered entries."	matchingEntries do:		[ : eachEntry | | physicalStream |		physicalStream := StandardFileStream readOnlyFileNamed: (fd fullNameFor: eachEntry name).		(physicalStream isNil or: [ physicalStream closed ]) ifTrue: [ MagmaEnvironmentError signal: 'file did not open for read-only' ].		fileStreams add: physicalStream.		physicalStream			close ;			readWrite ;			binary.		sizes add: eachEntry fileSize ]! !!MaAtomicFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/13/2005 15:04'!initializeWriters	writers := BTree new.	uncommittedSize := 0! !!MaAtomicFileStream methodsFor: 'initialize-release' stamp: 'cmm 10/22/2006 15:00'!pool: aMaFileStreamPool	pool := aMaFileStreamPool! !!MaAtomicFileStream methodsFor: 'commit' stamp: 'cmm 4/9/2015 21:45'!maCommit	"writers, write!!  If shouldFlush is true, only flush if I actually wrote something (if an unconditional flush is needed, use #flush)."	guard critical:		[ | needsFlush |		needsFlush := false.		self writersDo:			[ : each | each write.			needsFlush := true ].		needsFlush ifTrue:			[ self initializeWriters.			self physicalFlush ] ]! !!MaAtomicFileStream methodsFor: 'printing' stamp: 'cmm 4/23/2007 17:37'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	aStream maPrint: filename! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAtomicFileStream class	instanceVariableNames: ''!!MaAtomicFileStream class methodsFor: 'create' stamp: 'cmm 4/23/2007 00:24'!fileNamed: filenameString 	^ self new		filename: filenameString ;		initializeStreamsAndSizes ;		yourself! !!MaAtomicFileStream class methodsFor: 'class initialization' stamp: 'cmm 5/23/2007 23:18'!initialize	super initialize.	self maxPhysicalFileSize: 1800000000 "1.8 gigabytes"! !!MaAtomicFileStream class methodsFor: 'class initialization' stamp: 'cmm 5/23/2007 23:18'!maxPhysicalFileSize: anInteger	"Do not change this unless you know what you are doing."	MaxPhysicalFileSize := anInteger! !MaObject subclass: #MaAtomicFileWriter	instanceVariableNames: 'file filePos byteArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-File'!!MaAtomicFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 10:27'!byteArray	^ byteArray! !!MaAtomicFileWriter methodsFor: 'accessing' stamp: 'cmm 8/13/2007 22:39'!currentRecord	^ file currentRecordFor: self! !!MaAtomicFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 22:18'!endFilePos	^ filePos + byteArray size - 1! !!MaAtomicFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 17:27'!filePos	^ filePos! !!MaAtomicFileWriter methodsFor: 'testing' stamp: 'cmm 6/15/2005 17:11'!coversFilePosition: filePosition	^ filePosition		between: filePos		and: filePos + byteArray size - 1! !!MaAtomicFileWriter methodsFor: 'testing' stamp: 'cmm 7/12/2005 22:20'!willCauseGrowth	^ filePos >= file committedSize! !!MaAtomicFileWriter methodsFor: 'initialize-release' stamp: 'cmm 10/21/2006 20:06'!setFile: aMaTransactionalFileStream filePos: anInteger byteArray: aByteArray	file := aMaTransactionalFileStream.	filePos := anInteger.	byteArray := aByteArray! !!MaAtomicFileWriter methodsFor: 'actions' stamp: 'cmm 4/20/2007 15:28'!write	file 		physicallyWrite: byteArray size		bytesFromPosition: 1		of: byteArray		atFilePosition: filePos! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAtomicFileWriter class	instanceVariableNames: ''!!MaAtomicFileWriter class methodsFor: 'as yet unclassified' stamp: 'cmm 10/21/2006 20:05'!file: aMaTransactionalFileStream filePos: anInteger byteArray: aByteArray	^ self new		setFile: aMaTransactionalFileStream		filePos: anInteger		byteArray: aByteArray! !MaObject subclass: #MaFileStreamPool	instanceVariableNames: 'guard openStreams maxSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-File'!!MaFileStreamPool methodsFor: 'api' stamp: 'cmm 4/20/2007 15:01'!close: aStandardFileStream 	| stream |	guard critical: 		[ stream := openStreams 			remove: aStandardFileStream			ifAbsent: [ nil ].		stream ifNotNil: [ stream close ] ]! !!MaFileStreamPool methodsFor: 'api' stamp: 'cmm 10/22/2006 15:18'!maxSize	^maxSize! !!MaFileStreamPool methodsFor: 'api' stamp: 'cmm 10/22/2006 15:19'!maxSize: anInteger	maxSize := anInteger! !!MaFileStreamPool methodsFor: 'api' stamp: 'cmm 4/8/2015 15:03'!renewAccess: aStandardFileStream 	"Add or move aStandardFileStream to the bottom (most recently accessed), ensuring I do not exceed my limit of simultaneously-allowed open FileStreams."	guard critical: 		[ "Performance enhancement:  since many consecutive writes to the same fileStream is common, check if already renewed."		| existing |		(openStreams notEmpty and: [ openStreams last == aStandardFileStream ]) ifFalse: 			[ existing := openStreams 				remove: aStandardFileStream				ifAbsent: [ nil ].			"If already existing, no need to pop anything off, otherwise make sure we don't exceed.."			existing ifNil: 				[ [ openStreams size >= maxSize ] whileTrue: [ self close: openStreams first ].				aStandardFileStream ensureOpen.				aStandardFileStream closed ifTrue: 					[ MagmaEnvironmentError signal: 'Could not open ' , aStandardFileStream name , '.  File in use?' ] ].			openStreams addLast: aStandardFileStream ] ]! !!MaFileStreamPool methodsFor: 'initialize' stamp: 'cmm 9/23/2008 14:25'!initialize	super initialize.	openStreams := OrderedCollection new.	guard := Mutex new! !!MaFileStreamPool methodsFor: 'initialize' stamp: 'cmm 10/22/2006 15:18'!setMaxPoolSize: anInteger 	maxSize := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaFileStreamPool class	instanceVariableNames: ''!!MaFileStreamPool class methodsFor: 'create' stamp: 'cmm 10/21/2006 17:42'!maxSize: anInteger 	^ (self new)		setMaxPoolSize: anInteger ;		yourself! !MaAtomicFileStream initialize!