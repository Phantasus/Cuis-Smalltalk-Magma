Collection subclass: #BTree	instanceVariableNames: 'root'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTree methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:51'!at: aMagnitude	^ self at: aMagnitude ifAbsent: [self error: aMagnitude printString, ' not found']! !!BTree methodsFor: 'accessing' stamp: 'lr 4/15/2009 09:50'!at: aMagnitude ifAbsent: errorBlock       | leaf |       leaf := root existingLeafForKey: aMagnitude.       leaf ifNil: [^ errorBlock value].       ^ leaf valueForKey: aMagnitude ifAbsent: errorBlock! !!BTree methodsFor: 'accessing' stamp: 'RamonLeon 5/5/2011 23:16'!at: aMagnitude ifPresent: aBlock	| leaf |	leaf := root existingLeafForKey: aMagnitude.	leaf ifNil: [ ^ nil ].	^ leaf valueForKey: aMagnitude ifPresent: aBlock! !!BTree methodsFor: 'accessing' stamp: 'avi 4/21/2005 02:28'!depth	^ root depth! !!BTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 12:56'!first	^ root first! !!BTree methodsFor: 'accessing' stamp: 'avi 4/20/2005 14:29'!keys	^ Array streamContents:		[:s |		self keysDo: [:k | s nextPut: k]]! !!BTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 12:56'!last	^ root last! !!BTree methodsFor: 'accessing' stamp: 'avi 2/25/2004 23:32'!order	^ root size! !!BTree methodsFor: 'accessing' stamp: 'pmm 10/12/2005 10:57'!values	^ Array streamContents:		[:s |		self valuesDo: [:k | s nextPut: k]]! !!BTree methodsFor: 'adding' stamp: 'avi 9/6/2005 17:10'!at: aMagnitude ifAbsentPut: aBlock	^ self at: aMagnitude ifAbsent: [self at: aMagnitude put: aBlock value]! !!BTree methodsFor: 'adding' stamp: 'lr 4/15/2009 09:50'!at: aMagnitude put: anObject	| leaf |	leaf := root leafForKey: aMagnitude.	leaf insertKey: aMagnitude value: anObject.	root := leaf root.	^ anObject! !!BTree methodsFor: 'adding' stamp: 'ac 11/15/2005 13:08'!removeKey: aMagnitude	^ self removeKey: aMagnitude ifAbsent: [self error: aMagnitude printString, ' not found.']! !!BTree methodsFor: 'adding' stamp: 'lr 4/15/2009 09:50'!removeKey: aMagnitude ifAbsent: aBlock	| leaf |	leaf := root existingLeafForKey: aMagnitude.	leaf ifNil: [^ aBlock value].	leaf removeKey: aMagnitude ifAbsent: [^ aBlock value].	root := leaf root! !!BTree methodsFor: 'enumerating' stamp: 'avi 4/21/2005 02:41'!commonKeysWith: aTree keysAndValuesDo: aBlock	^ aTree depth < self depth		ifTrue: [aTree root commonKeysWith: root keysAndValuesDo: aBlock flip: true]		ifFalse: [root commonKeysWith: aTree root keysAndValuesDo: aBlock flip: false]! !!BTree methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:49'!do: aBlock	root allLeavesDo: [:ea | ea valuesDo: aBlock]! !!BTree methodsFor: 'enumerating' stamp: 'avi 1/2/2006 16:03'!from: start do: aBlock	self from: start to: nil keysAndValuesDo: [:k :v | aBlock value: v]! !!BTree methodsFor: 'enumerating' stamp: 'avi 1/2/2006 16:14'!from: start keysAndValuesDo: aBlock	self from: start to: nil keysAndValuesDo: aBlock! !!BTree methodsFor: 'enumerating' stamp: 'avi 10/8/2004 18:04'!from: start to: end do: aBlock	self from: start to: end keysAndValuesDo: [:k :v | aBlock value: v]! !!BTree methodsFor: 'enumerating' stamp: 'avi 1/2/2006 16:02'!from: start to: end keysAndValuesDo: aBlock	root leavesFrom: start to: end do:		[:ea |		ea keysAndValuesDo:			[:k :v |			((start isNil or: [k >= start]) and:				[end isNil or: [k <= end]]) ifTrue:					[aBlock value: k value: v]]]! !!BTree methodsFor: 'enumerating' stamp: 'avi 2/24/2004 22:49'!keysAndValuesDo: aBlock	root allLeavesDo: [:ea | ea keysAndValuesDo: aBlock]! !!BTree methodsFor: 'enumerating' stamp: 'avi 4/20/2005 14:29'!keysDo: aBlock	root allLeavesDo: [:ea | ea keysDo: aBlock]! !!BTree methodsFor: 'enumerating' stamp: 'avi 1/2/2006 16:03'!upTo: end do: aBlock	self from: nil to: end keysAndValuesDo: [:k :v | aBlock value: v]! !!BTree methodsFor: 'enumerating' stamp: 'avi 1/2/2006 16:03'!upTo: end keysAndValuesDo: aBlock	self from: nil to: end keysAndValuesDo: aBlock! !!BTree methodsFor: 'enumerating' stamp: 'pmm 10/12/2005 10:57'!valuesDo: aBlock	root allLeavesDo: [:ea | ea valuesDo: aBlock]! !!BTree methodsFor: 'copying' stamp: 'avi 5/1/2005 14:51'!emptyCopy	^ BTree keys: root keyArray emptyCopy! !!BTree methodsFor: 'initialize-release' stamp: 'lr 4/15/2009 09:50'!initializeWithKeys: aBTreeKeys	aBTreeKeys size > 3 ifFalse: [self error: 'The BTree order must be at least 4'].	root := BTreeLeafNode keys: aBTreeKeys! !!BTree methodsFor: 'private' stamp: 'avi 2/23/2004 21:21'!root	^ root! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BTree class	instanceVariableNames: ''!!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 15:03'!keys: aBTreeKeys	^ self basicNew initializeWithKeys: aBTreeKeys! !!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 12:38'!new	^ self order: 5! !!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:01'!order: aNumber	^ self keys: (BTreeKeysArray new: aNumber)! !Object subclass: #BTreeKeys	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 20:40'!canGrow	^ (self at: self size) isNil! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:00'!canShrink	^  (self at: self size // 2 + 1) notNil! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 23:39'!emptyCopy	^ self class new: self size! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:39'!findIndexForKey: aMagnitude	self withIndexDo:		[:key :i |		(key isNil or: [key > aMagnitude]) ifTrue:			[^ i - 1]].	^ self size! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:02'!first	^ self at: 1! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 1/2/2006 16:00'!lastIndex	self withIndexDo:		[:key :i |		key isNil ifTrue:			[^ i - 1]].	^ self size! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 17:40'!shiftLeftTo: index	index to: self size - 1 by: 1 do:		[:i |		self at: i put: (self at: i+1)].	self at: self size put: nil.! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 23:37'!shiftRightFrom: index	self size to: index+1 by: -1 do:		[:i |		self at: i put: (self at: i - 1)]	! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:02'!withIndexDo: aBlock	1 to: self size do: [:i | aBlock value: (self at: i) value: i]! !BTreeKeys variableSubclass: #BTreeKeysArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!Object variableSubclass: #BTreeNode	instanceVariableNames: 'parent keys'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:24'!allChildrenDo: aBlock	self childrenDo:		[:ea |		aBlock value: ea.		ea allChildrenDo: aBlock]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:34'!allLeavesDo: aBlock	self withAllChildrenDo: [:ea | ea isLeaf ifTrue: [aBlock value: ea]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:44'!childrenDo: aBlock	self subclassResponsibility! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/25/2004 23:31'!keysAndValuesDo: aBlock	keys withIndexDo:		[:key :i |		key ifNotNil: [aBlock value: key value: (self at: i)]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 4/20/2005 16:33'!keysDo: aBlock	keys withIndexDo:		[:key :i |		key ifNotNil: [aBlock value: key] ifNil: [^ self]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 10/8/2004 17:57'!leavesFrom: start to: end do: aBlock	self subclassResponsibility! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:59'!valuesDo: aBlock	self keysAndValuesDo: [:k :v | aBlock value: v]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:27'!withAllChildrenDo: aBlock	aBlock value: self.	self allChildrenDo: aBlock.! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/27/2004 20:41'!canGrow	^ keys canGrow! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/26/2004 17:59'!canShrink	^ keys canShrink! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/24/2004 00:22'!isLeaf	self subclassResponsibility! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:23'!children	^ Array streamContents: [:s | self childrenDo: [:ea | s nextPut: ea]]! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:27'!depth	^ parent ifNil: [1] ifNotNil: [1 + parent depth]! !!BTreeNode methodsFor: 'accessing' stamp: 'lr 10/8/2009 12:56'!first	self subclassResponsibility! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/26/2004 00:35'!firstKey	^ keys first! !!BTreeNode methodsFor: 'accessing' stamp: 'lr 10/8/2009 12:56'!last	self subclassResponsibility! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/24/2004 00:24'!parent	^ parent! !!BTreeNode methodsFor: 'accessing' stamp: 'lr 4/15/2009 09:50'!parent: aBTreeNode	parent := aBTreeNode! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 22:17'!root	^ parent		ifNil: [self]		ifNotNil: [parent root]! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:47'!values	^ Array streamContents: [:s | self valuesDo: [:ea | s nextPut: ea]]! !!BTreeNode methodsFor: 'private' stamp: 'avi 4/29/2005 12:57'!ensureParent	parent ifNil:		 [self parent: (self interiorNodeClass keys: keys emptyCopy).		parent insertKey: self firstKey value: self].	^ parent! !!BTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!grow	| sibling |	parent ifNotNil:		[sibling := parent nextSiblingForChild: self.		sibling ifNil: [self parent: nil. ^ self].		sibling canShrink			ifTrue: [self stealFrom: sibling]			ifFalse: [self mergeWith: sibling]]				! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 23:29'!insertKey: aMagnitude value: anObject at: index	keys at: index put: aMagnitude.	self at: index put: anObject! !!BTreeNode methodsFor: 'private' stamp: 'avi 4/29/2005 12:51'!interiorNodeClass	^ BTreeInteriorNode! !!BTreeNode methodsFor: 'private' stamp: 'avi 5/1/2005 13:56'!keyArray	^ keys! !!BTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!keys: anArray	keys := anArray! !!BTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!mergeWith: aNode			| oldKey |	oldKey := self firstKey.	aNode keysAndValuesDo:		[:k :v |		self insertKey: k value: v].	parent removeKey: aNode firstKey.	parent updateKey: oldKey to: self firstKey.! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/26/2004 17:39'!shiftLeftTo: index	keys shiftLeftTo: index.	index to: self size - 1 by: 1 do:		[:i |		self at: i put: (self at: i+1)].	self at: self size put: nil.! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 23:37'!shiftRightFrom: index	keys shiftRightFrom: index.	self size to: index+1 by: -1 do:		[:i |		self at: i put: (self at: i-1)]! !!BTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!split	| other midpoint |	other := self class keys: keys emptyCopy.	midpoint := self size // 2 + 1.	midpoint to: self size do:		[:i |		other insertKey: (keys at: i) value: (self at: i) at: (i - midpoint + 1).		keys at: i put: nil.		self at: i put: nil].		self ensureParent insertKey: other firstKey value: other! !!BTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!stealFrom: aNode	| key value |	aNode firstKey > self firstKey		ifTrue: [value := aNode at: 1. key := aNode firstKey]		ifFalse:			[aNode keysAndValuesDo: [:k :v | key := k. value := v].			parent ifNotNil: [parent updateKey: self firstKey to: key]].	self insertKey: key value: value.	aNode removeKey: key! !!BTreeNode methodsFor: 'inserting' stamp: 'lr 4/15/2009 09:50'!insertKey: aMagnitude value: anObject	| index key |	index := keys findIndexForKey: aMagnitude.	index = 0 ifTrue:		[self canGrow			ifTrue:				[self shiftRightFrom: 1.				^ self insertKey: aMagnitude value: anObject at: 1]			ifFalse:				[self split.				^ (parent childForKey: aMagnitude) insertKey: aMagnitude value: anObject]].		key := keys at: index.	key = aMagnitude ifTrue:		[^ self insertKey: aMagnitude value: anObject at: index].	index < self size ifTrue:		[key := keys at: index + 1.		key			ifNil: [^ self insertKey: aMagnitude value: anObject at: index+1]			ifNotNil:				[self canGrow ifTrue:					[self shiftRightFrom: index+1.					^ self insertKey: aMagnitude value: anObject at: index+1]]].	"otherwise"	self split.	^ (parent childForKey: aMagnitude) insertKey: aMagnitude value: anObject! !!BTreeNode methodsFor: 'removing' stamp: 'ac 11/15/2005 16:42'!removeKey: aMagnitude	self removeKey: aMagnitude ifAbsent: [self error: aMagnitude printString, ' not found.'].! !!BTreeNode methodsFor: 'removing' stamp: 'lr 4/15/2009 09:50'!removeKey: aMagnitude ifAbsent: aBlock	| index key |	self canShrink ifFalse: [self grow].		index := keys findIndexForKey: aMagnitude.	index = 0 ifTrue: [^ aBlock value].	key := keys at: index.	key = aMagnitude ifFalse: [^ aBlock value].		self shiftLeftTo: index.		index = 1 ifTrue: [parent ifNotNil: [parent updateKey: key to: self firstKey]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BTreeNode class	instanceVariableNames: ''!!BTreeNode class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 12:28'!keys: anArray	^ (self new: (anArray size)) keys: anArray! !BTreeNode variableSubclass: #BTreeInteriorNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!childForKey: aMagnitude	| index |	index := keys findIndexForKey: aMagnitude.	index = 0 ifTrue:		[keys at: 1 put: aMagnitude.		^ self at: 1].	^ self at: index		! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:47'!childrenDo: aBlock	self valuesDo: aBlock! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean	| index |	aNode firstKey < self firstKey ifTrue: [^ aNode commonKeysWith: self keysAndValuesDo: aBlock flip: aBoolean not].	index := (keys findIndexForKey: aNode firstKey) max: 1.	index to: self size do:		[:i |		(self at: i) ifNotNilDo: [:c | c commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean]]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 4/21/2005 02:28'!depth	^ 1 + self firstChild depth! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!existingChildForKey: aMagnitude       "Unlike #childForKey:, this method looks for a child, but doesn't mess with the tree if it doesn't exist."       | index |       index := keys findIndexForKey: aMagnitude.       index = 0               ifTrue: [^ nil]               ifFalse: [^ self at: index].! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!existingLeafForKey: aMagnitude       "Unlike #leafForKey:, this method looks for a leaf but doesn't mess with the tree if it doesn't exist."       | child |       child := self existingChildForKey: aMagnitude.       ^ child ifNotNil: [child existingLeafForKey: aMagnitude]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 12:55'!first	self childrenDo: [ :node | ^ node first ].	self error: 'this tree is empty'! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 00:39'!firstChild	self childrenDo: [:ea | ^ ea].	self error: 'No children'.! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 12:05'!insertKey: aMagnitude value: anObject at: index	super insertKey: aMagnitude value: anObject at: index.	anObject parent: self! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 00:22'!isLeaf	^ false! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 12:56'!last	| child |	child := nil.	self childrenDo: [ :node | child := node ].	child isNil ifTrue: [ self error: 'this tree is empty' ].	^ child last! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 01:59'!leafForKey: aMagnitude	^ (self childForKey: aMagnitude) leafForKey: aMagnitude! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!leavesFrom: start to: end do: aBlock	| startIndex endIndex |	startIndex := start ifNil: [1] ifNotNil: [(keys findIndexForKey: start) max: 1].	endIndex := end ifNil: [keys lastIndex] ifNotNil: [keys findIndexForKey: end].	startIndex to: endIndex do: [:i | (self at: i) leavesFrom: start to: end do: aBlock]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!nextSiblingForChild: aNode	| index |	index := keys findIndexForKey: aNode firstKey.	^ (index = self size or: [(keys at: index+1) isNil]) 		ifTrue: [index = 1 ifFalse: [self at: index - 1] ifTrue: [nil]]		ifFalse: [self at: index + 1]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 1/11/2005 13:13'!updateKey: oldMagnitude to: newMagnitude       keys withIndexDo:               [:key :i |               key = oldMagnitude ifTrue:                       [(i = 1 and: [parent notNil]) ifTrue:                               [parent updateKey: oldMagnitude to: newMagnitude].                       ^ keys at: i put: newMagnitude]].       self error: 'No such key'! !BTreeNode variableSubclass: #BTreeLeafNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:45'!childrenDo: aBlock	"no children"! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean	| index key block leaf advanceKey last |	aNode firstKey ifNil: [^ self].	block := aBoolean ifTrue: [[:k :v1 :v2 | aBlock value: k value: v2 value: v1]] ifFalse: [aBlock].	index := 0.	advanceKey :=		[index := index + 1.		index > self size ifTrue: [^ self].		key := keys at: index.		key ifNil: [^ self]].	last := self lastKey.		advanceKey value.	[key < aNode firstKey] whileTrue: advanceKey.			[leaf := aNode existingLeafForKey: key.	leaf lastKey < key ifTrue: advanceKey ifFalse:		[leaf keysAndValuesDo:			[:otherKey :otherValue |			otherKey > last ifTrue: [^ self].			[key < otherKey] whileTrue: advanceKey.			key = otherKey ifTrue: [block value: key value: (self at: index) value: otherValue]].		key > leaf lastKey ifFalse: advanceKey]] repeat! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/21/2005 02:28'!depth	^ 1! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'jcg 1/17/2005 23:08'!existingLeafForKey: aMagnitude       ^ self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 12:55'!first	^ self values first! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:22'!isLeaf	^ true! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 16:41'!keys	^ Array streamContents: [:s | self keysDo: [:ea | s nextPut: ea]]! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 12:55'!last	^ self values last! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!lastKey	| last |	last := nil.	self keysDo: [:k | last := k].	^ last! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:41'!leafForKey: aMagnitude	^ self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 10/8/2004 18:00'!leavesFrom: start to: end do: aBlock	aBlock value: self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!valueForKey: aMagnitude ifAbsent: errorBlock	| i |	i := keys findIndexForKey: aMagnitude.	^ (i > 0 and: [(keys at: i) = aMagnitude])		ifTrue: [self at: i]		ifFalse: [errorBlock value]! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 15:03'!valueForKey: aMagnitude ifPresent: aBlock	^ aBlock value: (self valueForKey: aMagnitude ifAbsent: [^ nil])! !BTreeKeys subclass: #BTreeStringKeys	instanceVariableNames: 'keys prefix abbreviations'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:00'!abbreviationSize	^ 3! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!abbreviationsAndIndicesDo: aBlock	| stream |	stream := abbreviations readStream.	1 to: self size do:		[:i |		stream atEnd			ifFalse: [aBlock value: prefix, (stream next: self abbreviationSize) value: i]			ifTrue: [aBlock value: nil value: i]]! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 15:41'!at: aNumber	^ keys at: aNumber! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!at: aNumber put: aString	keys at: aNumber put: aString.	prefix := self nilPrefix.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!buildAbbreviationsFrom: readStreams	| nextChars |	1 to: self abbreviationSize do:		[:i |		nextChars := readStreams collect: [:ea | ea next ifNil: [Character value: 0]].		nextChars withIndexDo:			[:c :j |			abbreviations at: (j-1 * self abbreviationSize) + i put: c]].	^ abbreviations! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!extractPrefixFrom: readStreams	| prefixStream nextChars |	prefixStream := String new writeStream.		[readStreams anySatisfy: [:ea | ea atEnd]] whileFalse:		[nextChars := readStreams collect: [:ea | ea next].		(nextChars allSatisfy: [:ea | ea = nextChars first])				ifTrue: [prefixStream nextPut: nextChars first]				ifFalse: [readStreams do: [:ea | ea skip: -1]. ^ prefixStream contents]].	^ prefixStream contents! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!findIndexForKey: aString	| stream str diff |	prefix = self nilPrefix ifTrue: [self rebuildAbbreviations].	stream := aString readStream.	str := stream next: prefix size + self abbreviationSize.	diff := prefix size + self abbreviationSize - str size.	str := str, (String new: diff).	self abbreviationsAndIndicesDo:		[:abbr :i |		abbr ifNil: [^ i - 1].		str < abbr ifTrue: [^ i - 1].		str = abbr ifTrue: [^ super findIndexForKey: aString]].	^ self size! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!initializeWithSize: aNumber	keys := Array new: aNumber.	prefix := self nilPrefix.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:51'!nilPrefix	^ '^^^'! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!rebuildAbbreviations	| keyStreams filled |	filled := keys count: [:ea | ea notNil].	abbreviations := String new: (filled * self abbreviationSize).	filled = 0 ifTrue: [prefix := ''. ^ self ].	keyStreams := (1 to: filled) collect: [:i | (keys at: i) readStream].		prefix := self extractPrefixFrom: keyStreams.	abbreviations := self buildAbbreviationsFrom: keyStreams.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 16:47'!size	^ keys size! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BTreeStringKeys class	instanceVariableNames: ''!!BTreeStringKeys class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 14:31'!new	^ self new: 8! !!BTreeStringKeys class methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:04'!new: aNumber	^ self basicNew initializeWithSize: aNumber! !TestCase subclass: #BTreeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!assertConsistent: aBTree	| depths root |	root := aBTree root.	 " http://www.cs.umbc.edu/~woodcock/cmsc341/btree/defn.htmlA B-Tree of order m is a search tree, where the data   (or pointers to it) is stored at the leaves, such that:1) the root is either a leaf (as well--i.e. the tree is      a single node) or has between 2 and m children"		self assert: (root isLeaf or: [root values size between: 2 and: aBTree order]).	"  2) all other (non-root) nodes have at least m/2 children,     but no more than m children"	root allChildrenDo: [:ea | self assert: (ea values size between: (aBTree order // 2) and: aBTree order)]. "  3) all leaves are at the same depth"	depths := Set new.	root withAllChildrenDo: [:ea | ea isLeaf ifTrue: [depths add: ea depth]].	self assert: depths size = 1.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!assertSorted: aTree	| last |	last := nil.	aTree keysAndValuesDo:		[:k :v |		last ifNotNil: [self assert: last < k].		last := k]! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:58'!checkTree: tree array: pairArray	pairArray withIndexDo:		[:pair :i |		tree at: pair first put: pair second.		self assert: tree size = i.		"self assertConsistent: tree.		self assertSorted: tree"].	pairArray shuffled do:		[:pair |		self assert: (tree at: pair first) = pair second].	self assert: tree size = pairArray size.	self assertConsistent: tree.	self assertSorted: tree.	^ tree		 ! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!checkTree: tree items: count	| pairArray  |	pairArray := ((1 to: count) collect: [:i | Array with: i asString with: i]) shuffled.	self checkTree: tree array: pairArray! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:59'!checkTreeWithOrder: order items: count	self checkTree: (BTree order: order) items: count! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:08'!testAddAndRetrieveWithSplit	self checkTreeWithOrder: 4 items: 5! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:08'!testAddAndRetrieveWithTwoSplits	self checkTreeWithOrder: 4 items: 17! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testCommonKeysDifferentValues	| large small expectedResults results |	large := BTree new.	1 to: 1000 by: 2 do: [:i | large at: i put: i].	small := BTree new.	2 to: 2000 by: 11 do: [:i | small at: i put: i*2].		expectedResults := ((-9 to: 1000 by: 22) allButFirst collect: [:i | Array with: i with: i with: i*2]) asOrderedCollection.		results := OrderedCollection new.	large commonKeysWith: small keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v1 with: v2)].	self assert: results = expectedResults.		results := OrderedCollection new.	small commonKeysWith: large keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v2 with: v1)].	self assert: results = expectedResults! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testCommonKeysSameValues	| large small expectedResults results |	large := BTree new.	1 to: 1000 by: 2 do: [:i | large at: i put: i].	small := BTree new.	2 to: 2000 by: 11 do: [:i | small at: i put: i].		expectedResults := ((-9 to: 1000 by: 22) allButFirst collect: [:i | Array with: i with: i with: i]) asOrderedCollection.		results := OrderedCollection new.	large commonKeysWith: small keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v1 with: v2)].	self assert: results = expectedResults.		results := OrderedCollection new.	small commonKeysWith: large keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v2 with: v1)].	self assert: results = expectedResults! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testEmptyTree	self checkTreeWithOrder: 5 items: 0! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 13:02'!testFirstLast	| tree |	tree := BTree new.	self should: [ tree first ] raise: Error.	self should: [ tree last ] raise: Error.	tree at: SmallInteger minVal put: SmallInteger minVal.	tree at: SmallInteger maxVal put: SmallInteger maxVal.	10000 timesRepeat: [ 		tree at: 536870911 atRandom put: nil.		self assert: tree first = SmallInteger minVal.		self assert: tree last = SmallInteger maxVal ]! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'RamonLeon 5/5/2011 23:26'!testFound	| tree found |	found := false.	tree := BTree new.	tree at: 1 put: 'foo'.	tree		at: 1		ifPresent: [ :val | 			self assert: 'foo' equals: val.			found := true ].	self assert: found! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 12:47'!testLargeTree	self checkTreeWithOrder: 8 items: 5000	! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testMissing	| tree |	tree := BTree new.	tree at: 1 put: 'foo'.	tree at: 2 put: 'bar'.	self assert: (tree at: 1 ifAbsent: [42]) = 'foo'.	self assert: (tree at: 2 ifAbsent: [42]) = 'bar'.	self assert: (tree at: 3 ifAbsent: [42]) = 42.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testMultipleAddAndRetrieve	self checkTreeWithOrder: 5 items: 3! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testRange	| tree keys |	tree := BTree new.	1 to: 100 by: 2 do: [:ea | tree at: ea put: ea * 2].	self assert: tree size = 50.	keys := OrderedCollection new.	tree from: 12 to: 19 keysAndValuesDo:		[:k :v |		self assert: k * 2 = v.		keys add: k].	self assert: keys asArray = #(13 15 17 19).	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testRemoval	| tree |	tree := BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	tree removeKey: #d.	self assert: tree size = 11.	self assert: (tree at: #d ifAbsent: [32]) = 32.	tree removeKey: #k.	self assert: tree size = 10.	self assert: (tree at: #k ifAbsent: [32]) = 32.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 1/11/2005 13:12'!testRemoval2	| tree |	tree := BTree new.	1 to: 15 do: [:i | tree at: i put: i].	1 to: 15 do: [:i | tree removeKey: i].	self assert: tree isEmpty! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testRemoveAll	| tree |	tree := BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(a b c d e f g h i j k l)  shuffled do: [:ea | tree removeKey: ea].	self assert: tree size = 0.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testRemoveAllFailing	| tree |	tree := BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(#c #j #g #i #k #l #f #e #d #h #a #b) do: [:ea | tree removeKey: ea].	self assert: tree size = 0.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testRemoveLots	| tree |	tree := BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(a c e g i k) shuffled do: [:ea | tree removeKey: ea].	self assert: tree size = 6.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testSimpleAddAndRetrieve	self checkTreeWithOrder: 5 items: 1! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 22:01'!testStoreNil	self checkTree: BTree new array: {{'x'. 1}. {'y'. nil}}! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:59'!testStringKeys	self checkTree: (BTree keys: BTreeStringKeys new) items: 100! !Collection subclass: #DateTree	instanceVariableNames: 'startTimes endTimes events'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!DateTree commentStamp: '<historical>' prior: 0!I provide a way to efficiently store and access date intervals. I am capable of answering the question, "What events lie within a given date range." !!DateTree methodsFor: 'accessing' stamp: 'bmp 9/13/2005 22:25'!at: aTimepan	^ self at: aTimepan ifAbsent: [ self error: aTimepan printString, ' not found' ]! !!DateTree methodsFor: 'accessing' stamp: 'bmp 9/13/2005 22:25'!at: aTimespan ifAbsent: aBlock	^ events at: aTimespan ifAbsent: aBlock! !!DateTree methodsFor: 'accessing' stamp: 'bmp 9/14/2005 02:48'!at: aTimespan ifAbsentPut: exceptionBlock	^ self at: aTimespan ifAbsent: [ self at: aTimespan put: exceptionBlock value ].! !!DateTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 17:18'!endTimes	^ endTimes! !!DateTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 14:37'!first	| timespans |	timespans := startTimes first 		asSortedCollection: [ :a :b | a start <= b start ].	^ events 		at: timespans first		ifAbsent: [ self errorEmptyCollection ]! !!DateTree methodsFor: 'accessing' stamp: 'lr 4/15/2009 09:50'!keys	| keys |	keys := Set new.	self keysAndValuesDo: [:k :v | keys add: k].	^ keys! !!DateTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 14:28'!last	| timespans |	timespans := endTimes last 		asSortedCollection: [ :a :b | a end <= b end ].	^ events 		at: timespans last		ifAbsent: [ self errorEmptyCollection ]! !!DateTree methodsFor: 'accessing' stamp: 'lr 10/8/2009 17:18'!startTimes	^ startTimes! !!DateTree methodsFor: 'adding' stamp: 'bmp 9/14/2005 02:49'!at: aTimespan put: anObject	| timespans |	timespans := startTimes at: aTimespan start ifAbsentPut: [ Set new ].	timespans add: aTimespan.	timespans := endTimes at: aTimespan end ifAbsentPut: [ Set new ].	timespans add: aTimespan.	events at: aTimespan put: anObject.	^ anObject! !!DateTree methodsFor: 'adding' stamp: 'bmp 9/14/2005 03:08'!removeKey: aTimespan	self removeKey: aTimespan ifAbsent: [ self error: aTimespan printString, ' not found' ].! !!DateTree methodsFor: 'adding' stamp: 'ac 11/17/2005 15:14'!removeKey: aTimespan ifAbsent: exceptionBlock	| set |	events removeKey: aTimespan ifAbsent: [^ exceptionBlock].		"If we got here, we should be able to remove the start and end caches too."	set := (startTimes at: aTimespan start) remove: aTimespan; yourself.	set isEmpty ifTrue: [ startTimes removeKey: aTimespan start ].	set := (endTimes at: aTimespan end) remove: aTimespan; yourself.	set isEmpty ifTrue: [ endTimes removeKey: aTimespan end ].! !!DateTree methodsFor: 'enumerating' stamp: 'lr 4/15/2009 09:50'!between: startDateAndTime and: endDateAndTime	"I return all events between a given start date and end date."		| values |	values := TreeSet new.	self between: startDateAndTime and: endDateAndTime keysAndValuesDo: [ :key :val | values add: val ].	^ values! !!DateTree methodsFor: 'enumerating' stamp: 'bmp 9/15/2005 17:35'!between: startDateAndTime and: endDateAndTime keysAndValuesDo: aBlock	| startOrLater endOrEarlier |	"This adds stuff really slowly; I'm not sure what to do about that yet"	startOrLater := TreeSet new.	endOrEarlier := TreeSet new.	startTimes from: DateAndTime epoch to: endDateAndTime do: [ :ea | endOrEarlier addAll: ea ].	"Kluge to make the ranges work."	endTimes from: startDateAndTime to: (DateAndTime year: 2029 day: 1) do: [ :ea | startOrLater addAll: ea ].	(startOrLater intersection: endOrEarlier) do: [ :ea | aBlock value: ea value: (self at: ea) ].! !!DateTree methodsFor: 'enumerating' stamp: 'bmp 9/13/2005 21:40'!do: aBlock	events do: aBlock.! !!DateTree methodsFor: 'enumerating' stamp: 'bmp 9/13/2005 22:46'!during: aTimespan	"Return all events occuring within a given timespan"		^ self between: aTimespan start and: aTimespan end! !!DateTree methodsFor: 'enumerating' stamp: 'bmp 9/14/2005 02:50'!keysAndValuesDo: aBlock	events keysAndValuesDo: aBlock.! !!DateTree methodsFor: 'enumerating' stamp: 'bmp 9/13/2005 22:45'!within: aDuration of: aDateAndTime	"Returns all events within the given duration from the given date, in either direction."		^ self between: (aDateAndTime - aDuration) and: (aDateAndTime + aDuration)! !!DateTree methodsFor: 'initialize-release' stamp: 'avi 10/15/2005 19:56'!initialize	startTimes := BTree new.	endTimes := BTree new.	events := Dictionary new! !TestCase subclass: #DateTreeTest	instanceVariableNames: 'now sixHours tomorrow nextWeek twoWeeks threeWeeks timespans'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!setUp	now := DateAndTime now.	sixHours := now + 6 hours.	tomorrow := now + 1 day.	nextWeek := now + 1 week.	twoWeeks := now + 2 weeks.	threeWeeks := now + 3 weeks.		timespans := Set new.		timespans add: (Timespan starting: now ending: nextWeek).	timespans add: (Timespan starting: nextWeek ending: twoWeeks).	timespans add: (Timespan starting: now ending: tomorrow).	timespans add: (Timespan starting: sixHours ending: (sixHours + 6 hours)).! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testAdd	| dateRanges timespan |	dateRanges := DateTree new.	timespan := Timespan starting: now ending: twoWeeks.	dateRanges at: timespan put: timespan.	self assert: ((dateRanges at: timespan) = timespan)! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!testClipEndRange	| dateRanges returnedDates expectedDates |		dateRanges := DateTree new.	timespans do: [ :ea | dateRanges at: ea put: ea asString ].	expectedDates := timespans select: [ :ea | (ea start >= now) and: [ ea end <= nextWeek ]] thenCollect: [ :ea | ea asString ].	returnedDates := (dateRanges between: now and: nextWeek) collect: [ :ea | ea asString ].	self assert: (returnedDates intersection: expectedDates) size = expectedDates size.! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testClipStartRange	| dateRanges returnedDates expectedDates |		dateRanges := DateTree new.	timespans do: [ :ea | dateRanges at: ea put: ea asString ].	expectedDates := timespans select: [ :ea | (ea start >= nextWeek) and: [ ea end <= twoWeeks ]] thenCollect: [ :ea | ea asString ].	returnedDates := (dateRanges between: nextWeek and: twoWeeks) collect: [ :ea | ea asString ].	self assert: (returnedDates intersection: expectedDates) size = expectedDates size.! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 10/8/2009 14:45'!testFirstLast	| dateRanges |	dateRanges := DateTree new.	self should: [ dateRanges first ] raise: Error.	self should: [ dateRanges last ] raise: Error.	dateRanges at: (Timespan starting: tomorrow ending: nextWeek) put: #inner.	self assert: dateRanges first = #inner.	self assert: dateRanges last = #inner.	dateRanges at: (Timespan starting: now ending: twoWeeks) put: #outer.	self assert: dateRanges first = #outer.	self assert: dateRanges last = #outer.	dateRanges at: (Timespan starting: tomorrow ending: threeWeeks) put: #last.	self assert: dateRanges first = #outer.	self assert: dateRanges last = #last! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testInclusiveRange	| dateRanges returnedDates expectedDates |		dateRanges := DateTree new.	timespans do: [ :ea | dateRanges at: ea put: ea asString ].	expectedDates := timespans collect: [ :ea | ea asString ].	returnedDates := (dateRanges between: now and: threeWeeks) collect: [ :ea | ea asString ].	self assert: (returnedDates intersection: expectedDates) size = expectedDates size.! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testIteration	| dateRanges |		dateRanges := DateTree new.	timespans do: [ :ea | dateRanges at: ea put: ea asString ].	dateRanges keysAndValuesDo: [ :key :val | self assert: (key asString) = val ].! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testMissing	| dateRanges timespan missingTimespan |	dateRanges := DateTree new.	timespan := Timespan starting: now ending: twoWeeks.	missingTimespan := Timespan starting: now ending: tomorrow.	dateRanges at: timespan put: timespan.	self assert: (dateRanges at: missingTimespan ifAbsent: [ false ]) = false.! !!DateTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/15/2005 19:54'!testRemove	| dateRanges timespan |	dateRanges := DateTree new.	timespans do: [ :ea | dateRanges at: ea put: ea asString. ].	timespan := timespans anyOne.	self assert: (dateRanges at: timespan) = timespan asString.	dateRanges removeKey: timespan.	self assert: ((dateRanges at: timespan ifAbsent: [ false ]) = false)! !Collection subclass: #TSTree	instanceVariableNames: 'root emptyValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:11'!at: aString	^ self at: aString ifAbsent: [self error: aString printString, ' not found']! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/7/2005 21:55'!at: aString ifAbsent: exceptionBlock	aString isEmpty ifTrue: [^ emptyValue ifNil: [exceptionBlock value]].	root ifNil: [^ exceptionBlock value].		^ (root lookupString: aString startingAt: 1) ifNil: exceptionBlock! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:11'!at: aString ifAbsentPut: exceptionBlock	^ self at: aString ifAbsent: [self at: aString put: exceptionBlock value]! !!TSTree methodsFor: 'accessing' stamp: 'lr 4/15/2009 09:50'!at: aString put: anObject	aString isEmpty ifTrue: [^ emptyValue := anObject].	root ifNil: [root := TSTreeNode key: aString first].	root lookupString: aString startingAt: 1 insert: anObject.	^ anObject! !!TSTree methodsFor: 'accessing' stamp: 'avi 8/11/2005 13:33'!keys	^ Array streamContents: [:s | self keysAndValuesDo: [:k :v | s nextPut: k]]! !!TSTree methodsFor: 'accessing' stamp: 'avi 12/13/2004 13:09'!removeKey: aString	^ self removeKey: aString ifAbsent: [self error: 'Could not find key ', aString printString]! !!TSTree methodsFor: 'accessing' stamp: 'lr 4/15/2009 09:50'!removeKey: aString ifAbsent: errorBlock	| val |	^ root ifNil: errorBlock		ifNotNil:			[val := root removeString: aString startingAt: 1.			root canBeCulled ifTrue: [root := nil].			val ifNil: errorBlock]! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:34'!values	^ Array streamContents: [:s | self do: [:ea | s nextPut: ea]]! !!TSTree methodsFor: 'enumerating' stamp: 'avi 9/7/2005 21:56'!do: aBlock	emptyValue ifNotNilDo: aBlock.	root ifNotNil: [root do: aBlock]! !!TSTree methodsFor: 'enumerating' stamp: 'avi 9/7/2005 21:55'!keysAndValuesDo: aBlock	emptyValue ifNotNil:		[aBlock value: '' value: emptyValue].	root ifNotNil: [root keysAndValuesDo: aBlock prefix: '']! !!TSTree methodsFor: 'matching' stamp: 'avi 9/15/2004 21:59'!matchesForPrefix: aString	^ Array streamContents:		[:s |		self matchesForPrefix: aString do:			[:match |			s nextPut: match]]! !!TSTree methodsFor: 'matching' stamp: 'avi 9/22/2004 00:57'!matchesForPrefix: aString do: aBlock	aString isEmpty		ifTrue: [self do: aBlock]		ifFalse: [root ifNotNil: [root matchesForPrefix: aString startingAt: 1 do: aBlock]]! !!TSTree methodsFor: 'matching' stamp: 'avi 9/15/2004 15:21'!matchesForString: aString distance: aNumber	^ Array streamContents:		[:s |		self matchesForString: aString distance: aNumber do:			[:match |			s nextPut: match]]! !!TSTree methodsFor: 'matching' stamp: 'avi 10/20/2004 21:26'!matchesForString: aString distance: aNumber do: aBlock	self matchesForString: aString distance: aNumber limitNodes: nil do: aBlock! !!TSTree methodsFor: 'matching' stamp: 'lr 4/15/2009 09:50'!matchesForString: aString distance: aNumber limitNodes: maxNodes do: aBlock	| nodeCount |	nodeCount := 0.	aString isEmpty ifTrue: [^ self].	root isNil ifTrue: [^ self].	root matchesForString: aString startingAt: 1 distance: aNumber do: aBlock nodesDo:		[:ea |		nodeCount := nodeCount + 1.		nodeCount = maxNodes ifTrue: [^ self]]! !Object subclass: #TSTreeNode	instanceVariableNames: 'key value low high equal'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!TSTreeNode methodsFor: 'private' stamp: 'RamonLeon 5/5/2011 23:20'!canBeCulled	^ self value isNil and: [ low isNil and: [ equal isNil and: [ high isNil ] ] ]! !!TSTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!cullNode: aNode	low == aNode ifTrue: [^ low := nil].	equal == aNode ifTrue: [^ equal := nil].	high == aNode ifTrue: [^ high := nil]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:00'!do: aBlock	self nodesDo: [:ea | ea value ifNotNilDo: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!initializeWithKey: aCharacter	key := aCharacter! !!TSTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!keysAndValuesDo: aBlock prefix: aString	| fullKey |	fullKey := aString copyWith: key.	value ifNotNil: [aBlock value: fullKey value: value].	low ifNotNil: [low keysAndValuesDo: aBlock prefix: aString].	equal ifNotNil: [equal keysAndValuesDo: aBlock prefix: fullKey].	high ifNotNil: [high keysAndValuesDo: aBlock prefix: aString]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 12/13/2004 13:26'!lookupString: aString startingAt: i"inlined for performance""	self		lookupString: aString		startingAt: i		whenFound: [^ value]		whenNil: [:c | ^ nil]		recurseWith: [:node :j | ^ node lookupString: aString startingAt: j]"	| char |	char := aString at: i.	char = key		ifTrue:			[aString size = i				ifTrue: [^ value]				ifFalse: [^ equal ifNotNil: [equal lookupString: aString startingAt: i+1]]]		ifFalse:			[char < key				ifTrue: [^ low ifNotNil: [low lookupString: aString startingAt: i]]				ifFalse: [^ high ifNotNil: [high lookupString: aString startingAt: i]]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:41'!lookupString: aString startingAt: i insert: anObject	self		lookupString: aString		startingAt: i		whenFound: [self value: anObject]		whenNil: [:c | self newNodeWithKey: c]		recurseWith: [:node :j | node lookupString: aString startingAt: j insert: anObject]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:04'!lookupString: aString startingAt: i whenFound: foundBlock whenNil: nilBlock recurseWith: recurseBlock	| char |	char := aString at: i.	char = key		ifTrue:			[aString size = i				ifTrue: [foundBlock value]				ifFalse: [equal ifNil: [equal := nilBlock value: (aString at: i+1)].						 recurseBlock value: equal value: i+1]]		ifFalse:			[char < key				ifTrue: [low ifNil: [low := nilBlock value: char].						recurseBlock value: low value: i]				ifFalse: [high ifNil: [high := nilBlock value: char].						recurseBlock value: high value: i]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:04'!matchesForPrefix: aString startingAt: i do: aBlock	self		lookupString: aString		startingAt: i		whenFound: [value ifNotNil: [aBlock value: value].  equal ifNotNil: [equal do: aBlock]]		whenNil: [:c | ^ self]		recurseWith: [:n :j | n matchesForPrefix: aString startingAt: j do: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 10/20/2004 21:27'!matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock		| char d2 |	nodeBlock value: self.	d < 0 ifTrue: [^ self].		char := aString at: i.	(d > 0 or: [char < key])		ifTrue: [low ifNotNil: [low matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock]].			d2 := char = key ifTrue: [d] ifFalse: [d-1].	(i + d2 = aString size and: [value notNil]) ifTrue: [aBlock value: value].	equal ifNotNil: [equal matchesForString: aString startingAt: (i+1 min: aString size) distance: d2 do: aBlock nodesDo: nodeBlock].		(d > 0 or: [char > key])		ifTrue: [high ifNotNil: [high matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:41'!newNodeWithKey: aCharacter	^ self class key: aCharacter! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 00:51'!nodesDo: aBlock	aBlock value: self.	low ifNotNil: [low nodesDo: aBlock].	equal ifNotNil: [equal nodesDo: aBlock].	high ifNotNil: [high nodesDo: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!removeString: aString startingAt: i	| val |	self		lookupString: aString		startingAt: i		whenFound: [val := self value. self value: nil]		whenNil: [:c | ^ nil]		recurseWith:			[:node :j |			val := node removeString: aString startingAt: j.			node canBeCulled ifTrue:				[self cullNode: node]].	^ val! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 00:51'!value	^ value! !!TSTreeNode methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!value: anObject	value := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TSTreeNode class	instanceVariableNames: ''!!TSTreeNode class methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 01:03'!key: aCharacter	^ self basicNew initializeWithKey: aCharacter! !TestCase subclass: #TSTreeTest	instanceVariableNames: 'tree empty'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'lr 4/15/2009 09:50'!setUp	tree := TSTree new.	self words shuffled do: [:ea | tree at: ea put: ea asUppercase].	empty := TSTree new.! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 01:01'!testAt	self assert: (tree at: 'abear') = 'ABEAR'.	self assert: (tree at: 'abelmosk') = 'ABELMOSK'.	self assert: (tree at: 'abracadabra' ifAbsent: [42]) = 42.	self assert: (tree at: '' ifAbsent: [42]) = 42.	self assert: (empty at: 'foo' ifAbsent: [42]) = 42 ! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/21/2004 20:38'!testMatch	self assert: (tree matchesForString: 'abea' distance: 1) asSet = #(ABEAM ABEAR ABED ABEL ABET ABE) asSet.	self assert: (tree matchesForString: 'abel' distance: 2) asSet = #(ABELIA ABEAM ABEAR) asSet.	self assert: (tree matchesForString: 'abel' distance: 0) = #(ABEL).	self assert: (tree matchesForString: '' distance: 1) = #().	self assert: (empty matchesForString: 'foo' distance: 0) = #()! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 00:48'!testPrefix	self assert: (tree matchesForPrefix: 'abet') asSet = #(ABET ABETMENT) asSet.	self assert: (tree matchesForPrefix: 'abelm') asSet = #(ABELMOSCHUS ABELMOSK) asSet.	self assert: (tree matchesForPrefix: '') asSet = (self words asSet collect: [:ea | ea asUppercase]).	self assert: (empty matchesForPrefix: 'foo') = #()! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 12/13/2004 13:07'!testRemove	self assert: (tree at: 'abel') = 'ABEL'.	self assert: (tree removeKey: 'abel') = 'ABEL'.	self assert: (tree at: 'abel' ifAbsent: [42]) = 42.	self assert: (tree at: 'abelmosk') = 'ABELMOSK'.	self assert: (tree removeKey: 'foo' ifAbsent: [42]) = 42.	self assert: (tree removeKey: 'abel' ifAbsent: [42]) = 42.! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/21/2004 20:38'!testValues	self assert: tree values asSet = (self words asSet collect: [:ea | ea asUppercase]).	self assert: empty values isEmpty! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 00:58'!words	^ #(abeabeamabearabearanceabecedarianabecedariumabecedaryabedabeighabelabeleabeliaabelianabeliceaabeliteabeliteabelmoschusabelmoskabelonianabeltreeabencerragesabentericabepithymiaaberdeenaberdevineaberdonianaberiaaberranceaberrancyaberrantaberrateaberrationaberrationalaberratoraberrometeraberroscopeaberuncatorabetabetment) ! !Collection subclass: #TreeSet	instanceVariableNames: 'tree sortKey equalsKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-BTree'!!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!add: anObject	| key bucket |	key := self keyForValue: anObject.	bucket := tree at: key ifAbsent: [#()].	(self bucket: bucket includes: anObject) ifFalse:		[tree at: key put: (bucket copyWith: anObject)].! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!addAll: aCollection	| oldVals newVals combined |	(self isCompatibleTreeSetWith: aCollection) ifFalse: [^ super addAll: aCollection].	aCollection tree keysAndValuesDo:		[:key :vals |		oldVals := tree at: key ifAbsent: [#()].		newVals := oldVals isEmpty					ifTrue: [vals]					ifFalse: [vals reject: [:ea | self bucket: oldVals includes: ea]].		newVals isEmpty ifFalse:			[combined := oldVals isEmpty ifTrue: [newVals] ifFalse: [oldVals, newVals].			tree at: key put: combined]]! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!atIndex: index	| count |	count := 0.	self do: [:ea | (count := count + 1) = index ifTrue: [^ ea]].	self error: 'No item at index: ', index asString.! !!TreeSet methodsFor: 'public' stamp: 'avi 3/2/2004 11:16'!do: aBlock	tree do: [:bucket | bucket do: aBlock]! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!equalitySelector	^ equalsKey ifNil: [equalsKey := self class defaultEqualitySelector]! !!TreeSet methodsFor: 'public' stamp: 'ac 5/17/2005 14:07'!first	^ self atIndex: 1! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!includes: anObject	| bucket |	bucket :=  tree at: (self keyForValue: anObject) ifAbsent: [^ false].	^ self bucket: bucket includes: anObject! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!intersection: aCollection	| newTree intersection |	(self isCompatibleTreeSetWith: aCollection) ifFalse: [^ super intersection: aCollection].	newTree := tree emptyCopy.		tree commonKeysWith: aCollection tree keysAndValuesDo:		[:key :left :right |		intersection := left select: [:ea | self bucket: right includes: ea].		intersection isEmpty ifFalse: [newTree at: key put: intersection]].		^ TreeSet basicNew setTree: newTree sortSelector: self sortSelector equalitySelector: self equalitySelector! !!TreeSet methodsFor: 'public' stamp: 'avi 5/1/2005 14:10'!isTreeSet	^ true! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!remove: anObject	| key bucket |	key := self keyForValue: anObject.	bucket := tree at: key ifAbsent: [^ self].	(self bucket: bucket includes: anObject) ifTrue:		[bucket := bucket reject: [:ea | self value: anObject matches: ea].		bucket isEmpty			ifTrue: [tree removeKey: key]			ifFalse: [tree at: key put: bucket]]! !!TreeSet methodsFor: 'public' stamp: 'lr 5/3/2005 17:24'!remove: anObject ifAbsent: aBlock	self remove: anObject.! !!TreeSet methodsFor: 'public' stamp: 'lr 4/15/2009 09:50'!removeAllSuchThat: aBlock	| changes remove |	changes := Dictionary new.	tree keysAndValuesDo:		[:key :bucket |		remove := bucket select: aBlock.		remove isEmpty ifFalse:			[changes at: key put: (bucket copyWithoutAll: remove)]].	changes keysAndValuesDo:		[:key :bucket |		tree at: key put: bucket]! !!TreeSet methodsFor: 'public' stamp: 'ac 5/17/2005 14:07'!second	^ self atIndex: 2! !!TreeSet methodsFor: 'public' stamp: 'avi 4/21/2005 02:45'!sortSelector	^ sortKey! !!TreeSet methodsFor: 'private' stamp: 'avi 5/21/2004 12:18'!bucket: anArray includes: anObject	^ anArray anySatisfy: [:ea | (self value: anObject matches: ea)]! !!TreeSet methodsFor: 'private' stamp: 'avi 5/1/2005 15:26'!isCompatibleTreeSetWith: aCollection	aCollection isTreeSet ifFalse: [^ false].	aCollection equalitySelector = self equalitySelector ifFalse: [^ false].	aCollection sortSelector = self sortSelector ifFalse: [^ false].	^ true! !!TreeSet methodsFor: 'private' stamp: 'avi 4/20/2005 14:16'!tree	^ tree! !!TreeSet methodsFor: 'private' stamp: 'lr 4/15/2009 09:50'!tree: aBTree	tree := aBTree! !!TreeSet methodsFor: 'initialize-release' stamp: 'avi 5/1/2005 14:52'!initializeWithKeys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol	self setTree: (BTree keys: aBtreeKeys) sortSelector: sortSymbol equalitySelector: equalsSymbol! !!TreeSet methodsFor: 'initialize-release' stamp: 'lr 4/15/2009 09:50'!setTree: aBTree sortSelector: sortSymbol equalitySelector: equalsSymbol	tree := aBTree.	sortKey := sortSymbol.	equalsKey := equalsSymbol! !!TreeSet methodsFor: 'plugs' stamp: 'avi 3/2/2004 15:01'!keyForValue: anObject	^ anObject perform: sortKey! !!TreeSet methodsFor: 'plugs' stamp: 'avi 5/1/2005 15:51'!value: anObject matches: otherObject	^ anObject perform: self equalitySelector with: otherObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreeSet class	instanceVariableNames: ''!!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!defaultEqualitySelector	^ #=! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:57'!defaultKeys	^ BTreeKeysArray new: 64! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!defaultSortSelector	^ #hash! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:43'!keys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol	^ self basicNew initializeWithKeys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:55'!new	^ self sortBy: self defaultSortSelector! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!sortBy: aSymbol	^ self sortSelector: aSymbol equalitySelector: self defaultEqualitySelector! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:57'!sortSelector: sortSymbol equalitySelector: equalsSymbol	^ self keys: self defaultKeys sortSelector: sortSymbol equalitySelector: equalsSymbol! !