MaObject subclass: #MaLargeCollectionManager	instanceVariableNames: 'collection memberIndex repository'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-private'!!MaLargeCollectionManager commentStamp: 'cmm 3/16/2005 12:48' prior: 0!I perform server-side operations for MagmaLargeCollections.  Adding, removing and accessing.!!MaLargeCollectionManager methodsFor: 'initializing' stamp: 'cmm 1/5/2010 17:48'!close	memberIndex ifNotNil: [ memberIndex close ]! !!MaLargeCollectionManager methodsFor: 'initializing' stamp: 'cmm 10/22/2006 15:56'!ensureMemberIndexOpen	memberIndex ifNil:		[ memberIndex := self openIndex: (repository collectionFilenameFor: collection) asString.		memberIndex filePool: repository filePool ]! !!MaLargeCollectionManager methodsFor: 'initializing' stamp: 'cmm 10/22/2006 15:09'!filePool: aMaFileStreamPool	"Set my pool so that Magma can limit the number simultaneously open files, something required by some ISP's."	memberIndex filePool: aMaFileStreamPool! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:57'!collection	^ collection! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 8/22/2002 19:25'!filename	^memberIndex filename! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 6/8/2005 15:13'!filenames	^ { repository directory localNameFor: self filename }! !!MaLargeCollectionManager methodsFor: 'accessing'!memberIndex	^memberIndex! !!MaLargeCollectionManager methodsFor: 'accessing'!size	^memberIndex size! !!MaLargeCollectionManager methodsFor: 'private' stamp: 'cmm 3/17/2005 22:23'!collection: aMagmaLargeCollection	collection := aMagmaLargeCollection! !!MaLargeCollectionManager methodsFor: 'private' stamp: 'cmm 12/2/2004 13:22'!collectionOid	^ repository session oidFor: collection! !!MaLargeCollectionManager methodsFor: 'private'!repository: aMaObjectRepository	repository := aMaObjectRepository! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 7/12/2005 11:02'!createNewLargeCollection	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/17/2005 23:14'!openIndex: filenameString	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 22:57'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 14:17'!processAddsIn: aMaCollectionChanges using: aMaCommitResult	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 21:24'!recordConflictsBetween: aMagmaCollectionChanges and: challengingCommitLogEntry in: myCommitLogEntry	"If there are any conflicts, record them in myCommitLogEntry."	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 21:24'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 4/30/2005 11:16'!upTo: anInteger inSegmentFromIndex: lowIndex	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'actions' stamp: 'cmm 7/12/2005 11:18'!createSupplementaryIndexes	"Nothing to do by default."! !!MaLargeCollectionManager methodsFor: 'actions' stamp: 'cmm 3/17/2005 17:22'!ensureOpen	^ self 		ensureMemberIndexOpen ;		yourself! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/9/2006 17:25'!fileIdForIndex: anInteger	"To support recovery, we must populate MaBeforeImageRecords with a fileId, which identifies which file it is a before-image of.  We have eight bytes available for this.  The high-order 6 bytes are my collectionOid, the low-order two bytes indicate which index of the collection it is.  0 is the memberIndex."	^ (self collectionOid bitShift: 16) + anInteger! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/5/2005 23:43'!filesDo: twoArgBlock	memberIndex filesDo: 		[ : each |		twoArgBlock			value: each			value: (self fileIdForIndex: 0) ]! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 5/30/2005 21:25'!indexForFileId: anInteger	"To support recovery of LargeCollections, we must replace the applied records to their prior-state, which is contained inside MaBeforeImageRecords."	^ memberIndex "the only possibility"! !!MaLargeCollectionManager methodsFor: 'testing' stamp: 'cmm 7/9/2006 17:42'!isLoading	"Answer whether this collection is being loaded from another collection.  This happens only for MagmaCollections when the client requests they be sorted, it never happens for MagmaArrays."	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLargeCollectionManager class	instanceVariableNames: ''!!MaLargeCollectionManager class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!collection: aMagmaCollection repository: aMaObjectRepository	^self new		collection: aMagmaCollection ;		repository: aMaObjectRepository ;		yourself! !MaObject subclass: #MaObjectFiler	instanceVariableNames: 'directory file preMadeObjectBuffer filePositionIndex usedByteArrays primitiveAttributeAddressesMap magmaStatClassIds'	classVariableNames: ''	poolDictionaries: 'MaSerializerConstants'	category: 'Magma-Server-private'!!MaObjectFiler commentStamp: 'cmm 5/25/2005 14:24' prior: 0!I am used to cache values committed in the server.  When a value is cached, we must remember from which commitPackage it came from in case the same object is updated again by a subsequent commitPackage, in which case we would not want to uncache the value when the first commitPackage is applied.!!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:14'!anchorOid	^ self primitiveAttributeAt: #anchorOid! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 10/23/2008 17:58'!branchCode	"The branchCode is a randomly-generated number used to prevent accidentally applying the wrong commit-logs to a repository.  When performing a forward recovery, each CommitLogRecord's #branchCode must match mine.  Every time a commitRestore is performed, this branchCode is updated to a new number."	^ self primitiveAttributeAt: #branchCode! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:14'!classDefinitionsOid	^self primitiveAttributeAt: #classDefinitionsOid! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:15'!commitNumber	^ self primitiveAttributeAt: #commitNumber! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:15'!definitionOid	^ self primitiveAttributeAt: #definitionOid! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 9/26/2004 20:25'!directory	^ directory! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 3/9/2009 22:28'!filePointerForOid: oidInteger 	| answer |	answer := filePositionIndex 		at: (MaOidCalculator indexPositionForOid: oidInteger)		ifAbsent: 			[ MagmaInvalidOid signal: oidInteger printString , ' is not a valid oid.' ].	answer = 0 ifTrue: 		[ MagmaInvalidOid signal: oidInteger printString , ' has been reclaimed.' ].	^ answer! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 9/24/2004 13:07'!filePositionIndexFileName	^ directory fullNameFor: self class objectPointersFilename! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 5/27/2007 15:08'!getNextOid	^ MaOidCalculator oidForFilePositionIndexPosition: filePositionIndex size! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 2/24/2009 14:37'!initializeBranchCode	| oldBranchCode newBranchCode |	oldBranchCode := self branchCode.	[ (newBranchCode := (1 to: (1 bitShift: 32) - 1) atRandom) = oldBranchCode ] whileTrue.	self branchCode: newBranchCode! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 5/1/2003 17:37'!isOpen	^file notNil and: [ file closed not ]! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:29'!objectFileSize	^file size! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 11/26/2010 11:51'!open	directory exists ifFalse: [ MagmaEnvironmentError signal: 'Database Directory Not Found' ].	(directory fileExists: self class objectsPhysicalFilename) ifFalse: [ MagmaEnvironmentError signal: (directory fullNameFor: self class objectsPhysicalFilename) , ' not found.' ].	self openObjectsFile.	[ self		 validateSignature ;		 openFilePositionIndex ] ifCurtailed: [ self close ]! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:14'!primitiveAttributeAt: aSymbol	| assoc |	^self		uint: (assoc := self primitiveAttributeAddressesMap at: aSymbol) value		at: assoc key! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 1/8/2014 20:55'!recordSampleAt: filePointer do: oneArgBlock 	"Value oneArgBlock with the header and enough bytes for the first 8 oid pointers of MaObjectBuffer currently residing at filePointer.  8 because we need up to and including the 'deltaSum' inst-var of MagmaStat."	preMadeObjectBuffer startPos: 0.	file 		maRead: 72 "(MagmaBufferPositionMap headerSize - 7 + 1) + (8*(MaObjectBuffer oidSize/8))"		bytesFromPosition: preMadeObjectBuffer bufferPositionOfBytesToStore		of: preMadeObjectBuffer byteArray		atFilePosition: filePointer.	^ oneArgBlock value: preMadeObjectBuffer! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 6/18/2007 23:17'!restoreMode	^ self booleanFlags maIsBitSet: 1! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 6/19/2007 21:53'!restoreMode: aBoolean 	^ self booleanFlags: 		(aBoolean 			ifTrue: [ self booleanFlags maBitSet: 1 ]			ifFalse: [ self booleanFlags maBitClear: 1 ])! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:16'!signature	^self primitiveAttributeAt: #signature! !!MaObjectFiler methodsFor: 'accessing' stamp: 'kph 6/18/2007 12:17'!version	^self primitiveAttributeAt: #version! !!MaObjectFiler methodsFor: 'building' stamp: 'kph 6/18/2007 12:15'!anchorOid: anInteger	^ self		primitiveAttributeAt: #anchorOid		put: anInteger! !!MaObjectFiler methodsFor: 'building' stamp: 'kph 6/18/2007 12:15'!classDefinitionsOid: anInteger	self		primitiveAttributeAt: #classDefinitionsOid		put: anInteger! !!MaObjectFiler methodsFor: 'building' stamp: 'kph 6/18/2007 12:15'!commitNumber: anInteger 	self 		primitiveAttributeAt: #commitNumber		put: anInteger! !!MaObjectFiler methodsFor: 'building' stamp: 'kph 6/18/2007 12:15'!definitionOid: anInteger	^self		primitiveAttributeAt: #definitionOid		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 2/26/2016 16:02'!append: aMaObjectBuffer to: aMaSerializedGraphBuffer withDataAt: filePositionInteger 	| startPos |	startPos := aMaSerializedGraphBuffer bufferSize.	startPos > MaSerializedGraphBuffer sizeWarningThreshold ifTrue: [ (MaEnvironmentError messageText: 'Read too big (>' , startPos asBytesDescription , ').  Make a smaller read or increase the MaSerializedGraphBuffer class>>#sizeWarningThreshold on the server.') signal ].	self		ensureByteArrayIn: aMaObjectBuffer		and: aMaSerializedGraphBuffer		canAccomodate: self trackSize + aMaObjectBuffer bufferPositionOfBytesToStore		bytesFrom: startPos + 1.	aMaSerializedGraphBuffer increaseBufferSizeBy:		(self			read: self trackSize			bytesInto: aMaObjectBuffer			and: aMaSerializedGraphBuffer			startingAt: startPos			filePosition: filePositionInteger)! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 10/24/2008 00:06'!booleanFlags	^ self primitiveAttributeAt: #booleanFlags! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 10/24/2008 00:06'!booleanFlags: anInteger 	^ self 		primitiveAttributeAt: #booleanFlags		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 10/23/2008 17:53'!branchCode: anInteger 	^ self 		primitiveAttributeAt: #branchCode		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 1/7/2014 22:28'!canPossiblyConflict: eachObjectBuffer	^ (eachObjectBuffer classId = MagmaClassIdManager magmaCounterClassId) not and: [ (magmaStatClassIds includes: eachObjectBuffer classId) not ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 16:42'!create: aFileDirectory	self		directory: aFileDirectory assureExistence ;		createDataFile ;		createFilePositionIndex.	^ self! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 8/15/2008 12:23'!createDataFile	(directory fileExists: self class objectsPhysicalFilename) ifTrue: 		[ MagmaEnvironmentError signal: directory pathName , ' already exists.' ].	self openObjectsFile.	"Write some extra blank space to allow for possible future fields."	file 		maWrite: self class sizeOfEmptyRepository		bytesFromPosition: 1		of: (ByteArray new: self class sizeOfEmptyRepository)		atFilePosition: 0; 		maCommit.	self		restoreMode: false ;		classDefinitionsOid: MaOidCalculator oidForNil ;		definitionOid: MaOidCalculator oidForNil ;		signature: MaObjectRepository recognitionSignature ;		version: MagmaSession magmaVersion ;		commitNumber: 0 ;		initializeBranchCode ! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 4/29/2007 21:48'!createFilePositionIndex	filePositionIndex := MaLargeArrayOfNumbers 		create: (MaAtomicFileStream fileNamed: self filePositionIndexFileName)		bitSize: self class maxDbSize! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 12:55'!directory: aFileDirectory	directory := aFileDirectory! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/30/2002 17:28'!ensureByteArrayIn: aMaObjectBuffer and: aMaSerializedGraphBuffer canAccomodate: anInteger bytesFrom: startPos	(startPos + anInteger) > aMaObjectBuffer byteArray size		ifTrue:			[ | bigByteArray beforeSize afterSize |			beforeSize := aMaObjectBuffer byteArray size.			afterSize := (aMaObjectBuffer byteArray size * 2) max: startPos + anInteger.			bigByteArray := ByteArray new: afterSize.			bigByteArray				replaceFrom: 1				to: beforeSize				with: aMaSerializedGraphBuffer byteArray				startingAt: 1.			aMaObjectBuffer byteArray: bigByteArray.			aMaSerializedGraphBuffer byteArray: bigByteArray ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 6/1/2005 23:57'!ensureFilesOpen	file ifNotNil: [ file closed ifTrue: [ self openObjectsFile ] ].	filePositionIndex ifNil: [ self openFilePositionIndex ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 1/8/2014 18:29'!initialize	super initialize.	preMadeObjectBuffer := MaObjectBuffer new.	usedByteArrays := (1 to: 8) collect: [ :each | ByteArray new: each ].	self initializePrimitiveAttributeAddressesMap.	magmaStatClassIds := Set new! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 10/23/2008 17:57'!initializePrimitiveAttributeAddressesMap	primitiveAttributeAddressesMap := Dictionary new		at: #signature put: (Association key: 0 value: 64);		at: 0 put: #signature ;		at: #version put: (Association key: 8 value: 16);		at: 2 put: #version ;		at: #booleanFlags put: (Association key: 10 value: 8);		at: 10 put: #booleanFlags ;		at: #definitionOid put: (Association key: 11 value: 64);		at: 11 put: #definitionOid ;		"gap 19-26"		at: #classDefinitionsOid put: (Association key: 27 value: 64) ;		at: 27 put: #classDefinitionsOid ;		at: #anchorOid put: (Association key: 43 value: 64);		at: 43 put: #anchorOid ;		at: #commitNumber put: (51 -> 48) ;		at: 51 put: #commitNumber ;		at: #branchCode put: (57->32) ;		at: 57 put: #branchCode ;		yourself! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 1/3/2014 14:41'!magmaStatClassIds	^ magmaStatClassIds! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 4/29/2007 21:48'!openFile: unqualifiedName 	^ MaAtomicFileStream fileNamed: (directory fullNameFor: unqualifiedName)! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 4/29/2007 21:48'!openFilePositionIndex	filePositionIndex := 	[ MaLargeArrayOfNumbers open: (MaAtomicFileStream fileNamed: self filePositionIndexFileName) ] ifCurtailed: [ self close ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 5/10/2005 19:08'!openObjectsFile	file := self openFile: self class objectsFilename! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/13/2016 20:46'!prewriteAdjustmentTo: bufferToWrite from: persistentBuffer	bufferToWrite classId = MagmaClassIdManager magmaCounterClassId 		ifTrue:			[ | sharedValue delta |			"These inst-var indices match MagmaCounter; hard-coded for maximum performance."			sharedValue := persistentBuffer				ifNil: [ "A brand new counter" 0 ]				ifNotNil: [ MaOidCalculator integerFromOid: (persistentBuffer maInstVarAt: 1) ].			delta := MaOidCalculator integerFromOid: (bufferToWrite maInstVarAt: 2).			(sharedValue+delta) > 1073741823 ifTrue: [ MagmaStatOverflowCommitError signal ].			bufferToWrite				maInstVarAt: 1				put: (MaOidCalculator oidForInteger: sharedValue + delta) ;				maInstVarAt: 2				put: (MaOidCalculator oidForInteger: 0) ]		ifFalse:			[ (magmaStatClassIds includes: bufferToWrite classId) ifTrue:				[ | sharedCount deltaCount sharedSum deltaSum sharedMin sharedMax |				"These inst-var indices match MagmaStat; hard-coded for maximum performance."				persistentBuffer					ifNil: 						[ "A brand new stat" 						sharedCount := 0.						sharedSum := 0.0.						sharedMin := Float infinity.						sharedMax := Float infinity negated ]					ifNotNil: 						[ sharedCount := MaOidCalculator integerFromOid: (persistentBuffer maInstVarAt: 2).						sharedSum := MaOidCalculator floatFromOid: (persistentBuffer maInstVarAt: 3).						sharedMin := MaOidCalculator floatFromOid: (persistentBuffer maInstVarAt: 4).						sharedMax := MaOidCalculator floatFromOid: (persistentBuffer maInstVarAt: 5) ].				deltaCount := MaOidCalculator integerFromOid: (bufferToWrite maInstVarAt: 7).				sharedCount + deltaCount >  1073741823 "SmallInteger maxVal" ifTrue: [ MagmaStatOverflowCommitError signal ].				deltaSum := MaOidCalculator floatFromOid: (bufferToWrite maInstVarAt: 8).				bufferToWrite					maInstVarAt: 2 "count"					put: (MaOidCalculator oidForInteger: (sharedCount+deltaCount)) ;					maInstVarAt: 3 "sum"					put: (MaOidCalculator oidForFloat: sharedSum + deltaSum) ;					maInstVarAt: 4 "min"					put: (MaOidCalculator oidForFloat: (sharedMin min: (MaOidCalculator floatFromOid: (bufferToWrite maInstVarAt: 4)))) ;					maInstVarAt: 5 "max"					put: (MaOidCalculator oidForFloat: (sharedMax max: (MaOidCalculator floatFromOid: (bufferToWrite maInstVarAt: 5)))) ;					"The 'last' variable in bufferToWrite wins over the one in persistentBuffer."					maInstVarAt: 7  "deltaCount -- make it 0 so that's how it'll be read by clients."					put: (MaOidCalculator oidForInteger: 0) ;					maInstVarAt: 8  "deltaSum -- make it 0 so that's how it'll be read by clients."					put: (MaOidCalculator oidForFloat: 0.0) ] ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/30/2002 21:15'!primitiveAttributeAddressesMap	^primitiveAttributeAddressesMap! !!MaObjectFiler methodsFor: 'private' stamp: 'kph 6/18/2007 12:13'!primitiveAttributeAt: aSymbol put: anInteger	| assoc |	self		uint: (assoc := self primitiveAttributeAddressesMap at: aSymbol) value		at: assoc key		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/24/2012 10:48'!read: numberOfBytes bytesInto: aMaObjectBuffer and: aMaSerializedGraphBuffer startingAt: startPos filePosition: anInteger 	"startPos is 0-based, answer the physicalSize of the buffer read."	^ file guard:		[ | physicalSize numberOfBytesRead numberOfBytesStored |		numberOfBytesRead := file			maRead: numberOfBytes			bytesFromPosition: startPos + aMaObjectBuffer bufferPositionOfBytesToStore			of: aMaObjectBuffer byteArray			atFilePosition: anInteger.		"See if we have read enough, if not read the rest of the buffer."		numberOfBytesStored := aMaObjectBuffer numberOfBytesToStore.		physicalSize := aMaObjectBuffer physicalSize.		numberOfBytesStored > numberOfBytesRead ifTrue:			[ | resumePosition |			resumePosition := startPos + numberOfBytesRead + aMaObjectBuffer bufferPositionOfBytesToStore.			self				ensureByteArrayIn: aMaObjectBuffer				and: aMaSerializedGraphBuffer				canAccomodate: physicalSize				bytesFrom: resumePosition.			file				next: numberOfBytesStored - numberOfBytesRead				into: aMaSerializedGraphBuffer byteArray				startingAt: resumePosition ].		physicalSize ]! !!MaObjectFiler methodsFor: 'private' stamp: 'kph 6/18/2007 12:17'!signature: anInteger	self		primitiveAttributeAt: #signature		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 8/12/2002 23:48'!trackSize	"This is the minimum number of bytes to read from disk for any object.	This particular value allows up to 32 instVars to be read at once."	"^MaAbstractObjectBuffer addressSize * 32 + MaNormalObjectBuffer headerSize"	^280 "same as above, but faster.."! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 13:22'!uint: bits at: anInteger	| address bytes |	address := self usedByteArray: (bytes := bits / 8).	file		maRead: bytes		bytesFromPosition: 1		of: address		atFilePosition: anInteger.	^address		maUint: bits		at: 0! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 5/16/2007 10:19'!uint: bits at: filePointer put: anInteger 	| ba bytes |	ba := self usedByteArray: (bytes := bits / 8).	ba 		maUint: bits		at: 0		put: anInteger.	file 		maWrite: bytes		bytesFromPosition: 1		of: ba		atFilePosition: filePointer! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/16/2002 00:08'!usedByteArray: size	^usedByteArrays at: size! !!MaObjectFiler methodsFor: 'private' stamp: 'kph 6/18/2007 12:17'!version: anInteger	self		primitiveAttributeAt: #version		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 1/19/2005 15:40'!write: aMaObjectBuffer at: filePosition	"Note that the oid is stored in the filePositionsIndex, so there is no need to store it in the data file too.  The oid is the first 8-bytes of the buffer."	file		maWrite: aMaObjectBuffer numberOfBytesToStore		bytesFromPosition:			aMaObjectBuffer startPos + aMaObjectBuffer bufferPositionOfBytesToStore		of: aMaObjectBuffer byteArray		atFilePosition: filePosition! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 1/25/2005 14:10'!appendObject: oidInteger into: aMaSerializedGraphBuffer	"Read a single object into aMaSerializedGraphBuffer and adjust its bufferSize accordingly."	| buffer |	preMadeObjectBuffer		byteArray: aMaSerializedGraphBuffer byteArray;		startPos: aMaSerializedGraphBuffer bufferSize.	self		append: preMadeObjectBuffer		to: aMaSerializedGraphBuffer		withDataAt: (self filePointerForOid: oidInteger).	buffer := preMadeObjectBuffer asSentientBuffer.	"Set oid only after append because that is where the need for growth is checked."	buffer oid: oidInteger.	^buffer! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 9/24/2004 13:22'!close	file ifNotNil:		[ file closed ifFalse: [ file close ].		file := nil ].	filePositionIndex ifNotNil:		[ filePositionIndex close.		filePositionIndex := nil ]! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 12/2/2004 13:45'!index: oidInteger at: filePositionInteger	^filePositionIndex		at: (MaOidCalculator indexPositionForOid: oidInteger)		put: filePositionInteger! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 2/21/2008 12:04'!validateSignature	self signature = MaObjectRepository recognitionSignature ifFalse: 		[ MagmaUserError signal: 'This does not appear to be a Magma database.' ]! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 1/25/2013 09:55'!validateVersion	"14 requires an upgrade using the Magma upgrader package."	self version = 14 ifFalse:		[ | msg |		msg := 'This database requires Magma version ' , self version printString , '.  You are running version ' , MagmaSession magmaVersion printString.		({12. 		13} includes: self version)			ifTrue: 			[ "This warning is handled by the MagmaUpgrader, so the user should not see it.  If they do, the message is correct."			MagmaWarning signal: msg , '  You are not running the Magma Upgrader, so you must select Abandon.' ]			ifFalse:				[ ({MagmaSession magmaVersion. 16} includes: self version) ifFalse: [ MagmaUserError signal: msg ] ] ]! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 1/16/2014 16:54'!write: aMaObjectBuffer index: aBoolean 	"write a single object encapsulated by aMaObjectBuffer."	| filePosition |	filePosition := aBoolean		ifTrue:			[ self								prewriteAdjustmentTo: aMaObjectBuffer				from: nil ;								index: aMaObjectBuffer oid				at: file size ]		ifFalse:			[ | pos |			pos := self filePointerForOid: aMaObjectBuffer oid.			aMaObjectBuffer canGrow				ifTrue:					[ self						recordSampleAt: pos						do:							[ : existingBuffer | self								prewriteAdjustmentTo: aMaObjectBuffer								from: existingBuffer.							existingBuffer physicalSize = aMaObjectBuffer physicalSize								ifTrue: [ pos ]								ifFalse:									[ self										index: aMaObjectBuffer oid										at: file size ] ] ]				ifFalse: [ pos ] ].	self		write: aMaObjectBuffer		at: filePosition! !!MaObjectFiler methodsFor: 'debugging' stamp: 'cmm 3/26/2007 23:09'!bufferFor: oidInteger 	| buffer |	buffer := MaSerializedGraphBuffer new: 400.	self 		appendObject: oidInteger		into: buffer.	^ buffer rootBuffer trimByteArray! !!MaObjectFiler methodsFor: 'debugging' stamp: 'cmm 12/3/2014 10:44'!validateSpecialOid: selectorSymbol 	((self perform: selectorSymbol) 		between: FirstUserObjectOid		and: FirstUserObjectOid + 10000) ifFalse: 		[ MagmaCorruptionError signal: 'The ' , selectorSymbol , ' does not appear valid' ]! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 7/5/2005 23:39'!filesDo: twoArgBlock	twoArgBlock		value: file 		value: MaApplyRecord objectsFileId.	filePositionIndex filesDo:		[ : each |		twoArgBlock			value: each			value: MaApplyRecord filePositionsFileId ]! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 6/5/2005 18:24'!unapplyFilePositionsFileUsing: aMaApplyRecord	filePositionIndex unapplyUsing: aMaApplyRecord! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 4/10/2007 22:35'!unapplyObjectsFileUsing: aMaApplyRecord 	aMaApplyRecord unapplySelf: file! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 6/13/2005 21:50'!unapplyUsing: aMaApplyRecord	"Reapply the contents of aMaBeforeImageRecord to the file it came from."	aMaApplyRecord fileId		caseOf:			{ [ MaApplyRecord objectsFileId ] -> [ self unapplyObjectsFileUsing: aMaApplyRecord ].			[ MaApplyRecord filePositionsFileId ] -> [ self unapplyFilePositionsFileUsing: aMaApplyRecord ] }		otherwise:			[ MagmaSoftwareError signal: 'unknown fileId' ]! !!MaObjectFiler methodsFor: 'utilities' stamp: 'cmm 12/3/2014 10:43'!objectBuffersDo: oneArgBlock 	FirstUserObjectOid 		to: self getNextOid		do: 			[ : eachOid | 			| buffer |			[ buffer := self bufferFor: eachOid.			oneArgBlock value: buffer ] 				on: MagmaInvalidOid				do: [ : err |  ] ]! !!MaObjectFiler methodsFor: 'utilities' stamp: 'cmm 8/10/2010 20:52'!objectFileOnlyBuffersDo: oneArgBlock 	| graphBuffer nextStart oidSize |	oidSize := MaObjectBuffer oidSize / 8.	nextStart := self class sizeOfEmptyRepository.	[ nextStart < file size ] whileTrue:		[ graphBuffer := MaSerializedGraphBuffer new: 400.		preMadeObjectBuffer			 byteArray: graphBuffer byteArray ;			 startPos: graphBuffer headerSize.		self			append: preMadeObjectBuffer			to: graphBuffer			withDataAt: nextStart.		oneArgBlock value: graphBuffer.		nextStart := nextStart + preMadeObjectBuffer physicalSize - oidSize ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectFiler class	instanceVariableNames: ''!!MaObjectFiler class methodsFor: 'creation' stamp: 'cmm 9/24/2004 12:52'!create: aFileDirectory	^ self new create: aFileDirectory! !!MaObjectFiler class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:23'!open: aFileDirectory	^ self new		directory: aFileDirectory ;		open ;		yourself! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 4/28/2005 11:36'!maxDbSize	"Answers the maximum size of a Magma database as a power of 2.  Hmm, wow, 281 Terabytes huh..  This seems to be beyond any practical limits for a single repository; at least in year 2005, so we'll go with this for now."	^ 48! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 5/10/2005 19:04'!objectPointersFilename	^ 'objects.idx'! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 4/23/2007 00:49'!objectsFilename	^ 'objects.dat'! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 4/23/2007 15:08'!objectsPhysicalFilename	"Since we're using MaTransactionalFileStreams, they also save multiple numbered files, so that unlimited repository sizes are possible."	^ 'objects.1.dat'! !!MaObjectFiler class methodsFor: 'accessing'!sizeOfEmptyRepository	"Answer in bytes."	^1024! !MaObject subclass: #MaObjectRepository	instanceVariableNames: 'transactionLog sessions filer repositoryController largeCollectionManagers systemReadStrategy nextOid recoveryManager commitGuard applyProcess wantsToClose filePool flushGuard restoreMode'	classVariableNames: 'EmergencyMemory SimulateOutage'	poolDictionaries: 'MaSerializerConstants'	category: 'Magma-Server-private'!!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 1/18/2005 22:39'!abortTransactionFor: sessionId	^ transactionLog 		abortTransactionEntryFor: sessionId		repository: self! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 3/14/2009 17:17'!commitRecordAt: startNumber 	"Answer the CommitLogRecord for startNumber."	^ (self 		commitRecordsFrom: startNumber		to: startNumber) ifNotEmptyDo: [ : arr | arr first ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 3/14/2009 16:41'!commitRecordsFrom: startNumber 	"Answer a collection of MaCommitLogEntry which clients use to advance their image."	^ self 		commitRecordsFrom: startNumber		to: 281474976710655	"The maximum possible commitNumber."! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 2/27/2016 23:01'!commitRecordsFrom: startNumber to: endNumber 	"Answer a collection of MaCommitLogEntry which clients use to advance their image."	| startTime size answer |	answer := OrderedCollection new.	startTime := Time millisecondClockValue.	size := 0.	recoveryManager		commitLogRecordsFrom: startNumber		do:			[ : each | size := size + each record size.			answer add: each independentCopy ]		until:			[ : each | answer notEmpty and:				[ (Time millisecondsSince: startTime) > 3000 or: [ each commitNumber >= endNumber or: [ size > 50000000 "50MB worth of updates at a time should be enough!!" ] ] ] ].	^ answer asArray! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/31/2013 18:22'!connectionsList	^ Array streamContents:		[ : stream | self sessions do:			[ : each | each isSystem ifFalse:				[ stream					 nextPut: each informationalCopy ;					 yourself ] ] ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 8/6/2006 18:32'!getTrunkFor: collectionOid expression: aMaTerm 	| executor |	executor := MaQueryExecutor 		collectionManager: (self collectionManagerFor: collectionOid)		expression: aMaTerm.	^ executor trunk! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 4/13/2006 17:11'!numberOfEntriesFrom: lowKeyInteger to: highKeyInteger inLargeCollection: collectionOid on: attributeSymbol 	| index |	index := (self collectionManagerFor: collectionOid) 		oidsIndexForAttribute: attributeSymbol.	^ index 		numberOfEntriesFrom: lowKeyInteger		to: highKeyInteger! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/6/2007 01:28'!read: oidInteger for: sessionId using: aMaReadStrategy 	| result |	self commitCritical: 		[ result := MaReadResult byteArray: 			(self 				byteArrayAt: oidInteger				using: (self 						ensureReadStrategy: aMaReadStrategy						forSession: sessionId)).		self 			renewServerNotificationsIn: result			for: sessionId ].	^ result! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 2/16/2015 21:39'!readAnchorFor: sessionId using: aMaReadStrategy 	^ self		read: filer anchorOid		for: sessionId		using: aMaReadStrategy! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/10/2009 16:33'!refreshAll: oidsCollection for: sessionId 	"We will use a minimal strategy because we really just want exactly the buffers requested.  So save whatever the sessions current strategy."	| answer sessionReadStrategy minimalStrategy |	sessionReadStrategy := (self sessionWithId: sessionId) currentReadStrategy.	minimalStrategy := MaBasicReadStrategy minimumDepth: 0.	answer := Array streamContents: 		[ : stream | 		oidsCollection do: 			[ : eachRequestedOid | 			(MaOidCalculator isOidForUserObject: eachRequestedOid) ifTrue: 				[ stream nextPut: 					(MaSerializedGraphBuffer byteArray: 						(self 							read: eachRequestedOid							for: sessionId							using: minimalStrategy) byteArray) ] ] ].	"Now restore the readStrategy to whatever it was."	(self sessionWithId: sessionId) currentReadStrategy: sessionReadStrategy.	^ answer! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 11/12/2007 22:28'!refreshSegmentIn: aMaRefreshSegmentRequest 	(self collectionManagerFor: aMaRefreshSegmentRequest collectionOid) 		load: aMaRefreshSegmentRequest segment		upTo: (aMaRefreshSegmentRequest quantity min: 10000)		where: aMaRefreshSegmentRequest expression		withObjects: aMaRefreshSegmentRequest loadObjects		except: aMaRefreshSegmentRequest exceptions.	aMaRefreshSegmentRequest segment 		collectBuffers: aMaRefreshSegmentRequest sessionId		from: self		using: aMaRefreshSegmentRequest readStrategy.	self 		renewServerNotificationsIn: aMaRefreshSegmentRequest segment		for: aMaRefreshSegmentRequest sessionId.	^ aMaRefreshSegmentRequest segment! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 12/18/2008 20:50'!removeSessionFor: sessionId 	| clientConnection |	clientConnection := sessions 		removeKey: sessionId		ifAbsent: 			[ "Perhaps the other session suddenly disconnected..?"			 ].	clientConnection ifNotNil: 		[ clientConnection maClientConnection ifNotNilDo: [ : cc | cc shouldContinue: false ] ].	transactionLog 		removeEntryForSessionId: sessionId		ifAbsent: 			[ "Perhaps the other session suddenly disconnected..?"			 ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 1/8/2009 19:02'!renewTransactionEntryFor: sessionId 	^ transactionLog 		renewTransactionEntryFor: sessionId		repository: self! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 6/14/2005 17:30'!sizeOfLargeCollection: oidInteger	^ (self collectionManagerFor: oidInteger) size! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 1/17/2014 16:15'!submitAll: aMaCommitPackage for: sessionId beginAnother: aBoolean 	"Save all of the serialized objects in aMaCommitPackage to the repository.	If any of the objects in aMaCommitPackage have been changed by other transactions, signal a commit failure."	| entry |	self restoreMode ifTrue: 		[ MagmaUserError signal: 'Commits are not allowed because this repository is in restoreMode.' ].	entry := transactionLog 		renewEntryFor: sessionId		withNew: (aBoolean 				ifTrue: [ MaCommitLogEntry ]				ifFalse: [ MaTransactionLogEntry ])		for: self.	entry isCommitEntry ifFalse: 		[ (MagmaNoTransactionError result: entry result) signal: 'No commit-entry on server.' ].	entry		determineResultFor: aMaCommitPackage			using: self ;		initializeChallengers.	"No need for these challengers anymore, delete them, save memory."	entry result hasConflicts 		ifTrue: 			[ (MagmaCommitConflictError result: entry result ) signal ]		ifFalse: 			[ entry commitPackage: aMaCommitPackage.			self write: entry ].	(sessionId ~= repositoryController sessionId and: [ transactionLog isFirstEntryFor: repositoryController sessionId ]) ifTrue: [ repositoryController refreshView ].	^ entry result! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 4/12/2006 21:14'!upTo: anInteger oidsFromIndex: startIndex inLargeCollection: collectionOid using: aMaReadStrategy forSession: sessionId 	| segmentResult |	segmentResult := (self collectionManagerFor: collectionOid) 		upTo: anInteger		inSegmentFromIndex: (startIndex max: 1).	segmentResult 		collectBuffers: sessionId		from: self		using: aMaReadStrategy.	self 		renewServerNotificationsIn: segmentResult		for: sessionId.	^ segmentResult! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 3/3/2009 16:53'!applyCommitRecords: commitRecords 	"Private - apply commitRecords to this repository."	| branchCode |	branchCode := self branchCode.	self flushCritical: 		[ commitRecords do: 			[ : each | 			| commitLogEntry |			commitLogEntry := self recoveryManager materializeCommitLogEntryIn: each.			"Note, we've already validated our branchCode (the sender of this method), so if we notice a change in the branchCode in a commit-log, we can safely assume the repository branched at that point, therefore we can update our branchCode."			branchCode = each branchCode ifFalse: 				[ branchCode := each branchCode.				self branchCode: branchCode ].			self 				write: commitLogEntry				logged: true				commitLogRecord: each.			self session advanceWith: commitLogEntry ] ].	^ branchCode! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 11/15/2008 11:34'!beginRestore	"Set my restoreMode bit, indicating I can only receive commitLogRecords in order from the primary.  This should only be done in conjunction with a corresponding change in the Node."	self restoreMode 		ifTrue: [ MagmaUserError signal: 'Already in restoreMode' ]		ifFalse: [ self restoreMode: true ]! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 2/7/2013 19:36'!catch: thisBackupLocation upTo: primaryLocation 	"Request batches of commit-log records and apply them to my repository.  When this method finishes successfully I will be caught up and the primary will be sending me the updates automatically."	| session |	session := primaryLocation newAdminSession.		[ 	[ 	[ | serverResponse commitRecords done cn |	repositoryController requestCritical: 		[ serverResponse := session 			warmBackupUpdatesFrom: (cn := self commitNumber + 1)			for: thisBackupLocation.		done := serverResponse value.		commitRecords := serverResponse key.		MagmaNotification signal: 'Catching up from primary, commitNumber:  ', cn asString.		self applyCommitRecords: commitRecords.		done ] ] whileFalse ] 		on: MagmaUnavailableCommitRecord		do: 			[ : err | 			"The warm backup must be re-established, page the DBA?"			"pass the buck for now"			err pass ] ] ensure: [ session ifNotNil: [ session disconnect ] ]! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 3/3/2009 21:12'!commitRestore	"Do NOT use this unless you know what you are doing, use the public API only.  Set whether the receiver is operating in restoreMode.  Warm backups operate in restoreMode, taking commits broadcasted to them from the 'primary' and applying them."	self restoreMode 		ifTrue: 			[ self				restoreMode: false ;				initializeBranchCode ]		ifFalse: [ MagmaUserError signal: 'Not in restore mode!!' ]! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 11/23/2008 12:38'!initializeBranchCode	filer initializeBranchCode.	recoveryManager ifNotNil: [ recoveryManager branchCode: filer branchCode ]! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 11/14/2008 13:18'!restoreMode: aBoolean 	filer restoreMode: aBoolean.	restoreMode := aBoolean! !!MaObjectRepository methodsFor: 'high-availability' stamp: 'cmm 11/13/2008 20:57'!sendToWarmBackups: aMaCommitLogRecord 	"Update my warmBackups with aMaCommitLogEntry."	repositoryController node secondaryLocationsDo: 		[ : each | 		"Asynchronous request!!  Only a send error will detect a problem."		[ (self node sessionFor: each) write: aMaCommitLogRecord ] 			on: NetworkError "this is a send-only request, there will be no response and no server-generated error (i.e., we can't handle MagmaWrongCommitNumber)."			do: [ : err | MagmaNodeUpdate signalRemove: each ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/9/2014 15:57'!applyToCache: trimmedCommitLogEntry 	| newObjects buffersToRefresh |	newObjects := trimmedCommitLogEntry result newObjectBuffers.	trimmedCommitLogEntry commitPackage objectsDo:		[ : eachBuffer | filer			write: eachBuffer			index: (newObjects includesKey: eachBuffer oid) ].	"If writing regular objects caused any new LargeCollections we need to refresh my sessions view of the repository so I know about those collections because I'm about to update them, except of course unless trimmedCommitLogEntry is for the servers session."	(trimmedCommitLogEntry isSystem not and: [ trimmedCommitLogEntry shouldServerRefresh ]) ifTrue:		[ repositoryController refreshView.		buffersToRefresh := self postWriteAdjustmentFor: trimmedCommitLogEntry ].	self		updateLargeCollectionsIn: trimmedCommitLogEntry commitPackage		recordResultsIn: trimmedCommitLogEntry result.	filer commitNumber: recoveryManager commitNumber.	^ buffersToRefresh ifNil: [ Array empty ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 7/8/2009 21:07'!challengeOthersWith: aMaCommitLogEntry 	| entriesToRemove |	entriesToRemove := transactionLog 		challenge: self restoreMode not		entriesWith: aMaCommitLogEntry.	entriesToRemove ifNotNil: 		[ entriesToRemove do: 			[ : each | 			each isSystem 				ifTrue: [ repositoryController refreshView ]				ifFalse: [ self removeSessionFor: each sessionId ] ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 7/5/2005 12:36'!commitCritical: aBlock	^ commitGuard critical: aBlock! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 5/21/2007 00:08'!create: aFileDirectory 	filer := MaObjectFiler create: aFileDirectory.	self postOpenInitialize! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 9/25/2014 15:59'!freeSomeSpace	self class freeSomeSpace! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/31/2017 19:33'!freeSomeSpaceIfNecessary: sessionId 	| totalFreed count |	totalFreed := count := 0.	"Free SockeStream buffers first, then, only if enough could not be retcovered, start terminating sessions.."	(EmergencyMemory isEmpty or: [ self isLowOnMemory ]) ifTrue:		[ transactionLog entriesDo:			[ : each | each connection isRemote ifTrue: [ each resetSocketStreamBuffer ].			Smalltalk garbageCollect.			self isLowOnMemory ifFalse: [ ^ self ] ] ].	[ (EmergencyMemory isEmpty or: [ self isLowOnMemory ]) and: [ transactionLog numberOfEntries > 1 ] ] whileTrue:		[ | oldestEntry |		oldestEntry := transactionLog removeOldestEntryExceptFrom: sessionId.		oldestEntry notNil and:			[ totalFreed := totalFreed + oldestEntry bytesConsumed.			count := count + 1 ].		Smalltalk garbageCollect.		(totalFreed > 50 million and: [ EmergencyMemory isEmpty ]) ifTrue: [ self reserveEmergencySpace ] ].	count > 0 ifTrue:		[ MagmaServerLowOnMemoryNotification signal: count asString , ' sessions terminated to recover ' , totalFreed asBytesDescription , ' of server memory.'.		self isOpen ifFalse: [ self unregisterAsMemoryHog ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 5/27/2007 15:19'!initializeNextOid	"Initialize it to the current-highest oid, because we always incrmement it when getting it."	nextOid := filer getNextOid - 1! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 8/30/2010 17:17'!open: aFileDirectory 	[ filer := MaObjectFiler open: aFileDirectory.	filer validateVersion ] ifCurtailed:		[ self close.		^ self ].	self postOpenInitialize! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 8/3/2007 13:00'!postOpenInitializeRecoveryManager	recoveryManager		commitNumber: filer commitNumber ;		branchCode: filer branchCode! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/14/2014 11:16'!postWriteAdjustmentFor: trimmedCommitLogEntry 	"Adding the very first MagmaStat to a repository, that class will not have been known until AFTER the normal write, but that means we won't have performed the prewriteAdjustmentTo:from: on it!!  So, we have to go back to write it one more time to capture that adjustment and write the object properly."	^ self initializeMagmaStatClassIds ifNotEmpty:		[ : classIdsOfBuffersNeedingRewritten | Array streamContents: [ : stream | trimmedCommitLogEntry commitPackage objectsDo:			[ : eachBuffer | (classIdsOfBuffersNeedingRewritten includes: eachBuffer classId) ifTrue:				[ filer					write: (stream nextPut: eachBuffer copyWithSameBuffer)					index: false] ] ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 6/1/2007 14:13'!queueForDelete: aMaAtomicFileStream 	"When removing indexees, we actually remove the supporting file.  However, we don't want to do that until the commit actually succeeds.  Therefore, we a queue the files to deleted until the commit succeeds, then we delete it."	recoveryManager queueForDelete: aMaAtomicFileStream! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 4/28/2003 23:51'!renewCurrentReadStrategy: aMaReadStrategy for: sessionId	| session |	session := self sessionWithId: sessionId.	aMaReadStrategy ifNotNil: [ session currentReadStrategy: aMaReadStrategy ].	^session currentReadStrategy! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 11/5/2008 15:51'!renewServerNotificationsIn: aMagmaServerResult for: sessionId 	self 		renewServerNotificationsIn: aMagmaServerResult		from: (transactionLog entryFor: sessionId)! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 6/28/2009 19:33'!renewServerNotificationsIn: aMagmaServerResult from: aMaTransactionLogEntry 	aMagmaServerResult serverNotifications: aMaTransactionLogEntry renewServerNotifications.	aMagmaServerResult serverNotifications keysAndValuesDo: 		[ : eachKey : eachSet | 		aMagmaServerResult serverNotifications 			at: eachKey			put: (eachSet asArray collect: 				[ : eachOid | 				self 					byteArrayAt: eachOid					using: MaReadStrategy deep ]) ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 2/25/2013 10:25'!validate: aMaCommitLogRecord with: aMaCommitLogEntry 	aMaCommitLogRecord ifNotNil: [ recoveryManager validateRecord: aMaCommitLogRecord ].	self		validateCommitNumber: aMaCommitLogRecord		with: aMaCommitLogEntry.	self validateMagmaArrayChangesIn: aMaCommitLogEntry! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 9/24/2009 10:28'!validateCommitNumber: aMaCommitLogRecord with: aMaCommitLogEntry 	aMaCommitLogRecord ifNotNil: 		[ "I could be a warm backup receiving previously-written commit-log entries.  Be absolutely positive it is the correct one!!"		aMaCommitLogEntry result commitNumber = (self commitNumber + 1) ifFalse: 			[ MagmaWrongCommitNumber new				expectedCommitNumber: self commitNumber + 1 ;				signal ].		aMaCommitLogRecord branchCode ~= filer branchCode ifTrue: [ MagmaDifferentBranch signal ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/8/2014 21:54'!write: aMaCommitLogEntry 	self commitCritical: 		[ aMaCommitLogEntry			registerUsing: self ;			link ;			recordUsing: self.		self 			write: aMaCommitLogEntry			logged: true			commitLogRecord: nil ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 4/8/2015 20:06'!write: aMaCommitLogEntry logged: shouldLog commitLogRecord: aMaCommitLogRecord 	"This is the main 'write' logic for Magma.  It is used for 1) regular commits, 2) recovering from records in the commits.log file and, 3) updating warm backups.  Case 1 will pass a non-trimmed aMaCommitLogEntry and NO aMaCommitLogRecord (nil).  Cases 2 and 3 will pass a trimmed MaCommitLogEntry and the MaCommitLogRecord it was materialized from."	| trimmedEntry commitLogRecord extraBuffersToRefresh |	self 		validate: aMaCommitLogRecord		with: aMaCommitLogEntry.	"I could be a warm backup receiving previously-written commit-log entries.  Be absolutely positive it is the correct one!!"	recoveryManager nextCommitNumber.	self challengeOthersWith: aMaCommitLogEntry.	"If aMaCommitLogRecord is specified (notNil), then we know aMaCommitLogEntry is already a trimmedCopy, otherwise aMaCommitLogEntry is for a new commit."	trimmedEntry := aMaCommitLogRecord 		ifNil: 			[ aMaCommitLogEntry commitNumber: recoveryManager commitNumber.			aMaCommitLogEntry trimmedCopy ]		ifNotNil: [ aMaCommitLogEntry ].	commitLogRecord := aMaCommitLogRecord ifNil: [ recoveryManager newCommitLogRecordFor: trimmedEntry ].	"Don't log when we're *reading* from the log file to recover!!  Nor should we send anything off to warm-backups.  Those will be caught up afterward."	shouldLog ifTrue: 		[ "To test rollback-recovery, we cannot log the commits because, even though the files are rolled back, they would then be forward-recovered to include the commitDisaster commit!!  We cannot allow this because we compare the file hashes after the rollback."		SimulateOutage ifFalse: 			[ self restoreMode ifFalse: 				[ "The recovery in an on-line system will be from the warm-backups.  Therefore send off to the warmBackups first so they have the best chance of being up to date."				self sendToWarmBackups: commitLogRecord ].			recoveryManager log: commitLogRecord ] ].	extraBuffersToRefresh := self applyToCache: trimmedEntry.	extraBuffersToRefresh do: [ : each | aMaCommitLogEntry refreshIfCountersOrStat: each using: self ].	self		initializeNextOid ;		flushCacheSoon	"needed after recovery, doesn't hurt regular commits"! !!MaObjectRepository methodsFor: 'backup / restore' stamp: 'cmm 8/1/2007 22:16'!archiveCommitLog	recoveryManager archiveCommitLog! !!MaObjectRepository methodsFor: 'backup / restore' stamp: 'cmm 8/3/2007 11:02'!deleteUnnecessaryCommitLogs	recoveryManager deleteUnnecessaryCommitLogFiles ! !!MaObjectRepository methodsFor: 'backup / restore' stamp: 'cmm 6/6/2007 22:46'!flushCritical: aBlock	^ flushGuard critical: aBlock! !!MaObjectRepository methodsFor: 'backup / restore' stamp: 'cmm 8/2/2007 00:16'!logArchiveFrequency	"Answer the frequency which commit.log files are closed and a new one started.  Commit log files are used to apply to a backup to bring it up to date."	^ recoveryManager logArchiveFrequency! !!MaObjectRepository methodsFor: 'backup / restore' stamp: 'cmm 8/2/2007 00:16'!logArchiveFrequency: aDuration 	"Override the default frequency which commit.log files are closed and a new one started.  Commit log files are used to apply to a backup to bring it up to date with the latest commits since that backup."	recoveryManager logArchiveFrequency: aDuration! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 11/18/2008 12:54'!branchCode	"The branchCode is a randomly-generated number used to prevent accidentally applying the wrong commit-logs to a repository.  When performing a forward recovery, each CommitLogRecord's #branchCode must match mine.  Every time a commitRestore is performed, this branchCode is updated to a new number."	^ filer branchCode! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 2/27/2009 15:31'!branchCode: anInteger 	"Private - Do not update the branchCode from outside!!"	filer branchCode: anInteger.	recoveryManager ifNotNil: [ recoveryManager branchCode: anInteger ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 3/19/2005 10:59'!byteArrayAt: oidInteger using: aMaReadStrategy	^ (MaOidCalculator isOidForUserObject: oidInteger)		ifTrue:			[ (self				graphBufferAt: oidInteger				using: aMaReadStrategy) trimmedByteArray ]		ifFalse:			[ "When could this happen?  (Sigh), when they put an atomic in a MagmaLargeCollection."			(self session serializer serializeGraph:				(MaOidCalculator					objectWithOid: oidInteger					ifNone: [ MagmaSoftwareError signal: 'unknown oid' ])) trimmedByteArray ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:41'!classDefinitionsByteArray	"When initially creating the repository, before even the system root is	written, the classDefinitionsOid will be a new-object oid."	| loid |	^MaOidCalculator oidForNil = (loid := filer classDefinitionsOid)		ifTrue:			[ (self serverSerializer serializeGraph: repositoryController definition classDefinitions) trimmedByteArray ]		ifFalse:			[ self				byteArrayAt: loid				using: MaBasicReadStrategy deep "we need it all" ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 4/26/2007 23:38'!collectionFilenameFor: aMaLargeCollection	^ self directory fullNameFor:		(String streamContents:			[ : stream |			stream				print: (self session oidFor: aMaLargeCollection) ;				nextPutAll: '-members.' ;				nextPutAll: aMaLargeCollection implementationClass suggestedFileExtension ])! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:52'!commitNumber	^ filer commitNumber! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 3/18/2011 12:34'!definitionByteArray	| oid |	^ MaOidCalculator oidForNil = (oid := filer definitionOid)		ifTrue:			[ (self serverSerializer serializeGraph: repositoryController definition) trimmedByteArray ]		ifFalse:			[ self				byteArrayAt: oid				using: systemReadStrategy ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 9/24/2004 15:42'!directory	^ filer directory! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 10/22/2006 15:39'!filePool	^ filePool! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 10/22/2006 21:39'!filePoolSize: anInteger 	"Set the maximum number of simultaneously-open files that Magma will have."	anInteger < 4 ifTrue: [ MagmaUserError signal: 'Magma requires at least 4 open files.' ].	filePool maxSize: anInteger - 4	"-4 : 1 for objects file, 1 for file-positions index, 2 for recovery files."! !!MaObjectRepository methodsFor: 'accessing'!filer	^filer! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:25'!getNextOid	^nextOid := nextOid + 1! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 10/8/2014 19:42'!graphBufferAt: oidInteger using: aMaReadStrategy 	"Answers a MaSerializedGraphBuffer."	| answer rootBuffer |	answer := MaSerializedGraphBuffer new: 400.	rootBuffer := filer		appendObject: oidInteger		into: answer.	rootBuffer		appendGraphUsing: aMaReadStrategy		into: answer		currentDepth: 1		minDepth: aMaReadStrategy minimumDepth		with: (PluggableSet integerSet add: oidInteger; yourself)		filer: filer.	^ answer! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 5/30/2007 21:38'!initializeSystemReadStrategyUsing: aMaClassIdManager 	"The object and its immediate variables"	systemReadStrategy := MaReadStrategy minimumDepth: 1.	systemReadStrategy makeReadyForUseUsing: aMaClassIdManager! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 11/1/2004 10:23'!isOpen	^ filer notNil and: [ filer isOpen ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 11/13/2008 10:33'!node	^ repositoryController node! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:29'!objectFileSize	^filer objectFileSize! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/3/2014 10:45'!oidCount	"The number of oids allocated by this repository.  The total number of objects ever committed, even if some have since been garbage-collected."	^ nextOid - FirstUserObjectOid! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 3/17/2010 21:22'!primitiveAttributes	"Answer a Dictionary of the primitiveAttributes of my filer (with special logic for exploding the single #booleanFlags attribute to all of its logical boolean attributes we really care about)."	| answer |	answer := Dictionary new.	filer primitiveAttributeAddressesMap keysDo: 		[ : key | 		key isSymbol ifTrue: 			[ | desiredKeys |			desiredKeys := key = #booleanFlags 				ifTrue: 					[ {  #restoreMode  } ]				ifFalse: 					[ {  key  } ].			desiredKeys do: 				[ : eachDesiredKey | 				answer 					at: eachDesiredKey					put: (filer perform: eachDesiredKey) ] ] ].	^ answer! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/8/2005 17:16'!repositoryController	^ repositoryController! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/31/2002 12:56'!serverSerializer	^repositoryController serverSerializer! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/31/2002 12:55'!session	^repositoryController session! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 2/8/2009 19:22'!sessionWithId: aUuid 	^ self 		sessionWithId: aUuid		ifAbsent: [ MagmaSessionLost signal ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 2/8/2009 19:22'!sessionWithId: aUuid ifAbsent: aBlock 	^ sessions 		at: aUuid		ifAbsent: aBlock! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 5/2/2003 15:05'!sessions	^sessions! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 2/8/2009 19:26'!systemReadStrategy: aMaReadStrategy	systemReadStrategy := aMaReadStrategy! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:02'!version	^filer version! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/4/2006 16:20'!wantsToClose	^ wantsToClose ! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 8/13/2007 22:22'!captureBeforeImages	"Capture a current description of the actual files in the places where we intend to change them.  We capture whether a file is new, whether it will be extended in length, and what file positions will be overwritten and what contents are there presently."	self openDbFilesDo: 		[ : eachAtomicFileStream : eachFileId | 		recoveryManager 			writeRollbackRecordsFor: eachAtomicFileStream			fileId: eachFileId ].	recoveryManager flush! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/16/2005 11:04'!fileManagerFor: aMaApplyRecord ifPresent: oneArgBlock ifAbsent: aBlock	| fileManager |	fileManager := aMaApplyRecord fileId		caseOf:			{ [ MaApplyRecord objectsFileId ] -> [ filer ].			[ MaApplyRecord filePositionsFileId ] -> [ filer ] }		otherwise:			[ (self 				collectionManagerFor: aMaApplyRecord collectionOid				ifAbsent: [ ^ aBlock value ]) indexForFileId: aMaApplyRecord fileId ].	^ oneArgBlock value: fileManager! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/5/2008 21:08'!flushCache	"Flush all caches as an uncorruptible unit-of-work.  If this forked code completes all files are flushed.  Should a power outage occur somewhere in the middle, the recovery will reverse what had been written so far."	"Define what we're going to do to (flush) into a block, since we have to determine whether to time it."	| stats |	stats := repositoryController serverStatistics.	stats flushTimeHistory addValue: (Time millisecondsToRun: 			[ recoveryManager beginApply.			self				captureBeforeImages ;				flushIndividualCaches.			SimulateOutage ifTrue: [ self simulateOutage ].			recoveryManager endApply ])! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 8/30/2016 21:25'!flushCacheSoon	"Flushing is horribly expensive, but essential to ensure we can survive a power-outage without corruption.  To balance these opposing forces, we apply and flush only at certain interval, only in the background, only the files that needed flushed, and each file only flushed once."	applyProcess ifNil: 		[ applyProcess := 		[ | startTime |		startTime := Time millisecondClockValue.				[ (Time millisecondsSince: startTime) > (repositoryController cacheFlushFrequency * 1000) or: [ wantsToClose ] ] whileFalse: [ (Delay forSeconds: 1) wait ].		self flushCritical: 			[ self commitCritical: 				[ self flushCache.				applyProcess := nil ] ] ] forkAt: (Processor userInterruptPriority max: Processor activeProcess priority+1).		applyProcess name: 'flush Magma cache' ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 1/2/2009 20:50'!flushIndividualCaches	self openDbFilesDo: [ : eachFile : eachFileId | eachFile maCommit ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 10/26/2006 18:43'!openDbFilesDo: twoArgBlock 	"Value twoArgBlock with each database file and its fileId."	filer filesDo: twoArgBlock.	largeCollectionManagers do: [ : each | each filesDo: twoArgBlock ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/1/2005 23:56'!primitiveRecover	"This is needed in very rare, dire circumstances where the server was actually writing its own system-definition when an outage occurred.  In that case the repository will not even be able to open normally to get to the normal recovery.  That condition is trapped for any Error and sent here to try opening all files in the directory and then doing a normal unapply (rollback).  Theoretically, that should work."	filer ensureFilesOpen.	recoveryManager primitiveRecoverUsing: self! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 10/28/2008 11:27'!recoveryManager	^ recoveryManager ! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 3/2/2009 15:44'!rollbackIfNecessary	recoveryManager isRollbackNeeded ifTrue: 		[ MagmaRepositoryDefinition runningTestCases ifFalse: 			[ MagmaRollbackRecoveryNeeded signal: 'A partially flushed cache has been detected!!  This repository will now be recovered.' ].		recoveryManager rollbackUsing: self	"NOTE:  This replaces me in my repositoryController." ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 3/6/2009 15:52'!rollforwardIfPossible	^ recoveryManager isRollbackNeeded 		ifTrue: 			[ MagmaUserError signal: 'A rollback of the last incomplete commit is still needed.  Cannot roll forward until this is done.' ]		ifFalse: 			[ recoveryManager				reapplyCommitPackagesUsing: self ;				resetApplyFile ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 3/7/2011 18:47'!unapply: aMaApplyRecord 	"Reapply the contents of aMaApplyRecord to the file it came from."	aMaApplyRecord isContentRelated		ifTrue:			[ self				fileManagerFor: aMaApplyRecord				ifPresent:					[ : fileManager | fileManager unapplyUsing: aMaApplyRecord ]				ifAbsent: [ "I don't think we should ever get here now thanks to the new ifFalse: path just recently added.  Before, we could get here if a new file was created (i.e., a new large-collection) but the vm crashed before the writes of the definition occurred; in which case the largeCollectionManager would not be able to be opened."					"It should only be a MaNewFileRecord in that case, so we don't even need to pass a fileStream of any kind.."					aMaApplyRecord unapplySelf: nil ] ]		ifFalse: [ aMaApplyRecord unapplySelf: nil ]! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 8/22/2011 22:35'!close	self isOpen ifFalse: [ ^ self ].	wantsToClose := true.	[ applyProcess notNil and: [ applyProcess isTerminated not ] ] whileTrue: [ (Delay forSeconds: 1) wait ].	[ largeCollectionManagers anySatisfy: [ : each | each isLoading ] ] whileTrue: [ (Delay forMilliseconds: 500) wait ].	self commitCritical: 		[ (self isOpen and: [recoveryManager notNil and: [ self restoreMode not ] ]) ifTrue: [ self flushCritical: [ self flushCache	"just to be sure" ] ] ].	filer ifNotNil: [ filer close ].	largeCollectionManagers do: [ : each | each close ].	recoveryManager ifNotNil: [ recoveryManager close ].	self unregisterAsMemoryHog! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 8/12/2014 12:03'!initialize	super initialize.	transactionLog := MaTransactionLog new.	largeCollectionManagers := Dictionary new.	sessions := Dictionary new.	commitGuard := Mutex new.	flushGuard := Mutex new.	filePool := MaFileStreamPool maxSize: 180.	wantsToClose := false.	self reserveEmergencySpace! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 1/20/2014 20:18'!initializeMagmaStatClassIds	"The filer must know what the classId for MagmaStat and all subclasses are, so it can properly do prewriteAdjustmentTo: bufferBeingCommitted from: thePersistentBuffer."	| ids mustRewrite |	ids := repositoryController session magmaStatClassIds.	mustRewrite := ids difference: filer magmaStatClassIds.	filer magmaStatClassIds addAll: ids.	^ mustRewrite! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 11/26/2011 16:25'!initializeSpecialOidsList	"See MagmaSession>>#handleSpecialOidNotifications:"	| classDefinitions session |	classDefinitions := repositoryController definition classDefinitions.	session := self session.	(session isPersistent: classDefinitions) ifTrue: 		[ transactionLog			onChangeOf: (self session oidFor: repositoryController definition classDefinitions)				clientsShould: #refreshClassDefinitions ;			onChangeOf: (self session oidFor: self node)				clientsShould: #refreshNode ]! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 9/24/2009 18:07'!postOpenInitialize	self initializeNextOid.	recoveryManager := (MaRecoveryManager repository: self)		open: self repositoryController localLocation ;		yourself.	self postOpenInitializeRecoveryManager.	self registerAsMemoryHog! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 7/15/2009 11:32'!registerAsMemoryHog	(Smalltalk memoryHogs includes: self) ifFalse: [ Smalltalk memoryHogs add: self ]! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 9/25/2014 16:00'!reserveEmergencySpace	EmergencyMemory isEmptyOrNil ifTrue: [ EmergencyMemory := String new: 50 million ]! !!MaObjectRepository methodsFor: 'initialize-release' stamp: 'cmm 7/15/2009 11:33'!unregisterAsMemoryHog	Smalltalk memoryHogs 		remove: self		ifAbsent: 			[ "just making sure"			 ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 6/16/2005 10:53'!collectionManagerFor: oidInteger	^ self		collectionManagerFor: oidInteger		ifAbsent:			[ MagmaSoftwareError signal:				'MagmaCollection ' , oidInteger printString ,					' not found.  MaObjectRepository>>collectionManagerFor:' ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 10/25/2006 23:29'!collectionManagerFor: oidInteger ifAbsent: aBlock 	^ largeCollectionManagers 		at: oidInteger		ifAbsent: 			[ | mc |			mc := self session 				objectWithOid: oidInteger				ifAbsent: [ ^ aBlock value ].			self openLargeCollectionIfNecessary: mc ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 5/28/2007 21:21'!hashKeysReferencing: eachOid inIndexesOf: sourceManager using: aMagmaCollectionManager 	| hashesByIndex |	hashesByIndex := OrderedCollection new.	"Normally there will be just one index at this time (building a sort result), but be generic anyway.."	aMagmaCollectionManager collection descriptionsDo:  		[ : each | 		| eachKeysHdx eachHashes |		eachHashes := OrderedCollection new.		eachKeysHdx := sourceManager keysIndexForAttribute: each attribute.		eachKeysHdx 			keysAndValuesFrom: eachOid			startingAt: 1			do: [ : eachOidAgain : eachKeyLocation | eachHashes add: eachKeyLocation ]			until: [ : eachOidAgain : eachKeyLocation | eachOidAgain > eachOid ].		hashesByIndex add: eachHashes ].	^ hashesByIndex! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 1/6/2010 09:30'!loadMemberIndexOf: aMagmaCollectionManager using: aMaTerm from: oidInteger distinct: wantsDistinct 	"Load memberIndex from the results expression aMaTerm."	| executor sourceManager x mcChanges stillDoing nextWriteStop |	sourceManager := self collectionManagerFor: oidInteger.	[ sourceManager isLoading ] whileTrue: [ (Delay forMilliseconds: 500) wait ].	executor := MaQueryExecutor 		collectionManager: sourceManager		expression: aMaTerm.	aMagmaCollectionManager loadExecutor: executor.	x := 1.	nextWriteStop := 50.		[ stillDoing := false.	mcChanges := (MagmaCollectionChanges collection: aMagmaCollectionManager collection)		collectionOid: aMagmaCollectionManager collectionOid ;		yourself.	executor 		trunkFrom: x		do: 			[ : eachKey : eachOid | 			| canPossiblyAdd |			stillDoing := true.			canPossiblyAdd := (wantsDistinct and: 				[ (mcChanges added includesKey: eachOid) or: [ aMagmaCollectionManager memberIndex includesKey: eachOid ] ]) not.			(canPossiblyAdd and: 				[ aMaTerm 					shouldInclude: eachOid					using: sourceManager ]) ifTrue: 				[ | hashesByIndex |				hashesByIndex := self 					hashKeysReferencing: eachOid					inIndexesOf: sourceManager					using: aMagmaCollectionManager.				mcChanges added 					at: eachOid					put: hashesByIndex ].			x := x + 1 ]		until: [ aMagmaCollectionManager shouldStopLoading or: [ x = nextWriteStop ] ].	stillDoing ] whileTrue: 		[ | commitPackage |		commitPackage := MaCommitPackage new			objects: (MaSerializedGraphBuffer new: 4) ;			yourself.		commitPackage addLargeCollectionChanges: mcChanges.		"Spare a potentially skewed read with requestCritical, not just commitCritical"		repositoryController requestCritical: 			[ self session begin.			repositoryController forceWritePackage: commitPackage ].		self flushCacheSoon.		nextWriteStop := nextWriteStop + 50 ].	"Fork the removeManager: to only do it *after* the flush of the transient MaHashIndex file.  That way, the manager will be able to be handled if a request come in before the flush writes out the file."	[ (Delay forMilliseconds: (repositoryController cacheFlushFrequency*1000) + 1000) wait.	self removeManager: aMagmaCollectionManager ] fork! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 10/26/2006 15:09'!registerAndLoad: aMaCommitPackage using: aMaTerm from: oidInteger forSession: sessionId distinct: aBoolean 	| newManager result |	result := self 		registerResultSet: aMaCommitPackage		forSession: sessionId.	newManager := self collectionManagerFor: aMaCommitPackage allLargeCollectionChanges anyOne collectionOid.	newManager loadProcess: (		[ self 			loadMemberIndexOf: newManager			using: aMaTerm			from: oidInteger			distinct: aBoolean ] forkAt: Processor userBackgroundPriority).	newManager loadProcess name: 'loading ' , newManager collectionOid printString.	^ result! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 10/30/2006 11:58'!registerResultSet: aMaCommitPackage forSession: sessionId 	"Write buffers for aMaCommitPackage and its indexes collection so that, in case it becomes persistently referenced."	self session begin.	"Begin a tran to allow the submitAll:for:.."	^ repositoryController forceWritePackage: aMaCommitPackage! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 10/30/2014 10:57'!updateLargeCollectionsIn: aMaCommitPackage recordResultsIn: aMaCommitResult	"The repositoryControllers sessions view of the repository must be completely refreshed, it must know about all new collections."	aMaCommitPackage allLargeCollectionChangesDo:		[ : each |		each isNewCollection			ifTrue:				[ | mc |				mc := 					self session 						objectWithOid: each collectionOid 						ifAbsent:							[ MagmaSoftwareError signal: 'expected to know about MagmaCollection ', each collectionOid, ' here.' ].				(self ensureManagerCreatedFor: mc) createNewLargeCollection ].		each hasAddedIndexes 			ifTrue:				[ (self collectionManagerFor: each collectionOid) createSupplementaryIndexes ] ].	aMaCommitPackage allLargeCollectionChangesDo:		[ :each |		(self collectionManagerFor: each collectionOid)			process: each			recordResultsIn: aMaCommitResult ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 9/24/2009 10:35'!validateMagmaArrayChangesIn: aMaCommitLogEntry 	aMaCommitLogEntry commitPackage allLargeCollectionChanges do: [ : each | each validate ]! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 6/11/2006 21:30'!ensureManagerCreatedFor: aMagmaLargeCollection 	^ largeCollectionManagers 		at: (self session oidFor: aMagmaLargeCollection)		ifAbsentPut: [ aMagmaLargeCollection newManagerUsing: self ]! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 5/14/2005 18:08'!ensureReadStrategy: aMaReadStrategy forSession: sessionId	| strategy |	^(strategy :=		self			renewCurrentReadStrategy: aMaReadStrategy			for: sessionId)				ifNil: [ self systemReadStrategy ] 				ifNotNil: [ strategy ]! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 5/24/2010 16:33'!newSessionFor: userIdString sessionId: aUuid numberOfChallengers: anInteger clientConnection: aMaClientConnection 	"Answer an Array whose first element is the sessionId, second is the classDefinitionsByteArray, third is the RepositoryDefinition byteArray, fourth is a boolean, true if single-user, false if listening on a port."	| connection |	aUuid class = UUID ifFalse: 		[ MagmaSoftwareError signal: 'sessionId is ' , aUuid printString , ' but must be a UUID.' ].	userIdString isString ifFalse: 		[ MagmaSoftwareError signal: 'userId must be a String but is ' , userIdString printString ].	(userIdString = MagmaRepositoryController systemSessionUserId and: [ transactionLog hasAnyEntries ]) ifTrue: 		[ MagmaUserError signal: MagmaRepositoryController systemSessionUserId, ' id is reserved.  Please choose a different connection id.' ].	anInteger isInteger ifFalse: 		[ MagmaSoftwareError signal: 'numberOfChallengers must be an Integer but is ' , anInteger printString ].	aMaClientConnection ifNotNil: 		[ aMaClientConnection class = MaClientConnection ifFalse: 			[ MagmaSoftwareError signal: 'clientConnection must be a MaClientConnection but is ' , aMaClientConnection printString ] ].	(transactionLog hasEntryFor: aUuid) 		ifTrue: 			[ "Be extra safe for now, only a notification."			MagmaNotification signal: 'Potential software error:  Client ' , aUuid asString , ' attempted to connect to the same server even though it was already connected.' ]		ifFalse: 			[ connection := transactionLog 				newSessionFor: userIdString				sessionId: aUuid				numberOfChallengers: anInteger				clientConnection: aMaClientConnection.			sessions 				at: aUuid				put: connection ].	^ (Array new: 4)		at: 1			put: self classDefinitionsByteArray ;		at: 2			put: self definitionByteArray ;		at: 3			put: self commitNumber ;		at: 4			put: self restoreMode not ;		yourself! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 12/18/2008 19:32'!newTransactionFor: sessionUuid 	(transactionLog entryFor: sessionUuid) isCommitEntry ifTrue: [ MagmaAlreadyInTransaction signal: 'Already in a transaction.' ].	^ transactionLog 		newTransactionFor: sessionUuid		repository: self! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 4/17/2010 15:05'!openLargeCollectionIfNecessary: aMagmaLargeCollection 	"Must commit-guard this because I witnessed the flushCache process jumping in between when creating the manager and ensuring it open; the flush process absolutely requires all large-collection managers to be open."	^ self commitCritical: 		[ (self ensureManagerCreatedFor: aMagmaLargeCollection) ensureOpen ]! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 1/5/2010 22:23'!removeManager: aMagmaCollectionManager 	self flushCritical: 		[ self commitCritical: 			[ (largeCollectionManagers 				removeKey: aMagmaCollectionManager collectionOid				ifAbsent: [ nil ]) ifNotNilDo: [ : removed | removed close ] ] ]! !!MaObjectRepository methodsFor: 'building'!repositoryController: aMaRepositoryController	repositoryController := aMaRepositoryController.	aMaRepositoryController repository == self ifFalse: [ aMaRepositoryController repository: self ]! !!MaObjectRepository methodsFor: 'notifications' stamp: 'cmm 11/2/2008 09:39'!informDba: aString 	"Signal DBA notification.."	self halt: 'For informational purposes.  Does not page.'! !!MaObjectRepository methodsFor: 'notifications' stamp: 'cmm 11/2/2008 09:39'!pageDba: aString 	"Signal DBA notification.."	self halt: 'System needs help from the DBA'! !!MaObjectRepository methodsFor: 'notifications' stamp: 'cmm 11/2/2008 09:39'!warnDba: aString 	"Signal DBA notification.."	self halt: 'Warn the DBA of potential trouble'! !!MaObjectRepository methodsFor: 'capacity management' stamp: 'cmm 9/28/2014 20:36'!isLowOnMemory	^ Smalltalk maMemoryAvailable < (MaSerializedGraphBuffer unreasonablePhysicalSize + EmergencyMemory size)! !!MaObjectRepository methodsFor: 'testing' stamp: 'cmm 11/15/2008 11:03'!restoreMode	^ restoreMode ifNil: [ restoreMode := filer restoreMode ]! !!MaObjectRepository methodsFor: 'read strategies' stamp: 'cmm 9/1/2003 19:11'!systemReadStrategy	^systemReadStrategy! !!MaObjectRepository methodsFor: '*magma-tester' stamp: 'cmm 1/6/2010 22:55'!hasCollectionManagerFor: collectionOid 	^ largeCollectionManagers includesKey: collectionOid! !!MaObjectRepository methodsFor: '*magma-tester' stamp: 'cmm 4/10/2015 11:04'!simulateOutage	MagmaTestCase new killVm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectRepository class	instanceVariableNames: ''!!MaObjectRepository class methodsFor: 'creation' stamp: 'cmm 9/24/2004 12:50'!create: aFileDirectory controller: aMaRepositoryController	^ (self new repositoryController: aMaRepositoryController) create: aFileDirectory! !!MaObjectRepository class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:23'!open: aFileDirectory controller: aMaRepositoryController	^self new		repositoryController: aMaRepositoryController ;		open: aFileDirectory ;		yourself! !!MaObjectRepository class methodsFor: 'private' stamp: 'cmm 9/24/2014 15:24'!freeSomeSpace	"Called by LowSpaceWatcher.  See #lowSpaceWatcher."	"lowSpaceWatcher requires SOME space to be freed to avoid the debugger on LowSpaceSignal.  So we free 'someSpace' for now, and I will then see it is empty and free space myself at next opportunity."	EmergencyMemory := String empty.  "<--- This is the 'request' to free some space, it can only be done *between* requests."! !!MaObjectRepository class methodsFor: 'class initialization' stamp: 'cmm 11/7/2008 16:01'!initialize	super initialize.	SimulateOutage := false! !!MaObjectRepository class methodsFor: 'accessing' stamp: 'cmm 5/29/2007 22:35'!oldRecognitionSignature	^ 5191969! !!MaObjectRepository class methodsFor: 'accessing' stamp: 'cmm 4/2/2007 17:38'!recognitionSignature	"('cmmuller' asArray collect: [ : e | e asciiValue * 2 ]) asByteArray maUint: 64 at: 0"	^ 16486227812107868870! !!MaObjectRepository class methodsFor: '*magma-tester' stamp: 'cmm 4/29/2007 15:06'!simulateOutage	^ SimulateOutage! !!MaObjectRepository class methodsFor: '*magma-tester' stamp: 'cmm 6/1/2005 16:13'!simulateOutage: aBoolean	"this will cause the server to exit the Squeak image in the middle of a commit so that the fault-tolerance feature can be tested."	SimulateOutage := aBoolean! !MaObject subclass: #MaQueryExecutor	instanceVariableNames: 'expression collectionManager trunk trunkPosition'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-private'!!MaQueryExecutor methodsFor: 'accessing' stamp: 'cmm 12/26/2009 13:20'!fractionComplete	^ trunkPosition 		ifNil: [ 0 ]		ifNotNil: 			[ | trunkSize |			trunkSize := self trunk trunkSize.			trunkSize = 0 				ifTrue: [ 1 ]				ifFalse: 					[ Fraction 						numerator: trunkPosition						denominator: self trunk trunkSize ] ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 2/19/2008 22:27'!load: aMagmaCollectionSegment upTo: anInteger withObjects: aBoolean except: removedSet 	"Load my segment with up to anInteger oids.  Since we load segments in succession, only capture the answer oids for the page that surrounds targetIndexInteger."	| trunkEndPosition hitCount highestKey endIndex lowestKey |	lowestKey := 1 bitShift: 4096.	highestKey := hitCount := 0.	trunkEndPosition := self 		trunkFrom: aMagmaCollectionSegment trunkStart		do: 			[ : eachKey : eachOid | 			(expression isClause or: 				[ expression 					shouldInclude: eachOid					using: collectionManager ]) ifTrue: 				[ highestKey := eachKey max: highestKey.				lowestKey := eachKey min: lowestKey.				(removedSet includes: eachOid) ifFalse: 					[ hitCount := hitCount + 1.					aBoolean ifTrue: [ aMagmaCollectionSegment addObject: eachKey -> eachOid ] ] ] ]		until: [ hitCount = anInteger ].	endIndex := aMagmaCollectionSegment startIndex + hitCount - 1.	aMagmaCollectionSegment		trunk: self trunk ;		lowestKey: lowestKey ;		highestKey: highestKey ;		trunkEnd: trunkEndPosition.	aMagmaCollectionSegment endIndex: endIndex.	expression isClause 		ifTrue: 			[ aMagmaCollectionSegment lastKnownSize: trunk trunkSize ]		ifFalse: 			[ self 				recordLastKnownSizeOn: aMagmaCollectionSegment				to: endIndex				ifBeyond: trunkEndPosition ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 7/28/2006 14:57'!recordLastKnownSizeOn: aMagmaCollectionReaderSegment to: endIndex ifBeyond: trunkEndPosition 	trunk trunkSize = 0 		ifTrue: 			[ "empty, no possible results"			aMagmaCollectionReaderSegment lastKnownSize: 0 ]		ifFalse: 			[ trunkEndPosition ifNotNil: 				[ aMagmaCollectionReaderSegment lastKnownSize: (trunkEndPosition >= trunk trunkSize ifTrue: [ endIndex ]) ] ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 6/13/2006 13:27'!trunk	^ trunk ifNil: 		[ trunk := MaQueryTrunk new.		expression 			addMinimumEnumerationsTo: trunk			using: collectionManager.		trunk ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 7/26/2006 17:36'!trunkFrom: startPosition do: twoArgBlock until:  conditionBlock	"Enumerate my query-trunk from a particular starting point."	| trunkSearchPosition |	trunkSearchPosition := 1.	trunkPosition := nil.	self trunk trunkDo: 		[ : eachTrunkClause | 		| hdx rangeSize |		hdx := collectionManager oidsIndexForAttribute: eachTrunkClause attribute.		rangeSize := hdx 			numberOfEntriesFrom: eachTrunkClause lowKey			to: eachTrunkClause highKey.		eachTrunkClause lastKnownSize: rangeSize.		"is this NOT the trunk-clause which will contain trunk-position startPosition?"		trunkSearchPosition + rangeSize - 1 < startPosition 			ifTrue: [ trunkSearchPosition := trunkSearchPosition + rangeSize ]			ifFalse: 				[ "trunkSearchPosition is only set to position of the beginning of this clause of the trunk, trunkPosition keeps the actual trunkPosition."				trunkPosition ifNil: [ trunkPosition := startPosition - 1 "start one-back since we pre-increment (because post-increment leaves it advanced one too far)" ].				conditionBlock value ifFalse:					[ hdx 						keysAndValuesFrom: eachTrunkClause lowKey						startingAt: (startPosition - trunkSearchPosition + 1 max: 1)						do: 							[ : eachKey : eachOid | 							trunkPosition := trunkPosition + 1.							twoArgBlock value: eachKey value: eachOid  ]						until: 							[ : eachKey : eachOid | 							conditionBlock value 							or: [ eachKey > eachTrunkClause highKey ] ].					trunkSearchPosition := trunkPosition ] ]. ].	^ trunkPosition! !!MaQueryExecutor methodsFor: 'initializing' stamp: 'cmm 6/11/2006 20:06'!setCollectionManager: aMagmaCollectionManager expression: aMaExpression 	collectionManager := aMagmaCollectionManager.	expression := aMaExpression! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaQueryExecutor class	instanceVariableNames: ''!!MaQueryExecutor class methodsFor: 'create' stamp: 'cmm 6/11/2006 20:06'!collectionManager: aMagmaCollectionManager expression: aMaExpression 	^ self new 		setCollectionManager: aMagmaCollectionManager		expression: aMaExpression! !MaObject subclass: #MaTransactionLog	instanceVariableNames: 'entries specialOids'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-private'!!MaTransactionLog commentStamp: '<historical>' prior: 0!This class resides on the server.!!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 1/8/2009 18:52'!abortTransactionEntryFor: sessionIdInteger repository: aMaObjectRepository 	^ (self 		renewEntryFor: sessionIdInteger		withNew: MaTransactionLogEntry		for: aMaObjectRepository) result! !!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 7/11/2005 15:07'!entriesDo: aBlock	entries do: aBlock! !!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 1/8/2009 18:51'!renewEntryFor: sessionUuid withNew: entryClass for: aMaObjectRepository 	"Gives the session identified by sessionUuid a new TranslactionLogEntry, where its challengers will be accumulated.  The entry prior to replacement is answered."	| entry |	entry := self 		renewEntryFor: sessionUuid		withNew: entryClass		ifAbsent: [ MagmaSessionLost signal ].	aMaObjectRepository 		renewServerNotificationsIn: entry result		from: entry.	entry result		commitNumber: aMaObjectRepository commitNumber ;		oidCount: aMaObjectRepository oidCount.	^ entry! !!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 1/8/2009 18:57'!renewTransactionEntryFor: sessionUuid repository: aMaObjectRepository 	^ (self 		renewEntryFor: sessionUuid		withNew: (self entryFor: sessionUuid) class		for: aMaObjectRepository) result! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 7/15/2009 11:59'!challenge: aBoolean entriesWith: aMaCommitLogEntry 	"We record all objects that were committed to all the entries in the receiver.  Some of the entries are in transaction, some are not.  The ones that are will use aMaCommitLogEntry to verify their commit has no conflicts with this entry.  The ones that are not will use the result of the receiver to know which objects need refreshed."	| entriesToRemove |	entriesToRemove := nil.	self entriesDo: 		[ : each | 		(each isForSameSessionAs: aMaCommitLogEntry) ifFalse: 			[ each hasExcessiveChallengers 				ifTrue: 					[ entriesToRemove ifNil: [ entriesToRemove := OrderedCollection new ].					entriesToRemove add: each ]				ifFalse: 					[ (aBoolean or: [ each isSystem ]) ifTrue: [ each addChallengingEntry: aMaCommitLogEntry ].					each 						recordChangesToSpecialObjectsIn: aMaCommitLogEntry						using: self ] ] ].	^ entriesToRemove! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 9/5/2014 10:36'!removeOldestEntryExceptFrom: sessionId 	"Remove the oldest entry, but not the system session, of course."	^ entries		detect:			[ : each | each isSystem not and: [ each id ~= sessionId ] ]		ifFound:			[ : foundEntry | entries remove: foundEntry ]		ifNone: [  ]! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 11/5/2008 15:55'!renewEntryFor: sessionUuid withNew: aClass ifAbsent: aBlock	"aClass should be either MaTransactionLogEntry or MaCommitLogEntry"	| entry |	entry :=		(self			removeEntryForSessionId: sessionUuid			ifAbsent: [ ^ aBlock value ]).	entry recordAllChangedObjects.	entries add: 		(aClass			id: sessionUuid			connection: entry result connection).	^ entry! !!MaTransactionLog methodsFor: 'accessing' stamp: 'cmm 1/8/2009 18:43'!entryFor: sessionId 	^ self 		entryFor: sessionId		ifAbsent: [ MagmaSessionLost signal ]! !!MaTransactionLog methodsFor: 'accessing' stamp: 'cmm 1/8/2009 18:42'!entryFor: sessionId ifAbsent: aBlock 	^ entries 		detect: [ : each | each sessionId = sessionId ]		ifNone: aBlock! !!MaTransactionLog methodsFor: 'accessing' stamp: 'cmm 9/25/2014 13:37'!numberOfEntries	^ entries size! !!MaTransactionLog methodsFor: 'testing' stamp: 'cmm 11/18/2009 14:20'!hasAnyEntries	^ entries notNil and: [ entries notEmpty ]! !!MaTransactionLog methodsFor: 'testing' stamp: 'cmm 1/8/2009 18:44'!hasEntryFor: sessionUuid 	self 		entryFor: sessionUuid		ifAbsent: [ ^ false ].	^ true! !!MaTransactionLog methodsFor: 'testing' stamp: 'cmm 12/31/2002 12:31'!isFirstEntryFor: sessionId	^entries notEmpty and: [ entries first connection sessionId = sessionId ]! !!MaTransactionLog methodsFor: 'initialize-release' stamp: 'cmm 3/9/2009 17:33'!initialize	super initialize.	"An OrderedCollection of MaCommitLogEntrys and MaTransactionLogEntrys.."	entries := OrderedCollection new.	specialOids := Dictionary new! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 3/6/2009 16:27'!newSessionFor: userIdString sessionId: aUuid numberOfChallengers: anInteger clientConnection: aMaClientConnection 	| connection |	connection := MagmaClientConnection 		userId: userIdString		sessionId: aUuid		maximumNumberOfChallengers: anInteger		clientConnection: aMaClientConnection		isSystem: entries isEmpty.	entries add: (MaTransactionLogEntry 			id: aUuid			connection: connection).	aMaClientConnection ifNotNil: [ aMaClientConnection info: userIdString , ' - ' , aUuid asString ].	^ connection! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 1/8/2009 18:53'!newTransactionFor: sessionUuid repository: aMaObjectRepository 	^ (self 		renewEntryFor: sessionUuid		withNew: MaCommitLogEntry		for: aMaObjectRepository) result! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 6/12/2006 23:50'!removeEntryForSessionId: sessionId ifAbsent: aBlock 	^ entries 		maDetect: [ : each | each sessionId = sessionId ]		ifFound: [ : foundTransactionLogEntry | entries remove: foundTransactionLogEntry ]		ifNone: aBlock! !!MaTransactionLog methodsFor: 'special oids' stamp: 'cmm 5/19/2004 22:24'!onChangeOf: anInteger clientsShould: aSymbol	specialOids		at: anInteger		put: aSymbol! !!MaTransactionLog methodsFor: 'special oids' stamp: 'cmm 5/19/2004 00:10'!specialOidsDo: twoArgBlock	specialOids keysAndValuesDo: twoArgBlock! !MaLargeCollectionManager subclass: #MagmaArrayManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-private'!!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 6/6/2007 00:05'!createNewLargeCollection	| fullFilename |	fullFilename := repository collectionFilenameFor: collection.	memberIndex := MaLargeArrayOfNumbers 		create: (			(MaAtomicFileStream fileNamed: fullFilename)				pool: repository filePool ;				yourself)		bitSize: MaObjectFiler maxDbSize! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 2/13/2008 13:35'!recordConflictsBetween: aMagmaArrayChanges and: challengingCommitLogEntry in: myCommitLogEntry 	"For MagmaArray's, different sessions may update the Array as long as they update different indexes."	(challengingCommitLogEntry hasChangesToMagmaArray: aMagmaArrayChanges collectionOid) ifTrue: 		[ | foreignChanges |		foreignChanges := challengingCommitLogEntry magmaArrayChangesAt: aMagmaArrayChanges collectionOid.		aMagmaArrayChanges additionsDo: 			[ : eachIndex : eachOid | 			((foreignChanges includesObject: eachIndex) and: [ (foreignChanges added at: eachIndex) ~= eachOid ]) ifTrue: 				[ "this user tried to put a different oid at the same index, conflict!!"				myCommitLogEntry 					failResultWith: challengingCommitLogEntry connection					on: aMagmaArrayChanges collectionOid ] ] ]! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 3/18/2005 13:33'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	"no general conflicts for MagmaArray's."! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 6/5/2006 23:35'!upTo: anInteger inSegmentFromIndex: lowIndex	| oids |	oids := 		memberIndex			upTo: anInteger			startingAt: lowIndex.	^ MagmaCollectionSegment new		lastKnownSize: memberIndex size ;		startIndex: lowIndex ;		objects: oids ;		yourself! !!MagmaArrayManager methodsFor: 'initializing' stamp: 'cmm 4/29/2007 21:48'!openIndex: filenameString 	^ MaLargeArrayOfNumbers open: ((MaAtomicFileStream fileNamed: filenameString)			pool: repository filePool ;			yourself)! !!MagmaArrayManager methodsFor: 'actions' stamp: 'cmm 3/18/2005 10:55'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self		processAddsIn: aMaCollectionChanges		using: aMaCommitResult.! !!MagmaArrayManager methodsFor: 'private' stamp: 'cmm 2/13/2008 11:58'!processAddsIn: aMagmaArrayChanges using: aMaCommitResult 	aMagmaArrayChanges additionsDo: 		[ : eachIndex : eachOid | 		memberIndex 			at: eachIndex			put: eachOid ]! !MaLargeCollectionManager subclass: #MagmaCollectionManager	instanceVariableNames: 'oidOfIndexesCollection lockedBy keyIndexesByAttribute oidIndexesByAttribute keyIndexes oidIndexes loadProcess loadExecutor wantsReleased'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-private'!!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/4/2006 15:43'!addMember: addedObjectOid atHashes: eachHashIndexArrays 	memberIndex 		add: self dummyValue		at: addedObjectOid.	eachHashIndexArrays withIndexDo: 		[ : eachHashValues : x | 		eachHashValues do: 			[ : eachHashValue | 			(oidIndexes at: x) 				add: addedObjectOid				at: eachHashValue.			(keyIndexes at: x) 				add: eachHashValue				at: addedObjectOid ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/2/2006 21:22'!dummyValue	"For the memberIndex, we only use the keys, answer a dummy value for the values."	^ 0! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/11/2006 21:38'!fileIdForOids: aBoolean index: anInteger	"To support recovery, we must populate MaBeforeImageRecords with a fileId identifying which file it is a before-image of.  We have eight bytes available for this.  The high-order 48-bits are my collectionOid, the low-order 15 bits indicate which index of the collection it is.  0 is the memberIndex.  For the other indexes (where lower-order 15 bits > 0), bit 16 is 1 for keys, 0 for oids."	| isKeysBit indexId |	isKeysBit := 16.	(anInteger maIsBitSet: isKeysBit) ifTrue: 		[ MagmaSoftwareError signal: 'Cannot have more than ' , ((0 maBitSet: isKeysBit) - 1) printString , ' indexes for a single collection.' ].	indexId := aBoolean 		ifTrue: [ anInteger ]		ifFalse: [ anInteger maBitSet: isKeysBit ].	^ (self collectionOid bitShift: 16) + indexId! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 5/28/2007 10:28'!filenameComponentFor: aMagmaIndexDescription 	^ self collectionOid printString , aMagmaIndexDescription attribute! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 5/28/2007 10:27'!filenameFor: keysOrOids of: aMagmaIndexDescription	^ (String streamContents:		[ : stream |		stream			nextPutAll: (self filenameComponentFor: aMagmaIndexDescription) ;			nextPut: $- ;			nextPutAll: keysOrOids ;			nextPut: $. ;			nextPutAll: MaHashIndex suggestedFileExtension ])! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 5/28/2007 10:27'!fullFileNameStringFor: keysOrOids of: aMagmaIndexDescription 	^ repository directory fullNameFor: 		(self 			filenameFor: keysOrOids			of: aMagmaIndexDescription)! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 8/6/2006 21:21'!load: aMagmaCollectionReaderSegment upTo: anInteger where: aMaExpression withObjects: aBoolean except: removedOids	(MaQueryExecutor 		collectionManager: self		expression: aMaExpression) 		load: aMagmaCollectionReaderSegment		upTo: anInteger		withObjects: aBoolean		except: removedOids.	^ aMagmaCollectionReaderSegment! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 17:34'!processAddNewIndexValuesIn: aMagmaCollectionChanges 	"Serialize the new values for an index that is being built."	aMagmaCollectionChanges hasNewIndexValues ifFalse: [ ^ self ].	aMagmaCollectionChanges newIndexValues keysAndValuesDo: 		[ : eachAttribute : eachValues | 		| oidsIndex keysIndex |		oidsIndex := self oidsIndexForAttribute: eachAttribute.		keysIndex := self keysIndexForAttribute: eachAttribute.		eachValues do: 			[ : eachAssociation | 			eachAssociation key do: 				[ : eachKey | 				oidsIndex 					add: eachAssociation value					at: eachKey.				keysIndex					add: eachKey					at: eachAssociation value ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/11/2006 20:35'!processAddsIn: aMaCollectionChanges using: aMaCommitResult 	aMaCollectionChanges additionsDo: 		[ : eachOid : eachHashIndexArrays | 		| addedObjectOid |		addedObjectOid := (MaOidCalculator isOidForNewObject: eachOid) 			ifTrue: [ aMaCommitResult permanentOids at: eachOid ]			ifFalse: [ eachOid ].		self 			addMember: addedObjectOid			atHashes: eachHashIndexArrays ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 8/17/2007 21:59'!processChangedIndexValuesIn: aMaCollectionChanges 	aMaCollectionChanges changedKeySpecificationsDo: 		[ : eachChangedKeySpecification | 		| oidsIndex keysIndex |		oidsIndex := self oidsIndexForAttribute: eachChangedKeySpecification attribute.		keysIndex := self keysIndexForAttribute: eachChangedKeySpecification attribute.		(memberIndex includesKey: eachChangedKeySpecification object) ifTrue: 			[ eachChangedKeySpecification oldHashValues do: 				[ : eachChangedKeySpecificationHashKeyValue | 				oidsIndex 					remove: eachChangedKeySpecification oid					at: eachChangedKeySpecificationHashKeyValue.				keysIndex					remove: eachChangedKeySpecificationHashKeyValue 					at: eachChangedKeySpecification oid ].			eachChangedKeySpecification newHashValues do: 				[ : eachChangedKeySpecificationHashKeyValue | 				oidsIndex 					add: eachChangedKeySpecification oid					at: eachChangedKeySpecificationHashKeyValue.				keysIndex					add: eachChangedKeySpecificationHashKeyValue 					at: eachChangedKeySpecification oid ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 3/16/2005 22:58'!processLockIn: aMaCollectionChanges using: aMagmaConnection	aMaCollectionChanges hasLockSpecified		ifTrue:			[ aMaCollectionChanges isLocked				ifTrue: [ self beLockedBy: aMagmaConnection ]				ifFalse: [ self beLockedBy: nil ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/23/2009 10:33'!processRemovedIndexesIn: aMaCollectionChanges 	aMaCollectionChanges removedIndexesDo: 		[ : eachAttribute | 		{ 			(self oidsIndexForAttribute: eachAttribute).			(self keysIndexForAttribute: eachAttribute)		 } do: [ : eachHashIndex | self removeIndex: eachHashIndex ].		keyIndexesByAttribute 			removeKey: eachAttribute			ifAbsent: 				[ "hmmm"				 ].		oidIndexesByAttribute 			removeKey: eachAttribute			ifAbsent: 				[ "don't think this should happen, but would hate to blow up when someone is just trying to remove an index."				 ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/12/2006 23:29'!processRemovesIn: aMaLargeCollectionChanges 	aMaLargeCollectionChanges removedDo: 		[ : eachOid : eachHashIndexValuesArray | 		| didRemove |		didRemove := memberIndex 			remove: self dummyValue			at: eachOid.		didRemove ifTrue: 			[ eachHashIndexValuesArray withIndexDo: 				[ : eachArray : x | 				eachArray do: 					[ : eachKeyValue | 					(oidIndexes at: x) 						remove: eachOid						at: eachKeyValue.					(keyIndexes at: x) 						remove: eachKeyValue						at: eachOid ] ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 8/19/2007 21:00'!recordConflictsBetween: aMagmaCollectionChanges and: challengingCommitLogEntry in: myCommitLogEntry 	"Fail my result if any indexes have been added or removed since my last transaction boundary, because any adds or removes will have the wrong number of index values."	(challengingCommitLogEntry hasCommitted: oidOfIndexesCollection) ifTrue: 		[ myCommitLogEntry 			failResultWith: challengingCommitLogEntry connection			on: oidOfIndexesCollection ].	"Fail my result if any objects being added or removed have been changed by any other session, because otherwise their index hash calculations may be incorrect."	aMagmaCollectionChanges additionsDo: 		[ : eachOid : eachHashIndexValues | 		(challengingCommitLogEntry hasCommitted: eachOid) ifTrue: 			[ myCommitLogEntry 				failResultWith: challengingCommitLogEntry connection				on: eachOid ] ].	aMagmaCollectionChanges removedDo: 		[ : eachOid : eachHashIndexValues | 		(challengingCommitLogEntry hasCommitted: eachOid) ifTrue: 			[ myCommitLogEntry 				failResultWith: challengingCommitLogEntry connection				on: eachOid ] ].	"Fail my result if any objects being indexed have been changed by any other session, because otherwise their index hash calculations may be incorrect."	aMagmaCollectionChanges newIndexValuesDo: 		[ : eachOrderedCollection | 		eachOrderedCollection do: 			[ : eachAssocation | 			(challengingCommitLogEntry hasCommitted: eachAssocation value) ifTrue: 				[ myCommitLogEntry 					failResultWith: challengingCommitLogEntry connection					on: eachAssocation value ] ] ].	"Fail my result if object keys being changed have been added or removed by any other session."	challengingCommitLogEntry commitPackage allLargeCollectionChanges do: 		[ : eachChallengingChanges | 		eachChallengingChanges collectionOid = aMagmaCollectionChanges collectionOid ifTrue: 			[ aMagmaCollectionChanges changedKeySpecificationsDo: 				[ : eachChangedKeySpecification | 				{ 					(eachChallengingChanges added).					(eachChallengingChanges removed)				 } do: 					[ : addedOrRemoved | 					(addedOrRemoved includesKey: eachChangedKeySpecification oid) ifTrue: 						[ myCommitLogEntry 							failResultWith: challengingCommitLogEntry connection							on: eachChangedKeySpecification oid ] ] ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 9/28/2008 15:11'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	"If its locked by someone else, no changes are allowed."	(self isLocked	and: [ aMaCommitLogEntry connection sessionId ~= lockedBy sessionId ])		ifTrue:			[ aMaCommitLogEntry				failResultWith: self lockedBy				on: aMagmaLargeCollectionChanges collectionOid ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/23/2009 10:28'!removeIndex: aMaHashIndex 	aMaHashIndex		close ;		filesDo: [ : each | repository queueForDelete: each ].	oidIndexes 		remove: aMaHashIndex		ifAbsent: 			[ "normal"			 ].	keyIndexes 		remove: aMaHashIndex		ifAbsent: 			[ "normal"			 ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/5/2006 23:34'!upTo: anInteger inSegmentFromIndex: lowIndex	| keysAndValues |	keysAndValues :=  		memberIndex			upTo: anInteger			keysAndValuesFromIndex: lowIndex.	^ MagmaCollectionSegment new		lastKnownSize: memberIndex size ;		startIndex: lowIndex ;		objects: keysAndValues first  "there are no 'values' in the member-index, the keys are the objects." ;		yourself! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 5/28/2007 10:26'!addNewIndex: aMagmaIndexDescription 	oidIndexes add: (oidIndexesByAttribute 			at: aMagmaIndexDescription attribute			put: (MaHashIndex 					create: (						(MaAtomicFileStream fileNamed: (self 								fullFileNameStringFor: 'oids'								of: aMagmaIndexDescription))							pool: repository filePool ;							yourself)					keySize: aMagmaIndexDescription keySize					valueSize: MaObjectBuffer oidSize					recordSize: aMagmaIndexDescription recordSize)).	keyIndexes add: (keyIndexesByAttribute 			at: aMagmaIndexDescription attribute			put: (MaHashIndex 					create: (						(MaAtomicFileStream fileNamed: (self 								fullFileNameStringFor: 'keys'								of: aMagmaIndexDescription))							pool: repository filePool ;							yourself)					keySize: MaObjectBuffer oidSize					valueSize: aMagmaIndexDescription keySize					recordSize: aMagmaIndexDescription recordSize))! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 14:30'!close	super close.	oidIndexes do: [ : each | each close ].	keyIndexes do: [ : each | each close ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 10:05'!ensureIndex: aMaIndexDefinition at: indexPosition 	oidIndexes size < indexPosition ifTrue: [ self addNewIndex: aMaIndexDefinition ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 5/28/2007 21:21'!ensureIndexesOpen	collection descriptionsDo: 		[ : each | 		(self hasIndexFor: each attribute) ifFalse: 			[ oidIndexes add: 				(oidIndexesByAttribute 					at: each attribute					put: 						(self openIndex: 							(self 								fullFileNameStringFor: 'oids'								of: each))).			keyIndexes add: 				(keyIndexesByAttribute 					at: each attribute					put: 						(self openIndex: 							(self 								fullFileNameStringFor: 'keys'								of: each))) ] ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 10/22/2006 15:10'!filePool: aMaFileStreamPool	super filePool: aMaFileStreamPool.	oidIndexes do: [ : each | each filePool: aMaFileStreamPool ].	keyIndexes do: [ : each | each filePool: aMaFileStreamPool ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 8/12/2007 20:22'!initialize	super initialize.	"we need them mapped to the correct attribute."	oidIndexesByAttribute := Dictionary new.	keyIndexesByAttribute := Dictionary new.	"and we must know the correct order, as well"	oidIndexes := OrderedCollection new.	keyIndexes := OrderedCollection new! !!MagmaCollectionManager methodsFor: 'locking' stamp: 'cmm 3/16/2005 14:13'!beLockedBy: aMagmaClientConnection	lockedBy := aMagmaClientConnection! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 11/17/2010 10:37'!createNewLargeCollection	| fullFilename |	fullFilename := repository collectionFilenameFor: collection.	memberIndex := MaHashIndex 		create: (			(MaAtomicFileStream fileNamed: fullFilename)				pool: repository filePool ;				yourself)		keySize: MaObjectBuffer oidSize		valueSize: 8		recordSize: 32! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 4/29/2007 21:48'!openIndex: aString 	^ MaHashIndex open: ((MaAtomicFileStream fileNamed: aString)			pool: repository filePool ;			yourself)! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 3/16/2005 22:57'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self		processLockIn: aMaCollectionChanges		using: aMaCommitResult connection.	self processRemovedIndexesIn: aMaCollectionChanges.	self		processAddsIn: aMaCollectionChanges		using: aMaCommitResult.	self		processRemovesIn: aMaCollectionChanges;		processChangedIndexValuesIn: aMaCollectionChanges;		processAddNewIndexValuesIn: aMaCollectionChanges! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 5/28/2007 21:21'!createSupplementaryIndexes	| position |	position := 0.	collection descriptionsDo:		[ : each |		self			ensureIndex: each			at: (position := position + 1) ]! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 6/13/2006 00:26'!delete	self filesDo: 		[ : eachFile : eachFileId | 		eachFile close.		repository directory deleteFileNamed: eachFile filename ]! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 3/17/2005 17:22'!ensureOpen	super ensureOpen.	self ensureIndexesOpen! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 4/13/2006 12:48'!filenames	^ super filenames , 	(oidIndexes, keyIndexes collect: [ : each | repository directory localNameFor: each filename ])! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/19/2007 22:26'!keysIndexForAttribute: aSymbol	aSymbol isNil ifTrue: [ ^ self memberIndex ].	^ keyIndexesByAttribute 		at: aSymbol		ifAbsent: 			[ MagmaUserError signal: 'The keys index for ' , aSymbol , ' was not found. ' ]! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:39'!loadExecutor: aMaQueryExecutor	loadExecutor := aMaQueryExecutor! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/4/2006 18:33'!loadProcess	^loadProcess! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/4/2006 18:33'!loadProcess: aProcess	loadProcess := aProcess! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 1/5/2010 14:58'!loadProgress	^ loadExecutor 		ifNil: 			[ Fraction 				numerator:					(self isLoading 						ifTrue: [ 0 ]						ifFalse: [ 1 ])				denominator: 1 ]		ifNotNil: [ loadExecutor fractionComplete ]! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:22'!lockedBy	"Answers a MagmaClientConnection."	^lockedBy! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:13'!oidOfIndexesCollection: anInteger	oidOfIndexesCollection := anInteger! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/19/2007 22:25'!oidsIndexForAttribute: aSymbol	aSymbol isNil ifTrue: [ ^ self memberIndex ].	^ oidIndexesByAttribute 		at: aSymbol		ifAbsent: 			[ MagmaUserError signal: 'The oids index for ' , aSymbol , ' was not found. ' ]! !!MagmaCollectionManager methodsFor: 'recovery' stamp: 'cmm 4/14/2006 12:41'!filesDo: twoArgBlock 	super filesDo: twoArgBlock.	oidIndexes withIndexDo: 		[ : each : x | 		each filesDo: 			[ : eachIndexFile | 			twoArgBlock 				value: eachIndexFile				value: 					(self 						fileIdForOids: true						index: x) ] ].	keyIndexes withIndexDo: 		[ : each : x | 		each filesDo: 			[ : eachIndexFile | 			twoArgBlock 				value: eachIndexFile				value: 					(self 						fileIdForOids: false						index: x) ] ]! !!MagmaCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/16/2006 22:41'!indexForFileId: anInteger 	"To support recovery of LargeCollections, we must replace the applied records to their prior-state, which is contained inside MaBeforeImageRecords."	| indexId |	indexId := 2r111111111111111 bitAnd: anInteger.	"15-bit index #"	^ indexId = 0 		ifTrue: [ memberIndex ]		ifFalse: 			[ (anInteger maIsBitSet: 16) 				ifTrue: [ keyIndexes at: indexId ]				ifFalse: [ oidIndexes at: indexId ] ]! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 4/13/2006 10:05'!hasIndexFor: attributeSymbol 	^ oidIndexesByAttribute includesKey: attributeSymbol! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 11/10/2010 14:21'!isLoading	^ loadProcess notNil and:		[ loadProcess everStarted and: [ loadProcess isTerminated not ] ]! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 3/16/2005 14:22'!isLocked	^lockedBy ~= nil! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 1/5/2010 13:52'!shouldStopLoading	^ repository wantsToClose or: [ self wantsReleased ]! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 1/5/2010 14:36'!wantsReleased	^ wantsReleased ifNil: [ false ]! !!MagmaCollectionManager methodsFor: 'load' stamp: 'cmm 1/5/2010 13:52'!wantsReleased: aBoolean 	wantsReleased := aBoolean! !MaObjectRepository initialize!