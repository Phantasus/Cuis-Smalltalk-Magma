MaObject subclass: #MaClientServerPreferences	instanceVariableNames: 'timeoutSeconds compressThreshold'	classVariableNames: 'Debug'	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaClientServerPreferences commentStamp: 'cmm 2/1/2005 15:27' prior: 0!Control your Ma client server preferences with this class.!!MaClientServerPreferences methodsFor: 'accessing' stamp: 'cmm 7/5/2008 23:02'!compressThreshold	"The maximum number of bytes a request will be before the client decides it should be compressed."	^compressThreshold! !!MaClientServerPreferences methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:48'!compressThreshold: anInteger	"The maximum number of bytes a request will be before the client decides it should be compressed."	compressThreshold := anInteger! !!MaClientServerPreferences methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:48'!timeoutSeconds	^timeoutSeconds! !!MaClientServerPreferences methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:52'!timeoutSeconds: anInteger 	"The number of seconds to wait for responses from network requests before assuming they are lost."	timeoutSeconds := anInteger! !!MaClientServerPreferences methodsFor: 'initialize-release' stamp: 'cmm 9/24/2014 11:03'!initialize	super initialize.	compressThreshold := MaSerializedGraphBuffer unreasonablePhysicalSize * 2.	timeoutSeconds := 45! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientServerPreferences class	instanceVariableNames: ''!!MaClientServerPreferences class methodsFor: 'accessing' stamp: 'cmm 1/2/2003 14:35'!debug	^Debug! !!MaClientServerPreferences class methodsFor: 'accessing' stamp: 'cmm 1/2/2003 14:53'!debug: aBoolean	Debug := aBoolean! !!MaClientServerPreferences class methodsFor: 'private' stamp: 'cmm 1/2/2003 14:35'!initialize	super initialize.	Debug := false! !MaObject subclass: #MaClientServerRequest	instanceVariableNames: 'lifecycle'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaClientServerRequest commentStamp: 'cmm 9/20/2008 16:45' prior: 0!An abstract superclass for all requests in the "Ma client server" framework.  This superclass knows the #clientConnection, a MaClientConnection, which may be useful to the application server program.!!MaClientServerRequest methodsFor: 'accessing' stamp: 'cmm 9/21/2008 15:45'!clientConnection	^ self lifecycle ifNotNilDo: [ : lc | lc clientConnection ]! !!MaClientServerRequest methodsFor: 'accessing' stamp: 'cmm 9/20/2008 17:08'!lifecycle	^lifecycle! !!MaClientServerRequest methodsFor: 'accessing' stamp: 'cmm 9/20/2008 17:08'!lifecycle: aMaServerRequestLifecycle	lifecycle := aMaServerRequestLifecycle! !!MaClientServerRequest methodsFor: 'accessing' stamp: 'cmm 3/1/2009 12:01'!requeue	"Put this request back to the end of the requestQueue."	self serverSocket primQueueRequest: self lifecycle! !!MaClientServerRequest methodsFor: 'accessing' stamp: 'cmm 3/1/2009 11:20'!serverSocket	^ lifecycle serverSocket! !!MaClientServerRequest methodsFor: 'testing' stamp: 'cmm 10/28/2008 14:34'!wantsResponse	"Answer whether this request expects a response from the server.  If false, submitting this request will be sent over the socket and immediately answer nil.  The server will make the same test to detemine whether to bother sending a response.	If true, submitting this request will block and wait for a response from the server."	"Default is true, subclasses may override."	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientServerRequest class	instanceVariableNames: 'defaultSound'!!MaClientServerRequest class methodsFor: 'auditorialization' stamp: 'cmm 10/12/2015 17:32'!defaultSound	^ defaultSound ifNil: [ superclass defaultSound ]! !!MaClientServerRequest class methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 14:34'!initialize	self initializeDefaultSound! !!MaClientServerRequest class methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 17:27'!initializeDefaultSound	"I don't have time to come up with unique and meaningful sounds for all these different request types.  So, the default is no sound.  I will define sounds for meaningful requests."	defaultSound := nil! !MaObject subclass: #MaClientSocket	instanceVariableNames: 'location socket socketStream byteArray stat preferences networkProtocol sequenceNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaClientSocket commentStamp: 'cmm 2/1/2005 15:29' prior: 0!An easy-to-use class to send ByteArray or String requests to a socket listening on the network.  The other socket is listening using MaServerSocket.!!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:51'!compressThreshold	"The maximum number of bytes a request will be before the client decides it should be compressed."	^ preferences compressThreshold ! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:51'!compressThreshold: anInteger 	"The maximum number of bytes a request will be before the client decides it should be compressed."	preferences compressThreshold: anInteger! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 13:26'!hostAddress	^ location hostAddress! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 15:19'!location	^ location! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:37'!networkProtocol	^ networkProtocol! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:36'!networkProtocol: aSymbol	networkProtocol := aSymbol! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/21/2008 16:16'!port	^ location ifNotNil: [ location port ]! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 8/18/2009 22:54'!preferences	^ preferences! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 8/18/2009 22:55'!preferences: aMaClientServerPreferences 	preferences := aMaClientServerPreferences! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:42'!timeoutSeconds	"The number of seconds to wait for responses from network requests before assuming they are lost."	^ preferences timeoutSeconds ! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 10/24/2014 13:14'!timeoutSeconds: anInteger 	"The number of seconds to wait for responses from network requests before assuming they are lost."	preferences timeoutSeconds: anInteger.	socketStream ifNotNil: [ socketStream timeout: anInteger ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 10/28/2014 12:45'!connect	| startTryingToConnectSocket |	Socket initializeNetwork.	socket 		ifNotNil: 			[ MaSoftwareError signal: 'client trying to make multiple connects?' ]		ifNil: 			[ self isUdp 				ifTrue: 					[ "Do NOT set the port now or it will not work.  It is specified on every send call."					socket := Socket newUDP ]				ifFalse: 					[ | hostAddr |					socket := Socket newTCP.					startTryingToConnectSocket := Time millisecondClockValue.					hostAddr := self hostAddress ifNil: [ NetworkError signal: 'Could not resolve ' , self location host ].					socket 						connectTo: hostAddr						port: self port						waitForConnectionFor: self timeoutSeconds.					socketStream := (SocketStream on: socket) binary; autoFlush: false; timeout: self timeoutSeconds.					self resetSequenceNumber.					stat ensureActive timeToConnectSocketHistory addValue: (Time millisecondsSince: startTryingToConnectSocket) ] ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 9/19/2014 11:38'!disconnect	stat release.	socket ifNotNil: 		[ socket closeAndDestroy: 5.		socket := socketStream := nil ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 6/2/2008 15:53'!ensureConnected	"Ensure the primitive Socket is connected."	socket 		ifNil: [ self connect ]		ifNotNil: 			[ socket isConnected ifFalse: 				[ self					disconnect ;					connect ] ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 10/27/2014 15:43'!headerSize	"First 4 bytes:  size of entire message (including header).	Bytes 5-8:  sequenceNumber of this request or response."	^ self isUdp ifTrue: [4] ifFalse: [8]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 7/5/2008 15:39'!hostAndPortString	^ String streamContents: [ : stream | location maPrintAbbreviatedOn: stream ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 9/8/2015 15:06'!receiveInto: aByteArray 	"First, we receive into *my* byteArray, then I paste it into aByteArray."	| header bodySize bytesExpected answer startedWaitingForResponse compressed incomingSequenceNumber |	startedWaitingForResponse := Time millisecondClockValue.	[ header := socketStream next: self headerSize.	bytesExpected := header maUnsigned32At: 1.	compressed := bytesExpected maIsBitSet: 32.	compressed ifTrue: [ bytesExpected := bytesExpected maBitClear: 32 ].	incomingSequenceNumber := header maUnsigned32At: 5.	answer := (bodySize := bytesExpected - self headerSize) > aByteArray size		ifTrue: [ ByteArray new: bodySize ]		ifFalse: [ aByteArray ].	socketStream		next: bodySize		into: answer.	incomingSequenceNumber > sequenceNumber ifTrue: [ (MaClientServerOutOfSequence expected: sequenceNumber) signal ].	incomingSequenceNumber < sequenceNumber ] whileTrue.	stat timeReceivingResponsesHistory addValue: (Time millisecondsSince: startedWaitingForResponse).	^ compressed		ifTrue: [ answer lzUncompressed ]		ifFalse: [ answer ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 10/28/2014 12:45'!resetSequenceNumber	sequenceNumber := 0! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 10/28/2014 13:25'!sequenceNumber: sequenceNumber totalToSend: totalToSend compressed: compressed 	| header |	header := ByteArray new: self headerSize.	header		maUint: 32		at: 0		put:			(self				setCompressedBit: compressed				for: totalToSend).	self isUdp ifFalse:		[ header			maUint: 32			at: 4			put: sequenceNumber ].	^ header! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 6/29/2008 11:01'!setCompressedBit: aBoolean for: headerInteger 	^ aBoolean 		ifTrue: 			[ "Below is the correct implementation, but we would need a 2GB ByteArray for the simpler faster implementation below not to work.  2GB can't happen."			"ba maUint: 32 at: 0 put: ((ba maUint: 32 at: 0) maBitSet: 32)."			headerInteger maBitSet: 32 ]		ifFalse: [ headerInteger maBitClear: 32 ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 5/6/2008 23:17'!stat	^stat! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 5/6/2008 23:18'!stat: aMaClientStat	stat := aMaClientStat! !!MaClientSocket methodsFor: 'initializing' stamp: 'cmm 10/28/2014 12:45'!initialize	super initialize.	stat := MaClientStat new.	preferences := MaClientServerPreferences new.	self resetSequenceNumber! !!MaClientSocket methodsFor: 'initializing' stamp: 'cmm 7/5/2008 14:21'!location: aMaServerLocation	location := aMaServerLocation! !!MaClientSocket methodsFor: 'testing' stamp: 'cmm 9/21/2008 17:53'!isConnected	^ socket notNil and: [ socket isConnected ]! !!MaClientSocket methodsFor: 'testing' stamp: 'cmm 11/11/2008 14:46'!isUdp	"Answer true if using a UDP interface, false if TCP/IP."	^ networkProtocol == #udp! !!MaClientSocket methodsFor: 'printing' stamp: 'cmm 11/19/2008 14:33'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	location maPrintAbbreviatedOn: aStream! !!MaClientSocket methodsFor: 'send' stamp: 'cmm 9/19/2014 15:38'!sendData: requestByteArray 	^ self 		sendData: requestByteArray		startingAt: 1		count: requestByteArray size		waitForReplyIn: (self isUdp ifFalse: [ #[] ])! !!MaClientSocket methodsFor: 'send' stamp: 'cmm 10/28/2014 09:59'!sendData: requestByteArray startingAt: startIndex count: numberOfBytes waitForReplyIn: answerByteArray 	"Perform a synchronous TCP call, sending count bytes of requestByteArray from position startIndex to my peer socket and then wait up to my timeout period for a reply, which I'll put in answerByteArray.  If I run out of room in answerByteArray, I'll create you a new one and return it, otherwise you'll get your own answerByteArray back.  If communications are disrupted, I'll signal a NetworkError."	"Do a retry logic to help with the case where the server has dropped only momentarily.  Sockets will be invalid but, unfortunately, they don't always correctly report they are invalid, as if they don't 'realize' it yet."	| tries |	sequenceNumber:=sequenceNumber+1.	tries := 0.	[ | startedSending header toSend compressed totalToSend |	(numberOfBytes > MaClientSocket mtuSize and: [ self isUdp ]) ifTrue: [ MaClientServerUserError signal: '#udp transmissions should be less than ' , MaClientSocket mtuSize-self headerSize , ' bytes' ].	startedSending := Time millisecondClockValue.	self ensureConnected.	totalToSend := numberOfBytes + self headerSize.	toSend := requestByteArray size > self compressThreshold		ifTrue:			[ compressed := (requestByteArray				copyFrom: startIndex				to: startIndex + numberOfBytes - 1) lzCompressed.			compressed size < numberOfBytes				ifTrue: [ compressed ]				ifFalse:					[ compressed := nil.					requestByteArray ] ]		ifFalse: [ requestByteArray ].	header := self sequenceNumber: sequenceNumber totalToSend: totalToSend compressed: compressed notNil.	self isUdp		ifTrue:			[ socket				sendUDPData:					(compressed						ifNil:							[ header, (toSend								copyFrom: startIndex								to: startIndex + numberOfBytes - 1) ]						ifNotNil: [ header, toSend ])				toHost: self hostAddress				port: self port ]		ifFalse:			[ socketStream nextPutAll: header.			compressed				ifNil:					[ socketStream						next: numberOfBytes						putAll: toSend						startingAt: startIndex ]				ifNotNil: [ socketStream nextPutAll: toSend ].			socketStream flush.			socket waitForSendDoneFor: self timeoutSeconds ].	"Only include successful sends to measure real network performance, not timeouts perhaps due to user-error."	stat timeToSendRequestsHistory addValue: (Time millisecondsSince: startedSending) ]		on: Error		do:			[ : sendErr | self disconnect.			"Handle a specific bug in Squeak, arrggghh!!"			(sendErr messageText = 'a primitive has failed' or: [ sendErr isKindOf: NetworkError ])				ifTrue:					[ tries < 3						ifTrue:							[ tries := tries + 1.							sendErr retry ]						ifFalse: [ sendErr pass ] ]				ifFalse: [ sendErr pass ] ].	"Retry logic is not appropriate on the receive side."	^ answerByteArray ifNotNil:		[ self isUdp ifFalse: [ self receiveInto: answerByteArray ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientSocket class	instanceVariableNames: ''!!MaClientSocket class methodsFor: 'creation' stamp: 'cmm 7/5/2008 14:21'!location: aMaServerLocation 	Socket initializeNetwork.	^ self new		location: aMaServerLocation ;		yourself! !!MaClientSocket class methodsFor: 'private' stamp: 'cmm 11/9/2008 20:03'!mtuSize	^ 1500! !MaSerializationStat subclass: #MaClientStat	instanceVariableNames: 'timeToConnectSocketHistory timeToLoadBuffersHistory timeToSendRequestsHistory timeWaitingForResponsesHistory timeReceivingResponsesHistory timeToSubmitByRequestClassHistorys'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaClientStat methodsFor: 'enumerate' stamp: 'cmm 5/9/2008 17:46'!historysDo: aBlock 	super historysDo: aBlock.	{ 		timeToConnectSocketHistory.		timeToLoadBuffersHistory.		timeToSendRequestsHistory.		timeWaitingForResponsesHistory.		timeReceivingResponsesHistory	 } do: aBlock.	timeToSubmitByRequestClassHistorys do: aBlock! !!MaClientStat methodsFor: 'initialize-release' stamp: 'cmm 5/9/2008 17:45'!initialize	super initialize.	timeToSubmitByRequestClassHistorys := Dictionary new.	timeToConnectSocketHistory := MaStatHistory name: 'Time to Connect Sockets to Server'.	timeToLoadBuffersHistory := MaStatHistory name: 'Time to Load Buffers'.	timeToSendRequestsHistory := MaStatHistory name: 'Time to Send Requests'.	timeWaitingForResponsesHistory := MaStatHistory name: 'Time for Initial Response'.	timeReceivingResponsesHistory := MaStatHistory name: 'Time to Download Full Response'! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 4/27/2009 20:50'!networkStats	"Statistics related to the networking."	^ { 		timeToConnectSocketHistory.		timeToLoadBuffersHistory.		timeToSendRequestsHistory.		timeWaitingForResponsesHistory.		timeReceivingResponsesHistory	 }! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 4/27/2009 21:03'!requestHistory	^ timeToSubmitByRequestClassHistorys asSortedCollection: [ : a : b | a name < b name ]! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:32'!timeReceivingResponsesHistory	"The time from when the initial response is received from the server to when all bytes of the response are downloaded.  By excluding the time waiting for the *initial* response, this stat attempts to measure the speed of downloading responses over the network."	^timeReceivingResponsesHistory! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:33'!timeToConnectSocketHistory	"Time to initiate a socket-connections, performed for for each request of the server."	^timeToConnectSocketHistory! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:33'!timeToLoadBuffersHistory	"For now Ma client server makes lots of copies of ByteArrays.  Until this is optimized, this stat tracks it to see how big of an impact it is."	^timeToLoadBuffersHistory! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:34'!timeToSendRequestsHistory	"The time needed just to send requests to the server."	^timeToSendRequestsHistory! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 6/25/2008 14:43'!timeToSubmitHistoryFor: requestClass 	"The total time, by request class, including serialization, materialization, and all other house keeping.  A useful set of stats measuring the total reality for the client, by request type."	^ timeToSubmitByRequestClassHistorys 		at: requestClass		ifAbsentPut: 			[ MaStatHistory new				name: 'Time waiting for ' , requestClass name , ' requests' ;				transition ;				yourself ]! !!MaClientStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:40'!timeWaitingForResponsesHistory	"When all bytes for a request have been pumped into the TCP/IP socket connected to the server, this stat immediately starts timing until we get the *first* initial response bytes back (which won't occur until the server has completely processed our request and is now sending back the response).  Therefore, this stat is a approximate measure of the time the server spends processing each request, including any time waiting in its request queue."	^timeWaitingForResponsesHistory! !!MaClientStat methodsFor: 'copying' stamp: 'cmm 12/22/2008 19:54'!postArchivalCopy	timeToSubmitByRequestClassHistorys := timeToSubmitByRequestClassHistorys copy.	super postArchivalCopy! !MaClientServerRequest subclass: #MaRemotePerformRequest	instanceVariableNames: 'selector arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaRemotePerformRequest commentStamp: 'cmm 8/18/2009 21:41' prior: 0!Perform #selector in the TestCase subclass instance of a remote test-player image.!!MaRemotePerformRequest methodsFor: 'accessing' stamp: 'cmm 5/6/2002 23:28'!arguments	^arguments! !!MaRemotePerformRequest methodsFor: 'accessing' stamp: 'cmm 5/6/2002 23:28'!arguments: aSymbol	arguments := aSymbol! !!MaRemotePerformRequest methodsFor: 'accessing' stamp: 'cmm 4/27/2002 15:07'!selector	^selector! !!MaRemotePerformRequest methodsFor: 'accessing' stamp: 'cmm 4/27/2002 15:07'!selector: aSymbol	selector := aSymbol! !!MaRemotePerformRequest methodsFor: 'private' stamp: 'cmm 1/3/2013 09:32'!processFor: anObject 	^ anObject		perform: selector		withArguments: arguments! !MaObject subclass: #MaServerLink	instanceVariableNames: 'stat'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaServerLink commentStamp: 'cmm 2/1/2005 15:36' prior: 0!Abstract superclass representing a clients link to a server.  A client uses this link to submit request objects via #submit:.!!MaServerLink methodsFor: 'actions' stamp: 'cmm 6/26/2008 23:05'!connect	stat transition! !!MaServerLink methodsFor: 'actions' stamp: 'cmm 5/7/2008 16:49'!disconnect	"Remote links need to clean up resources."	stat release! !!MaServerLink methodsFor: 'actions' stamp: 'cmm 3/30/2002 22:01'!submit: aMaServerRequest	self subclassResponsibility! !!MaServerLink methodsFor: 'access' stamp: 'cmm 7/5/2008 14:37'!host	MaUserError signal: 'not remotly connected.'! !!MaServerLink methodsFor: 'access' stamp: 'cmm 8/12/2007 20:38'!port	MaUserError signal: 'not remotly connected.'! !!MaServerLink methodsFor: 'access' stamp: 'cmm 5/6/2008 23:14'!stat: aMaClientStat	stat := aMaClientStat! !!MaServerLink methodsFor: 'access' stamp: 'cmm 8/17/2011 09:27'!timeoutSeconds	"for interface compatibility with remote server links."	^ 30! !!MaServerLink methodsFor: 'access' stamp: 'cmm 10/16/2002 22:05'!timeoutSeconds: anInteger	"for interface compatibility with remote server links."! !!MaServerLink methodsFor: 'initialize-release' stamp: 'cmm 5/7/2008 16:10'!initialize	super initialize.	stat := MaClientStat new! !!MaServerLink methodsFor: 'testing' stamp: 'cmm 9/20/2008 13:14'!isConnected	^ true! !!MaServerLink methodsFor: 'testing' stamp: 'cmm 10/8/2002 23:59'!isLocal	^false! !!MaServerLink methodsFor: 'testing' stamp: 'cmm 9/20/2008 13:21'!protocolEstablished	^ true! !!MaServerLink methodsFor: 'override' stamp: 'cmm 7/2/2004 17:16'!linkInformation	self subclassResponsibility! !MaServerLink subclass: #MaLocalServerLink	instanceVariableNames: 'localRequestServer'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaLocalServerLink commentStamp: 'cmm 2/1/2005 15:32' prior: 0!This is your clients interface to the server when the server is running locally (e.g., with MaLocalRequestServer).!!MaLocalServerLink methodsFor: 'actions' stamp: 'cmm 11/22/2008 12:29'!disconnect	super disconnect.	localRequestServer shutdown! !!MaLocalServerLink methodsFor: 'actions' stamp: 'cmm 3/30/2002 22:03'!submit: aMaServerRequest	^localRequestServer processRequest: aMaServerRequest! !!MaLocalServerLink methodsFor: 'testing' stamp: 'cmm 10/8/2002 23:59'!isLocal	^true! !!MaLocalServerLink methodsFor: 'accessing' stamp: 'cmm 11/3/2008 11:47'!linkInformation	^ localRequestServer processor pathName! !!MaLocalServerLink methodsFor: 'private' stamp: 'cmm 7/2/2004 13:17'!localRequestServer	^ localRequestServer! !!MaLocalServerLink methodsFor: 'private' stamp: 'cmm 3/30/2002 22:52'!localRequestServer: aMaLocalRequestServer	localRequestServer := aMaLocalRequestServer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLocalServerLink class	instanceVariableNames: ''!!MaLocalServerLink class methodsFor: 'as yet unclassified' stamp: 'cmm 3/30/2002 22:50'!localRequestServer: aMaLocalRequestServer	^self new localRequestServer: aMaLocalRequestServer! !MaServerLink subclass: #MaNetworkServerLink	instanceVariableNames: 'serializer socket submitGuard'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaNetworkServerLink commentStamp: 'cmm 9/13/2013 12:23' prior: 0!A MaNetworkServerLink handles the actual communications with a remotely-running MaRequestServer.!!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 7/5/2008 23:02'!compressThreshold	"The maximum number of bytes a request will be before the client decides it should be compressed."	^ socket compressThreshold! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 7/5/2008 23:03'!compressThreshold: anInteger 	"The maximum number of bytes a request will be before the client decides it should be compressed."	socket compressThreshold: anInteger! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 11/10/2008 14:07'!isUdp	^ socket isUdp! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 7/5/2008 13:30'!linkInformation	^ socket hostAndPortString! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 7/5/2008 15:04'!location	"Answer the MaServerLocation of the server at the other end of this link."	^ socket location! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:41'!networkProtocol	^ socket networkProtocol! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:37'!networkProtocol: aSymbol	socket networkProtocol: aSymbol! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 2/6/2009 13:42'!port	^ self location port! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 8/19/2009 13:10'!preferences	^ socket preferences! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 8/19/2009 13:10'!preferences: aMaClientServerPreferences	socket preferences: aMaClientServerPreferences ! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 9/17/2013 21:04'!protocol	"Answer the array of classes which I can send and receive."	^ serializer protocol! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 5/7/2008 16:06'!stat	^ stat! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds	^socket timeoutSeconds! !!MaNetworkServerLink methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:22'!timeoutSeconds: anInteger	socket timeoutSeconds: anInteger! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 9/15/2013 16:33'!connect	"Request and establish protocol from server."	| idAndProtocol |	super connect.	idAndProtocol := self primSubmit: self connectionRequest.	"Shouldn't need to re-establish protocol if it was just a socket timeout."	self protocolEstablished ifFalse:		[ serializer			 resetOidManager ;			 classDefinitionsByteArray: (idAndProtocol at: 2).		serializer classIdManager beImmutable ]! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 5/7/2008 16:49'!disconnect	super disconnect.	socket disconnect! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 9/15/2013 16:58'!ensureConnected	submitGuard critical:		[ self isConnected ifFalse: [ self connect ] ]! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 9/15/2013 15:19'!isConnected	^ socket notNil and: [ socket isConnected and: [ self protocolEstablished ] ]! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 3/18/2015 13:52'!ping	^ submitGuard critical:		[ [ self ensureConnected.		(self primSubmit: 'ping') = 'pong' ]			on: ConnectionRefused, ConnectionClosed			do:				[ : err | false ] ]! !!MaNetworkServerLink methodsFor: 'connections' stamp: 'cmm 3/16/2009 20:24'!protocolEstablished	"Once protocol is established, it is not changed."	^ serializer protocolEstablished ! !!MaNetworkServerLink methodsFor: 'private' stamp: 'cmm 10/16/2002 14:26'!connectionRequest	^'connect'! !!MaNetworkServerLink methodsFor: 'private' stamp: 'cmm 7/13/2009 18:03'!primSubmit: aMaClientServerRequest 	^ submitGuard critical: 		[ | answer responseByteArray beganSubmitting graphBuffer timeToSerialize |		beganSubmitting := Time millisecondClockValue.		socket stat: stat.		timeToSerialize := Time millisecondsToRun: 			[ serializer resetOidManager.			graphBuffer := serializer serializeGraph: aMaClientServerRequest ].		stat timeToSerializeHistory addValue: timeToSerialize.		responseByteArray := socket 			sendData: graphBuffer byteArray			startingAt: 1			count: graphBuffer bufferSize			waitForReplyIn: ((aMaClientServerRequest wantsResponse and: [ self isUdp not ]) ifTrue: [ serializer byteArray ]).		responseByteArray ifNotNil: 			[ serializer resetOidManager.			stat timeToMaterializeHistory addValue: (Time millisecondsToRun: [ answer := serializer materializeGraph: responseByteArray ]) ].		(stat timeToSubmitHistoryFor: aMaClientServerRequest maOriginalClass) addValue: (Time millisecondsSince: beganSubmitting).		answer ]! !!MaNetworkServerLink methodsFor: 'private' stamp: 'cmm 9/22/2002 21:32'!socket: aMaClientSocket	socket := aMaClientSocket! !!MaNetworkServerLink methodsFor: 'initialize-release' stamp: 'cmm 9/23/2008 14:25'!initialize	super initialize.	self initializeSerializer.	submitGuard := Mutex new! !!MaNetworkServerLink methodsFor: 'initialize-release' stamp: 'cmm 6/10/2005 12:21'!initializeSerializer	serializer := MaObjectSerializer new! !!MaNetworkServerLink methodsFor: 'initialize-release' stamp: 'cmm 9/17/2013 20:56'!protocol: aCollection 	"Establish the class ids of classes in the protocol."	serializer protocol: aCollection! !!MaNetworkServerLink methodsFor: 'initialize-release' stamp: 'cmm 2/4/2009 15:37'!serializer	^ serializer! !!MaNetworkServerLink methodsFor: 'printing' stamp: 'cmm 11/12/2008 18:18'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self location maPrintAbbreviatedOn: aStream! !!MaNetworkServerLink methodsFor: 'actions' stamp: 'cmm 9/20/2013 15:55'!submit: aMaClientServerRequest 	^ submitGuard critical:		[ aMaClientServerRequest wantsResponse			ifTrue:				[ self protocolEstablished ifFalse: [ self connect ].				self primSubmit: aMaClientServerRequest ]			ifFalse:				[ self primSubmit: aMaClientServerRequest.				nil ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaNetworkServerLink class	instanceVariableNames: ''!!MaNetworkServerLink class methodsFor: 'creation' stamp: 'cmm 7/5/2008 14:29'!host: hostName port: portInteger 	^ self location: 		(MaServerLocation 			host: hostName			port: portInteger)! !!MaNetworkServerLink class methodsFor: 'creation' stamp: 'cmm 7/5/2008 14:18'!location: aMaServerLocation 	^ self new		socket: (MaClientSocket location: aMaServerLocation) ;		yourself! !!MaNetworkServerLink class methodsFor: 'creation' stamp: 'cmm 7/24/2018 15:40'!port: portInteger 	^ self		host: NetNameResolver maLocalHostName		port: portInteger! !MaObject subclass: #MaServerLocation	instanceVariableNames: 'host port'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Client API'!!MaServerLocation commentStamp: 'cmm 7/5/2008 13:21' prior: 0!A MaServerLocation simply encapsulates a host and port, allowing the receiver to serve as a 'bookmark' to a server resource.!!MaServerLocation methodsFor: 'testing' stamp: 'cmm 6/16/2009 19:09'!= aMaServerLocation 	| myAddress otherAddress |	aMaServerLocation maOriginalClass = self species ifFalse: [ ^ false ].	myAddress := self hostAddress.	otherAddress := aMaServerLocation hostAddress.	(myAddress isNil xor: otherAddress isNil) ifTrue: [ ^ false ].	^ (myAddress isNil and: [ otherAddress isNil ]) 		ifTrue: 			[ "If neither resolvable, we're not gonna get very far anyway, but at least base this answer on something as meaningful as I can, thehost name."			host = aMaServerLocation host and: [ port = aMaServerLocation port ] ]		ifFalse: 			[ port = aMaServerLocation port and: 				[ myAddress = otherAddress or: [ myAddress maIsLocalHost and: [ otherAddress maIsLocalHost ] ] ] ]! !!MaServerLocation methodsFor: 'testing' stamp: 'cmm 3/2/2009 17:20'!hash	"Local addresses may be anything that begins with 127."	^ self hostAddress 		ifNil: [ nil hash bitXor: port hash ]		ifNotNilDo: 			[ : addr | 			| simplifiedAddress |			simplifiedAddress := addr maIsLocalHost 				ifTrue: [ #(127 0 0 1 ) asByteArray ]				ifFalse: [ addr ].			simplifiedAddress hash bitXor: port hash ]! !!MaServerLocation methodsFor: 'testing' stamp: 'cmm 3/5/2018 21:57'!isLocalHost	^ (self host beginsWith: '127') or: 		[ { 			'localhost'."			(NetNameResolver localHostName)."			(NetNameResolver localAddressString)		 } includes: self host ]! !!MaServerLocation methodsFor: 'testing' stamp: 'cmm 6/16/2012 12:30'!isReachable	"Answer whether the host specified by my host can be reached on the specified port."	| socket |	^ 	[ socket := Socket newTCP 		connectTo: (self hostAddress ifNil: [ ^ false ])		port: port		waitForConnectionFor: 10.	socket closeAndDestroy.	true ] 		on: ConnectionTimedOut, ConnectionRefused		do: [ : err | false ]! !!MaServerLocation methodsFor: 'access' stamp: 'cmm 7/5/2008 13:18'!host	"The host name of the computer at the remote location."	^ host! !!MaServerLocation methodsFor: 'access' stamp: 'cmm 7/16/2012 09:49'!hostAddress	"Answer a ByteArray representing the IP address of my host name."	^ self isLocalHost 		ifTrue: [ NetNameResolver localHostAddress ]		ifFalse: 			[ [ NetNameResolver 				addressForName: host				timeout: 10 ] 				on: NameLookupFailure				do: [ : err | nil ] ]! !!MaServerLocation methodsFor: 'access' stamp: 'cmm 7/5/2008 13:18'!port	"Answer the value of port"	^ port! !!MaServerLocation methodsFor: 'printing' stamp: 'cmm 7/5/2008 14:50'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	aStream		maPrint: host ;		maPrint: $: ;		maPrint: port! !!MaServerLocation methodsFor: 'initialize-release' stamp: 'cmm 11/11/2008 14:32'!setHost: aString port: anInteger 	host := aString.	port := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaServerLocation class	instanceVariableNames: ''!!MaServerLocation class methodsFor: 'create' stamp: 'cmm 7/5/2008 13:20'!host: aString port: anInteger 	^ self new 		setHost: aString		port: anInteger! !MaClientServerPreferences initialize!MaClientServerRequest initialize!