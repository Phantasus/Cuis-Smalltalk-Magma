MaObject subclass: #MaObjectBuffer	instanceVariableNames: 'byteArray startPos'	classVariableNames: 'BufferClasses BufferPositionMaps'	poolDictionaries: 'MaSerializerConstants'	category: 'Ma-Serializer-Core-Buffers'!!MaObjectBuffer commentStamp: 'cmm 11/13/2014 17:00' prior: 0!This class encapsulates a single object into its byteArray.  The 0-based buffer positions of my fields are:	0 = oid (6 bytes)	6 = physicalSize (4 bytes)	10 = control-fields2 (1 byte)		bit 1 = 			For MethodContextBuffers, 0 if small-frame, 1 = largeFrame.			For CompiledMethodBuffers, 0 = Cog header, 1 = spurHeader.	11 = filler (2 bytes)	13 = control-fields (1 byte)		4 bits (low-order) = bufferType (logical-type indicator of one of my subclasses)		4 bits (high-order) = indexed position into my class' #bpMaps Array, this value 0-15 (so +1 for access), the attribute-map Dictionary, mapping each attribute Symbol (i.e., #oid) to its bufferPosition.  This allows advanced users like Magma to add its fields without interfering into the simpler nature of Ma object serialization.		bpMaps:			at: 0 = Ma object serialization minimum.			at: 1 = Magma-added fields	14 = classId (2 bytes)!!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/25/2008 22:43'!bpMap	"Answer the actual MaBufferPositionMap used to map this buffer."	^ self class bpMapsAt: self bpMapIndex+1! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/25/2008 22:17'!bpMapIndex	"Answer the index into my BufferPositionMaps array that has my buffer position map.  It is the 4 high-order bits of my controlFields."	^ self controlFields bitShift: -4! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/25/2008 22:24'!bpMapIndex: anInteger 	"Set my bpMapIndex to a value between 0 and 15."	| shifted |	shifted := anInteger bitShift: 4.	self controlFields: (shifted bitOr: self type)! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 10/21/2004 12:41'!classId	^self 		uint: 16		at: self bufferPositionOfClassId! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 10/21/2004 12:41'!classId: anInteger	self		uint: 16		at: self bufferPositionOfClassId		put: anInteger! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 10/30/2004 16:00'!classVersion	^ 1! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 12/2/2004 12:35'!instVarsDoWithIndex: twoArgBlock	1		to: self objectInstSize		do:			[ :index |			twoArgBlock				value: (self maInstVarAt: index)				value: index ]! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 4/21/2005 15:44'!maInstVarAt: anInteger 	^ self 		uint: 48   "self class oidSize"		at: (self bufferPositionOfInstVarAt: anInteger)! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 4/21/2005 15:45'!maInstVarAt: anInteger put: oid	self		uint: 48  "self class oidSize"		at: (self bufferPositionOfInstVarAt: anInteger)		put: oid! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 12/2/2004 12:35'!objectInstSize	"Answer the capacity of this buffer to hold references to other objects."	^ self objectSize / self slotSize! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 12/2/2004 12:34'!objectSize	^ self physicalSize - self headerSize! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 4/27/2005 23:03'!oid	^self 		uint: 48  "self class oidSize"		at: self bufferPositionOfOid! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 4/21/2005 15:47'!oid: anInteger	self		uint: 48  "self class oidSize"		at: self bufferPositionOfOid		put: anInteger! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/10/2010 15:47'!physicalSize	^ self 		uint: self class sizeOfPhysicalSizeField 		at: self class bufferPositionOfPhysicalSize! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 7/31/2011 20:51'!physicalSize: anInteger 	self		uint: self class sizeOfPhysicalSizeField		at: self class bufferPositionOfPhysicalSize		put: anInteger! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 4/28/2005 12:50'!slotSize	^ 6   "self class oidSize / 8"! !!MaObjectBuffer methodsFor: 'access'!startPos	^startPos! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 3/26/2007 22:36'!trimByteArray	byteArray := self trimmedByteArray.	startPos := 0! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 3/26/2007 22:21'!trimmedByteArray	^ byteArray copyFrom: startPos+1 to: startPos + self physicalSize! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/2/2011 15:41'!type	"Answer the type of buffer this is.		1=MaByteObjectBuffer		2=MaVariableObjectBuffer		3=MaFixedObjectBuffer		4=MaVariableWordBuffer 		5=MaStorageObjectBuffer		6=MaCompiledMethodBuffer 		7=MaContextMethodBuffer"	^ self controlFields bitAnd: 2r00001111! !!MaObjectBuffer methodsFor: 'access' stamp: 'cmm 8/25/2008 22:06'!type: anInteger 	| controlFieldsValue withZeroedBits |	controlFieldsValue := self controlFields.	"Zero out 4 lowest-order bits, that's where this field is stored."	withZeroedBits := controlFieldsValue >> 4 << 4.	"Now OR these bits with anInteger."	self controlFields: (withZeroedBits bitOr: anInteger)! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 8/10/2010 15:20'!bufferPositionOfClassId	"Zero-based position of the class id."	^ 14! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/19/2004 15:52'!bufferPositionOfInstVarAt: anInteger	"Answer the physical 0-based byte-position within the receivers byteArray	where the instVar with index anInteger is located."	^ self headerSize + ((anInteger - 1) * self slotSize)! !!MaObjectBuffer methodsFor: 'private'!bufferPositionOfOid	"Zero-based position within a buffer that the oid is at."	^0! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 07:35'!bufferType	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'private'!byteArray	^byteArray! !!MaObjectBuffer methodsFor: 'private'!byteArray: aByteArray	byteArray := aByteArray! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 7/31/2011 21:35'!calculateHeaderSizeUsing: aMaBufferPositionMap	^ aMaBufferPositionMap headerSize! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 08:03'!controlFields	^ self class		controlFieldsIn: byteArray		startingAt: startPos! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 8/4/2011 20:35'!controlFields2	^ self class		controlFields2In: byteArray		startingAt: startPos! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 8/4/2011 20:35'!controlFields2: anInteger 	self		uint: 8		at: self class bufferPositionOfControlFields2		put: anInteger! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 08:08'!controlFields: anInteger	self		uint: 8		at: self class bufferPositionOfControlFields		put: anInteger! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/21/2004 23:29'!ensureClassUsing: aMaObjectSerializer	^ (aMaObjectSerializer classIdManager		classForId: self classId		ifAbsent:			[ "going to materialize an instance of the missing class."			| sourceDefinition |			sourceDefinition :=				(aMaObjectSerializer classIdManager classDefinitionsForId: self classId) last.  "the most-recent one is the best guess."			sourceDefinition createClassUsing: aMaObjectSerializer ])! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 6/10/2009 11:35'!ensureSpaceFor: storageObject using: bpMapClass 	| totalSize requiredSpace |	requiredSpace := self 		physicalSizeFor: storageObject		using: bpMapClass.	(totalSize := requiredSpace + self startPos) > MaSerializedGraphBuffer sizeWarningThreshold ifTrue: 		[ MaObjectSerializationWarning signal: 'Serialization sizeWarningThreshold reached.  Proceed to double it.'.		MaSerializedGraphBuffer doubleSizeWarningThreshold ].	totalSize > byteArray size ifTrue: [ self growTo: totalSize * 2 ].	self physicalSize: requiredSpace! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:09'!growTo: anInteger	self byteArray: (		(ByteArray new: anInteger)			replaceFrom: 1			to: byteArray size			with: byteArray			startingAt: 1)! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 8/25/2008 22:34'!headerSize	"The number of bytes in each object record before its 'data' begins; the objects it references."	^self bpMap headerSize! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/13/2014 13:23'!longAt: position 	^ byteArray		longAt: self startPos + position + 1		bigEndian: false! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/13/2014 13:28'!longAt: position put: anInteger	^ byteArray		longAt: self startPos + position + 1		put: anInteger		bigEndian: false! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 12/1/2004 22:54'!physicalDataSizeNeededFor: storageObject	^ storageObject maSizeIn: self! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 8/27/2008 14:40'!physicalSizeFor: storageObject 	^ self 		physicalSizeFor: storageObject		using: nil! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 7/31/2011 21:41'!physicalSizeFor: storageObject using: bpMapClassOrNil 	| headerSize |	headerSize := bpMapClassOrNil		ifNil: [ self headerSize ]		ifNotNil: [ self calculateHeaderSizeUsing: bpMapClassOrNil ].	^ headerSize + (self physicalDataSizeNeededFor: storageObject)! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/21/2004 18:53'!populateBodyFor: storageObject using: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/22/2013 22:10'!populateHeaderFor: anObject using: aMaObjectSerializer 	"physicalSize was already set in ensureSpaceFor:, no need to calculate it again."	self		oid: (aMaObjectSerializer oidFor: anObject) ;		type: self bufferType ;		bpMapIndex: aMaObjectSerializer bpMapIndex ;		classId: (aMaObjectSerializer classIdManager 				idForClass: anObject maSerializationClass				ifAbsent: 					[ (aMaObjectSerializer classIdManager addNewClass: anObject maSerializationClass) id ])! !!MaObjectBuffer methodsFor: 'private'!startPos: anInteger	startPos := anInteger! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:09'!uint: numberOfBits at: position	^byteArray		maUint: numberOfBits		at: self startPos + position! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!uint: numberOfBits at: zeroBasedIndexPosition put: valueInteger	^byteArray		maUint: numberOfBits		at: self startPos + zeroBasedIndexPosition		put: valueInteger! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 10/10/2004 00:03'!copyWithSameBuffer	^ self copy! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:00'!independentCopy	^ self copy postIndependentCopy! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 7/12/2007 21:23'!postIndependentCopy	self trimByteArray! !!MaObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 12:44'!createObjectUsing: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/22/2004 14:40'!establishReferencesFrom: anObject using: aMaObjectSerializer	"This is the second-stage of materializing anObject.  The first stage populated its instVars with oids, this stage now replaces those oids with the actual objects.  Typically, only Fixed and VariableObject buffers will need to do anything on this."! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/8/2012 16:54'!equivalentTo: aMaObjectBuffer 	self type = aMaObjectBuffer type ifFalse: [ ^ false ].	self oid = aMaObjectBuffer oid ifFalse: [ ^ false ].	self classId = aMaObjectBuffer classId ifFalse: [ ^ false ].	self objectInstSize = aMaObjectBuffer objectInstSize ifFalse: [ ^ false ].	self instVarsDoWithIndex:		[ : eachRef : n | eachRef = (aMaObjectBuffer maInstVarAt: n) ifFalse: [ ^ false ] ].	^ true! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/21/2004 22:46'!isBytes	^ false! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:00'!isPointers	^ true! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 4/19/2009 17:45'!references: oid 	^ self isPointers and: 		[ (1 to: self objectInstSize) anySatisfy: [ : n | (self maInstVarAt: n) = oid ] ]! !!MaObjectBuffer methodsFor: 'initializing'!initialize	super initialize.	startPos := 0! !!MaObjectBuffer methodsFor: 'printing' stamp: 'cmm 3/9/2009 22:35'!maPrintAbbreviatedOn: aStream 	self 		maPrintAttributes: #(				#oid				#classId				#objectInstSize				#commitNumber			)		on: aStream! !!MaObjectBuffer methodsFor: 'printing' stamp: 'cmm 4/21/2005 15:46'!oids	"This method is intended for printing only.  Use instVarsDoWithIndex: if you need to enumerate my oids."	| oids |	self objectInstSize isInteger ifFalse: [ ^ '** invalid **' ].	oids := OrderedCollection new.	1		to: self objectInstSize		do: [ :index | oids add: (self maInstVarAt: index) ].	^ oids! !!MaObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 8/27/2008 18:48'!bufferPositionOfCommitNumber	^ self bpMap bufferPositionOfCommitNumber! !!MaObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 8/27/2008 18:48'!commitNumber	^ self 		uint: 48		at: self bufferPositionOfCommitNumber! !!MaObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 8/27/2008 18:53'!commitNumber: anInteger 	^ self 		uint: 48		at: self bufferPositionOfCommitNumber		put: anInteger! !!MaObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 11/23/2004 23:19'!isDifferent: anObject using: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 1/10/2014 17:03'!refresh: anObject using: aMaObjectSerializer includingLocal: aBoolean	self subclassResponsibility! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 10/31/2018 15:53'!appendGraphNode: oid into: aMaSerializedGraphBuffer using: aMaReadStrategy currentDepth: anInteger minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	| buffer |	(alreadyAppendedSet ifAbsentAdd: oid) ifFalse: [ ^ self ].	buffer := aMaObjectFiler		appendObject: oid		into: aMaSerializedGraphBuffer.	buffer		appendGraphUsing: aMaReadStrategy		into: aMaSerializedGraphBuffer		currentDepth: anInteger + 1		minDepth: minDepth		with: alreadyAppendedSet		filer: aMaObjectFiler! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 1/25/2005 14:01'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	1		to: self objectInstSize		do:			[ :varIndex | | oid |			(MaOidCalculator isOidForOptimizedObject: (oid := self maInstVarAt: varIndex))				ifFalse:					[ | newMinDepth |					currentDepth < (						newMinDepth :=							(aMaReadStrategy								depthOfAttribute: varIndex								onClassWithId: self classId								version: self classVersion) + currentDepth									max: minDepth)										ifTrue:											[ self												appendGraphNode: oid												into: aMaSerializedGraphBuffer												using: aMaReadStrategy												currentDepth: currentDepth												minDepth: newMinDepth												with: alreadyAppendedSet												filer: aMaObjectFiler ] ] ]! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 3/26/2007 22:40'!asSentientBuffer	"Convert me to a buffer of the correct type."	^ self species 		createFromByteArray: byteArray		startPos: startPos! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 5/24/2005 17:20'!bufferPositionOfBytesToStore	"Default 1-based position of the byte within each byteArray that we start storing to disk at."	^ 7! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 7/20/2007 11:11'!canConflict	^ true! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 1/8/2014 20:38'!canGrow	"Answer whether my buffer can grow.  3=MaFixedObjectBuffer, 2=MaVariableObjectBuffer, 5=MaStorageObjectBuffer."	^ self type = 3 or: [ self type = 2 or: [ self type = 5 ] ]! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 12:58'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	self subclassResponsibility! !!MaObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 11/24/2004 13:35'!numberOfBytesToStore	"Answer the number of bytes that should be stored for this buffer.  This is used by Magma, which doesn't need to store the oid since that is kept in the oid table."	^self physicalSize - self bufferPositionOfBytesToStore + 1! !!MaObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 3/19/2007 00:26'!hasValidReferencesFor: aMaObjectFiler	^ true! !!MaObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 8/4/2011 20:34'!isValidBufferType	^ self type between: 1 and: MaObjectBuffer classes size! !!MaObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 12/3/2014 10:42'!isValidOid: anInteger for: aMaObjectFiler 	^ anInteger		between: FirstUserObjectOid		and: aMaObjectFiler getNextOid - 1! !!MaObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 3/19/2007 12:21'!isValidOidFor: aMaObjectFiler 	^ self 		isValidOid: self oid		for: aMaObjectFiler! !!MaObjectBuffer methodsFor: '*magma-tester' stamp: 'cmm 1/15/2014 20:50'!magmaStat	"Helpful for debugging MagmaStat.  Assuming I represent a MagmaStat, show my values mapped to its inst-vars."^self oids withIndexCollect: [ : e : x | (MagmaStat allInstVarNames at: x) -> (MaOidCalculator infoFor: e)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectBuffer class	instanceVariableNames: ''!!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/26/2008 02:24'!bpMapsAt: anIndex	"Answer the requested Dictionary of attribute positions."	^ BufferPositionMaps at: anIndex! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/26/2008 02:34'!bpMapsAt: anIndex put: aMaBufferPositionMap 	^ BufferPositionMaps 		at: anIndex		put: aMaBufferPositionMap! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/26/2005 08:00'!bufferClassFor: aByteArray startPos: anInteger	^ self bufferClasses at: 		(self			bufferTypeIn: aByteArray			startingAt: anInteger)! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 7/15/2002 23:04'!bufferClasses	^BufferClasses! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/10/2010 16:33'!bufferPositionOfControlFields	"Zero-based position of the control-fields (buffer-type and isStorageObject)."	^ 13! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/4/2011 20:33'!bufferPositionOfControlFields2	"Zero-based position of the new control-fields - bit-level fields."	^ 10! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/27/2005 23:01'!bufferPositionOfPhysicalSize	"Zero-based logical position within this buffer's byteArray that contains the physical size of this buffer."	^ 6! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/26/2005 07:57'!bufferTypeIn: aByteArray startingAt: startPositionOfObjectBuffer	"The bufferType is stored in the 4 low-order bits of the controlFields."	^ (self 		controlFieldsIn: aByteArray		startingAt: startPositionOfObjectBuffer) bitAnd: 2r00001111! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:16'!controlFields2In: aByteArray startingAt: startPositionOfObjectBuffer	^ aByteArray"		maUint: 8"		byteAt: startPositionOfObjectBuffer + self bufferPositionOfControlFields2 + 1! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:16'!controlFieldsIn: aByteArray startingAt: startPositionOfObjectBuffer	^ aByteArray"		maUint: 8"		byteAt: startPositionOfObjectBuffer + self bufferPositionOfControlFields + 1! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/27/2008 14:31'!defaultBpMap	^ MaBufferPositionMap! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/27/2008 21:39'!indexOfBpMap: bpMapClass 	"Answer the 0-based index"	^ (BufferPositionMaps indexOf: bpMapClass) - 1! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/21/2005 15:43'!oidSize	^ 48! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 8/10/2010 15:28'!sizeOfPhysicalSizeField	"in bits."	^ 32! !!MaObjectBuffer class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!byteArray: aByteArray startPos: anInteger	^self new		startPos: anInteger ;		byteArray: aByteArray ;		yourself! !!MaObjectBuffer class methodsFor: 'creation' stamp: 'cmm 7/10/2002 20:28'!createFromByteArray: aByteArray startPos: anInteger	^(self		bufferClassFor: aByteArray		startPos: anInteger)			byteArray: aByteArray			startPos: anInteger! !!MaObjectBuffer class methodsFor: 'initializing' stamp: 'cmm 8/25/2008 21:50'!initialize	"Called from preamble of MaObjectSerialization."	self		initializeBufferClasses ;		initializeBufferPositionMaps! !!MaObjectBuffer class methodsFor: 'initializing' stamp: 'cmm 7/30/2011 12:03'!initializeBufferClasses	BufferClasses := 		{ MaByteObjectBuffer. 		MaVariableObjectBuffer. 		MaFixedObjectBuffer. 		MaVariableWordBuffer. 		MaStorageObjectBuffer.		MaCompiledMethodBuffer.		MaMethodContextBuffer }! !!MaObjectBuffer class methodsFor: 'initializing' stamp: 'cmm 8/25/2008 22:38'!initializeBufferPositionMaps	BufferPositionMaps := Array new: 16.	self 		bpMapsAt: 1		put: self defaultBpMap! !MaObjectBuffer subclass: #MaFixedObjectBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaFixedObjectBuffer commentStamp: 'cmm 8/10/2010 21:07' prior: 0!This class encapsulates an object that has a fixed-size.  Most objects are fixed-size.  My 0-based buffer fields are:	(see superclass)	16 = classVersion (2 bytes)	18 = first instance-variable			OR (in Magma only)	16 = commitNumber (6 bytes)	22 = filler (6 bytes)	28 = classVersion (2 bytes)	30 = first instance-variable!!MaFixedObjectBuffer methodsFor: 'private' stamp: 'cmm 8/25/2008 22:14'!bufferPositionOfClassVersion	^ self bpMap bufferPositionOfClassVersion! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:32'!bufferType	^ 3! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 22:05'!classVersion	^self 		uint: 16		at: self bufferPositionOfClassVersion! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 22:05'!classVersion: anInteger	self		uint: 16		at: self bufferPositionOfClassVersion		put: anInteger! !!MaFixedObjectBuffer methodsFor: 'creation' stamp: 'cmm 8/1/2011 20:46'!createObjectUsing: aMaObjectSerializer 	| class indexedSize sourceDefinition |	class := self ensureClassUsing: aMaObjectSerializer.	sourceDefinition := aMaObjectSerializer classIdManager		definitionForClassId: self classId		version: self classVersion.	indexedSize := self objectInstSize - sourceDefinition namedInstSize.	^ indexedSize = 0		ifTrue: [ class basicNew ]		ifFalse: [ class basicNew: indexedSize ]! !!MaFixedObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/10/2014 10:29'!establishReferencesFrom: anObject using: aMaObjectSerializer 	| class sourceDefinition inImageDefinition |	class := self ensureClassUsing: aMaObjectSerializer.	sourceDefinition := aMaObjectSerializer classIdManager		definitionForClassId: self classId		version: self classVersion.	inImageDefinition := aMaObjectSerializer classIdManager inImageDefinition: class.	self instVarsDoWithIndex:		[ : eachOid : sourceIndex | | targetIndex |		targetIndex := inImageDefinition			indexOfInstVarCorrespondingTo: sourceIndex			of: sourceDefinition.		targetIndex > 0			ifTrue:				[ anObject					slotAt: targetIndex					put: (aMaObjectSerializer objectWithOid: eachOid) ] ]! !!MaFixedObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/8/2012 16:55'!equivalentTo: aMaFixedObjectBuffer 	(super equivalentTo: aMaFixedObjectBuffer) ifFalse: [ ^ false ].	self classVersion = aMaFixedObjectBuffer classVersion ifFalse: [ ^ false ].	^ true! !!MaFixedObjectBuffer methodsFor: 'printing' stamp: 'cmm 11/11/2014 14:08'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(#classVersion #oids "#infos")		on: aStream! !!MaFixedObjectBuffer methodsFor: 'building' stamp: 'cmm 12/2/2014 17:09'!populateBodyFor: storageObject using: aMaObjectSerializer	1		to: storageObject maInstSize		do:			[ :index |			self				maInstVarAt: index				put:					((storageObject maIsTransient: index)						ifTrue: [ OidForNil ]						ifFalse: [ aMaObjectSerializer oidFor: (storageObject slotAt: index) ]) ]! !!MaFixedObjectBuffer methodsFor: 'building' stamp: 'cmm 4/22/2013 22:10'!populateHeaderFor: anObject using: aMaObjectSerializer	| classVersion |	super		populateHeaderFor: anObject		using: aMaObjectSerializer.	classVersion := 		aMaObjectSerializer classIdManager			currentVersionOfClass: (aMaObjectSerializer classFor: anObject).	self classVersion: classVersion! !!MaFixedObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 11/13/2014 09:22'!isDifferent: anObject using: aMaObjectSerializer 	"Only report anObject different if any of its *recorded* instVars changed, or if any of its *new* instVars is not nil."	| classIdManager inImageDefinition bufferDefinition |	classIdManager := aMaObjectSerializer classIdManager.	inImageDefinition := classIdManager inImageDefinition: anObject maSerializationClass.	bufferDefinition := classIdManager		definitionForClassId: self classId		version: self classVersion.	bufferDefinition id = inImageDefinition id ifFalse: [ ^ true ].	1		to: anObject maInstSize		do:			[ : index | | instVarIndexInBackup |			(anObject maIsTransient: index) ifFalse:				[ instVarIndexInBackup := bufferDefinition					indexOfInstVarCorrespondingTo: index					of: inImageDefinition.				instVarIndexInBackup == 0					ifTrue:						[ (anObject slotAt: index) ~~ nil ifTrue: [ ^ true ] ]					ifFalse:						[ (aMaObjectSerializer oidFor: (anObject slotAt: index)) = (self maInstVarAt: instVarIndexInBackup) ifFalse: [ ^ true ] ] ] ].	^ false! !!MaFixedObjectBuffer methodsFor: '*magma-client' stamp: 'cmm 1/13/2014 16:29'!refresh: anObject using: aMagmaSession includingLocal: aBoolean 	"WeakKeyDictionaries can have nil keys."	anObject ifNil: [ ^ self ].	anObject realObjectIfMutatingProxy		refreshFrom: self		using: aMagmaSession		includingLocal: aBoolean! !!MaFixedObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 7/20/2007 11:16'!canConflict	^ self classId ~= MagmaClassIdManager magmaCounterClassId! !!MaFixedObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 12:58'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	aMagmaFileTraverser		graphFromPointers: self		do: oneArgBlock		using: aMaReadStrategy.	(aMagmaFileTraverser isForLargeCollection: self)		ifTrue:			[ aMagmaFileTraverser				graphFromLargeCollection: self oid				do: oneArgBlock				using: aMaReadStrategy ]! !!MaFixedObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 3/19/2007 12:25'!hasValidReferencesFor: aMaObjectFiler 	self instVarsDoWithIndex: 		[ : eachOid : x | 		(self 			isValidOid: eachOid			for: aMaObjectFiler) ifFalse: [ ^ false ] ].	^ true! !MaFixedObjectBuffer subclass: #MaCompiledMethodBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaCompiledMethodBuffer commentStamp: 'cmm 11/13/2014 15:47' prior: 0!A MaCompiledMethodBuffer encapsulates all data needed to instantiate a CompiledMethod.  CompiledMethod objects are special because they store bytes and pointers.  Therefore, this buffer type maps additional fields essential to storing CompiledMethods.	(see superclass)	18 = methodHeader (4 bytes)	22 = byteCodesPlusTrailerSize (4 bytes).	26 = first inst-var	28 = second inst-var		... etc...	nn = byteCodes plus trailer bytes		OR (in Magma only)	(see superclass)	16 = commitNumber (6 bytes)	22 = method header (4 bytes)	26 = filler (2 bytes)	28 = classVersion (2 bytes)	30 = byteCodesPlusTrailerSize (4 bytes)	34 = first inst-var	40 = second inst-var		... etc...	nn = byteCodes plus trailer bytes!!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/30/2011 21:44'!bufferPositionOfByteCodesPlusTrailerBytes	"The 1-based delta from my startPos where the bytes of the original CompiledMethod are stored."	^ self headerSize + self objectSize + 1! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/29/2011 18:25'!bufferPositionOfByteCodesPlusTrailerSize	^ self bpMap bufferPositionOfByteCodesPlusTrailerSize! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/29/2011 18:25'!bufferPositionOfMethodHeader	^ self bpMap bufferPositionOfMethodHeader! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/30/2011 11:58'!bufferType	^ 6! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 8/4/2011 21:32'!calculateHeaderSizeUsing: aMaBufferPositionMap	^ aMaBufferPositionMap headerSizeForCompiledMethodBuffer! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 5/5/2015 11:15'!headerForThisVm	"Header fields and number of bits:	Cog:							Spur:	9:  primitive #					15:	numLiterals	8:  numLiterals					1:									1:  has primitive	1:  frameSize					1:  frameSize	6:  numTemps					6:  numTemps	4:  numArgs						4:  numArgs"	| headerVal |	headerVal := self longAt: self bufferPositionOfMethodHeader.	^ self spurHeader		ifTrue:			[ Smalltalk isRunningSpur				ifTrue: [headerVal]				ifFalse: 					[ "Spur-to-Cog header conversion."					|cogHeader numLits| 					(numLits:= headerVal bitAnd: 2r111111111111111) > 255 ifTrue: [ MaEnvironmentError signal: 'This image cannot materialize the CompiledMethod from Spur because it has more than 255 literals.' ].					"Rebuild Cog header starting with high-order bits.  Erase low-order 16 bits by shifting right, then back left only 8 because that's all there is for Cog."					cogHeader := (headerVal bitShift: -17) bitShift: 8.					"Add in numLits to properly set the low-order 8 bits."					cogHeader := cogHeader + numLits.					"Finally, the 9 low-order bits in Cog are for primitive #.  We don't need to support CM's with primitives right now, so simply shift left."					cogHeader bitShift: 9 ] ]		ifFalse:			[ Smalltalk isRunningSpur				ifTrue:					[ "Cog-to-Spur header conversion."					| spurHeader numLits |					"Obtain number of literals."					numLits := (headerVal bitShift: -9) bitAnd: 16rFF.					"Erase bottom 17 bits.  'has primitive' bit is 0, but we dont care about those right now."					spurHeader := (headerVal bitShift: -17) bitShift: 17.					"Bottom 16 bits are 0.  Set bottom 8 with numLits."					spurHeader := spurHeader + numLits ]				ifFalse: [ headerVal ] ]! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/30/2011 16:09'!populateBytesFor: aCompiledMethod using: aMaObjectSerializer 	1		to: aCompiledMethod maBytesSize		do:			[ : n | self				putByte: n				of: aCompiledMethod ]! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/30/2011 20:48'!populateLiteralsFor: aCompiledMethod using: aMaObjectSerializer 	1		to: aCompiledMethod numLiterals		do:			[ : index | 			self				maInstVarAt: index				put: (aMaObjectSerializer oidFor: (aCompiledMethod literalAt: index)) ]! !!MaCompiledMethodBuffer methodsFor: 'private' stamp: 'cmm 7/30/2011 21:52'!putByte: anInteger of: aCompiledMethod 	"Value aBlock with each byteCode and trailer byte."	byteArray		at: startPos + self bufferPositionOfByteCodesPlusTrailerBytes + anInteger - 1		put: (aCompiledMethod basicAt: aCompiledMethod initialPC + anInteger - 1)! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 7/29/2011 17:56'!byteCodeAndTrailerBytesDo: aBlock	"Value aBlock with each byteCode and trailer byte."	self bufferPositionOfByteCodesPlusTrailerBytes to: self physicalSize do:		[ : n |		aBlock value: (byteArray at: (startPos + n)) ]! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 7/29/2011 17:58'!byteCodesPlusTrailerSize	^ self		uint: 32		at: self bufferPositionOfByteCodesPlusTrailerSize! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 7/29/2011 17:55'!byteCodesPlusTrailerSize: anInteger 	self		uint: 32		at: self bufferPositionOfByteCodesPlusTrailerSize		put: anInteger! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 8/4/2011 21:32'!headerSize	^ self bpMap headerSizeForCompiledMethodBuffer! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 11/13/2014 13:30'!methodHeader	^ self longAt: self bufferPositionOfMethodHeader! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 11/13/2014 13:30'!methodHeader: anInteger 	^ self		longAt: self bufferPositionOfMethodHeader		put: anInteger! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 7/29/2011 17:51'!objectSize	^ self physicalSize - self byteCodesPlusTrailerSize - self headerSize! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 11/13/2014 17:04'!spurHeader	"Answer whether the CompiledMethod this buffer represents should calculate its numLiterals using the new Spur way (1) or the old Cog way (0).  If the CM instance was serialized under Spur, it will be 1, otherwise 0.	See class comment of CompiledMethod (and in a Cog image)."	^ (self controlFields2 bitAnd: 2r00000001) = 1! !!MaCompiledMethodBuffer methodsFor: 'access' stamp: 'cmm 11/13/2014 17:49'!spurHeader: aBoolean 	"Specify whether the CompiledMethod this buffer should, when materialized, calculate its numLiterals using the new Spur way (1) or the old Cog way (0)."	self controlFields2:		(self controlFields2			bitAt: 1			put:				(aBoolean					ifTrue: [ 1 ]					ifFalse: [ 0 ]))! !!MaCompiledMethodBuffer methodsFor: 'printing' stamp: 'cmm 7/30/2011 18:15'!bytes	^ ByteArray streamContents:		[ : stream | self byteCodeAndTrailerBytesDo:			[ : eachByte | stream nextPut: eachByte ] ]! !!MaCompiledMethodBuffer methodsFor: 'printing' stamp: 'cmm 8/1/2011 14:04'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(#byteCodesPlusTrailerSize #bytes )		on: aStream! !!MaCompiledMethodBuffer methodsFor: 'building' stamp: 'cmm 11/13/2014 16:58'!captureEssentialAttributesFrom: aCompiledMethod	self		byteCodesPlusTrailerSize: aCompiledMethod maBytesSize ;		methodHeader: aCompiledMethod header ;		spurHeader: Smalltalk isRunningSpur! !!MaCompiledMethodBuffer methodsFor: 'building' stamp: 'cmm 7/30/2011 20:39'!populateBodyFor: aCompiledMethod using: aMaObjectSerializer 	self				populateBytesFor: aCompiledMethod		using: aMaObjectSerializer ;				populateLiteralsFor: aCompiledMethod		using: aMaObjectSerializer! !!MaCompiledMethodBuffer methodsFor: 'building' stamp: 'cmm 4/22/2013 22:11'!populateHeaderFor: aMethodContextOrCompiledMethod using: aMaObjectSerializer 	super		populateHeaderFor: aMethodContextOrCompiledMethod		using: aMaObjectSerializer.	self captureEssentialAttributesFrom: aMethodContextOrCompiledMethod! !!MaCompiledMethodBuffer methodsFor: 'creation' stamp: 'cmm 11/18/2014 20:35'!createObjectUsing: aMaObjectSerializer 	| cm offset |	cm := CompiledMethod		newMethod: self byteCodesPlusTrailerSize		header: self headerForThisVm.	"First populate the bytes."	offset := self bufferPositionOfByteCodesPlusTrailerBytes.	1		to: self byteCodesPlusTrailerSize		do:			[ : n | cm				basicAt: cm initialPC + n - 1				put: (byteArray at: startPos + offset + n - 1) ].	^ cm! !!MaCompiledMethodBuffer methodsFor: 'creation' stamp: 'cmm 8/10/2011 16:09'!establishReferencesFrom: anObject using: aMaObjectSerializer 	1		to: anObject maInstSize		do:			[ : instVarIndex | 			anObject				literalAt: instVarIndex				put: (aMaObjectSerializer objectWithOid: (self maInstVarAt: instVarIndex)) realObjectIfMutatingProxy ]! !MaFixedObjectBuffer subclass: #MaMethodContextBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaMethodContextBuffer commentStamp: 'cmm 8/4/2011 20:25' prior: 0!A MaMethodContextBuffer is a special buffer to represent instances of MethodContext.  This is necessary because of the special-nature of MethodContexts; that you must know the correct frame size (small or full) but that is separate from the number of instance-variables it has.  Therefore, we add an attribute, #frameSize to the header.	(see superclass)	12 = control-byte		bit 1 (low-order bit) "largeFrame"			0 = CompiledMethod smallFrameSize			1 = CompiledMethod fullFrameSize!!MaMethodContextBuffer methodsFor: 'private' stamp: 'cmm 7/31/2011 17:53'!bufferType	^ 7! !!MaMethodContextBuffer methodsFor: 'building' stamp: 'cmm 8/4/2011 20:44'!captureEssentialAttributesFrom: aMethodContext 	self largeFrame: aMethodContext method frameSize = CompiledMethod fullFrameSize! !!MaMethodContextBuffer methodsFor: 'building' stamp: 'cmm 4/22/2013 22:10'!populateHeaderFor: aMethodContextOrCompiledMethod using: aMaObjectSerializer 	super		populateHeaderFor: aMethodContextOrCompiledMethod		using: aMaObjectSerializer.	self captureEssentialAttributesFrom: aMethodContextOrCompiledMethod! !!MaMethodContextBuffer methodsFor: 'creation' stamp: 'cmm 4/16/2018 20:15'!createObjectUsing: aMaObjectSerializer 	^ Context basicNew:		(self largeFrame			ifTrue: [ CompiledMethod fullFrameSize ]			ifFalse: [ CompiledMethod smallFrameSize ])! !!MaMethodContextBuffer methodsFor: 'access' stamp: 'cmm 8/4/2011 20:39'!largeFrame	"Answer whether this MethodContext must be created with the largeFrame size."	^ (self controlFields2 bitAnd: 2r00000001) = 1! !!MaMethodContextBuffer methodsFor: 'access' stamp: 'cmm 11/13/2014 17:47'!largeFrame: aBoolean 	"Specify whether this MethodContext must be created with the largeFrame size."	self controlFields2:		(self controlFields2			bitAt: 1			put:				(aBoolean					ifTrue: [ 1 ]					ifFalse: [ 0 ]))! !!MaMethodContextBuffer methodsFor: 'printing' stamp: 'cmm 8/4/2011 20:43'!maPrintAbbreviatedOn: aStream 	self		maPrintAttributes: #(#oid #classId #objectInstSize #commitNumber #oids)		on: aStream! !MaObject subclass: #MaSerializedGraphBuffer	instanceVariableNames: 'byteArray'	classVariableNames: 'SizeWarningThreshold'	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaSerializedGraphBuffer commentStamp: 'cmm 6/10/2009 09:32' prior: 0!I represent a serialized graph of objects.  Normally entire graphs are serialized but a #toCreateProxies: block may be specified for materialization so that the graph will be terminated with proxy objects.!!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 8/10/2010 14:03'!bufferPositionsDo: oneArgBlock 	"Value oneArgBlock with the value of the starting position of each	buffer in the receiver."	| pos end |	pos := self headerSize.	end := self bufferSize - 1.	[ pos <= end ] whileTrue:		[ | physicalSize bufferClass |		oneArgBlock value: pos.		bufferClass := MaObjectBuffer			bufferClassFor: byteArray			startPos: pos.		physicalSize := byteArray			maUint: bufferClass sizeOfPhysicalSizeField			at: pos + bufferClass bufferPositionOfPhysicalSize.		pos := pos + physicalSize ]! !!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 07:59'!bufferTypeAt: startPositionOfObjectBuffer	^ MaObjectBuffer		bufferTypeIn: byteArray		startingAt: startPositionOfObjectBuffer! !!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 7/16/2002 21:42'!headerSize	^self class headerSize! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:18'!bufferSize	^ byteArray maUnsigned32At: 1! !!MaSerializedGraphBuffer methodsFor: 'accessing'!byteArray	"One ByteArray holds the entire graph of objects."	^byteArray! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 2/15/2005 22:18'!objectCount	| count |	count := 0.	self buffersDo: [ : each | count := count + 1 ].	^ count! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 5/3/2005 12:41'!rootBuffer	self buffersDo: [ : each | ^ each ]! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 3/15/2009 21:17'!sameBuffers	"Answer an Array of my individual MaObjectBuffers whose byteArray all share mine."	| arg x |	arg := Array new: self objectCount.	x := 0.	self buffersDo: 		[ : each | 		arg 			at: (x := x + 1)			put: each copyWithSameBuffer ].	^ arg! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 1/11/2007 21:34'!trimByteArray	byteArray := self trimmedByteArray! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 4/3/2003 00:11'!trimmedByteArray	^byteArray		copyFrom: 1		to: self bufferSize! !!MaSerializedGraphBuffer methodsFor: 'private building' stamp: 'cmm 4/3/2003 00:11'!bufferSize: anInteger	byteArray		maUint: 32		at: 0		put: anInteger! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 6/15/2005 22:53'!buffers	| coll |	coll := OrderedCollection new.	self buffersDo: [ :each | coll add: each independentCopy ].	^coll! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 5/7/2013 09:48'!buffersMissingFromWhole	"Answer whether I have all the object buffers needed to reconstitute my entire graph."	^ Array streamContents:		[ : stream | self			buffersMissingFromWholeWhere:				[ : each | true ]			do: [ : eachOid : eachBuffer | stream nextPut: eachOid -> eachBuffer copyWithSameBuffer ] ]! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 5/7/2013 09:48'!buffersMissingFromWholeWhere: aBlock	"Answer whether I have all the object buffers needed to reconstitute my entire graph."	^ Array streamContents:		[ : stream | self			buffersMissingFromWholeWhere: aBlock			do: [ : eachOid : eachBuffer | stream nextPut: eachOid -> eachBuffer copyWithSameBuffer ] ]! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 10/13/2014 21:34'!buffersMissingFromWholeWhere: conditionBlock do: twoArgBlock 	"Value twoArgBlock with an Association whose value is a buffer which references an oid for which there is no buffer and whose key is the oid which is unreferenced."	| oids |	oids := PluggableSet integerSet.	self buffersDo:		[ : each | oids add: each oid ].	self buffersDo:		[ : eachBuffer | eachBuffer isPointers ifTrue:			[ eachBuffer oids do:				[ : eachOid | ((MaOidCalculator isOidForOptimizedObject: eachOid) not and:					[ (oids includes: eachOid) not and: [ conditionBlock value: eachOid ] ]) ifTrue:					[ twoArgBlock						value: eachOid						value: eachBuffer ] ] ] ]! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 2/7/2005 17:29'!isWhole	"Answer whether I have all the object buffers needed to reconstitute my entire graph."	^ self buffersMissingFromWhole isEmpty! !!MaSerializedGraphBuffer methodsFor: 'actions' stamp: 'cmm 4/3/2003 00:11'!buffersDo: oneArgBlock	"Value oneArgBlock with each ObjectBuffer in the	receiver.  There is one ObjectBuffer for each object in the graph that	the receiver represents."	| preMadeBuffers |	preMadeBuffers := self newPremadeBuffers.	self bufferPositionsDo:		[ :eachPosition | | buffer |		buffer := (preMadeBuffers at: (self bufferTypeAt: eachPosition)).		buffer			byteArray: byteArray;			startPos: eachPosition.		oneArgBlock value: buffer ]! !!MaSerializedGraphBuffer methodsFor: 'building'!byteArray: aByteArray	byteArray := aByteArray! !!MaSerializedGraphBuffer methodsFor: 'building' stamp: 'cmm 3/7/2005 14:37'!increaseBufferSizeBy: anInteger	anInteger < self headerSize		ifTrue:			[ MaObjectSerializationSoftwareError signal: 'This object being appended is not properly supported.' ].	self bufferSize: self bufferSize + anInteger! !!MaSerializedGraphBuffer methodsFor: 'building'!resetBufferSize	"Reset the current pointer (which is the bufferSize) back to the beginning."	self bufferSize: self headerSize! !!MaSerializedGraphBuffer methodsFor: 'building'!resetByteArray: aByteArray	self		byteArray: aByteArray;		resetBufferSize! !!MaSerializedGraphBuffer methodsFor: 'printing' stamp: 'cmm 5/30/2013 17:08'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	byteArray notNil		ifTrue:			[ aStream				nextPutAll: ' (';				maPrint: self objectCount;				nextPutAll: ' objects in ';				maPrint: self bufferSize asBytesDescription;				nextPutAll: ' bytes)' ]! !!MaSerializedGraphBuffer methodsFor: 'private creation' stamp: 'cmm 10/21/2004 12:52'!newPremadeBuffers	^MaObjectBuffer bufferClasses collect: [ :each | each new ]! !!MaSerializedGraphBuffer methodsFor: 'private creation' stamp: 'cmm 7/12/2007 21:24'!postCopy	super postCopy.	self trimByteArray ! !!MaSerializedGraphBuffer methodsFor: '*magma-client' stamp: 'cmm 5/7/2013 09:49'!newObjectBuffersMissingFromWhole	^ Array streamContents:		[ : stream | self			buffersMissingFromWholeWhere:				[ : oid | MaOidCalculator isOidForNewObject: oid ]			do:				[ : referencedOid : referencingBuffer | stream nextPut: referencedOid -> referencingBuffer copyWithSameBuffer ] ]! !!MaSerializedGraphBuffer methodsFor: '*magma-server' stamp: 'cmm 8/13/2002 21:27'!decreaseBufferSizeBy: anInteger	self bufferSize: self bufferSize - anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaSerializedGraphBuffer class	instanceVariableNames: ''!!MaSerializedGraphBuffer class methodsFor: 'creation' stamp: 'cmm 5/1/2005 22:27'!byteArray: aByteArray	^ self new		byteArray: aByteArray ;		yourself! !!MaSerializedGraphBuffer class methodsFor: 'creation'!new: anInteger	^self new resetByteArray: (ByteArray new: anInteger)! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 6/10/2009 11:35'!doubleSizeWarningThreshold	self sizeWarningThreshold: self sizeWarningThreshold * 2! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 9/22/2002 23:52'!headerSize	"header only has 32-bit integer representing the physicalSize of my byteArray that holds the entire serialized graph."	^4! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 8/8/2011 21:26'!initialize	super initialize.	self sizeWarningThreshold: 100000000! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 6/10/2009 09:33'!sizeWarningThreshold	^ SizeWarningThreshold! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 6/10/2009 09:34'!sizeWarningThreshold: anInteger 	SizeWarningThreshold := anInteger! !!MaSerializedGraphBuffer class methodsFor: 'accessing' stamp: 'cmm 9/18/2014 14:46'!unreasonablePhysicalSize	"An arbitrary limit at this time, we need *something* to check to prevent unreasonable allocation attempts."	^ 150000000! !MaObjectBuffer subclass: #MaVariableBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaVariableBuffer commentStamp: 'cmm 12/1/2004 23:13' prior: 0!This class encapsulates an object that has a variable logical size, primarily Smalltalk collections including Byte-oriented collections such as ByteArray and String.I add no additional fields, only behavior.!!MaVariableBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anObject using: aMaObjectSerializer	"This method stores either anObject itself or the oid for anInteger."	self subclassResponsibility! !!MaVariableBuffer methodsFor: '*magma-client' stamp: 'cmm 11/24/2004 09:23'!isDifferent: anObject using: aMaObjectSerializer	"To determine different for variable classes requires special-case, therefore dispatch."	^ anObject		maIsChangedFrom: self		using: aMaObjectSerializer! !!MaVariableBuffer methodsFor: '*magma-client' stamp: 'cmm 1/10/2014 17:03'!refresh: variableObject using: aMagmaSession includingLocal: aBoolean	"Collections require special-case behavior to handle this, dispatch."	variableObject		maRefreshTo: self		using: aMagmaSession! !!MaVariableBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 12:59'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	aMagmaFileTraverser		graphFromPointers: self		do: oneArgBlock		using: aMaReadStrategy! !MaVariableBuffer subclass: #MaByteObjectBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaByteObjectBuffer commentStamp: 'cmm 8/10/2010 14:37' prior: 0!I encapsulate objects that represented as a series of bytes; such as Strings and ByteArrays.!!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 12/1/2004 22:47'!asByteArray	^ self asByteObject: ByteArray! !!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 2/23/2005 14:38'!asByteObject: byteClass	^ self fillByteObject: (byteClass new: self objectSize)! !!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 12/1/2004 22:47'!asString	^ self asByteObject: String! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:32'!bufferType	^ 1! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/9/2012 12:10'!maInstVarAt: anInteger 	^ self 		uint: 8		at: (self bufferPositionOfInstVarAt: anInteger)! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 7/18/2005 13:32'!numberToStoreFor: anObject using: aMaObjectSerializer	"This method stores either anObject itself or the oid for anInteger."	self shouldNotImplement! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 11:08'!slotSize	^ 1! !!MaByteObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 22:41'!createObjectUsing: aMaObjectSerializer	"Objects with byte-based storage-objects can and do materialize now, rather than pointer-based storage-objects, which aren't actually well-formed until after establishingReferencesFrom:."	^ (self ensureClassUsing: aMaObjectSerializer)		maMaterializeFrom: self		using: aMaObjectSerializer! !!MaByteObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!fillByteObject: byteObject	^byteObject		replaceFrom: 1		to: byteObject size		with: byteArray		startingAt: self startPos + self headerSize + 1.! !!MaByteObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!replaceFrom: startInteger to: endInteger with: byteObject startingAt: startingInteger	byteArray		replaceFrom: self startPos + self headerSize + startInteger		to: self startPos + self headerSize + endInteger		with: byteObject		startingAt: startingInteger! !!MaByteObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/8/2004 12:09'!isBytes	^ true! !!MaByteObjectBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:01'!isPointers	^ false! !!MaByteObjectBuffer methodsFor: 'actions' stamp: 'cmm 12/13/2016 17:27'!populateBodyFor: storageObject using: aMaObjectSerializer 	storageObject		maStreamBytesInto: self		for: aMaObjectSerializer! !!MaByteObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 1/25/2005 14:07'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	"Nothing to do for a byte-object."! !!MaByteObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 12:58'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	"nothing to do for a Byte-object buffer."! !MaByteObjectBuffer subclass: #MaStorageObjectBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaStorageObjectBuffer commentStamp: 'cmm 5/1/2005 21:12' prior: 0!I am a buffer for an object that requires first-class, custom 'storage-object' for serialization.  I contain a MaSerializedGraphBuffer which can be used to materialize the first-class storage object.!!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 21:13'!bufferType	^ 5! !!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/2/2005 13:39'!buffersDo: aBlock	(MaSerializedGraphBuffer byteArray: self asByteArray) buffersDo: aBlock! !!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 22:29'!createObjectUsing: aMaObjectSerializer	^ (self ensureClassUsing: aMaObjectSerializer)		maMaterializeFromGraph: self asByteArray		using: aMaObjectSerializer copyWithNewOidSpace! !!MaStorageObjectBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 13:00'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	"Though I am an object stored in a different representation, that representation is fully part of the repository, so enumerate the buffers my MaSerializedGraphBuffers buffers."	oneArgBlock value: self.	self buffersDo:		[ : eachBuffer |		"The buffers of a storage-object are never assigned permanent oids.  But if already-persistent objects are referenced from the storage-object, they will be and should be traversed normally."		(MaOidCalculator isOidForUserObject: eachBuffer oid)			ifTrue:				[ eachBuffer					graphDo: oneArgBlock					using: aMaReadStrategy					for: aMagmaFileTraverser ]			ifFalse:				[ oneArgBlock value: eachBuffer ] ]! !MaVariableBuffer subclass: #MaVariableObjectBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaVariableObjectBuffer commentStamp: 'cmm 8/10/2010 15:21' prior: 0!This class encapsulates variably-sized objects that reference objects.My buffer fields are (these are 0-based indexes):	(see superclass)	18 = inst var #1!!MaVariableObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:33'!bufferType	^ 2! !!MaVariableObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anObject using: aMaObjectSerializer	^ aMaObjectSerializer oidFor: anObject! !!MaVariableObjectBuffer methodsFor: 'creation' stamp: 'cmm 8/1/2011 21:17'!createObjectUsing: aMaObjectSerializer	| class |	class := self ensureClassUsing: aMaObjectSerializer.	"Set and Dictionary are special-case for this because we store their logical rather than physical representation.  Therefore, dispatch to the class to build the skeleton for VariableObjectBuffers."	^ class newSkeletonFor: self! !!MaVariableObjectBuffer methodsFor: 'creation' stamp: 'cmm 8/1/2011 20:55'!establishReferencesFrom: anObject using: aMaObjectSerializer 	"Set and Dictionary require special-case processing, therefore we dispatch."	anObject		maEstablishPointerReferencesFor: self		using: aMaObjectSerializer! !!MaVariableObjectBuffer methodsFor: 'printing' stamp: 'cmm 8/12/2010 14:28'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(#oids )		on: aStream! !!MaVariableObjectBuffer methodsFor: 'building' stamp: 'cmm 11/28/2004 16:21'!populateBodyFor: storageObject using: aMaObjectSerializer	"Logical storage of collections varies by collection, therefore dispatch back to it."	storageObject		maStreamVariablyInto: self		for: aMaObjectSerializer! !!MaVariableObjectBuffer methodsFor: '*magma-tools' stamp: 'cmm 3/19/2007 12:26'!hasValidReferencesFor: aMaObjectFiler 	self instVarsDoWithIndex: 		[ : eachOid : x | 		(self 			isValidOid: eachOid			for: aMaObjectFiler) ifFalse: [ ^ false ] ].	^ true! !MaVariableBuffer subclass: #MaVariableWordBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-Buffers'!!MaVariableWordBuffer commentStamp: 'cmm 8/26/2008 00:33' prior: 0!I encapsulate objects that represented as a series of words (2-byte numbers).  These types are useful for multimedia like sounds.!!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 21:08'!bufferType	^ 4! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 12/2/2004 12:35'!createObjectUsing: aMaObjectSerializer	| answer |	answer := (self ensureClassUsing: aMaObjectSerializer) basicNew: self objectInstSize.	1 to: self objectInstSize do:		[ : x |		answer			basicAt: x			put: (self wordAt: x) ].	^ answer! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:12'!maInstVarAt: logicalPosition	^ self wordAt: logicalPosition! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:12'!maInstVarAt: logicalPosition put: anInteger	^ self		wordAt: logicalPosition		put: anInteger! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anInteger using: aMaObjectSerializer	^ anInteger! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 12/31/2015 13:57'!populateBodyFor: storageObject using: aMaObjectSerializer	1		to: storageObject maInstSize		do:			[ :index |			self				wordAt: index				put: (storageObject wordAt: index) ]! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 11:08'!slotSize	^ 4! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:10'!wordAt: logicalPosition	^ self 		uint: 32		at: (self bufferPositionOfInstVarAt: logicalPosition)! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:09'!wordAt: logicalPosition put: anInteger	self		uint: 32		at: (self bufferPositionOfInstVarAt: logicalPosition)		put: anInteger! !!MaVariableWordBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:01'!isPointers	^ false! !!MaVariableWordBuffer methodsFor: 'printing' stamp: 'cmm 8/10/2010 22:07'!maPrintAbbreviatedOn: aStream	self		maPrintAttributes: #(words)		on: aStream! !!MaVariableWordBuffer methodsFor: 'printing' stamp: 'cmm 12/2/2004 12:35'!words	"This is intended for printing only."	self objectInstSize isInteger ifFalse: [ ^ '** invalid **' ].	^ (1 to: self objectInstSize) collect: [ : index | self maInstVarAt: index ]! !!MaVariableWordBuffer methodsFor: '*magma-client' stamp: 'cmm 11/8/2014 12:23'!isDifferent: anObject using: aMaObjectSerializer	"To determine different for variable classes requires special-case, therefore dispatch."	anObject maInstSize ~= self objectInstSize ifTrue: [ ^ true ].	self instVarsDoWithIndex: 		[ : eachWord : index |		eachWord ~= (anObject slotAt: index) ifTrue: [ ^ true ] ].	^ false! !!MaVariableWordBuffer methodsFor: '*magma-client' stamp: 'cmm 11/10/2014 10:29'!refresh: variableObject using: aMagmaSession includingLocal: aBoolean	"Collections require special-case behavior to handle this, dispatch."	self instVarsDoWithIndex:		[ : eachWord : eachIndex |		variableObject			slotAt: eachIndex			put: eachWord ]! !!MaVariableWordBuffer methodsFor: '*magma-server' stamp: 'cmm 1/25/2005 14:07'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	"Nothing to do for a variable-word object."! !!MaVariableWordBuffer methodsFor: '*magma-server' stamp: 'cmm 3/8/2007 12:59'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser	"nothing to do for a word-object buffer."! !MaObjectBuffer initialize!MaSerializedGraphBuffer initialize!