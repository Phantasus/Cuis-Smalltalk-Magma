MaObject subclass: #MaClientConnection	instanceVariableNames: 'serverSocket lifecycle extractProcess shouldContinue info lastAccess priorLifecycle'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaClientConnection commentStamp: 'cmm 11/13/2008 15:34' prior: 0!A MaClientConnection is created in the server image when a MaClientSocket connects to a MaServerSocket.  At that point, the client can send request ByteArrays which will be extracted by my extractProcess.  The server allows up to 50 simultaneous connections, after which the oldest is disconnected (but not while they're in a request-lifecycle, of course, since they have to be able to send the response).Instance Variables	extractProcess:		<Process> - loops while the client #socket is connected, listening for request ByteArrays, extracting them and processing them when they become available.	lifecycle:		<Object>	serverSocket:		<Object>	shouldContinue:		Set false to allow the extract process and associated socket to clean up normally.!!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 8/22/2013 13:34'!console	^ serverSocket console! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/6/2009 16:27'!info	^ info! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/6/2009 16:27'!info: aString 	info := aString! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2013 10:55'!lastAccess	"The millisecondClockValue of the last time a request was processed for this client.  However, when it is requested by another client, because the millisecondClockValue is different across all computers, this variable is converted to the NUMBER of milliseconds since the last access."	^ lastAccess! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/24/2013 16:59'!lastAccess: anInteger 	"The millisecondClockValue of the last time a request was processed for this client."	lastAccess := anInteger! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 9/28/2014 20:42'!lifecycle	^ lifecycle! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/1/2009 11:17'!serverSocket	^ serverSocket! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/8/2008 10:43'!shouldContinue	^ shouldContinue and: [ serverSocket isRunning ]! !!MaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/8/2008 11:40'!shouldContinue: aBoolean	shouldContinue := aBoolean! !!MaClientConnection methodsFor: 'copying' stamp: 'cmm 7/31/2013 18:21'!informationalCopy	^ self copy postInformationalCopy! !!MaClientConnection methodsFor: 'copying' stamp: 'cmm 7/31/2013 18:21'!postInformationalCopy	lastAccess ifNotNil: [ lastAccess := Time millisecondsSince: lastAccess ]! !!MaClientConnection methodsFor: 'initialize-release' stamp: 'cmm 7/31/2013 10:03'!initialize	super initialize.	shouldContinue := true.	lastAccess := Time millisecondClockValue! !!MaClientConnection methodsFor: 'initialize-release' stamp: 'cmm 8/22/2013 13:38'!setServerSocket: aMaServerSocket lifecycle: aMaServerRequestLifecycle 	serverSocket := aMaServerSocket.	lifecycle := aMaServerRequestLifecycle.	lifecycle clientConnection: self! !!MaClientConnection methodsFor: 'serialization' stamp: 'cmm 10/28/2014 13:29'!maTransientVariables	^ #('serverSocket' 'lifecycle' 'extractProcess' 'shouldContinue' 'priorLifecycle')! !!MaClientConnection methodsFor: 'actions' stamp: 'cmm 9/22/2014 15:55'!monitorForByteArrayRequests	"A socket connection has just been established.  Kickoff a new iterating process for the purpose of listening for requests bytes from a single client (my lifecycles #socket).  receiveOneByteArrayRequestFrom: waits a few seconds on the port, if data comes in it will extract the entire request and return it.  Otherwise it returns nil and the loop can check for shutdown or expiry."	extractProcess := [ [ self shouldContinue and: [ lifecycle socketStream isConnected ] ] whileTrue:		[ | requestByteArray |		requestByteArray := [ self receiveOneByteArrayRequestFrom: lifecycle ]			on: Error			do:				[ : exc | self console					noteException: exc					whileReceivingRequestFrom: lifecycle.				self shouldContinue: false.				nil ].		requestByteArray ifNotNil:			[ | newLifecycle |			newLifecycle := lifecycle copyForNewRequest				 requestByteArray: requestByteArray ;				 yourself.			serverSocket queueRequest: newLifecycle ] ].	lifecycle critical:		[ lifecycle socket closeAndDestroy: serverSocket timeoutSeconds.		lifecycle socketStream resetBuffers.		serverSocket removeConnection: self ] ] newProcess.	extractProcess		 name: 'extracting requests from ' , lifecycle remotePort asString ;		 priority: Processor userInterruptPriority ;		 resume! !!MaClientConnection methodsFor: 'actions' stamp: 'cmm 8/22/2013 13:34'!monitorForUdpByteArrayRequests	"Kickoff a new iterating process for the purpose of listening for requests bytes from UDP clients.  receiveOneByteArrayRequestFrom: waits a few seconds on the port, if data comes in it will extract the entire request and return it.  Otherwise it returns nil and the loop can check for shutdown or expiry."	extractProcess := 	[ [ self shouldContinue ] whileTrue: 		[ | requestByteArray |		requestByteArray := [ self receiveOneUdpRequestFrom: lifecycle ] 			on: Error			do: 				[ : exc | 				self console 					noteException: exc					whileReceivingRequestFrom: lifecycle.				self shouldContinue: false.				nil ].		requestByteArray ifNotNil: 			[ | newLifecycle |			newLifecycle := lifecycle copyForNewRequest				requestByteArray: requestByteArray ;				yourself.			serverSocket queueRequest: newLifecycle ] ] ] newProcess.	extractProcess		name: 'extracting requests from UDP clients' ;		priority: Processor userInterruptPriority ;		resume! !!MaClientConnection methodsFor: 'private' stamp: 'cmm 10/27/2014 16:28'!priorLifecycle: aMaServerRequestLifecycle	priorLifecycle := aMaServerRequestLifecycle! !!MaClientConnection methodsFor: 'private' stamp: 'cmm 9/8/2015 15:05'!receiveOneByteArrayRequestFrom: aMaRequestLifecycle 	"Wait up to 3 seconds for something from the client.  If data is received from aMaRequestLifecycle's socket be sure the entire data is received.  Otherwise answer nil."	| header bytesExpected incomingSequenceNumber answer firstDataReceived compressed priorTimeout |	bytesExpected := nil.	priorTimeout := aMaRequestLifecycle socketStream timeout.	[ aMaRequestLifecycle socketStream timeout: 3.	header := aMaRequestLifecycle socketStream next: 8.	aMaRequestLifecycle socketStream timeout: priorTimeout ]		on: ConnectionTimedOut		do: [ : err | ^ nil ].	firstDataReceived := Time millisecondClockValue.	bytesExpected := header maUnsigned32At: 1.	compressed := bytesExpected maIsBitSet: 32.	bytesExpected := bytesExpected maBitClear: 32.	bytesExpected > MaSerializedGraphBuffer unreasonablePhysicalSize ifTrue: [ MaMalformedRequestError signal: 'unreasonable request size' ].	incomingSequenceNumber := header maUnsigned32At: 5.	"To avoid brittleness, let client choose first sequenceNumber"	aMaRequestLifecycle ifNewAssignSequenceNumber: incomingSequenceNumber-1.	incomingSequenceNumber < aMaRequestLifecycle incrementSequenceNumber ifTrue:		[ self			resend: incomingSequenceNumber			insteadOf: aMaRequestLifecycle expectedSequenceNumber.		^ nil ].	incomingSequenceNumber > aMaRequestLifecycle sequenceNumber ifTrue: [ "Maybe should just allow this?  It probably wouldn't ever happen, but if it did the client is 'satisfied', and maybe because of having sent #wantsResponse=false requests?" (MaClientServerOutOfSequence expected: aMaRequestLifecycle sequenceNumber) signal ].	answer := aMaRequestLifecycle socketStream next: bytesExpected - serverSocket headerSize.	self console noteTimeToExtractRequestBytes: (Time millisecondsSince: firstDataReceived).	aMaRequestLifecycle socketStream isDataAvailable ifTrue: [ NetworkError signal: 'Unexpected client behavior, more bytes received than client stated sending.' ].	compressed ifTrue: [ answer := answer lzUncompressed ].	^ answer! !!MaClientConnection methodsFor: 'private' stamp: 'cmm 9/8/2015 15:05'!receiveOneUdpRequestFrom: aMaRequestLifecycle 	"Wait up to 3 seconds for something from any UDP client.  If data is received from aMaRequestLifecycle's socket, answer it, otherwise nil."	| bytesExpected bytesReceived compressed receiveArray answer |	bytesReceived := 0.	bytesExpected := nil.	aMaRequestLifecycle socket		waitForDataFor: 3		ifClosed: 			[ ConnectionClosed signal: 'Connection closed while waiting for data.' ]		ifTimedOut: 			[ "no data, just fall out"			 ].	^ aMaRequestLifecycle socket dataAvailable ifTrue: 		[ answer := ByteArray new: MaClientSocket mtuSize.		receiveArray := aMaRequestLifecycle socket receiveUDPDataInto: answer.		bytesReceived := receiveArray first.		bytesReceived > serverSocket headerSize ifTrue: 			[ bytesExpected := answer maUnsigned32At: 1.			compressed := bytesExpected maIsBitSet: 32.			bytesExpected := bytesExpected maBitClear: 32.			bytesExpected > MaClientSocket mtuSize ifTrue: [ ^ nil ].			self console noteTimeToLoadBuffers: 				(Time millisecondsToRun: 					[ answer := answer 						copyFrom: serverSocket headerSize + 1						to: bytesExpected.					compressed ifTrue: [ answer := answer lzUncompressed ] ]).			answer ] ]! !!MaClientConnection methodsFor: 'private' stamp: 'cmm 10/27/2014 16:03'!resend: priorSequenceNumber insteadOf: expectedSequenceNumber 	(priorLifecycle notNil and: [ priorLifecycle sequenceNumber = priorSequenceNumber ])		ifTrue: [ serverSocket sendResponseFor: priorLifecycle ]		ifFalse: [ (MaClientServerOutOfSequence expectedSequenceNumber: expectedSequenceNumber) signal ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientConnection class	instanceVariableNames: ''!!MaClientConnection class methodsFor: 'create' stamp: 'cmm 8/22/2013 13:38'!serverSocket: aMaServerSocket lifecycle: aMaServerRequestLifecycle 	^ self new		setServerSocket: aMaServerSocket 		lifecycle: aMaServerRequestLifecycle ;		yourself! !MaObject subclass: #MaServer	instanceVariableNames: 'console'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaServer commentStamp: 'cmm 2/1/2005 15:35' prior: 0!Abstract superclass for the "server engine".  I know a console which I send output to.!!MaServer methodsFor: 'console' stamp: 'cmm 8/22/2013 13:02'!console	^ console! !!MaServer methodsFor: 'initialize-release' stamp: 'cmm 10/7/2002 23:45'!console: aMaServerConsole	console := aMaServerConsole! !!MaServer methodsFor: 'initialize-release' stamp: 'cmm 10/8/2002 23:05'!initialize	super initialize.	console := MaServerConsole new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaServer class	instanceVariableNames: ''!!MaServer class methodsFor: 'system-initialization' stamp: 'cmm 7/30/2015 23:16'!initialize	Transcript cr; show: 'Declaring SigTermHandler'.	Smalltalk		addToStartUpList: self ;		at: #SigTermHandler ifAbsentPut: [ nil ] ;		restartSigTermHandler! !!MaServer class methodsFor: 'system-initialization' stamp: 'cmm 4/27/2015 12:49'!startUp: justLaunchedFromOs	justLaunchedFromOs ifTrue: [ Smalltalk restartSigTermHandler ]! !!MaServer class methodsFor: 'system-initialization' stamp: 'cmm 4/27/2015 12:29'!unload	Smalltalk removeFromStartUpList: self! !MaServer subclass: #MaRequestServer	instanceVariableNames: 'processor'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaRequestServer commentStamp: 'cmm 2/20/2005 17:15' prior: 0!Abstract class whose subclass instances handle the server portion of the client-server activity.  The processor should be an object that responds to #value:.  The argument is the actual request object and it should answer the result object.  Requests and responses can be arbitrary objects, not just byte-objects like Strings and ByteArrays, although you must set up your #protocol.!!MaRequestServer methodsFor: 'private' stamp: 'cmm 5/1/2008 20:55'!connectionRequest	^'connect'! !!MaRequestServer methodsFor: 'private' stamp: 'cmm 9/15/2013 15:27'!processRequest: aMaClientServerRequest 	"Here's your request object, do something with it and answer any object, though for remote connections only, every class throughout the entire request and responses graph must be part of your #protocol."	| answer |	console noteAboutToProcessRequest: aMaClientServerRequest.	answer := [ aMaClientServerRequest		caseOf:			{ [ self connectionRequest ] -> [ self connectionInfo ].			[ 'ping' ] -> [ 'pong' ]}		otherwise: [ processor value: aMaClientServerRequest ] ]		on: MaNotification		do:			[ : noti | console note: noti messageText.			noti resume ].	console noteRequestProcessed: aMaClientServerRequest.	^ answer! !!MaRequestServer methodsFor: 'private' stamp: 'cmm 9/19/2004 22:10'!processor: oneArgBlock	"oneArgBlock takes the request object, answers the response object you want to send back to the client.  For remote, these can only be objects defined in the protocol."	processor := oneArgBlock! !!MaRequestServer methodsFor: 'initializing' stamp: 'cmm 1/5/2003 23:12'!initialize	super initialize.	console := MaRequestServerConsole new! !!MaRequestServer methodsFor: 'testing' stamp: 'cmm 2/20/2005 17:18'!isRunning	self subclassResponsibility! !!MaRequestServer methodsFor: 'accessing' stamp: 'cmm 12/8/2004 13:34'!processor	^ processor! !!MaRequestServer methodsFor: 'accessing' stamp: 'cmm 11/21/2008 18:28'!shutdown	console noteServerShutdown! !MaRequestServer subclass: #MaLocalRequestServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaLocalRequestServer commentStamp: 'cmm 5/8/2008 21:21' prior: 0!Use this server as a stub when you are running your object-request server locally within the same image.!!MaLocalRequestServer methodsFor: 'as yet unclassified' stamp: 'cmm 5/2/2005 22:25'!isRunning	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLocalRequestServer class	instanceVariableNames: ''!!MaLocalRequestServer class methodsFor: 'creation' stamp: 'cmm 9/19/2004 22:38'!processor: oneArgBlockOrProcessor	^ self new 		processor: oneArgBlockOrProcessor ;		yourself! !MaRequestServer subclass: #MaNetworkRequestServer	instanceVariableNames: 'socket serializer nextId protocolByteArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaNetworkRequestServer commentStamp: 'cmm 2/1/2005 15:40' prior: 0!The server to use when you want to allow requests and responses to be any object and run on a remote server.!!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 7/15/2008 22:08'!compressThreshold	^ socket compressThreshold! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 7/15/2008 22:07'!compressThreshold: anInteger	socket compressThreshold: anInteger! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:13'!networkProtocol	"Answer #tcp for TCP/IP interfaces, #udp for UDP."	^ socket networkProtocol! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 11/11/2008 16:27'!networkProtocol: aSymbol 	"Specify #tcp or #udp."	^ socket networkProtocol: aSymbol! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 9/20/2008 16:08'!port	^ socket port! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds	^socket timeoutSeconds! !!MaNetworkRequestServer methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds: anInteger	socket timeoutSeconds: anInteger! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 10/11/2002 00:24'!connectionInfo	^Array		with: self getNextId		with: self protocolByteArray! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 10/11/2002 00:25'!getNextId	^nextId := nextId + 1! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 8/22/2013 12:46'!initialize	super initialize.	socket := MaServerSocket new		 doBlock: [ : eachRequest | self processRequestByteArray: eachRequest ] ;		 yourself.	nextId := 1.	self initializeSerializer! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 6/10/2005 12:21'!initializeSerializer	serializer := MaObjectSerializer new! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 8/22/2013 13:43'!materializeRequest: requestByteArray 	| timeToMaterialize requestObject |	timeToMaterialize := Time millisecondsToRun: 		[ serializer resetOidManager.		requestObject := serializer materializeGraph: requestByteArray ].	console noteTimeToMaterializeRequest: timeToMaterialize.	^ requestObject! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 1/16/2015 16:00'!processRequestByteArray: aMaServerRequestLifecycle 	"Materialize the object serialized in requestByteArray, and serialize the response I get from telling my processor to process it."	| requestObject responseObject |	[ requestObject := self materializeRequest: aMaServerRequestLifecycle requestByteArray.	aMaServerRequestLifecycle requestObject: requestObject ]		on: Error		do:			[ : exc | MaClientServerPreferences debug				ifTrue: [ exc pass ]				ifFalse: [ ^ self serializeResponse:						(MaMalformedRequestError new							 messageText: exc messageText ;							 yourself) ] ].	requestObject isString ifFalse: [ requestObject lifecycle: aMaServerRequestLifecycle ].	responseObject := self processRequest: requestObject.	^ (requestObject wantsResponse and: [ self isUdp not ]) ifTrue:		[ [ self serializeResponse: responseObject ]			maOn: OutOfMemory			do:				[ : err | processor					noteResponseSerializationError: err					lifecycle: aMaServerRequestLifecycle.				self serializeResponse: (MaEnvironmentError messageText: 'Server out of RAM while trying to serialize response.') ]			on: MaObjectSerializationWarning			do:				[ : err | self serializeResponse: (MaEnvironmentError messageText: 'Response size exceeds serializer sizeWarningThreshold of ' , MaSerializedGraphBuffer sizeWarningThreshold asBytesDescription) ] ]! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 9/18/2013 14:08'!protocol: aCollection 	"Establish the class ids of classes in the protocol."	serializer protocol: aCollection! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 8/17/2009 12:32'!protocolByteArray	^ protocolByteArray ifNil: 		[ serializer resetOidManager.		protocolByteArray := serializer classDefinitionsByteArray ]! !!MaNetworkRequestServer methodsFor: 'private' stamp: 'cmm 5/1/2008 19:00'!serializeResponse: anObject 	| timeToSerializeResponse response |	timeToSerializeResponse := Time millisecondsToRun: 		[ serializer resetOidManager.		response := (serializer serializeGraph: anObject) trimmedByteArray ].	console noteTimeToSerializeResponse: timeToSerializeResponse.	^ response! !!MaNetworkRequestServer methodsFor: 'testing' stamp: 'cmm 2/20/2005 17:18'!isRunning	^ socket isRunning! !!MaNetworkRequestServer methodsFor: 'testing' stamp: 'cmm 11/8/2008 16:58'!isUdp	^ socket isUdp! !!MaNetworkRequestServer methodsFor: 'start / stop' stamp: 'cmm 8/22/2013 14:59'!processOn: portNumber 	"Listen on portNumber in the background.  For each client request received, evaluate my processBlock.  I queue all requests so that your block will never be evaluating more than one client-request at a time."	socket console: console.	socket processOn: portNumber! !!MaNetworkRequestServer methodsFor: 'start / stop' stamp: 'cmm 11/9/2008 11:08'!processOn: portNumber using: yourProcessor 	"Listen on portNumber in the background.  For each client request received, send value: to yourProcessor (so yourProcessor must be a Block or respond to #value:).  I queue all requests and ensure your yourProcessor will never be evaluating more than one client-request at a time.  The argument to the value: message is an instance of MaClientServerRequest, of which you create application-specific subclasses."	processor := yourProcessor.	self processOn: portNumber! !!MaNetworkRequestServer methodsFor: 'start / stop' stamp: 'cmm 11/22/2008 10:51'!shutdown	socket shutdown.	"socket shutdown immediately disallows any more requests, but blocks until pending requests get processed.  Those remaining requests which are not finished writing responses can and will continue to write, but the server is no longer needed and able to shutdown."	super shutdown! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaNetworkRequestServer class	instanceVariableNames: ''!!MaNetworkRequestServer class methodsFor: 'creation' stamp: 'cmm 10/8/2002 22:50'!protocol: collectionOfClasses	"collectionOfClasses are all request classes and all response classes any client can expect to encounter in the full graph of the requests and responses"	^self new protocol: collectionOfClasses! !MaObject subclass: #MaServerConsole	instanceVariableNames: 'lastRequestStart lastRequestFinish statistics playAuditorialization soundTheme soundQueue'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaServerConsole commentStamp: 'cmm 2/1/2005 15:34' prior: 0!I am used to receive messages from the server.!!MaServerConsole methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 17:53'!initialize	super initialize.	self initializeStatistics.	playAuditorialization := false.	soundTheme := MacsSoundTheme new! !!MaServerConsole methodsFor: 'initialize-release' stamp: 'cmm 9/29/2008 16:11'!initializeStatistics	statistics := MaServerStat new! !!MaServerConsole methodsFor: 'logging' stamp: 'cmm 10/25/2008 14:54'!log: aString	"Write aString to a log file?"self halt: aString! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!note: aString	"The socket is notifying us of a message."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 15:34'!noteAboutToProcessRequest: yourRequestObject 	lastRequestStart := Time millisecondClockValue! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 12/17/2008 17:26'!noteAboutToStart	"For application hook."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:54'!noteClientTimedOut: aMaRequestLifecycle 	"Network issues, client socket is no longer communicating"	self statistics recordClientTimeout! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:15'!noteException: anException whileReceivingRequestFrom: aMaRequestLifecycle 	"anException was signaled when trying to read from aSocket."	self noteClientTimedOut: aMaRequestLifecycle! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/12/2013 21:02'!noteJustStarted	statistics ensureActive! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 22:50'!noteLastRequestFinish: millisecondClockValueOrNil	"Note the time the last request finished.  Used to track idle time between requests."	lastRequestFinish := millisecondClockValueOrNil! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerAcceptingRequests	"Called when the socket has previously been told to shutdown and can no longer accept requests."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerExtractingRequests	"Called when the socket has previously been told to shutdown and extracted the last pending sockets request."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerProcessingRequests	"Called when the socket has previously been told to shutdown and has processed the last pending request."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:16'!noteNumberOfConnections: anInteger 	"Report the number of known MaClientConnections."	self statistics numberOfClientConnectionsHistory addValue: anInteger! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 8/22/2013 13:40'!noteRequestDequeued: aMaRequestLifecycle 	"Indicates aSocket has delivered a ByteArray request that is about to be processed by my server."	self statistics isActive ifTrue: 		[ self statistics			recordTimeWaitingInRequestQueue: aMaRequestLifecycle timeWaitingInRequestQueue.		"Only record idleTime if there was a wait since the last request."		lastRequestFinish ifNotNil: 			[ self statistics recordIdleTime: 				(Time 					milliseconds: aMaRequestLifecycle requestQueueTime					since: lastRequestFinish).			self noteLastRequestFinish: nil ] ]! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/12/2015 20:08'!noteRequestProcessed: requestObject 	| time sound |	time := Time millisecondsSince: lastRequestStart.	(playAuditorialization and: [ (sound := soundTheme soundFor: requestObject) notNil ]) ifTrue:		[ soundQueue ifNil: [ soundQueue := QueueSound new play ].		soundQueue add: (sound copy duration: time / 1000.0) ].	(self statistics requestProcessingTimeHistoryFor: requestObject) addValue: time.	self statistics requestProcessingTimeHistory addValue: time! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 12/23/2008 19:23'!noteRequestQueued: aMaRequestLifecycle 	"The aMaRequestLifecycle's now has a requestByteArray that has been extracted from its socket.  The requestByteArray has now been appended to the end of the requestQueue."	self statistics isActive ifTrue: 		[ self statistics recordRequestSize: aMaRequestLifecycle requestByteArray size ]! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 12/23/2008 19:11'!noteRequestsQueued: anInteger 	self statistics isActive ifTrue: [ self statistics requestsQueuedHistory addValue: anInteger ]! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:16'!noteResponseSent: aMaRequestLifecycle 	"Successfully sent the aMaRequestLifecycle's responseByteArray to its socket."	self statistics		recordResponseSize: aMaRequestLifecycle responseByteArray size ;		recordTimeToSendResponse: aMaRequestLifecycle timeToSendResponse ;		recordSuccessfulLifecycle! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/27/2014 17:26'!noteResponseSerializationError: anException lifecycle: aMaServerRequestLifecycle	^ anException! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteSendResponse: aByteArray timedOutOn: aSocket	"aSocket must have disconnected or something, we couldn't get the response to them."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteSendingResponse: aByteArray to: aSocket	"a ByteArray is about to be sent to aSocket."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 8/22/2013 13:40'!noteServerShutdown	self statistics		release ;		stopTime: DateAndTime now! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/6/2014 16:20'!noteSocketDequeued: aMaRequestLifecycle 	self statistics isActive ifTrue: 		[ self statistics			recordTimeWaitingInSocketQueue: aMaRequestLifecycle timeWaitingInSocketQueue ]! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/6/2014 16:15'!noteSocketsQueued: anInteger 	self statistics isActive ifTrue: [ self statistics socketsQueuedHistory addValue: anInteger ]! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:22'!noteTimeToExtractRequestBytes: milliseconds 	"Time to extract the request bytes out of the primitive TCP/IP socket."	self statistics recordTimeToExtractRequestBytes: milliseconds! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:22'!noteTimeToLoadBuffers: milliseconds 	"The number of milliseconds spent compressing and uncompressing ByteArrays for more efficient network transport."	self statistics timeToLoadBuffersHistory addValue: milliseconds! !!MaServerConsole methodsFor: 'auditorialization' stamp: 'cmm 10/12/2015 11:03'!playAuditorialization	"Whether or not to play sounds representing request processing."	^ playAuditorialization! !!MaServerConsole methodsFor: 'auditorialization' stamp: 'cmm 10/12/2015 19:39'!playAuditorialization: aBoolean 	"Whether or not to play sounds representing request processing."	(playAuditorialization := aBoolean) = true		ifTrue: [ soundQueue ifNotNil: [soundQueue play] ]		ifFalse: [ soundQueue ifNotNil: [soundQueue reset] ]! !!MaServerConsole methodsFor: 'auditorialization' stamp: 'cmm 10/12/2015 11:09'!soundQueue	^ soundQueue! !!MaServerConsole methodsFor: 'access' stamp: 'cmm 9/29/2008 16:23'!statistics	^ statistics ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaServerConsole class	instanceVariableNames: ''!!MaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 8/16/2016 21:48'!run	"deamontools run script."	^ 'spur -vm display=none server-spur.image run.st `cat port`' ->	[ Smalltalk run:			[ : portString |			Smalltalk mitigateIfHeadless.			(MaNetworkRequestServer new				console: MaRequestServerConsole new ;				processOn: portString asInteger ;				yourself) explore ] ]! !MaServerConsole subclass: #MaRequestServerConsole	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaRequestServerConsole commentStamp: 'cmm 2/1/2005 15:34' prior: 0!I am used to receive messages from the server.!!MaRequestServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:22'!noteTimeToMaterializeRequest: milliseconds 	"The time to materialize a serialized request object."	self statistics timeToMaterializeHistory addValue: milliseconds! !!MaRequestServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:22'!noteTimeToSerializeResponse: milliseconds 	"The time to materialize a serialized request object."	self statistics timeToSerializeHistory addValue: milliseconds! !MaObject subclass: #MaServerRequestLifecycle	instanceVariableNames: 'socket sequenceNumber socketQueueTime socketDequeueTime requestQueueTime requestDequeueTime requestByteArray requestObject beginSendingResponseTime doneSendingResponseTime responseByteArray remoteAddress remotePort clientConnection guard socketStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaServerRequestLifecycle methodsFor: 'private' stamp: 'cmm 10/27/2014 16:29'!bePriorLifecycle	clientConnection priorLifecycle: self! !!MaServerRequestLifecycle methodsFor: 'private' stamp: 'cmm 10/28/2014 12:54'!incrementSequenceNumber	^ sequenceNumber := sequenceNumber + 1 \\ "2 raisedTo: 32" 4294967296! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 9/20/2008 17:09'!clientConnection	^clientConnection! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 9/20/2008 17:09'!clientConnection: aMaClientConnection	clientConnection := aMaClientConnection! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/28/2014 13:19'!ifNewAssignSequenceNumber: anInteger	sequenceNumber ifNil: [ sequenceNumber := anInteger ]! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 16:22'!millisecondsWaitingInSocketQueue	^ Time 		milliseconds: socketDequeueTime		since: socketQueueTime! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/14/2013 17:32'!noteTimeAboutToSendResponse	beginSendingResponseTime := Time millisecondClockValue! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/14/2013 17:52'!noteTimeJustFinishedSendingResponse	doneSendingResponseTime := Time millisecondClockValue! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 16:37'!requestByteArray	^requestByteArray! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 7/5/2008 19:43'!requestByteArray: aByteArray	requestByteArray := aByteArray! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/28/2008 14:48'!requestObject	^ requestObject! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/28/2008 14:48'!requestObject: aMaClientServerRequest	requestObject := aMaClientServerRequest! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 9/29/2008 22:31'!requestQueueTime	^ requestQueueTime! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 19:30'!responseByteArray	^responseByteArray! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 19:30'!responseByteArray: aByteArray 	responseByteArray := aByteArray! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 10/27/2014 15:44'!sequenceNumber	^ sequenceNumber! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 3/1/2009 11:17'!serverSocket	^ clientConnection serverSocket! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 16:18'!socket	^socket! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 9/18/2014 14:09'!socketStream	^socketStream! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 19:27'!timeToSendResponse	^ Time 		milliseconds: doneSendingResponseTime		since: beginSendingResponseTime! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 17:58'!timeWaitingInRequestQueue	^ Time 		milliseconds: requestDequeueTime		since: requestQueueTime! !!MaServerRequestLifecycle methodsFor: 'accessing' stamp: 'cmm 5/1/2008 17:42'!timeWaitingInSocketQueue	^ Time 		milliseconds: socketDequeueTime		since: socketQueueTime! !!MaServerRequestLifecycle methodsFor: 'copying' stamp: 'cmm 6/2/2008 13:15'!copyForNewRequest	^ self copy postCopyForNewRequest! !!MaServerRequestLifecycle methodsFor: 'copying' stamp: 'cmm 10/27/2014 19:49'!postCopyForNewRequest	"The lifecycle stat is instantiated upon the initial socket connection, then cloned for each request to have its own stats."	requestQueueTime := requestDequeueTime := requestByteArray := beginSendingResponseTime := doneSendingResponseTime := responseByteArray := nil! !!MaServerRequestLifecycle methodsFor: 'scheduling' stamp: 'cmm 7/29/2012 12:35'!critical: aBlock	^ guard critical: aBlock! !!MaServerRequestLifecycle methodsFor: 'initialize-release' stamp: 'cmm 7/29/2012 12:29'!initialize	super initialize.	guard := Mutex new! !!MaServerRequestLifecycle methodsFor: 'initialize-release' stamp: 'cmm 5/1/2008 16:30'!noteSocketDequeued	socketDequeueTime := Time millisecondClockValue! !!MaServerRequestLifecycle methodsFor: 'initialize-release' stamp: 'cmm 5/1/2008 16:24'!requestDequeueTime: anInteger	requestDequeueTime := anInteger! !!MaServerRequestLifecycle methodsFor: 'initialize-release' stamp: 'cmm 5/1/2008 16:24'!requestQueueTime: anInteger	requestQueueTime := anInteger! !!MaServerRequestLifecycle methodsFor: 'initialize-release' stamp: 'cmm 9/19/2014 15:01'!socket: aSocket	socket := aSocket.	socketStream := (SocketStream on: aSocket) binary; autoFlush: false.	socketQueueTime := Time millisecondClockValue.	remoteAddress := aSocket remoteAddress.	remotePort := aSocket remotePort! !!MaServerRequestLifecycle methodsFor: 'identification' stamp: 'cmm 5/6/2008 15:39'!remoteAddress	^ remoteAddress! !!MaServerRequestLifecycle methodsFor: 'identification' stamp: 'cmm 5/6/2008 15:39'!remotePort	^ remotePort! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaServerRequestLifecycle class	instanceVariableNames: ''!!MaServerRequestLifecycle class methodsFor: 'create' stamp: 'cmm 11/9/2008 20:15'!socket: aSocket 	^ self new		socket: aSocket ;		yourself! !MaServer subclass: #MaServerSocket	instanceVariableNames: 'socketQueue requestQueue processRequestProcess socket doBlock port running socketQueueMonitorProcess clientConnections clientConnectionsGuard preferences networkProtocol interface'	classVariableNames: 'ActiveSockets'	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaServerSocket commentStamp: 'cmm 6/6/2008 10:19' prior: 0!I am the class which manages the underlying Squeak socket that listens for connecting client sockets.  I receive and process requests in the order received in the background and send responses off in their own background process as well.!!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/18/2014 15:17'!byteArrayToSendFor: aByteArray 	^ aByteArray size > self compressThreshold  		ifTrue: 			[ | compressed |			compressed := aByteArray lzCompressed.			compressed size < aByteArray size 				ifTrue: [ compressed ]				ifFalse: [ aByteArray ] ]		ifFalse: [ aByteArray ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/20/2013 22:26'!dequeueRequest: requestLifecycle 	requestLifecycle requestDequeueTime: Time millisecondClockValue.	console noteRequestDequeued: requestLifecycle.	^ requestLifecycle! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/20/2013 22:27'!extractByteArrayRequestsFrom: aMaServerRequestLifecycle 	"A socket connection has just been established.  Kickoff a new iterating process for the purpose of listening for requests bytes from a single client.  receiveOneByteArrayRequestFrom: waits a few seconds on the port, if data comes in it will extract the entire request and return it.  Otherwise it returns nil and the loop can check for shutdown or expiry."	clientConnectionsGuard critical: 		[ 1 			to: clientConnections size - self maxConnections			do: [ : n | (clientConnections at: n) shouldContinue: false ].		clientConnections add: (MaClientConnection 				serverSocket: self				lifecycle: aMaServerRequestLifecycle) monitorForByteArrayRequests.		console noteNumberOfConnections: clientConnections size ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/27/2014 15:43'!headerSize	"First 4 bytes:  size of entire message (including header).	Bytes 5-8:  sequenceNumber of this request or response."	^ self isUdp ifTrue: [4] ifFalse: [8]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/8/2015 15:17'!initializeQueues	socketQueue := SharedQueue2 new.	requestQueue := SharedQueue2 new! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/9/2016 16:32'!listen	"By using this method, I will call my servers #processRequestByteArray:.  If you don't want to have a MaServer class, use listenOn:answer:."	running ifTrue: [ MaClientServerUserError signal: 'socket already listening.' ].	running := true.	ActiveSockets add: self.	console note: 'creating server socket'.	self isUdp		ifTrue:			[ socket := Socket newUDP				setPort: port				interface: interface ]		ifFalse:			[ socket := Socket newTCP.			socket				listenOn: port				backlogSize: 50				interface: interface ].	socket isValid ifFalse: [ NetworkError signal: 'Socket accept() not supported.' ].	socket port = port ifFalse:		[ self shutdown.		MaClientServerEnvironmentError signal: 'Port ' , port asString , ' could not be allocated.' ].	console		 note: 'now listening on ' , port printString ;		 noteAboutToStart.	self isUdp		ifTrue:			[ | lifecycle |			lifecycle := MaServerRequestLifecycle socket: socket.			lifecycle socketStream timeout: self timeoutSeconds.			clientConnections add:				(MaClientConnection					serverSocket: self					lifecycle: lifecycle) monitorForUdpByteArrayRequests ]		ifFalse:			[ self				 startAcceptingRequests ;				 startExtractingRequests ].	self startProcessingRequests.	console noteJustStarted! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 6/8/2008 16:51'!maxConnections	^ 50! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 3/24/2013 16:56'!primQueueRequest: aMaServerRequestLifecycle 	requestQueue nextPut: aMaServerRequestLifecycle! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/19/2014 10:41'!primShutdown	running := false.	console note: 'Server is shutting down right now.'.	[ socketQueue isEmpty ] whileFalse: [ (Delay forSeconds: 1) wait ].	socketQueueMonitorProcess ifNotNilDo:		[ : proc | proc terminate ].	processRequestProcess ifNotNil: [processRequestProcess terminate].	socket ifNotNil: [ socket closeAndDestroy: self timeoutSeconds ].	self initializeQueues.	socket := nil! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/27/2014 17:18'!processRequest: aMaServerRequestLifecycle 	| responseByteArray time |	responseByteArray := doBlock value: aMaServerRequestLifecycle.	time := Time millisecondClockValue.	aMaServerRequestLifecycle clientConnection lastAccess: time.	console noteLastRequestFinish: (requestQueue isEmpty ifTrue: [ time ]).	"aMaServerRequestLifecycle requestObject will be nil for ByteArray servers, which means TCP ByteArray servers must always provide a response."	(self isUdp not and: [ aMaServerRequestLifecycle requestObject wantsResponse ]) ifTrue:		[ aMaServerRequestLifecycle responseByteArray: responseByteArray.		self sendResponseFor: aMaServerRequestLifecycle ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/20/2013 22:33'!queueRequest: aMaRequestLifecycle 	running ifTrue: 		[ aMaRequestLifecycle requestQueueTime: Time millisecondClockValue.		console noteRequestsQueued: requestQueue size.		self primQueueRequest: aMaRequestLifecycle.		console noteRequestQueued: aMaRequestLifecycle ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/19/2014 16:54'!queueSocket: aSocket	| lifecycle | lifecycle := MaServerRequestLifecycle socket: aSocket.	socketQueue nextPut: lifecycle.	lifecycle socketStream timeout: self timeoutSeconds.	console noteSocketsQueued: socketQueue size! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/21/2013 09:33'!removeConnection: aMaClientConnection 	clientConnectionsGuard critical: 		[ clientConnections 			remove: aMaClientConnection			ifAbsent: 				[ "not worth blowing up"				 ].		console noteNumberOfConnections: clientConnections size ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 3/1/2009 12:43'!requestQueue	^ requestQueue! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 12/27/2014 20:20'!sendResponseFor: aMaServerRequestLifecycle 	[ aMaServerRequestLifecycle critical:		[ | byteArrayToSend writeStream header |		writeStream := aMaServerRequestLifecycle socketStream.		writeStream isConnected			ifTrue:				[ aMaServerRequestLifecycle noteTimeAboutToSendResponse.				byteArrayToSend := self byteArrayToSendFor: aMaServerRequestLifecycle responseByteArray.				header := self					sequenceNumber: aMaServerRequestLifecycle sequenceNumber					totalToSend: byteArrayToSend size + self headerSize					compressed: aMaServerRequestLifecycle responseByteArray ~~ byteArrayToSend.				console					noteSendingResponse: byteArrayToSend					to: writeStream.				[ writeStream					 nextPutAll: header ;					 nextPutAll: byteArrayToSend ;					 flush.				writeStream socket waitForSendDoneFor: self timeoutSeconds.				aMaServerRequestLifecycle noteTimeJustFinishedSendingResponse.				console noteResponseSent: aMaServerRequestLifecycle ]					on: ConnectionTimedOut					do:						[ : exc | writeStream socket closeAndDestroy: preferences timeoutSeconds ].				writeStream isConnected					ifTrue: [ aMaServerRequestLifecycle bePriorLifecycle ]					ifFalse: [ console noteClientTimedOut: aMaServerRequestLifecycle ] ]			ifFalse: [ console noteClientTimedOut: aMaServerRequestLifecycle ] ] ] forkAt: Processor userInterruptPriority! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/28/2014 13:25'!sequenceNumber: sequenceNumber totalToSend: totalToSend compressed: compressed 	| header |	header := ByteArray new: self headerSize.	header		maUint: 32		at: 0		put:			(self				setCompressedBit: compressed				for: totalToSend).	self isUdp ifFalse:		[ header			maUint: 32			at: 4			put: sequenceNumber ].	^ header! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 6/29/2008 11:10'!setCompressedBit: aBoolean for: headerInteger 	^ aBoolean 		ifTrue: 			[ "Below is the correct implementation, but we would need a 2GB ByteArray for the simpler faster implementation below not to work.  2GB can't happen."			"ba maUint: 32 at: 0 put: ((ba maUint: 32 at: 0) maBitSet: 32)."			headerInteger maBitSet: 32 ]		ifFalse: [ headerInteger maBitClear: 32 ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/27/2014 21:41'!startAcceptingRequests	| clientSocket |		[ [ running ] whileTrue: 		[ clientSocket := socket 			waitForAcceptFor: 5 "seconds to wait for server to shutdown, if asked"			ifTimedOut: [ nil ].		(clientSocket notNil and: [ clientSocket isConnected ]) ifTrue: [ self queueSocket: clientSocket ] ].	console noteNoLongerAcceptingRequests ] newProcess		name: 'Socket acceptor' ;		priority: Processor userInterruptPriority ;		resume.	console note: 'Ready to queue sockets'! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/18/2014 21:41'!startExtractingRequests	socketQueueMonitorProcess := 	[ [ running ] whileTrue: 		[ | requestLifecycle |		requestLifecycle := socketQueue next.		requestLifecycle noteSocketDequeued.		console noteSocketDequeued: requestLifecycle.		self extractByteArrayRequestsFrom: requestLifecycle.		requestLifecycle := nil ].	console noteNoLongerExtractingRequests ] newProcess		name: 'socketQueue Monitor' ;		priority: Processor userInterruptPriority ;		resume.	console note: 'ready to extract requests'! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/19/2014 11:28'!startProcessingRequests	processRequestProcess := 	[ [ running ] whileTrue: 		[ [ self processRequest: (self dequeueRequest: requestQueue next) ] 			on: Error			do: 				[ : err | 				MaClientServerPreferences debug 					ifTrue: [ err pass ]					ifFalse: 						[ MaClientServerNotification signal: 'ERROR PROCESSING REQUEST!!!!!!  (See SERVER-ERROR.log)'.						Smalltalk 							logError: err description							inContext: err signalerContext							to: 'SERVER-ERROR.log' ] ] ].	console noteNoLongerProcessingRequests ] newProcess		name: 'Request processor' ;		priority: Processor userSchedulingPriority+1 ;		resume.	console note: 'ready to process requests'! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:53'!compressThreshold	"The maximum number of bytes a request will be before the client decides it should be compressed."	^ preferences compressThreshold ! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:53'!compressThreshold: anInteger 	"The maximum number of bytes a request will be before the client decides it should be compressed."	preferences compressThreshold: anInteger! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 20:50'!interface	^interface! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 20:51'!interface: byteArrayAddress	"Specify which network interface this socket should listen/read."	interface := byteArrayAddress! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 14:15'!networkProtocol	"Answer #tcp for TCP/IP interfaces, #udp for UDP."	^ networkProtocol! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 11/11/2008 16:27'!networkProtocol: aSymbol 	"Specify #tcp or #udp."	networkProtocol := aSymbol! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 9/21/2008 16:16'!port	^ socket ifNotNil: [ socket port ]! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:52'!timeoutSeconds	"The number of seconds to wait for responses from network requests before assuming they are lost."	^ preferences timeoutSeconds! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 7/5/2008 22:52'!timeoutSeconds: anInteger 	"The number of seconds to wait for responses from network requests before assuming they are lost."	preferences timeoutSeconds: anInteger! !!MaServerSocket methodsFor: 'initialize-release' stamp: 'cmm 8/22/2013 12:45'!doBlock: aBlock	doBlock := aBlock! !!MaServerSocket methodsFor: 'initialize-release' stamp: 'cmm 8/22/2013 12:47'!initialize	super initialize.	running := false.	self initializeQueues.	clientConnections := OrderedCollection new.	clientConnectionsGuard := Mutex new.	preferences := MaClientServerPreferences new		compressThreshold: MaSerializedGraphBuffer unreasonablePhysicalSize * 2 ;		yourself.	networkProtocol := #tcp.	interface := NetNameResolver addressFromString: '0.0.0.0'! !!MaServerSocket methodsFor: 'printing' stamp: 'cmm 7/16/2008 09:55'!hostAndPortStringFor: aSocket 	^ 'host: ' , (NetNameResolver stringFromAddress: aSocket remoteAddress) , ' port: ' , aSocket port printString! !!MaServerSocket methodsFor: 'testing' stamp: 'cmm 3/1/2009 11:16'!isConnected	^ socket isConnected! !!MaServerSocket methodsFor: 'testing' stamp: 'cmm 2/10/2005 09:42'!isRunning	^ running! !!MaServerSocket methodsFor: 'testing' stamp: 'cmm 11/11/2008 14:15'!isUdp	^ networkProtocol == #udp! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 11/10/2008 16:03'!processOn: portNumber 	"By using this method, I will call my servers #processRequestByteArray:.  If you don't want to have a MaServer class, use listenOn:answer:."	port := portNumber.	self listen! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 11/10/2008 16:05'!processOn: portNumber using: oneArgBlock 	"Listen on portNumber, for each ByteArray request received answer the value of oneArgBlock (which should answer a ByteArray)."	doBlock := oneArgBlock.	self processOn: portNumber! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 4/30/2003 00:46'!shutdown	ActiveSockets remove: self ifAbsent: [ "do nothing" ].	self primShutdown! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaServerSocket class	instanceVariableNames: ''!!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 11/21/2008 12:52'!initialize	ActiveSockets ifNotNil: [ ActiveSockets do: [ : each | each shutdown ] ].	ActiveSockets := Set new.	Smalltalk		addToStartUpList: self ;		addToShutDownList: self! !!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 12/27/2004 23:16'!shutDown: aboutToQuit	super shutDown: aboutToQuit.	ActiveSockets do: [ :each | each primShutdown ]! !!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 9/2/2010 19:36'!startUp: amResuming	ActiveSockets do: 		[ :each | 		"If another startUp method creates and starts one of me listening, then I don't want to tell it to listen again"		each isRunning ifFalse: [ each listen ] ]! !MaSerializationStat subclass: #MaServerStat	instanceVariableNames: 'requestsQueuedHistory socketsQueuedHistory requestSizeHistory requestProcessingTimeHistory requestProcessingTimeHistorys responseSizeHistory extractTimeHistory timeWaitingInSocketQueueHistory timeWaitingInRequestQueueHistory timeToSendResponsesHistory clientTimeoutsHistory numberOfClientConnectionsHistory timeToLoadBuffersHistory idleTimeHistory'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:28'!clientTimeoutsHistory	"This history describes how often clients timed out.  When a request completes its lifecycle with no errors, a score of 0 is given.  When a network error occurs receiving the request or sending the response, a score of 1 is added.  Therefore, the sum is the total number of timeouts, #mean is how often they timed out."	^ clientTimeoutsHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:29'!extractTimeHistory	"This history describes the amount of time, in milliseconds, elapsed from the initial client socket connection to the point in which the entire request is uploaded to my server."	^ extractTimeHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 9/29/2008 22:01'!idleTimeHistory	"The time the server waited after processing a request, before a new request came in."	^ idleTimeHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 6/8/2008 11:33'!numberOfClientConnectionsHistory	"The number of client sockets simultaneously connected to this server.  There is a Process running for each one that extracts the request bytes from them."	^numberOfClientConnectionsHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:33'!requestProcessingTimeHistory	"These statistics represent the time, in milliseconds, actually consumed by the Magma server to process client requests.  Although requests are processed one at a time, responses are sent in separate threads and request input downloads are also concurrent."	^ requestProcessingTimeHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 7/13/2009 18:06'!requestProcessingTimeHistoryFor: requestObject 	"Different requests take different amounts of time to process.  Track them by the class of request."	^ requestProcessingTimeHistorys 		at: requestObject maOriginalClass		ifAbsentPut: 			[ MaStatHistory new				name: 'Time to process ' , requestObject class name ;				transition ;				yourself ]! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:33'!requestSizeHistory	"The size of client requests, in bytes.  This would be related to extractTime, timeToMaterializeRequests and requestProcessingTimes."	^ requestSizeHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!requestsQueuedHistory	"The number of requests queued at each moment a new client request is queued.  How long does the request line get.."	^ requestsQueuedHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!responseSizeHistory	"A statistic about how large the responses are.  As these numbers increase so, too, should the timeToSerializeResponses and timeToSendResponses increase."	^ responseSizeHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!socketsQueuedHistory	"The number of sockets in a queue waiting solely to have the bytes of the request extracted from the socket."	^ socketsQueuedHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 6/8/2008 21:33'!timeToLoadBuffersHistory	^timeToLoadBuffersHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!timeToSendResponsesHistory	"The time required to send serialized responses out the TCP/IP port over the network.  Responses are sent in individual background threads."	^ timeToSendResponsesHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!timeWaitingInRequestQueueHistory	"The time, in milliseconds, from the point when the request is put into the request queue, all requests in front of it have been processed, and it is dequeued."	^ timeWaitingInRequestQueueHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:34'!timeWaitingInSocketQueueHistory	"The duration, in milliseconds, from when the socket is queued until extraction of its ByteArray can begin.  All sockets in front of it get their ByteArray's extracted first."	^ timeWaitingInSocketQueueHistory! !!MaServerStat methodsFor: 'historys' stamp: 'cmm 8/18/2014 10:00'!topRequestProcessingTimeHistorysBy: operatorSymbol 	^ requestProcessingTimeHistorys asArray sort:		[ : a : b | (a perform: operatorSymbol) > (b perform: operatorSymbol) ]! !!MaServerStat methodsFor: 'private-chart' stamp: 'cmm 8/17/2014 23:37'!colorsForRankings: anInteger 	^ (Color wheel: anInteger * (4 / 3) rounded)		copyFrom: 1		to: anInteger! !!MaServerStat methodsFor: 'private' stamp: 'cmm 9/29/2008 21:43'!historysDo: aBlock 	super historysDo: aBlock.	{ 		socketsQueuedHistory.		timeWaitingInSocketQueueHistory.		extractTimeHistory.		requestsQueuedHistory.		timeWaitingInRequestQueueHistory.		requestSizeHistory.		requestProcessingTimeHistory.		responseSizeHistory.		timeToSendResponsesHistory.		clientTimeoutsHistory.		numberOfClientConnectionsHistory.		timeToLoadBuffersHistory.		idleTimeHistory	 } do: aBlock.	requestProcessingTimeHistorys do: aBlock! !!MaServerStat methodsFor: 'initialize-release' stamp: 'cmm 8/22/2013 17:03'!initialize	super initialize.	socketsQueuedHistory := MaStatHistory name: 'Sockets Queued'.	requestsQueuedHistory := MaStatHistory name: 'Requests Queued'.	requestSizeHistory := MaStatHistory name: 'Request Sizes'.	requestProcessingTimeHistory := MaStatHistory name: 'Request Processing Times'.	requestProcessingTimeHistorys := Dictionary new.	responseSizeHistory := MaStatHistory name: 'Response Sizes'.	extractTimeHistory := MaStatHistory name: 'Request Upload Times'.	timeWaitingInSocketQueueHistory := MaStatHistory name: 'Time Waiting in Socket Queue'.	timeWaitingInRequestQueueHistory := MaStatHistory name: 'Time Waiting in Request Queue'.	timeToSendResponsesHistory := MaStatHistory name: 'Response Upload Times'.	clientTimeoutsHistory := MaStatHistory name: 'Failed Lifecycles'.	numberOfClientConnectionsHistory := MaStatHistory name: 'Number of Connected Client Sockets'.	timeToLoadBuffersHistory := MaStatHistory name: 'Time to Compress and Uncompress'.	idleTimeHistory := MaStatHistory name: 'Server Idle Times'! !!MaServerStat methodsFor: 'copying' stamp: 'cmm 12/22/2008 19:56'!postArchivalCopy	requestProcessingTimeHistorys := requestProcessingTimeHistorys copy.	super postArchivalCopy.	self noteStop! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:58'!recordClientTimeout	self clientTimeoutsHistory addValue: 1! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 9/29/2008 15:28'!recordIdleTime: milliseconds	self idleTimeHistory addValue: milliseconds! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:58'!recordRequestSize: anInteger 	self requestSizeHistory addValue: anInteger! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordResponseSize: anInteger 	self responseSizeHistory addValue: anInteger! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordSuccessfulLifecycle	self clientTimeoutsHistory addValue: 0! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordTimeToExtractRequestBytes: milliseconds 	self extractTimeHistory addValue: milliseconds! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordTimeToSendResponse: anInteger 	self timeToSendResponsesHistory addValue: anInteger! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordTimeWaitingInRequestQueue: anInteger	self timeWaitingInRequestQueueHistory addValue: anInteger! !!MaServerStat methodsFor: 'recording' stamp: 'cmm 6/5/2008 21:59'!recordTimeWaitingInSocketQueue: anInteger	self timeWaitingInSocketQueueHistory addValue: anInteger! !!MaServerStat methodsFor: 'accessing' stamp: 'cmm 5/7/2008 17:32'!requestsQueuedStat	^ requestsQueuedHistory active! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/17/2014 23:58'!top: anInteger requestTypesBy: operatorAttribute 	| top |	top := self topRequestProcessingTimeHistorysBy: operatorAttribute.	^ top		copyFrom: 1		to: (anInteger min: top size)! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/18/2014 10:20'!topRequestTypesBy: operatorSymbol 	| stats colors nextStat plot stack |	plot := nil.	stack := StackedPlotMorph new.	stats := (self		top: requestProcessingTimeHistorys size		requestTypesBy: operatorSymbol) readStream.	[ (nextStat := stats next) notNil ] whileTrue:		[ plot ifNil:			[ plot := (#(#total #sum ) includes: operatorSymbol)				ifTrue: [ self newDateAndTimeBySizesPlot ]				ifFalse: [ self newDateAndTimeBySecondsPlot ].			colors := (self colorsForRankings: 4) readStream ].		plot addSeries: ((nextStat seriesOn: operatorSymbol) color: colors next).		plot series size = 4 ifTrue:			[ stack addPlot: plot.			plot := nil ] ].	^ stack! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/18/2014 10:10'!topRequestTypesByCount	^ self topRequestTypesBy: #count! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/21/2014 15:30'!topRequestTypesByMax	^ self topRequestTypesBy: #max! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/18/2014 10:10'!topRequestTypesByMean	^ self topRequestTypesBy: #mean! !!MaServerStat methodsFor: 'chart' stamp: 'cmm 8/18/2014 10:10'!topRequestTypesByTotal	^ self topRequestTypesBy: #total! !MaObject subclass: #MacsSoundTheme	instanceVariableNames: 'sounds'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Client-Server-Core-Server API'!!MacsSoundTheme methodsFor: 'configure' stamp: 'cmm 10/12/2015 14:08'!forAnyKindOf: subclassOfMaClientServerRequest play: aSound 	^ sounds		at: subclassOfMaClientServerRequest		put: aSound! !!MacsSoundTheme methodsFor: 'initialize-release' stamp: 'cmm 10/12/2015 14:10'!initialize	super initialize.	sounds := Dictionary new! !!MacsSoundTheme methodsFor: 'access' stamp: 'cmm 10/12/2015 14:05'!soundFor: aMaClientServerRequest 	^ sounds		at: aMaClientServerRequest maOriginalClass		ifAbsent: [ aMaClientServerRequest class defaultSound ]! !MaServer initialize!MaServerSocket initialize!