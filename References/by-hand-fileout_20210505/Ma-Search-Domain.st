MaObject subclass: #MaAbstractContext	instanceVariableNames: 'name keywords'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaAbstractContext commentStamp: 'cmm 2/7/2008 12:42' prior: 0!The purpose of this class is to provide a universal solution to the "Find by keyword" requirement.My instances represent a human-relatable context in which a set of objects have relevance, and provide keyword-access to those objects.  It is intended to help users find objects.  Each of my subclasses provides its own particular implementation to accessing the objects in a context.  These implementations are stream-based, therefore, very large contexts can be scanned.A MaCompositeContext can be used to aggregate contexts into single-keyword-searchable mega-context.  So, a "Squeak help-desk" context could composite an in-image-code-elements context, Swiki context, SqueakMap context and, finally, squeak-dev mailinglist archive context.  As searches within each context are kicked off in the background, results populate gradually so "research" can begin concurrently.As each context scans, results are organized into results which are, themselves, searchable contexts (MaContextResultsContext).  Currently, relevance-matching is based on a simple hierarchy of relevance, exact-match, case-insensitive match, begins-with match and, finally, contains match.   While these provide a lot of usability, this part needs to be extensible so we can support pluggable "sounds-like" or other matching algorithms.Matching is performed by matching the keywords against the strings provided by any objects enumeration method, #maContextKeywordsDo:.!!MaAbstractContext methodsFor: 'copying' stamp: 'cmm 3/6/2008 17:00'!copyForIndependentSearch	"Each instance maintains current-processing information, i.e., what am I doing right now and where am I?  Therefore, if you need to perform more than one search of a single context at a time, use this method to make a copy of me and use that one."	^ self copy postCopyForIndependentSearch! !!MaAbstractContext methodsFor: 'copying' stamp: 'cmm 3/7/2008 12:20'!postCopyForIndependentSearch	self initializeKeywords! !!MaAbstractContext methodsFor: 'testing' stamp: 'cmm 12/11/2004 09:10'!hasSubcontexts	^ false! !!MaAbstractContext methodsFor: 'testing' stamp: 'cmm 2/28/2008 22:23'!knowsSearchSize	"Some contexts will be able to know their size, others won't.  If the size is known, you must implement #size so percent-complete can be known while scanning."	^ false! !!MaAbstractContext methodsFor: 'initialize-release' stamp: 'cmm 3/7/2008 12:19'!initialize	name := self printString.	self initializeKeywords! !!MaAbstractContext methodsFor: 'initialize-release' stamp: 'cmm 3/7/2008 12:23'!initializeKeywords	keywords := OrderedCollection new! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 3/7/2008 12:18'!keywords	^ keywords! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/7/2008 15:46'!keywords: anArray	"Specify an Array of keywords.  There must be some level of match on all keywords for an object to be matched."	self initializeKeywords.	anArray ifNotEmpty: [ self orKeywords: anArray ]! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 3/7/2008 12:22'!keywordsSelection	"Answers the keywords selected in a readable String."	^ String streamContents: 		[ : stream | 		keywords withIndexDo: 			[ : eachAnded : orIndex | 			eachAnded withIndexDo: 				[ : eachWord : andIndex | 				stream					nextPutAll: eachWord ;					cr ].			orIndex = keywords size ifFalse: [ stream nextPutAll: 'or ' ] ] ]! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:30'!keywordsString: aString 	"Specify one or keywords.  There must be at least a partial match on all keywords for an object to be matched."	self		keywords: (self keywordsIn: aString) ;		refresh! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:37'!lastKnownSize	^ self size! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 12/30/2010 19:53'!mauiName	^ self name ifNil: [ super mauiName ]! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/7/2008 15:40'!name	"A name describing the objects that will be searched."	^name! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/7/2008 15:39'!name: aString	"A name describing the objects that will be searched, i.e., 'squeak-dev Mailing-List Archive'."	name := aString! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 3/7/2008 12:18'!orKeywords: anArray	keywords add: anArray! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:56'!orKeywordsString: keywordsString	self orKeywords: (self keywordsIn: keywordsString)! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 21:54'!searchSize	"If your subclass answers true to #knowsSize, then you must override this method.  Otherwise, you don't have to."	self subclassResponsibility! !!MaAbstractContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:01'!size	"This is the size of the *results* context."	self subclassResponsibility! !!MaAbstractContext methodsFor: 'private' stamp: 'cmm 12/10/2004 15:19'!keywordsIn: aString	^ aString substrings! !!MaAbstractContext methodsFor: 'private' stamp: 'cmm 2/7/2008 15:48'!maContextKeywordsDo: aBlock	"This is used if the user is actually searching for a context.  In other words, the results of a context search will, themselves, be contexts presumably for themselves to be searched."	aBlock value: self name! !!MaAbstractContext methodsFor: 'as yet unclassified' stamp: 'cmm 3/7/2008 12:29'!keywordsString	^ self keywordsSelection! !!MaAbstractContext methodsFor: 'scanning' stamp: 'cmm 1/2/2005 22:25'!refresh	"Refresh the results with a new search."	self subclassResponsibility! !!MaAbstractContext methodsFor: 'scanning' stamp: 'cmm 3/6/2008 17:40'!refreshSource	"Refresh the results."	self refresh! !!MaAbstractContext methodsFor: 'scanning' stamp: 'cmm 1/2/2005 22:26'!resetResults	self subclassResponsibility! !MaObject subclass: #MaClientProcess	instanceVariableNames: 'process shouldStop waiterOnStop progressor shouldPause waiterOnResume'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaClientProcess commentStamp: 'cmm 11/20/2007 17:46' prior: 0!I monitor background processes and allow their priorities to be adjusted, paused and resumed.To use, create with my #doBlock constructor.  The doBlock should set up and signal a MaProgressor just before starting the monitored work.  This will allow me to capture that progressor and report its attributes.  During the work, update the progressor's attributes.	self example1!!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:50'!advance	"Advance the progress bar one unit.  This should be put at the end of a loop of client processing work to support a graceful pause and cancel operations"	self advance: 1! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 6/23/2013 13:45'!advance: anInteger 	"Advance the progress bar by anInteger units.  This should be put at the end of a loop of client processing work to support a graceful pause and cancel operations."	progressor advance: anInteger.	self		 changed ;		 waitForResume! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 5/30/2013 14:54'!completionTime	^ progressor completionTime! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:50'!description	"What is being done right now."	^ progressor description! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:46'!description: aString	"Specify aString that describes what is happening right now.  This is independent of the overall progress message."	progressor description: aString! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:51'!elapsedTime	"The time this process has been running, excluding time paused."	^ progressor elapsedTime! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 11/20/2007 16:41'!mauiName	^ self name! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 11/20/2007 15:08'!name	^ process name! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 1/2/2008 16:49'!name: aString 	process name: aString! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:52'!percentComplete	"Answers a Float between 0.0 and 1.0."	^ progressor percentComplete! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 12/28/2007 14:53'!prioritySelection	^ self prioritySelectionFor: self priority! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 12/28/2007 16:01'!prioritySelection: prioritySymbol 	"#userBackgroundPriority - for background processes to run only when the UI or other higher priority processes are running.		#userSchedulingPriority - The UI shares an equal slice of time with all processes at this priority.		#userInterruptPriority - For processes desiring immediate service.  WARNING:  The UI will be unresponsive until the process completes."	self isTerminated ifTrue: [ ^ self ].	self priority: (Processor perform: prioritySymbol)! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:52'!progressMessage	^ progressor progressMessage! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/27/2007 13:03'!progressor	^ progressor! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:52'!rateMessage	^ progressor rateMessage! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:52'!ratePerMinute	^ progressor ratePerMinute! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:53'!ratePerSecond	"The estimated time remaining for this process."	^ progressor ratePerSecond! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:53'!remainingTime	^ progressor remainingTime! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 5/2/2013 17:11'!resetRunningTime	^ progressor resetRunningTime! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:54'!runningTime	^ progressor runningTime! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:43'!taskSize	^ progressor taskSize! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 9/10/2014 14:38'!taskSize: anInteger 	progressor taskSize: anInteger.	self changed! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:48'!unitsCompleted	^ progressor unitsCompleted! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:48'!unitsCompleted: anInteger 	progressor unitsCompleted: anInteger! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 4/16/2013 17:54'!unitsRemaining	^ progressor unitsRemaining! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 5/2/2007 12:29'!unitsVerbPhrase	^ progressor unitsVerbPhrase! !!MaClientProcess methodsFor: 'accessing' stamp: 'cmm 1/2/2008 16:50'!unitsVerbPhrase: aString 	progressor unitsVerbPhrase: aString! !!MaClientProcess methodsFor: 'initialize' stamp: 'cmm 2/18/2014 16:27'!doBlock: aBlock 	process := ([ : proc | [ aBlock argumentCount isZero		ifTrue: [ aBlock value ]		ifFalse: [ aBlock value: proc ] ] ensure:		[ self stopped			ifTrue: [ self signalWaiterOnStop ]			ifFalse: [ progressor stop ] ] ] newProcessWith: {self}) priority: Processor userBackgroundPriority! !!MaClientProcess methodsFor: 'initialize' stamp: 'cmm 6/1/2013 20:30'!initialize	shouldStop := shouldPause := false.	waiterOnStop := Semaphore new.	waiterOnResume := Semaphore new.	self resetProgressor! !!MaClientProcess methodsFor: 'initialize' stamp: 'cmm 11/13/2003 23:49'!postInitialize	self priority: Processor userBackgroundPriority! !!MaClientProcess methodsFor: 'initialize' stamp: 'cmm 6/3/2013 21:36'!resetProgressor	progressor := MaProgressor new		 description: 'waiting to start' ;		 yourself.	self changed! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 11/10/2010 14:19'!everStarted	"Answer whether I was ever started."	^ process everStarted! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 12/28/2007 16:23'!isPaused	^ shouldPause and: [ waiterOnResume isSignaled not ]! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 12/28/2007 16:39'!isRunning	"Answer whether my client doBlock code is executing."	^ progressor isRunning! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 3/4/2008 15:57'!isTerminated	^ process isTerminated! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 5/2/2013 14:32'!knowsTaskSize	^ progressor knowsTaskSize! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 6/24/2003 16:39'!shouldStop	^shouldStop! !!MaClientProcess methodsFor: 'testing' stamp: 'cmm 4/27/2007 17:22'!stopped	^ self shouldStop! !!MaClientProcess methodsFor: 'private' stamp: 'cmm 11/20/2007 16:56'!mauiClientProcessPriorities	^ #(		#userBackgroundPriority		#userSchedulingPriority		#userInterruptPriority	)! !!MaClientProcess methodsFor: 'private' stamp: 'cmm 5/2/2007 12:20'!priority	^ process priority ! !!MaClientProcess methodsFor: 'private' stamp: 'cmm 1/2/2008 16:49'!priority: anInteger 	process priority: anInteger! !!MaClientProcess methodsFor: 'private' stamp: 'cmm 11/20/2007 16:59'!prioritySelectionFor: priorityInteger 	^ self mauiClientProcessPriorities 		at: priorityInteger / 10 - 2		ifAbsent: [ priorityInteger asString ]! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 9/9/2014 15:51'!pause	"Pause the running of this process, lightening cpu burden."	self everStarted ifFalse: [ ^ self ].	process isTerminated ifTrue: [ ^ self ].	self isPaused ifTrue: [ ^ self ].	self startSubtask.	progressor description: 'pausing...'.	shouldPause := true! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 6/27/2013 20:21'!resume	"... when you're ready to continue."	process isTerminated ifTrue: [ ^ self ].	self isRunning ifTrue: [ ^ self ].	self everStarted ifFalse: [ ^ self start ].	self returnFromSubtask.	progressor description: 'Resuming...'.	progressor start.	shouldPause ifTrue: [ [ waiterOnResume isSignaled ] whileFalse: [ waiterOnResume signal ] ].	shouldPause := false! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 6/27/2013 20:12'!returnFromSubtask 	progressor := progressor returnFromSubtask! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 2/25/2004 00:01'!signalWaiterOnStop	"If your process has been asked to pleaseStop, be sure to call this method."	waiterOnStop signal! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 12/28/2007 16:40'!start	"Begin processing."	progressor		description: 'Starting...' ;		start.	process resume! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 6/27/2013 20:09'!startSubtask 	progressor := progressor startSubtask! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 3/8/2014 13:20'!stop	"Set my shouldStop flag true."	(process isNil or: [process isTerminated]) ifTrue: [ ^ self ].	shouldStop ifTrue: 		[ "already been here, don't fork another process."		^ self ].	shouldStop := true.		[ self resume. "Ensure running, so client will signalWaterOnStop.  Necessary even if everStarted not, because my 'process', a Process, will not get GC'd if it was never started (stays in the Process browser)."	self isRunning ifTrue: 		[ progressor description: 'stopping process, please wait...'.		waiterOnStop wait ].	progressor		stop ;		description: 'Stopped.'.	self changed ] fork! !!MaClientProcess methodsFor: 'actions' stamp: 'cmm 12/28/2007 16:18'!waitForResume	"If I am paused, wait here to resume.  I am called from within my doBlock code."	shouldPause ifTrue: 		[ progressor			stop ;			description: 'Paused.'.		waiterOnResume wait ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClientProcess class	instanceVariableNames: ''!!MaClientProcess class methodsFor: 'create' stamp: 'cmm 8/4/2003 12:17'!doBlock: aBlock	^self new		doBlock: aBlock;		postInitialize;		yourself! !!MaClientProcess class methodsFor: 'example' stamp: 'cmm 5/7/2014 20:48'!example1	| clientProcess monitoredBlock n delay |	delay := Delay forMilliseconds: 2.	n := 0.	clientProcess := nil.	monitoredBlock := 	[ clientProcess		taskSize: 10000 ;		unitsVerbPhrase: 'milliseconds waited'.	"Your block should check the clientProcess #shouldStop user request frequently to support a graceful cancel."	[ n < 10000 and: [ clientProcess shouldStop not ] ] whileTrue: 		[ "Here is the work..."		n := n + 1.		clientProcess description: 'working on ' , n printString.		delay wait.		"After your work code, you should also allow the clientProcess to support #pause and #resume by waiting for it gracefully in your work code.		The reason to put it at the end of your work code, rather than the beginning, is in case you pause, THEN stop.  Stop must resume to resume the loop to immediately exit rather than process one more loop of work."		clientProcess advance ].	"This is important to support a graceful cancel.."	clientProcess stopped		ifFalse: [ clientProcess description: 'Counting complete.' ] ].	clientProcess := (MaClientProcess doBlock: monitoredBlock)		name: 'Counting for Testing Progress Bar' ;		yourself.	^ clientProcess! !!MaClientProcess class methodsFor: 'example' stamp: 'cmm 5/2/2013 13:58'!example2	"Same as example1 except using the new shorter forkClientProcess method."	| n delay |	delay := Delay forMilliseconds: 2.	n := 0.	^ [ : clientProcess | clientProcess		 name: 'Counting for Testing Progress Bar' ;		 taskSize: 10000 ;		 unitsVerbPhrase: 'milliseconds waited'.	"Your block should check the clientProcess #shouldStop user request frequently to support a graceful cancel."	[ n < 10000 and: [ clientProcess shouldStop not ] ] whileTrue:		[ "Here is the work..."		n := n + 1.		clientProcess description: 'working on ' , n printString.		delay wait.		"After your work code, you should also allow the clientProcess to support #pause and #resume by waiting for it gracefully in your work code.		The reason to put it at the end of your work code, rather than the beginning, is in case you pause, THEN stop.  Stop must resume to resume the loop to immediately exit rather than process one more loop of work."		clientProcess advance ].	"This is important to support a graceful cancel.."	clientProcess stopped ifFalse: [ clientProcess description: 'Counting complete.' ] ] forkClientProcess! !MaAbstractContext subclass: #MaCompositeContext	instanceVariableNames: 'subcontexts didRefresh'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaCompositeContext commentStamp: 'cmm 3/6/2008 22:38' prior: 0!I represent a composition of multiple Contexts.!!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 23:09'!addContext: aMauiContext	subcontexts add: aMauiContext.	aMauiContext keywords: self keywords! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 23:09'!keywords	^ subcontexts anyOne keywords! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 12/11/2004 09:04'!keywords: anArray	subcontexts do: [ : each | each keywords: anArray ]! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:58'!orKeywords: anArray	subcontexts do: [ : each | each orKeywords: anArray ]! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 3/6/2009 11:02'!searchSize	^ subcontexts 		inject: 0		into: [ : sum : each | sum + each searchSize ]! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 3/6/2009 11:02'!size	^ subcontexts 		inject: 0		into: [ : sum : each | sum + each size ]! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 12/22/2009 10:15'!subcontextNamed: aString 	^ (subcontexts detect: [ : each | each name = aString ]) in: 		[ : foundSubcontext | 		(didRefresh and: [ foundSubcontext isRunning not ]) ifTrue: [ foundSubcontext refresh ].		foundSubcontext ]! !!MaCompositeContext methodsFor: 'accessing' stamp: 'cmm 1/4/2005 22:18'!subcontexts	^ subcontexts! !!MaCompositeContext methodsFor: 'initialize-release' stamp: 'cmm 3/18/2008 16:32'!initialize	subcontexts := OrderedCollection new.	didRefresh := false.	super initialize! !!MaCompositeContext methodsFor: 'initialize-release' stamp: 'cmm 3/7/2008 12:21'!initializeKeywords	super initializeKeywords.	subcontexts do: [ : each | each initializeKeywords ]! !!MaCompositeContext methodsFor: 'initialize-release' stamp: 'cmm 1/2/2005 22:27'!resetResults	subcontexts do: [ : each | each resetResults ]! !!MaCompositeContext methodsFor: 'testing' stamp: 'cmm 2/28/2008 22:22'!knowsSearchSize	^ subcontexts allSatisfy: [ : each | each knowsSearchSize ]! !!MaCompositeContext methodsFor: 'private' stamp: 'cmm 1/2/2005 22:17'!prepareForScan	"A scan is about to begin.  Ensure you're ready to do it by initializing any resources and setting the position of the scan back to the beginning."	subcontexts do: [ : each | each prepareForScan ]! !!MaCompositeContext methodsFor: 'scan' stamp: 'cmm 3/18/2008 16:16'!refresh	didRefresh 		ifTrue: 			[ "If already refreshed, tell them all to reset.  Their scans will pick up again when the individual contexts are accessed."			subcontexts do: 				[ : each | 				each					stopScanning ;					resetResults ] ]		ifFalse: [ didRefresh := true ]! !Object subclass: #MaCompositeReadStream	instanceVariableNames: 'streams currentInnerStream size'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaCompositeReadStream commentStamp: 'cmm 7/20/2004 12:37' prior: 0!I allow multiple read-streams to be treated as one big stream.  Start by creating me with a Collection of ReadStreams and then you can say next, next, next and I will enumerate them all, in sequence.!!MaCompositeReadStream methodsFor: 'access' stamp: 'cmm 7/20/2004 13:08'!atEnd	^ self currentInnerStream atEnd! !!MaCompositeReadStream methodsFor: 'access' stamp: 'cmm 7/20/2004 13:07'!next	^ self currentInnerStream next! !!MaCompositeReadStream methodsFor: 'access' stamp: 'cmm 7/20/2004 13:18'!reset	currentInnerStream := nil.	streams reset.	[ streams atEnd ] whileFalse: [ streams next reset ].	streams reset! !!MaCompositeReadStream methodsFor: 'access' stamp: 'cmm 7/20/2004 13:50'!size	"Once created, ReadStreams cannot change in size so this should be accurate."	^ size! !!MaCompositeReadStream methodsFor: 'private' stamp: 'cmm 7/20/2004 13:07'!currentInnerStream	(currentInnerStream isNil or: [ currentInnerStream atEnd ])		ifTrue:			[ streams atEnd ifFalse: [ currentInnerStream := streams next ] ].	^ currentInnerStream! !!MaCompositeReadStream methodsFor: 'initialize' stamp: 'cmm 7/20/2004 13:49'!streams: aCollectionOfStreams	streams := aCollectionOfStreams readStream.	size := aCollectionOfStreams		inject: 0		into: [ : sum : eachStream | sum + eachStream size ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCompositeReadStream class	instanceVariableNames: ''!!MaCompositeReadStream class methodsFor: 'examples' stamp: 'cmm 7/20/2004 13:13'!example1	"self example1"	| stream |	stream := self streams:		{ (1 to: 10) asArray readStream.		'abcxyz' readStream }.	[ stream atEnd ] whileFalse: [ Transcript show: stream next printString ].	stream reset.	"again."	[ stream atEnd ] whileFalse: [ Transcript show: stream next printString ]! !!MaCompositeReadStream class methodsFor: 'create' stamp: 'cmm 7/20/2004 13:48'!streams: aCollection	^ self new		streams: aCollection ;		yourself! !MaObject subclass: #MaContextPreferences	instanceVariableNames: 'maximumScanTime maximumScanResults'	classVariableNames: 'Global'	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaContextPreferences methodsFor: 'private' stamp: 'cmm 2/7/2008 15:55'!initialize	maximumScanTime := 5 minutes.	maximumScanResults := 250! !!MaContextPreferences methodsFor: 'accessing' stamp: 'cmm 8/8/2003 13:52'!maximumScanResults	"The maximum number of results per subcontext that will be retrieved before moving to the next subcontext."	^maximumScanResults! !!MaContextPreferences methodsFor: 'accessing' stamp: 'cmm 6/24/2003 16:25'!maximumScanResults: anInteger	maximumScanResults := anInteger! !!MaContextPreferences methodsFor: 'accessing' stamp: 'cmm 8/8/2003 13:53'!maximumScanTime	"The maximum time this context will scan before passing control to the next context."	^maximumScanTime! !!MaContextPreferences methodsFor: 'accessing' stamp: 'cmm 6/24/2003 16:25'!maximumScanTime: aMaDuration	maximumScanTime := aMaDuration! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaContextPreferences class	instanceVariableNames: ''!!MaContextPreferences class methodsFor: 'as yet unclassified' stamp: 'cmm 11/19/2003 00:44'!global	^Global! !!MaContextPreferences class methodsFor: 'as yet unclassified' stamp: 'cmm 11/19/2003 00:45'!initialize	Global := self new! !MaObject subclass: #MaProgressor	instanceVariableNames: 'description stopwatch taskSize unitsCompleted unitsVerbPhrase log parentTask subtask'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaProgressor commentStamp: 'cmm 3/26/2013 18:46' prior: 0!A MaProgressor encapsulates the API of progress on a long-running task.  For such tasks we want to know how fast it is and when its going to be done.!!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/6/2003 00:44'!addLogMessage: aString	log add: aString! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 3/7/2008 17:27'!advance	self advance: 1! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 3/4/2008 16:37'!advance: anInteger 	self unitsCompleted: unitsCompleted + anInteger! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 5/30/2013 18:32'!completionTime	"The estimated time the process will be completed."	^ self remainingTime ifNotNil:		[ : rt | DateAndTime now + rt ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 7/20/2004 20:47'!description	"A message from the domain."	^description! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 11/20/2007 15:17'!description: aString 	description := aString.	self changed! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 4/11/2013 15:32'!elapsedTime	"The time this process has been running, excluding time paused."	^ stopwatch duration ! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/8/2009 10:35'!percentComplete	"Answers a Float between 0.0 and 1.0."	^ self knowsTaskSize 		ifTrue: [ unitsCompleted / taskSize asFloat ]		ifFalse: [ 0.0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 7/24/2013 15:46'!progressMessage	^String streamContents:		[ : stream |		stream maPrint: self unitsCompleted asBytesDescription.		self knowsTaskSize			ifTrue:				[ stream					maPrint: ' of ';					maPrint: self taskSize asBytesDescription ].		stream space.		stream maPrint: self unitsVerbPhrase ] ! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 5/7/2014 20:48'!rateMessage	^ String streamContents: 		[ : stream | 		stream			maPrint: self ratePerMinute asInteger asBytesDescription ;			maPrint: ' / minute in ' ;			maPrint: stopwatch duration ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/8/2009 10:36'!ratePerMinute	| totalMilliseconds |	^ (totalMilliseconds := self runningTime asMilliSeconds) > 0 		ifTrue: [ self unitsCompleted * 60000 / totalMilliseconds asFloat roundTo: 1 ]		ifFalse: [ 0.0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/8/2009 10:36'!ratePerSecond	| totalMilliseconds |	^ (totalMilliseconds := self runningTime asMilliSeconds) > 0 		ifTrue: [ self unitsCompleted * 1000 / totalMilliseconds asFloat roundTo: 0.1 ]		ifFalse: [ 0.0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/6/2013 15:40'!remainingTime	"The estimated time remaining for this process."	^ (self knowsTaskSize and: [ self unitsCompleted isZero not and: [self runningTime isZero not ] ])		ifTrue: [ (self unitsRemaining / (self unitsCompleted / self runningTime asMilliSeconds) max: 0) asInteger milliSeconds ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 5/30/2013 18:31'!remainingTimeString	"A message describing how long it will take, and when it will be complete."	^ String streamContents:		[ : stream | self remainingTime			ifNil: [ stream maPrint: 'unknown' ]			ifNotNil:				[ : rt | stream					 maPrint: rt ;					 maPrint: ' remaining until ' ;					 maPrint: self completionTime ] ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 9/10/2014 14:51'!resetRunningTime	stopwatch reset; activate! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/19/2007 16:16'!runningTime	^ stopwatch duration! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/19/2007 16:15'!start	stopwatch activate! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/19/2007 16:17'!startTime	^ stopwatch start! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 1/9/2008 17:02'!stop	stopwatch suspend.	self changed! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:27'!taskSize	^taskSize! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 11/20/2007 15:16'!taskSize: anInteger 	taskSize := anInteger.	self changed! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:32'!unitsCompleted	^unitsCompleted! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 11/20/2007 15:16'!unitsCompleted: anInteger 	unitsCompleted := anInteger.	self changed! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 3/26/2013 18:52'!unitsRemaining	^ self knowsTaskSize		ifTrue: [ self taskSize - self unitsCompleted ]		ifFalse: [ 1 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:32'!unitsVerbPhrase	^unitsVerbPhrase! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 11/20/2007 15:16'!unitsVerbPhrase: aString 	unitsVerbPhrase := aString.	self changed! !!MaProgressor methodsFor: 'initialize' stamp: 'cmm 12/19/2007 16:15'!initialize	super initialize.	stopwatch := Stopwatch new.	unitsVerbPhrase := ' items processed.'.	unitsCompleted := 0.	log := OrderedCollection new.	description := 'not running.'! !!MaProgressor methodsFor: 'testing' stamp: 'cmm 3/4/2008 22:03'!isComplete	^ unitsCompleted >= taskSize! !!MaProgressor methodsFor: 'testing' stamp: 'cmm 12/19/2007 16:15'!isRunning	^ stopwatch isActive! !!MaProgressor methodsFor: 'testing' stamp: 'cmm 8/7/2003 17:06'!knowsTaskSize	^self taskSize notNil and: [ self taskSize > 0 ]! !!MaProgressor methodsFor: 'private' stamp: 'cmm 6/27/2013 19:57'!parentTask: aMaProgressor	parentTask := aMaProgressor! !!MaProgressor methodsFor: 'private' stamp: 'cmm 6/27/2013 20:07'!subtask: aMaProgressor 	subtask := aMaProgressor! !!MaProgressor methodsFor: 'subtask-reporting' stamp: 'cmm 6/27/2013 20:08'!returnFromSubtask	"After finishing a subtask, disconnect it."	^ parentTask ifNotNil:		[ parentTask subtask: nil.		parentTask ]! !!MaProgressor methodsFor: 'subtask-reporting' stamp: 'cmm 6/27/2013 20:09'!startSubtask	"Start a new subtask."	^ subtask := self copy		 parentTask: self ;		 yourself! !MaAbstractContext subclass: #MaSearchContext	instanceVariableNames: 'accessSelector results preferences scanProcess timer'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:36'!accessSelector	^ accessSelector! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 2/27/2008 16:57'!accessSelector: aSymbol 	"aSymbol will be performed to determine the object to match against the keywords."	accessSelector := aSymbol! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:25'!preferences	^preferences! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:28'!preferred: attributeSymbol	^(preferences perform: attributeSymbol)		ifNil: [ MaContextPreferences global perform: attributeSymbol ]! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 12/21/2009 20:45'!results	^ results ifNil: 		[ self initializeResults.		results ]! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 1/2/2005 22:26'!scanProcess	^scanProcess! !!MaSearchContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:17'!source	"Answer the object that will be searched."	self subclassResponsibility! !!MaSearchContext methodsFor: 'results access' stamp: 'cmm 2/28/2008 22:03'!at: anInteger 	^ self 		at: anInteger		ifAbsent: [ self errorSubscriptBounds: anInteger ]! !!MaSearchContext methodsFor: 'results access' stamp: 'cmm 12/21/2009 20:48'!at: anInteger ifAbsent: aBlock 	"Answer the result at: anInteger, in order of relevance."	results ifNil: aBlock.	^ self results 		at: anInteger		ifAbsent: aBlock! !!MaSearchContext methodsFor: 'results access' stamp: 'cmm 3/6/2008 10:39'!remove: anObject 	self 		remove: anObject		from: self results! !!MaSearchContext methodsFor: 'results access' stamp: 'cmm 12/21/2009 20:49'!remove: resultObject from: aMaContextResultsContext 	"Remove resultObject from the list."	results ifNil: [ ^ self ].	self results 		remove: resultObject		from: aMaContextResultsContext! !!MaSearchContext methodsFor: 'results access' stamp: 'cmm 12/21/2009 20:48'!size	"The number of results."	^ results 		ifNil: [ 0 ]		ifNotNil: [ self results size ]! !!MaSearchContext methodsFor: 'subclass behavior' stamp: 'cmm 1/2/2005 22:16'!atEnd	self subclassResponsibility! !!MaSearchContext methodsFor: 'subclass behavior' stamp: 'cmm 1/2/2005 22:16'!next	"Answer the next object that should be evaluated against the keyword selection."	"I keep track of my position (thus am meant to be used by a single Process at a time).  This method answers the next available element based on its current position.  If the subclass receiver has a way reducing the search-set and answering only the next that meets its selectionKey, it should.  Otherwise, they will be eliminated via serial searching."	self subclassResponsibility! !!MaSearchContext methodsFor: 'subclass behavior' stamp: 'cmm 1/2/2005 22:16'!prepareForScan	"A scan is about to begin.  Ensure you're ready to do it by initializing any resources and setting the position of the scan back to the beginning."	"optional subclass responsibility"! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 3/25/2017 17:03'!bestScoreFor: compareObject 	"Answer an Integer that represents the best match among my keywords.  Note that for each Array of anded keywords, *all* of that Array must match with a minimum score, otherwise none of the Array is a match and we move to the next Array."	| answer |	answer := self noMatchScore.	compareObject maContextKeywordsDo: 		[ : eachKeyword | 		| score |		eachKeyword ifNotNil: 			[ score := self calculateScoreFor: eachKeyword asString.			answer := answer min: score ] ].	^ answer! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 2/7/2008 16:44'!calculateScoreFor: compareString	"Enumerate my sets of keywords to find the lowest score of the set.  Recall, my keywords are an OrderedCollection of Array's of keywords.  Each Array are OR'd with the other Arrays, so whichever Array has the lowest (best) score represents the score for the entire keywords collection."	^ keywords		inject: self noMatchScore		into:			[ : min : eachArray |  | setScore |			setScore :=				self					calculateSet: eachArray					scoreFor: compareString.			setScore min: min ]! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 2/7/2008 17:09'!calculateSet: keywordsArray scoreFor: compareString 	"Every word in keywordsArray is considered AND'ed, therefore must minimally match, otherwise the entire set is not a match."	^ keywordsArray 		inject: self noMatchScore		into: 			[ : score : each | 			| selectionScore |			selectionScore := self 				scoreFor: compareString				keyword: each.			selectionScore = self noMatchScore ifTrue: [ ^ selectionScore ].			score min: selectionScore ]! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 1/2/2005 22:34'!getCompareObjectFor: anObject	"If using the accessSelector feature, compare based on that, otherwise on anObject."	^ accessSelector		ifNil: [ anObject ]		ifNotNil:			[ (anObject respondsTo: accessSelector)				ifTrue: [ anObject perform: accessSelector ]				ifFalse: [ anObject ] ]! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 1/2/2005 22:35'!noMatchScore	"A special number, higher than will ever be needed for any particular relevance-level, indicating no match."		^ 99! !!MaSearchContext methodsFor: 'private comparing' stamp: 'cmm 2/7/2008 17:09'!scoreFor: objectString keyword: keywordString 	"Answer a magnitude suitable for sorting results according to best match."	(objectString 		compare: keywordString		caseSensitive: true) = 2 ifTrue: [ ^ 1 ].	(objectString 		compare: keywordString		caseSensitive: false) = 2 ifTrue: [ ^ 2 ].	(objectString 		maBeginsWith: keywordString		caseSensitive: false) ifTrue: [ ^ 3 ].	(objectString 		includesSubstring: keywordString		caseSensitive: false) ifTrue: [ ^ 4 ].	^ self noMatchScore! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 3/6/2009 10:57'!indexOfRelevanceNamed: aString	^ self relevanceNames 		indexOf: aString		ifAbsent:			[ MaUserError signal:				(String streamContents:					[ : stream |					stream						nextPutAll: aString ;						nextPutAll: ' is not valid.  Must use any of '.					self relevanceNames do:						[ : each |						stream							nextPutAll: each ;							space ] ]) ]! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 3/6/2008 16:58'!initializeResults	^ results := MaContextResultsContext source: self! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 4/16/2013 17:55'!initializeScanProcess	scanProcess := (MaClientProcess doBlock: [ self scan ])		name: 'Scanning ' , self name , '...' ;		priority: Processor userBackgroundPriority ;		yourself.	scanProcess description: 'Waiting to search.'! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 6/29/2013 18:10'!primScan	"Stream the next anInteger objects into aMauiContextResults according to my keywords and organized in aMauiContextResults by relevance."	self		 startTimer ;		 prepareForScan.	[ self shouldStopScanning ] whileFalse:		[ | score next |		scanProcess description: 'scanning for ' , self keywordsSelection.		next := self next.		next ifNotNil:			[ score := self bestScoreFor: (self getCompareObjectFor: next).			score = self noMatchScore ifFalse:				[ self results					atRelevance: score					add: next.				self changed ].			scanProcess advance ] ].	timer cancel! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 2/7/2008 15:52'!relevanceNames	"Answer an Array of Strings that name the kinds of relevance matching as they relate to each search result, found by having applied a String in some way.  This is the default, subclasses may override as necessary, but if they do, they will also need to override matchFactorBetween:and: if they override the behavior, as well as the names of the various kinds of matching."	^#('exact' 'case-insensitive' 'starts with' 'contains')  "sounds-like?"! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 12/21/2009 20:46'!resetResults	results := nil.	self changed! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 6/28/2013 17:35'!scan	| description |	scanProcess		description: 'scanning for ' , self keywordsSelection ;		unitsVerbPhrase: 'objects scanned'.	self knowsSearchSize ifTrue: [ scanProcess unitsCompleted: 0; taskSize: self searchSize ].	self		resetResults ;		primScan.	description := scanProcess stopped		ifTrue: [ 'stopped' ]		ifFalse: 			[ self atEnd 				ifTrue: [ 'scanning complete' ]				ifFalse: 					[ scanProcess runningTime > (self preferred: #maximumScanTime) 						ifTrue: [ 'timed out' ]						ifFalse: [ 'max results found' ] ] ].	scanProcess description: description! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 3/7/2008 17:13'!startTimer	timer := MaTimer new 		in: (self preferred: #maximumScanTime)		do: 			[ "nothing, we only will check whether the timer has #expired."			 ]! !!MaSearchContext methodsFor: 'private' stamp: 'cmm 3/6/2008 21:53'!stopScanning	"If scan already in progress, terminate it."	scanProcess ifNotNil: [ scanProcess isRunning ifTrue: [ scanProcess stop ] ]! !!MaSearchContext methodsFor: 'initialize-release' stamp: 'cmm 3/18/2008 10:00'!initialize	super initialize.	preferences := MaContextPreferences new! !!MaSearchContext methodsFor: 'initialize-release' stamp: 'cmm 12/22/2009 10:22'!initializeKeywords	super initializeKeywords.	self		stopScanning ;		resetResults! !!MaSearchContext methodsFor: 'testing' stamp: 'cmm 3/4/2008 11:15'!isCollection	^ true! !!MaSearchContext methodsFor: 'testing' stamp: 'cmm 12/22/2009 10:20'!isRunning	"Answer whether I am scanning right now."	^ scanProcess notNil and: [ scanProcess isRunning ]! !!MaSearchContext methodsFor: 'testing' stamp: 'cmm 3/18/2008 16:18'!isStarted	"Answer whether I have yet been sent #refresh."	^ scanProcess notNil! !!MaSearchContext methodsFor: 'copying' stamp: 'cmm 3/18/2008 10:02'!postCopyForIndependentSearch	super postCopyForIndependentSearch.	self initializeResults.	scanProcess := nil! !!MaSearchContext methodsFor: 'scanning' stamp: 'cmm 3/6/2008 16:52'!refresh	self		stopScanning ;		resetResults.	self initializeScanProcess.	self changed.	scanProcess start! !!MaSearchContext methodsFor: 'scanning' stamp: 'cmm 10/5/2012 15:08'!shouldStopScanning	scanProcess waitForResume.	^ scanProcess shouldStop or:		[ self atEnd or:			[ timer expired or:				[ | maxResults |				maxResults := self preferred: #maximumScanResults.				maxResults > 0 and: [ self size >= maxResults ] ] ] ]! !MaSearchContext subclass: #MaContextForNonStreamable	instanceVariableNames: 'queue queueingProcess doneQueueing'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaContextForNonStreamable commentStamp: 'cmm 6/28/2013 17:23' prior: 0!This is an abstract class that allows contexts for objects that cannot implement #next, as required by MaSearchContext.Instead, my subclasses do their enumeration in a separate process and populate my 'queue' which is then accessed with my #next.So my subclasses, instead of implementing #next, they simply do their enumeration and call my #queue: method to add the objects to be scanned.!!MaContextForNonStreamable methodsFor: 'overriding' stamp: 'cmm 12/9/2004 16:38'!atEnd	^ doneQueueing and: [ queue isEmpty ]! !!MaContextForNonStreamable methodsFor: 'overriding' stamp: 'cmm 12/9/2004 14:39'!next	^ queue next! !!MaContextForNonStreamable methodsFor: 'overriding' stamp: 'cmm 6/30/2013 16:04'!prepareForScan	queue flush.	doneQueueing := false.	queueingProcess := 	[ self queueObjectsToScan.	scanProcess taskSize: queue size + scanProcess unitsCompleted.	doneQueueing := true ] newProcess		name: 'queueing for ' , self name asString ;		priority: Processor userBackgroundPriority ;		yourself.	queueingProcess resume! !!MaContextForNonStreamable methodsFor: 'initialize-release' stamp: 'cmm 3/6/2008 13:08'!initialize	super initialize.	self initializeQueue.	doneQueueing := false! !!MaContextForNonStreamable methodsFor: 'initialize-release' stamp: 'cmm 3/6/2008 13:08'!initializeQueue	queue := SharedQueue new! !!MaContextForNonStreamable methodsFor: 'copying' stamp: 'cmm 3/6/2008 16:55'!postCopyForIndependentSearch	super postCopyForIndependentSearch.	self initializeQueue.	queueingProcess := nil.	doneQueueing := false! !!MaContextForNonStreamable methodsFor: 'private' stamp: 'cmm 12/9/2004 14:25'!queue: anObject	queue nextPut: anObject! !!MaContextForNonStreamable methodsFor: 'private' stamp: 'cmm 3/6/2008 16:01'!scan	super scan.	self initializeQueue! !!MaContextForNonStreamable methodsFor: 'private' stamp: 'cmm 12/9/2004 15:01'!stopScanning	super stopScanning.	"If you have correctly implemented your queueObjectsToScan method, then your queuingProcess will abort from the above."	queueingProcess ifNotNil:		[ [ queueingProcess isTerminated ] whileFalse: [ (Delay forMilliseconds: 100) wait ] ]! !!MaContextForNonStreamable methodsFor: 'subclass responsibility' stamp: 'cmm 12/9/2004 14:54'!queueObjectsToScan	"Subclasses, override this method and call #queue: to queue the objects you want scanned.  Also, be sure to check #shouldStopScanning very frequently to determine whether to abort your queuing."	self subclassResponsibility! !MaContextForNonStreamable subclass: #MaAnyObjectContext	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaAnyObjectContext commentStamp: 'cmm 12/8/2004 23:01' prior: 0!I can search the graph of any object for objects matching a keyword.  I am useful for "default" searching and for developers who want to find objects quickly.I have a MaObjectGraphTraversalStrategy that you may customize.!!MaAnyObjectContext methodsFor: 'accessing' stamp: 'cmm 12/9/2004 15:06'!object	^ object! !!MaAnyObjectContext methodsFor: 'accessing' stamp: 'cmm 12/9/2004 15:06'!object: anObject	object := anObject! !!MaAnyObjectContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:18'!source	^ self object! !!MaAnyObjectContext methodsFor: 'overriding' stamp: 'cmm 3/6/2008 22:24'!queueObjectsToScan	object subobjectsDo: 		[ : each | 		self queue: each.		self shouldStopScanning ifTrue: [ ^ self ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAnyObjectContext class	instanceVariableNames: ''!!MaAnyObjectContext class methodsFor: 'create' stamp: 'cmm 12/9/2004 15:12'!object: anObject	"Create using the default traversal strategy."	^ self new		object: anObject ;		yourself! !MaContextForNonStreamable subclass: #MaCodeElementContext	instanceVariableNames: 'scanSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaCodeElementContext commentStamp: 'cmm 12/8/2004 15:42' prior: 0!I represent a context for objects in the image.!!MaCodeElementContext methodsFor: 'overriding' stamp: 'cmm 12/9/2004 16:23'!queueObjectsToScan	self perform: scanSelector! !!MaCodeElementContext methodsFor: 'initializing' stamp: 'cmm 12/3/2008 17:41'!scanClasses	self systemNavigation allBehaviorsDo: 		[ : eachClass | 		self queue: eachClass.		self shouldStopScanning ifTrue: [ ^ self ] ]! !!MaCodeElementContext methodsFor: 'initializing' stamp: 'cmm 12/3/2008 17:41'!scanMethods	self systemNavigation maAllMethodReferencesDo: 		[ : eachMr | 		self queue: eachMr.		self shouldStopScanning ifTrue: [ ^ self ] ]! !!MaCodeElementContext methodsFor: 'initializing' stamp: 'cmm 12/9/2004 15:21'!scanSelector: aSymbol	"The scanSelector is the selector of the method used to scan my objects."	scanSelector := aSymbol! !!MaCodeElementContext methodsFor: 'accessing' stamp: 'cmm 12/3/2008 17:42'!source	^ self systemNavigation! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCodeElementContext class	instanceVariableNames: ''!!MaCodeElementContext class methodsFor: 'as yet unclassified' stamp: 'cmm 3/7/2008 14:36'!forClasses	^ self new 		name: 'Classes' ;		scanSelector: #scanClasses ;		yourself! !!MaCodeElementContext class methodsFor: 'as yet unclassified' stamp: 'cmm 3/7/2008 14:36'!forImage	^ MaCompositeContext new		name: 'Code-elements in this image' ;"		addContext: self forPackages ;  "		addContext: self forClasses ;		addContext: self forMethods ;		yourself! !!MaCodeElementContext class methodsFor: 'as yet unclassified' stamp: 'cmm 3/7/2008 14:36'!forMethods	^ self new		name: 'Methods' ;		scanSelector: #scanMethods ;		yourself! !!MaCodeElementContext class methodsFor: 'as yet unclassified' stamp: 'cmm 8/7/2003 13:47'!forPackages	self maMarked: 'dev'! !!MaCodeElementContext class methodsFor: 'as yet unclassified' stamp: 'cmm 1/3/2005 10:19'!forSourceCode	"By default, we only look for method names when looking for methods.  This adds each methods sourceCode as an enumerator."	^ self forMethods		accessSelector: #sourceCode ;		yourself! !MaContextForNonStreamable subclass: #MaContextForComposite	instanceVariableNames: 'root childrenSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaContextForComposite commentStamp: 'cmm 2/27/2008 21:07' prior: 0!I am a context used to search a Composite domain structure (as in, the Composite design pattern).  To use, you specify the selector that accesses the "children" of each composite.!!MaContextForComposite methodsFor: 'accessing' stamp: 'cmm 3/8/2008 18:52'!childrenSelector	^childrenSelector! !!MaContextForComposite methodsFor: 'accessing' stamp: 'cmm 3/8/2008 18:52'!childrenSelector: selectorSymbol	childrenSelector := selectorSymbol! !!MaContextForComposite methodsFor: 'accessing' stamp: 'cmm 3/8/2008 18:51'!root	^root! !!MaContextForComposite methodsFor: 'accessing' stamp: 'cmm 3/8/2008 18:51'!root: anObject	root := anObject! !!MaContextForComposite methodsFor: 'accessing' stamp: 'cmm 3/8/2008 19:00'!source	^ root! !!MaContextForComposite methodsFor: 'overriding' stamp: 'cmm 3/8/2008 19:01'!queueObjectsToScan	"Subclasses, override this method and call #queue: to queue the objects you want scanned.  Also, be sure to check #shouldStopScanning very frequently to determine whether to abort your queuing."	self queueWithChildren: root! !!MaContextForComposite methodsFor: 'overriding' stamp: 'cmm 3/8/2008 18:59'!queueWithChildren: parentObject 	| children |	self queue: parentObject.	children := parentObject perform: childrenSelector.	children do: 		[ : each | 		self shouldStopScanning ifTrue: [ ^ self ].		self queueWithChildren: each ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaContextForComposite class	instanceVariableNames: ''!!MaContextForComposite class methodsFor: 'create' stamp: 'cmm 3/8/2008 18:52'!root: anObject childrenSelector: selectorSymbol 	^ self new		root: anObject ;		childrenSelector: selectorSymbol ;		yourself! !MaContextForNonStreamable subclass: #MaContextResultsContext	instanceVariableNames: 'source resultsByRelevance'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaContextResultsContext commentStamp: 'cmm 12/9/2004 16:55' prior: 0!I represent the results of the scan performed by some MaContext.  I provide categories for the results by a "relevance factor."  1 is the most relevant, higher numbers are less relevant.  The relevance factor is also, quite simply, the index into my resultsByRelevance.!!MaContextResultsContext methodsFor: 'testing' stamp: 'cmm 5/27/2008 22:26'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!MaContextResultsContext methodsFor: 'testing' stamp: 'cmm 12/11/2004 12:45'!includes: anObject	^ resultsByRelevance anySatisfy: [ : each | each includes: anObject ]! !!MaContextResultsContext methodsFor: 'testing' stamp: 'cmm 3/7/2015 15:17'!isSequenceable	^ true! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 8/21/2012 22:20'!asArray	| arr |	arr := Array new: self size.	1		to: self size		do:			[ : n | arr				at: n				put:					(self						at: n						ifAbsent: [ MaSoftwareError signal ]) ].	^ arr! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:44'!at: anInteger ifAbsent: aBlock 	resultsByRelevance 		inject: 0		into: 			[ : sum : each | 			sum + each size >= anInteger ifTrue: [ ^ each at: anInteger - sum ].			sum + each size ].	^ aBlock value! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 12/9/2004 22:35'!atRelevanceNamed: aString	^ resultsByRelevance at: (source indexOfRelevanceNamed: aString)! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:04'!maNewSearchContext	^ self maOriginalClass source: self! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 10:24'!remove: resultObject from: aMaContextResultsContext 	"Remove resultObject from the list."	self == aMaContextResultsContext 		ifTrue: 			[ resultsByRelevance do: 				[ : each | 				(each includes: resultObject) ifTrue: 					[ each 						remove: resultObject						ifAbsent: 							[ "no need to signal an error"							 ] ] ].			self changed ]		ifFalse: 			[ results 				remove: resultObject				from: aMaContextResultsContext ]! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:09'!searchSize	^ source size! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 12/9/2004 17:09'!size	^ resultsByRelevance		inject: 0		into: [ : sum : each | sum + each size ]! !!MaContextResultsContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:19'!source	^ source! !!MaContextResultsContext methodsFor: 'private' stamp: 'cmm 6/30/2013 15:38'!atRelevance: relevanceIndex add: anObject 	self queue: anObject.	(resultsByRelevance at: relevanceIndex) add: anObject.	self changed! !!MaContextResultsContext methodsFor: 'private' stamp: 'cmm 6/29/2013 18:09'!next	"Allow results are being scanned as they are still being populated by the source context."	[ queue isEmpty and: [ source source isRunning ] ] whileTrue: [ (Delay forSeconds: 1) wait ].	^ queue isEmpty ifFalse: [ queue next ]! !!MaContextResultsContext methodsFor: 'private' stamp: 'cmm 6/29/2013 17:47'!queue	^ queue! !!MaContextResultsContext methodsFor: 'private' stamp: 'cmm 8/7/2003 13:38'!resultsByRelevance	^resultsByRelevance ! !!MaContextResultsContext methodsFor: 'private' stamp: 'cmm 12/10/2004 15:41'!species	^ OrderedCollection! !!MaContextResultsContext methodsFor: 'enumeration' stamp: 'cmm 12/10/2004 15:40'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MaContextResultsContext methodsFor: 'enumeration' stamp: 'cmm 1/10/2005 23:13'!do: aBlock	resultsByRelevance ifNotNil:		[ resultsByRelevance do: [ : eachCollection | eachCollection do: aBlock ] ]! !!MaContextResultsContext methodsFor: 'enumeration' stamp: 'cmm 5/27/2008 22:26'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!MaContextResultsContext methodsFor: 'enumeration' stamp: 'cmm 12/10/2004 15:46'!maDo: aBlock while: conditionBlock	conditionBlock value ifFalse: [ ^ self ].	self do:		[ : each |		aBlock value: each.		conditionBlock value ifFalse: [ ^ self ] ]! !!MaContextResultsContext methodsFor: 'overriding' stamp: 'cmm 2/28/2008 22:22'!knowsSearchSize	^ true! !!MaContextResultsContext methodsFor: 'overriding' stamp: 'cmm 6/30/2013 15:44'!queueObjectsToScan	"This is sloppy -- but allows us to query AS the source is still searching."	source do: [ : each | self queue: each ].	scanProcess taskSize: queue size.	[ source source isRunning ] whileTrue:		[ (Delay forSeconds: 1) wait.		[ source queue peek notNil ] whileTrue:			[ scanProcess taskSize: scanProcess taskSize + 1.			self queue: source queue next ] ]! !!MaContextResultsContext methodsFor: 'copying' stamp: 'cmm 3/6/2008 16:59'!postCopyForIndependentSearch	super postCopyForIndependentSearch.	self resetResultsByRelevance! !!MaContextResultsContext methodsFor: 'printing' stamp: 'cmm 12/10/2004 15:51'!printOn: aStream	super printOn: aStream.	self do:		[ : each | 		aStream cr; maPrint: each ]! !!MaContextResultsContext methodsFor: 'scanning' stamp: 'cmm 3/6/2008 17:40'!refreshSource	"Refresh my source context and then refresh my own results."	source refreshSource.	self refresh! !!MaContextResultsContext methodsFor: 'initialize-release' stamp: 'cmm 3/5/2008 12:41'!resetResultsByRelevance	"Answer an Array whose elements parallel those of my sources #relevanceNames."	resultsByRelevance := (Array new: source relevanceNames size) collect: [ : each | OrderedCollection new ].	self changed! !!MaContextResultsContext methodsFor: 'initialize-release' stamp: 'cmm 6/29/2013 16:57'!source: aMaSearchContext 	source := aMaSearchContext.	self resetResultsByRelevance! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaContextResultsContext class	instanceVariableNames: ''!!MaContextResultsContext class methodsFor: 'creation' stamp: 'cmm 1/10/2005 23:09'!source: aMaContext	^ self new		source: aMaContext;		yourself! !MaContextForNonStreamable subclass: #MaFileDirectoryContext	instanceVariableNames: 'fileDirectory'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaFileDirectoryContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 16:09'!fileDirectory	^fileDirectory! !!MaFileDirectoryContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 16:09'!fileDirectory: aFileDirectory	fileDirectory := aFileDirectory! !!MaFileDirectoryContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:19'!source	^ self fileDirectory ! !!MaFileDirectoryContext methodsFor: 'overriding' stamp: 'cmm 2/28/2008 13:51'!queueObjectsToScan	fileDirectory directoryTreeDo: 		[ : path | 		self queue: path last.		self shouldStopScanning ifTrue: [ ^ self ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaFileDirectoryContext class	instanceVariableNames: ''!!MaFileDirectoryContext class methodsFor: 'create' stamp: 'cmm 3/8/2008 18:50'!forFileContentsIn: aFileDirectory 	"Answer a context that will match the specified keywords against the contents of files."self maMarked: 'dev'. "This is unfinished.."	^ (self new fileDirectory: aFileDirectory)		accessSelector: #readStream ;		yourself! !!MaFileDirectoryContext class methodsFor: 'create' stamp: 'cmm 2/28/2008 16:12'!forFileNamesIn: aFileDirectory 	"Answer a context that will match the specified keywords against the names of files."	^ self new		fileDirectory: aFileDirectory ;		yourself! !MaSearchContext subclass: #MaStreamContext	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaStreamContext commentStamp: 'cmm 2/7/2008 17:39' prior: 0!All of the context searching works by sending #next to the context to obtain the next object for evaluation.!!MaStreamContext methodsFor: 'private' stamp: 'cmm 6/23/2003 16:24'!atEnd	^stream atEnd! !!MaStreamContext methodsFor: 'private' stamp: 'cmm 6/21/2003 16:54'!next	^stream next! !!MaStreamContext methodsFor: 'private' stamp: 'cmm 4/2/2009 11:49'!prepareForScan	stream maReset! !!MaStreamContext methodsFor: 'private' stamp: 'cmm 6/21/2003 16:54'!stream: aStream	stream := aStream! !!MaStreamContext methodsFor: 'testing' stamp: 'cmm 2/28/2008 22:22'!knowsSearchSize	^ true! !!MaStreamContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 21:55'!searchSize	^ stream size! !!MaStreamContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:20'!source	^ stream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaStreamContext class	instanceVariableNames: ''!!MaStreamContext class methodsFor: 'create' stamp: 'cmm 12/30/2010 19:28'!stream: aStream 	^ self new		 stream: aStream ;		 yourself! !MaStreamContext subclass: #MaCollectionContext	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MaCollectionContext methodsFor: 'initializing' stamp: 'cmm 7/6/2003 23:00'!collection: aSequenceableCollection	^self stream: aSequenceableCollection readStream! !!MaCollectionContext methodsFor: 'initializing' stamp: 'cmm 2/28/2008 22:22'!knowsSearchSize	^ true! !!MaCollectionContext methodsFor: 'initializing' stamp: 'cmm 2/28/2008 21:55'!searchSize	^ stream size! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaCollectionContext class	instanceVariableNames: ''!!MaCollectionContext class methodsFor: 'creation' stamp: 'cmm 12/30/2010 19:29'!collection: aCollection 	^ self stream: aCollection readStream! !MaSearchContext subclass: #MagmaCollectionContext	instanceVariableNames: 'reader position'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Search-Domain'!!MagmaCollectionContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:05'!atEnd	^ position >= reader lastKnownSize! !!MagmaCollectionContext methodsFor: 'accessing' stamp: 'cmm 6/21/2003 16:38'!next	^reader at: self incrementPosition! !!MagmaCollectionContext methodsFor: 'accessing' stamp: 'cmm 2/28/2008 22:05'!searchSize	^ reader lastKnownSize! !!MagmaCollectionContext methodsFor: 'accessing' stamp: 'cmm 3/6/2008 16:20'!source	^ reader! !!MagmaCollectionContext methodsFor: 'private' stamp: 'cmm 6/21/2003 16:38'!incrementPosition	^position := position + 1! !!MagmaCollectionContext methodsFor: 'private' stamp: 'cmm 12/30/2010 19:54'!initialize	super initialize.	position := 0! !!MagmaCollectionContext methodsFor: 'private' stamp: 'cmm 6/21/2003 16:37'!reader: aMagmaCollectionReader	reader := aMagmaCollectionReader! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaCollectionContext class	instanceVariableNames: ''!!MagmaCollectionContext class methodsFor: 'creation' stamp: 'cmm 6/21/2003 16:35'!reader: aMagmaCollectionReader	^self new		reader: aMagmaCollectionReader;		yourself ! !MaContextPreferences initialize!