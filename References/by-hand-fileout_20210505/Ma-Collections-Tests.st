TestCase subclass: #MaHashIndexRecordTester	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Tests'!!MaHashIndexRecordTester methodsFor: 'overriding' stamp: 'cmm 2/11/2011 16:20'!defaultTimeout"Timeouts on tests, ain't it great?!!"	^ 99 days asSeconds! !!MaHashIndexRecordTester methodsFor: 'private tests' stamp: 'cmm 7/26/2012 20:16'!notify: aString	Transcript cr; show: aString! !!MaHashIndexRecordTester methodsFor: 'private tests' stamp: 'cmm 7/1/2005 16:53'!verifyConsecutiveContiguousKeyRangesOn: aMaHashIndexRecord	0		to: aMaHashIndexRecord numberOfSlots - 2		do:			[ : index |			self should:				[ aMaHashIndexRecord canHoldDuplicateKeys					ifTrue:						[ ((aMaHashIndexRecord lowestKeyAtIndex: index + 1) -							(aMaHashIndexRecord highestKeyAtIndex: index))								between: 0								and: 1 ]					ifFalse:						[ ((aMaHashIndexRecord lowestKeyAtIndex: index + 1) -							(aMaHashIndexRecord highestKeyAtIndex: index)) = 1 ] ] ]! !!MaHashIndexRecordTester methodsFor: 'private tests' stamp: 'cmm 7/1/2005 17:12'!verifyEntryIndexAndRangeEndpointCongruenceOn: aMaHashIndexRecord	0		to: aMaHashIndexRecord numberOfSlots - 1		do:			[ : x |  | key |			key := aMaHashIndexRecord lowestKeyAtIndex: x.			self should:				[ x					between: (aMaHashIndexRecord slotIndexFor: key)					and: (aMaHashIndexRecord highestSlotIndexFor: key) ].			x > 0 ifTrue:				[ self should: [ (aMaHashIndexRecord highestSlotIndexFor: key-1) < x ] ].			key := aMaHashIndexRecord highestKeyAtIndex: x.			self should:				[ x					between: (aMaHashIndexRecord slotIndexFor: key)					and: (aMaHashIndexRecord highestSlotIndexFor: key) ].			x < (aMaHashIndexRecord numberOfSlots - 1) ifTrue:				[ self should: [ (aMaHashIndexRecord slotIndexFor: key+1) > x ] ] ]! !!MaHashIndexRecordTester methodsFor: 'private tests' stamp: 'cmm 7/1/2005 17:00'!verifyRecord: aMaHashIndexRecord do: twoArgBlock	self		verifyConsecutiveContiguousKeyRangesOn: aMaHashIndexRecord;		verifyEntryIndexAndRangeEndpointCongruenceOn: aMaHashIndexRecord.	aMaHashIndexRecord		byteArrayIndexesFrom: 0		do:			[ : eachBax |			twoArgBlock value: aMaHashIndexRecord value: eachBax.			(aMaHashIndexRecord highKey - aMaHashIndexRecord lowKey) > 1  "if not fully zoomed in"				ifTrue:					[ | x lowestKey highestKey |					x := aMaHashIndexRecord slotIndexForBax: eachBax.					lowestKey := aMaHashIndexRecord lowestKeyAtIndex: x.					highestKey := aMaHashIndexRecord highestKeyAtIndex: x.					self						verifyRecord:							(aMaHashIndexRecord independentCopy								beZoomedInToward: (lowestKey to: highestKey) atRandom								from: aMaHashIndexRecord)						do: twoArgBlock ] ]! !!MaHashIndexRecordTester methodsFor: 'tests' stamp: 'cmm 8/17/2005 19:42'!testAll	"Test a variety of keySize and recordSize combinations.  For each pair, run only as far as it takes to get two-deep into duplicates for all originating from one entry in the root record, chosen at random."	| testCount |	testCount := 0.	#(16 24 32 40 56 64 96 128 160 192 256) "keySizes" do:		[ : keySize |		#(2 4 8 16 32 64 128) "recordSizes" do:			[ : recordSize |  | startRecord  |			"make test run-time reasonable by skipping enough levels to only test the bottom 100000 records or so."			startRecord := 				self					zoomedRecord: keySize 					recordSize: recordSize 					childSpace: 10000.			self notify: 'testing keySize: ', keySize printString, ' recordSize: ', recordSize printString, ', total key span: ', (startRecord highKey - startRecord lowKey) printString.			self 				verifyRecord: startRecord									do:					[ : record : eachBax |					record == startRecord						ifTrue:							[ self notify:								(String streamContents:									[ : stream |									stream										tab; maPrint: 'x:' ;										maPrint: (record slotIndexForBax: eachBax) ;										maPrint: ' (~' ;										maPrint: testCount ;										maPrint: ' records tested)' ]) ].					testCount := testCount + 1 ] ] ]! !!MaHashIndexRecordTester methodsFor: 'private creation' stamp: 'cmm 7/1/2005 17:15'!zoomedRecord: keySize recordSize: recordSize childSpace: anInteger	| answer prior |	answer :=		MaHashIndexRecord			keySize: keySize			valueSize: 64			numberOfSlots: recordSize.	[ (answer highKey - answer lowKey) > anInteger ]		whileTrue:			[ prior := answer.			answer := answer				beZoomedInToward: (answer lowKey to: answer highKey) atRandom				from: answer ].	^ (answer highKey - answer lowKey) < 1000		ifTrue: [ prior ]		ifFalse: [ answer ]! !MaTestCase subclass: #MaHashIndexTester	instanceVariableNames: 'sortedKeys predictedSize index values nextValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Tests'!!MaHashIndexTester methodsFor: 'private actions' stamp: 'cmm 4/28/2005 22:08'!addKey: keyInteger	| value |	self index		add: (value := self getNextValue)		at: keyInteger.	sortedKeys add: keyInteger.	(values		at: keyInteger		ifAbsentPut: [ OrderedCollection new ])			add: value.	predictedSize := predictedSize + 1.	^ value! !!MaHashIndexTester methodsFor: 'private actions'!addKeys: anArray	^anArray collect: [ :each | self addKey: each ]! !!MaHashIndexTester methodsFor: 'private actions' stamp: 'cmm 9/10/2006 00:47'!keySizes: keySizesArray withRecordSizes: recordSizesArray run: selectorSymbol	keySizesArray do:		[ : eachKeySize |		recordSizesArray do:			[ : eachRecordSize |			{ self 				newInMemoryHashIndexWithKeySize: eachKeySize				recordSize: eachRecordSize.			self				newHashIndexWithKeySize: eachKeySize				recordSize: eachRecordSize. }				do:					[ : eachIndex |					index := eachIndex.					self						setUp ;						run: selectorSymbol keySize: eachKeySize recordSize: eachRecordSize ;						tearDown ] ] ]! !!MaHashIndexTester methodsFor: 'private actions'!removeKey: keyInteger	^self		removeKey: keyInteger		at: 1! !!MaHashIndexTester methodsFor: 'private actions' stamp: 'cmm 4/28/2005 22:06'!removeKey: keyInteger at: anInteger	self index		remove: ((values at: keyInteger) removeAt: anInteger)		at: keyInteger.	sortedKeys remove: keyInteger.	(values at: keyInteger) isEmpty ifTrue: [ values removeKey: keyInteger ].	predictedSize := predictedSize - 1! !!MaHashIndexTester methodsFor: 'private actions' stamp: 'cmm 11/28/2002 00:15'!removeKeys: aCollection	aCollection do: [ :each | self removeKey: each ]! !!MaHashIndexTester methodsFor: 'private actions' stamp: 'cmm 8/19/2007 22:08'!run: selectorSymbol keySize: keySize recordSize: recordSize 	self notify: 		(String streamContents: 			[ : stream | 			stream				nextPutAll: 'keysize ' ;				maPrint: keySize ;				nextPutAll: ' record size ' ;				maPrint: recordSize ;				nextPutAll: ' completed in ' ;				nextPutAll: [ self perform: selectorSymbol ] durationToRun printString ])! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 4/28/2005 22:03'!allValues	^ values		inject: OrderedCollection new		into:			[ : coll : each |			coll				addAll: each;				yourself ]! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 4/28/2005 22:04'!getNextValue	^ nextValue := nextValue + 1! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 1/30/2002 12:48'!index	^index! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 4/11/2005 10:58'!indexFileNameForKeySize: keySize recordSize: recordSize	^ self environmentDirectory fullNameFor: 'k', keySize printString, 'r', recordSize printString, '.', MaHashIndex suggestedFileExtension! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 10/18/2014 15:01'!indexKeys	^(self index		upTo: predictedSize*2		keysFrom: 0) copy! !!MaHashIndexTester methodsFor: 'private accessing' stamp: 'cmm 10/18/2014 15:03'!indexValues	^ (self index		upTo: predictedSize*2		keysAndValuesFrom: self index lowestPossibleKey		to: self index highestPossibleKey		startingAt: 1) last copy! !!MaHashIndexTester methodsFor: 'overriding' stamp: 'cmm 2/11/2011 16:20'!defaultTimeout"Timeouts on tests, ain't it great?!!"	^ 99 days asSeconds! !!MaHashIndexTester methodsFor: 'accessing' stamp: 'cmm 8/30/2006 16:36'!keyAndRecordSizesToTest	^#(16 24 32 40 48 56 64 96 128 160 192 224 256) -> #(2 4 8 16 32 64 128)! !!MaHashIndexTester methodsFor: 'private creation' stamp: 'cmm 3/20/2009 18:50'!newHashIndexWithKeySize: keySize recordSize: recordSize	| filename |	self notify: 'creating ',		(filename := self			indexFileNameForKeySize: keySize			recordSize: recordSize), '..'.	self deleteFilesNamed: { filename }.	^ MaHashIndex		createNamed: filename		keySize: keySize		valueSize: 48 "MaObjectBuffer oidSize"		recordSize: recordSize! !!MaHashIndexTester methodsFor: 'private creation' stamp: 'cmm 3/20/2009 18:49'!newInMemoryHashIndexWithKeySize: keySize recordSize: recordSize 	self notify: 'creating in-memory with keySize: ' , keySize printString , ' recordSize: ' , recordSize printString , '.'.	^ MaHashIndex 		newWithKeySize: keySize		valueSize: 48 "MaObjectBuffer oidSize"		recordSize: recordSize	! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 7/26/2012 20:16'!notify: aString	Transcript cr; show: aString! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 10/18/2014 17:05'!verifyIndex	self shouldnt: [ index hasAnomalies ].	self		verifySize;		verifyKeys;		verifyKeyValuePairs;		verifyKeyQuantities;		verifyIndexPositions ;		verifyMidIndexAccess! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 4/28/2005 22:03'!verifyIndexPositions	| allValues |	allValues := self allValues.	(self index		upTo: allValues size		keysAndValuesFromIndex: 1) last			maConsistsOf: allValues! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 4/17/2005 22:07'!verifyInsertionOfDuplicateKey: keyInteger	"Test the insertion of a many of the same key, requiring the	receivers index to zoom all the way into that key and getting	into the inverted records."	25 timesRepeat: [ self addKey: keyInteger ].	self should:		[ (self index			upTo: 100			at: keyInteger) last				size = 25 ].	275 timesRepeat: [ self addKey: keyInteger ].	self should:		[ (self index			upTo: 350			at: keyInteger) last				size = 300 ]! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 11/3/2014 15:35'!verifyKeyQuantities	self assert:		(sortedKeys allSatisfy:			[ : each | (self index occurrencesOf: each) = (values at: each) size ]).	self assert:		((sortedKeys isEmpty and: [ self index size = 0 ]) or:			[ self index size =				(self index					numberOfEntriesFrom: 0					to: sortedKeys last) ])! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 10/18/2014 15:24'!verifyKeyValuePairs	| keysAndValues |	keysAndValues := self index		upTo: predictedSize * 2		keysAndValuesFromIndex: 1.	self assert: keysAndValues first size = self allValues size.	keysAndValues first		with: keysAndValues second		do:			[ : key : value | self assert: ((values at: key) includes: value) ]! !!MaHashIndexTester methodsFor: 'private tests'!verifyKeys	self should: [ self indexKeys maMatchesElementsOf: sortedKeys ]! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 10/18/2014 17:15'!verifyMidIndexAccess	| size |	(size:=self index size)		to: 1		by: (size//100 max: 1) negated		do:			[ : n | | count |			count := 0.			self index				entriesFromIndex: n				do:					[ : rec : bax : level | count := count + 1 ]				until:					[ : rec : bax : level | false ].			self assert: count = (size-n+1) ]! !!MaHashIndexTester methodsFor: 'private tests' stamp: 'cmm 10/18/2014 16:09'!verifySize	| size count |	self assert: (size := self index size) = predictedSize.	count := 0.	self index		entriesFromIndex: 1		do:			[ : rec : bax : level | count := count + 1 ]		until:			[ : rec : bax : level | false ].	self assert: size = count! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 11/3/2014 15:38'!runFullDepthKeyInsertionThenPullOut	self		addKeys: (64000 to: 0 by: -1) ;		verifyIndex;		"remove only half of them in the worst possible way and verify."		removeKeys: (0 to: 31999) ;		verifyIndex;		"Remove the remaining and verify."		removeKeys: (32000 to: 64000) ;		verifyIndex ;		"Now reuse some of those slots with a subset of the same key range"		addKeys: (35000 to: 25001 by: -1) ;		verifyIndex;		"Add some back once again."		removeKeys: (28001 to: 32000) ;		verifyIndex! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 11/4/2014 16:29'!runInsertionOfEndpointKeys	"This tests keys that fall at the endpoints of records.  It covers the lowest and highest keys."	self		verifyInsertionOfDuplicateKey: 1 ;		verifyInsertionOfDuplicateKey: 0 ;		verifyInsertionOfDuplicateKey: (2 raisedTo: index keySize) - 1;		verifyInsertionOfDuplicateKey: (2 raisedTo: index keySize) - 2.	self verifyIndex! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 3/10/2004 01:09'!runKeyInsertionIntoBroadRecords	"A 'broad' record is one whose key range is greater than its	numberOfEntries, thus it cannot hold duplicate keys.	This test adds keys in an order that requires the index to	re-sequence keys across multiple broad records."	self		addKeys: #(500 450 470 550 400);		verifyIndex;		removeKey: 450;		verifyIndex;		addKey: 471;		verifyIndex.	25 timesRepeat: [ self addKey: 470 ].	self verifyIndex.	25 timesRepeat: [ self addKey: 469 ].	self verifyIndex.	1		to: 25		do:			[ :each |			each even				ifTrue:					[ self						removeKey: 469						at: each // 2 ] ].	self verifyIndex! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 10/27/2014 10:36'!testFullDepthKeyInsertionThenPullOut	self		keySizes: self keyAndRecordSizesToTest key		withRecordSizes: self keyAndRecordSizesToTest value		run: #runFullDepthKeyInsertionThenPullOut! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 12/5/2002 17:28'!testInsertionOfEndpointKeys	self		keySizes: self keyAndRecordSizesToTest key		withRecordSizes: self keyAndRecordSizesToTest value		run: #runInsertionOfEndpointKeys! !!MaHashIndexTester methodsFor: 'tests' stamp: 'cmm 12/5/2002 17:28'!testKeyInsertionIntoBroadRecords	self		keySizes: self keyAndRecordSizesToTest key		withRecordSizes: self keyAndRecordSizesToTest value		run: #runKeyInsertionIntoBroadRecords! !!MaHashIndexTester methodsFor: 'private framework' stamp: 'cmm 11/4/2014 15:58'!setUp	predictedSize := 0.	values := PluggableDictionary integerDictionary.	sortedKeys := SortedCollection new.	nextValue := 2 raisedTo: 17  "some arbitrary number"! !!MaHashIndexTester methodsFor: 'private framework' stamp: 'cmm 4/16/2002 23:43'!tearDown	index ifNotNil: [ index close ]! !