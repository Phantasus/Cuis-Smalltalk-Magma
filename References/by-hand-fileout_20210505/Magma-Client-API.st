MaRefreshViewResult subclass: #MaCommitResult	instanceVariableNames: 'permanentOids changedObjectBuffers newObjectBuffers'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MaCommitResult commentStamp: 'cmm 7/24/2007 12:41' prior: 0!A MaCommitResult is the object returned to my client after performing a successful commit.Instance Variables	changedObjectBuffers : The 'committed' Dictionary from my containing MaCommitLogEntry which is used to update the clients readSet with the latest version of his buffers.	newObjectBuffers : Same as changedObjectBuffers, except the new objects that were attached to the repository via reachability.  Their oids were updated to permanent-oids in the #registerUsing: and #link steps of the commit process.	permanentOids : The Dictionary map of the transient-oid to the permanent-oid, used to update my clients OidManager.!!MaCommitResult methodsFor: 'converting' stamp: 'cmm 6/4/2009 13:27'!asFailedResult	^ self as: MaFailedCommitResult! !!MaCommitResult methodsFor: 'building' stamp: 'cmm 10/10/2004 21:46'!changedObjectBuffers: aDictionary	changedObjectBuffers := aDictionary! !!MaCommitResult methodsFor: 'building' stamp: 'cmm 5/9/2005 22:45'!recordNewObjectBuffer: aMaObjectBuffer	newObjectBuffers 		at: aMaObjectBuffer oid		put: aMaObjectBuffer! !!MaCommitResult methodsFor: 'testing'!hasConflicts	^false! !!MaCommitResult methodsFor: 'initializing' stamp: 'cmm 7/11/2005 12:56'!initialize	super initialize.	newObjectBuffers := Dictionary new.	changedObjectBuffers := Dictionary new! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 5/9/2005 22:47'!newObjectBuffers	^ newObjectBuffers! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:35'!permanentOids	"A Dictionary.  Key is the new-object oid, value is the permanent oid."	^ permanentOids! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:35'!permanentOids: aDictionary	"A Dictionary.  Key is the new-object oid, value is the permanent oid."	permanentOids := aDictionary! !!MaCommitResult methodsFor: 'copying' stamp: 'cmm 7/24/2007 13:11'!postTrimmedCopy	| withBuffers |	super postTrimmedCopy.	changedObjectBuffers := nil.	withBuffers := newObjectBuffers.	newObjectBuffers := withBuffers class new: withBuffers size.	withBuffers keysAndValuesDo: 		[ : eachOid : eachObject | 		newObjectBuffers 			at: eachOid			put: nil ]! !!MaCommitResult methodsFor: 'actions' stamp: 'cmm 1/10/2014 16:51'!refresh: aMagmaSession includingLocal: aBoolean 	aMagmaSession assignPermanentOidsFrom: permanentOids.	super		refresh: aMagmaSession		includingLocal: aBoolean.	aMagmaSession		 recordObjects: newObjectBuffers ;		 recordObjects: changedObjectBuffers! !MaCommitResult subclass: #MaFailedCommitResult	instanceVariableNames: 'commitConflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MaFailedCommitResult methodsFor: 'converting'!asFailedResult	^self! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:30'!attributeColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : anAssociation | anAssociation key ])		 headingText: nil ;		 alignLeft ;		 width: 20 ;		 repeatDuplicateValues: true ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:46'!comparisonSpec	^ MaFixedWidthRowSpecification new		addColumn: self oidColumn ;		addColumn: self objectColumn ;		yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:47'!conflictReport	^ MaFixedWidthReport new		for: MagmaCommitConflict		use: self conflictSpec ;		for: MagmaCommitConflict		subReportOn: [ : eachConflict | eachConflict comparisons ] ;		for: MaObjectComparison		use: self comparisonSpec ;		for: MaObjectComparison		subReportOn: [ : eachComparison | eachComparison differences ] ;		for: Association		use: self differenceSpec ;		yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/27/2013 21:56'!conflictSpec	^ MaFixedWidthRowSpecification new		addColumn: self sessionIdColumn ;		addColumn: self userIdColumn ;		yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:43'!differenceSpec	^ MaFixedWidthRowSpecification new		addColumn: self attributeColumn ;		addColumn: self winningValueColumn ;		addColumn: self losingValueColumn ;		yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:42'!losingValueColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : anAssociation | anAssociation value second ])		 headingText: nil ;		 alignLeft ;		 width: 50 ;		 repeatDuplicateValues: true ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 4/5/2013 10:02'!objectColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : aMaObjectComparison | aMaObjectComparison object1 ])		 headingText: nil ;		 alignLeft ;		 width: 120 ;		 repeatDuplicateValues: true ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 4/5/2013 10:01'!oidColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : aMaObjectComparison | 'oid:  ', aMaObjectComparison object1 magmaOid asString ])		 headingText: nil ;		 alignLeft ;		 width: 20 ;		 repeatDuplicateValues: false ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 6/26/2002 00:33'!populateConflictingObjectsFromOidsUsing: aMaObjectSerializer	commitConflicts do: [ :each | each initializeConflictingObjectsUsing: aMaObjectSerializer ]! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 4/5/2013 09:54'!sessionIdColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : aMagmaCommitConflict | aMagmaCommitConflict connection sessionId ])		 headingText: 'sessionId' ;		 alignLeft ;		 width: UUID new asString size ;		 repeatDuplicateValues: false ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 4/5/2013 09:59'!userIdColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : aMagmaCommitConflict | aMagmaCommitConflict connection userId ])		 headingText: 'userId' ;		 alignLeft ;		 width: 50 ;		 repeatDuplicateValues: true ;		 useEllipsisOnTruncate: true ;		 yourself! !!MaFailedCommitResult methodsFor: 'private' stamp: 'cmm 3/28/2013 13:42'!winningValueColumn	^ (MaFixedWidthReportColumn dataAccessBlock:		[ : anAssociation | anAssociation value first ])		 headingText: nil ;		 alignLeft ;		 width: 50 ;		 repeatDuplicateValues: true ;		 yourself! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 6/26/2002 22:16'!commitConflicts	^commitConflicts! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 5/9/2013 10:55'!comparisons	^ Array streamContents:		[ : stream | self conflictingObjectsDo:			[ : each | stream nextPut:				(MaObjectComparison					with: each key					with: each value) ] ]! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 2/28/2013 10:47'!comparisonsDo: aBlock 	commitConflicts do:		[ : each | aBlock value:			(MaObjectComparison				with: each key				with: each value) ]! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 1/22/2015 16:47'!conflictMessage	"This method demonstrates how the structure of a MaCommitResult might be utilized to	provide a message to an end-user."	^ String streamContents:		[ : stream | commitConflicts do:			[ : each | stream				 maPrint: each connection userId ;				 maPrint: ' has committed changes to ' ;								appendProperlyPluralized: 'object'				for: each conflictingOids size ;				 maPrint: ' with ' ;								maPrint: 'oid'				pluralizeIf: [ each conflictingOids size > 1 ] ;				 space ;				 appendAndedList: each conflictingOids ;				 maPrint: '; ' ].		stream maPrint: ' while you were working on those same objects.  Please review and reapply your changes if necessary.' ]! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 1/17/2014 16:05'!conflictingObjects	"Answer a collection of Associations whose keys are the persistent database object (updated) and whose values are a shallowCopy of that object with the local changes."	^ Array streamContents:		[ : stream | self conflictingObjectsDo:			[ : each | stream nextPut: each ] ]! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 10/2/2012 13:25'!conflictingObjectsDo: aBlock 	commitConflicts do:		[ : each | each conflictingObjects do: aBlock ]! !!MaFailedCommitResult methodsFor: 'printing' stamp: 'cmm 10/14/2013 20:25'!detailedPrintString	^ String streamContents: [ : stream | self printDetailsOn: stream ]! !!MaFailedCommitResult methodsFor: 'printing' stamp: 'cmm 3/28/2013 13:51'!printDetailsOn: aStream 	self conflictReport		write: commitConflicts		to: aStream! !!MaFailedCommitResult methodsFor: 'testing' stamp: 'cmm 1/17/2014 15:11'!hasConflicts	^ commitConflicts notEmpty! !!MaFailedCommitResult methodsFor: 'initializing' stamp: 'cmm 12/24/2002 15:42'!initialize	super initialize.	commitConflicts := OrderedCollection new! !!MaFailedCommitResult methodsFor: 'actions' stamp: 'cmm 7/9/2014 08:21'!mergeConflicts	"Let all conflicts merge from their conflictors.  After doing this, answer a collection of Associations of objects still in conflict.  The keys are the now-committed versions of the objects, the values are MY sessions versions of these objects."	^self conflictingObjects reject:		[ : eachAssoc | | eachChanged eachMine classDefs |		eachChanged := eachAssoc key.		eachMine := eachAssoc value.		classDefs := eachChanged magmaSession definition classDefinitions.		eachChanged == classDefs or: [ (classDefs includesIdentity: eachChanged) or: [ eachChanged mergeConflicting: eachMine ] ] ]! !!MaFailedCommitResult methodsFor: 'actions' stamp: 'cmm 10/15/2004 16:19'!recordObjectConflictWith: aMagmaClientConnection on: oidInteger	(commitConflicts		detect: [ : each | each conflictingConnection = aMagmaClientConnection ]		ifNone: [ commitConflicts add: (MagmaCommitConflict connection: aMagmaClientConnection) ])			addConflictingOid: oidInteger.	^ self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaFailedCommitResult class	instanceVariableNames: ''!!MaFailedCommitResult class methodsFor: 'as yet unclassified' stamp: 'cmm 6/4/2009 17:01'!newFrom: aMaCommitResult 	^ self new		copySameFrom: aMaCommitResult ;		yourself! !MaObject subclass: #MaImmutabilityStrategy	instanceVariableNames: 'specs immutables classes'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 11/11/2011 21:28'!classes	^ classes! !!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 11/7/2011 21:33'!finalizeImmutables	immutables finalizeValues! !!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 12/2/2011 17:10'!rememberIfImmutableByClass: anObject for: aMaTransaction 	classes		at: anObject maOriginalClass		ifPresent:			[ : foundCondition | (foundCondition value: anObject) ifTrue:				[ aMaTransaction remove: anObject.				immutables					at: anObject					put: nil ] ]		ifAbsent: [  ]! !!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 4/22/2013 16:44'!rememberImmutableReferencesFrom: anObject bySpecFor: aMaTransaction	specs		at: anObject maOriginalClass		ifPresent:			[ : foundSpec | foundSpec keysAndValuesDo:				[ : eachVarName : eachBlock | (eachBlock value: anObject) ifTrue:					[ | immutable |					immutable := anObject instVarNamed: eachVarName.					immutable maIsMutatingProxy ifTrue:						[ immutable := immutable maRealObjectIsReified ifTrue: [ immutable realObjectIfMutatingProxy ] ].					immutable ifNotNil:						[ aMaTransaction remove: immutable.						immutables							at: immutable							put: nil ] ] ] ]		ifAbsent: [  ]! !!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 12/2/2011 17:10'!rememberImmutableReferencesFrom: anObject for: aMaTransaction 	self				rememberIfImmutableByClass: anObject		for: aMaTransaction ;				rememberImmutableReferencesFrom: anObject		bySpecFor: aMaTransaction! !!MaImmutabilityStrategy methodsFor: 'private' stamp: 'cmm 11/11/2011 21:22'!specs	^ specs! !!MaImmutabilityStrategy methodsFor: 'initialize-release' stamp: 'cmm 11/13/2011 20:11'!initialize	super initialize.	specs := Dictionary new.	classes := Dictionary new.	self resetImmutables! !!MaImmutabilityStrategy methodsFor: 'initialize-release' stamp: 'cmm 11/13/2011 20:11'!resetImmutables	immutables := MaObjectSerializerPreferences newWeakIdentityKeyDictionary! !!MaImmutabilityStrategy methodsFor: 'testing' stamp: 'cmm 11/3/2011 23:06'!isImmutable: anObject using: aMaTransaction 	anObject maIsLargeCollection ifTrue: [ ^ false ].	self		rememberImmutableReferencesFrom: anObject		for: aMaTransaction.	^ immutables includesKey: anObject! !!MaImmutabilityStrategy methodsFor: 'setup' stamp: 'cmm 11/11/2011 21:23'!merge: aMaImmutabilityStrategy 	aMaImmutabilityStrategy specs keysAndValuesDo:		[ : eachClass : eachMap | specs			at: eachClass			ifAbsentPut: [ eachMap copy ] ].	aMaImmutabilityStrategy classes keysAndValuesDo:		[ : eachClass : eachBlock | classes			at: eachClass			ifAbsentPut: [ eachBlock ] ]! !!MaImmutabilityStrategy methodsFor: 'setup' stamp: 'cmm 11/10/2011 20:33'!treatAny: aClass asImmutableIf: oneArgBlock 	"Specify immutability of an object by its class and a condition on each instance of that class."	aClass withAllSubclassesDo:		[ : eachClass | classes			at: eachClass			put: oneArgBlock ]! !!MaImmutabilityStrategy methodsFor: 'setup' stamp: 'cmm 11/10/2011 20:32'!treatObjectReferencedBy: variableName onAny: aClass asImmutableIf: oneArgBlock 	"Specify immutability of an object by its referencing object."	| spec |	(aClass allInstVarNames includes: variableName) ifFalse: [ MagmaUserError signal: aClass name , ' does not have a variable named ' , variableName ].	aClass withAllSubclassesDo:		[ : eachClass | spec := specs			at: eachClass			ifAbsentPut: [ Dictionary new ].		spec			at: variableName			put: oneArgBlock ]! !MaBasicReadStrategy subclass: #MaReadStrategy	instanceVariableNames: 'depths depthSpecifications'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MaReadStrategy commentStamp: 'cmm 1/26/2005 21:28' prior: 0!When objects are retrieved from a Magma repository, the server must eventually decide to stop traversing the graph and return a reasonable chunk of objects.  Sometimes, the default pattern of reading may be ineffecient for the processing needed.Therefore, my instances can be used to suggest to the server a particular depth for particular class or even a variable within a class.Implementation notes:There are two parts; 'specifications' and 'depths'.  The specifications track what the user wants, while the depths are the efficiently-integerized representation for each MaClassDefinition (and version).  That's why there are not more first-class objects here, MaObjectSerializer is efficient with #'s (although now with the server caching it's probably no longer an excuse).  Whenever the specs change, or when the ClassDefinitions change the depths need to be rebuilt.  That's what my #isNew api is all about.When transmitted to the server, it caches me there and I am then told to #beOld.  But only my depths are actually transmitted for further efficiency.  My '*magma server' methods are employed to determine the depth on the server.Use my 'building' methods so that the Testing methods can then answer whether a particular depth should be read on a particular object or class.!!MaReadStrategy methodsFor: 'private' stamp: 'cmm 3/17/2010 21:21'!convertSpecificationsToIdsUsing: aMaClassIdManager 	"Convert the classes in the receiver to classId's, since that is what the server goes by."	| specifiedClassNames |	specifiedClassNames := (depthSpecifications keys collect: [ : each | each name ]) asSet.	aMaClassIdManager classDefinitionsById do: 		[ : eachDefinitions | 		eachDefinitions do: 			[ : eachDefinition | 			(specifiedClassNames includes: eachDefinition name) ifTrue: 				[ | depthSpec |				depthSpec := depthSpecifications at: eachDefinition classObject.				self beNew.				depths 					at: {  (eachDefinition id). (eachDefinition version)  }					put: 						(depthSpec isInteger 							ifTrue: [ depthSpec ]							ifFalse: [ self instVarMapFor: eachDefinition ]) ] ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 6/10/2004 22:27'!depthDictionaryOfSize: arraySize	^ Dictionary new: arraySize! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 4/26/2010 21:19'!depthSpecifications	^ depthSpecifications! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 9/24/2009 20:43'!inheritDeeperDepthsUsing: aMaClassIdManager 	"When the user specifies:		myReadStrategy			forVariableNamed: 'submorphs'			onAny: Morph			readToDepth: 999	then we need to ensure that any subclasses of Morph also read to 99999 for that variable.  Since each class has its own entire set of depth specs, we update the subclasses with the greater depth between their own and that of all their superclasses."	depths keysAndValuesDo: 		[ : eachIdAndVersion : eachDepths | 		| eachDefinition |		eachDefinition := aMaClassIdManager 			definitionForClassId: eachIdAndVersion first			version: eachIdAndVersion last.		eachDefinition allSuperclassDefinitionsDo: 			[ : eachSuperclassDefinition | 			eachDefinition 				inheritDeeperDepthsFrom: eachSuperclassDefinition				using: depths ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 2/9/2005 10:14'!initialize	super initialize.	"depths:  key is converted to the classId, value is either	anInteger for depth of all instVars or an Array detailing the	depth of each instVar."	self 		resetDepths ;		initializeDefaultSpecifications! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 5/15/2018 16:42'!initializeDefaultSpecifications	depthSpecifications := Dictionary new.	self				onAny: MaRootAnchor		readToDepth: 1 ;		onAny: BlockClosure		readToDepth: 1 ;		onAny: Context		readToDepth: 1 ;		onAny: Collection		readToDepth: 1 ;		onAny: Timespan		readToDepth: 1 ;		onAny: DateAndTime		readToDepth: 1 ;		onAny: Rectangle		readToDepth: 1 ;		forVariableNamed: 'next'		onAny: MaAssociation		readToDepth: 1 ;		forVariablesNamed: #('package' 'info' 'dependencies' )		onAny: MCVersion		readToDepth: 1 ;		forVariablesNamed: #('name' 'author' )		onAny: MCVersionInfo		readToDepth: 1 ;		onAny: MCDefinition		readToDepth: 1 ;		onAny: SOLHashTable		readToDepth: 1 ;		forVariableNamed: 'pointers'		onAny: SOLHashSegment		readToDepth: 1 ;		forVariableNamed: 'selector'		onAny: MessageSend		readToDepth: 1 ;		forVariableNamed: 'arguments'		onAny: MessageSend		readToDepth: 1.	"Try to avoid regular Dictionary's full of proxies."	#('key' 'value' ) do:		[ : each | self			forVariableNamed: each			onAny: Association			readToDepth: 1 ].	self		forVariablesNamed: (MagmaRepositoryDefinition allInstVarNames copyWithoutAll: #('codeBase' 'attributes' ))		onAny: MagmaRepositoryDefinition		readToDepth: 99.	#(#MagmaLocation #MagmaId #MagmaNode #MagmaCollection #MagmaCollectionReader #MagmaPreallocatedDictionary #MaClassDefinition #Project #Color #Duration #Point #Time #TimeZone #Form #BitMap #FileDirectory #DiskProxy #CompiledMethod #MaClassReference #ScaledDecimal #Fraction #LargePositiveInteger #FillStyle ) do:		[ : each | (self maOriginalClass environment hasClassNamed: each) ifTrue:			[ self				onAny: (self maOriginalClass environment classNamed: each)				readToDepth: 99 ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 10/28/2011 15:39'!instVarMapFor: aMaClassDefinition 	"Answer an Array with an instVarMap of aMaClassDefinition according to user-declared read depths."	^ (Array new: aMaClassDefinition namedInstSize) in: 		[ : arr | 		arr atAllPut: 0.		depthSpecifications 			at: aMaClassDefinition classObject			ifPresent: 				[ : specifiedDepth | 				specifiedDepth keysAndValuesDo: 					[ : eachInstVarName : eachDepth | 					| instVarIndex |					instVarIndex := aMaClassDefinition allInstVarNames indexOf: eachInstVarName.					instVarIndex > 0 ifTrue: 						[ arr 							at: instVarIndex							put: eachDepth ] ].				arr ]			ifAbsent: [ arr ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 9/24/2009 20:31'!makeReadyForUseUsing: aMaClassIdManager 	self		resetDepths ;		convertSpecificationsToIdsUsing: aMaClassIdManager ;		inheritDeeperDepthsUsing: aMaClassIdManager ;		unspecifiedClassesInheritUsing: aMaClassIdManager! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 6/30/2004 17:14'!resetDepths	depths := Dictionary new! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 10/28/2011 15:54'!unspecifiedClassesInheritUsing: aMaClassIdManager 	"All of the classes explicitly specified for this ReadStrategy have inherited deeper depths of specified superclasses.  Now we want all *subclasses* which were not explicitly specified, to inherit the specified depths of their superclasses."	aMaClassIdManager classDefinitionsById do: 		[ : eachDefinitions | 		eachDefinitions do: 			[ : eachClassDefinition | 			depths 				at: { 						(eachClassDefinition id).						(eachClassDefinition version)					 }				ifPresent: [ : foundSpec |  ]				ifAbsent: 					[ "Look through his superclasses to see whether he should be inheriting"					eachClassDefinition allSuperclassDefinitions reversed do: 						[ : eachSuperclassDefinition | 						depths 							at: { 									(eachSuperclassDefinition id).									(eachSuperclassDefinition version)								 }							ifPresent: 								[ : foundSuperSpec | 								depths 									at: { 											(eachClassDefinition id).											(eachClassDefinition version)										 }									put: (foundSuperSpec isInteger 											ifTrue: [ foundSuperSpec ]											ifFalse: [ self instVarMapFor: eachClassDefinition ]).								eachClassDefinition 									inheritDeeperDepthsFrom: eachSuperclassDefinition									using: depths ]							ifAbsent: [ "do nothing" ] ] ] ] ]! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 5/13/2011 14:12'!copyForOtherSession	^ self copy		resetDepths ;		yourself! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 5/2/2005 22:12'!copyWithoutSpecifications	^ self copy		resetSpecifications ;		yourself! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 9/23/2004 15:55'!resetSpecifications	depthSpecifications := nil! !!MaReadStrategy methodsFor: 'building' stamp: 'cmm 10/28/2011 15:39'!forVariableNamed: aString onAny: aClass readToDepth: anInteger 	| depthDict |	({Dictionary. 	Set} includes: aClass) ifTrue: [ MagmaUserError signal: 'Set and Dictionary are treated logically by Magma, just use #onAny: ' , aClass name , ' readToDepth:' ].	self beNew.	depthDict := depthSpecifications		at: aClass		ifPresent:			[ : foundSpec | foundSpec isInteger				ifTrue:					[ depthSpecifications						at: aClass						put: (self depthDictionaryOfSize: aClass instSize) ]				ifFalse: [ foundSpec ] ]		ifAbsent:			[ depthSpecifications				at: aClass				put: (self depthDictionaryOfSize: aClass instSize) ].	depthDict		at: aString		put: anInteger! !!MaReadStrategy methodsFor: 'building' stamp: 'cmm 3/14/2011 17:02'!forVariablesNamed: arrayOfStrings onAny: aClass readToDepth: anInteger 	arrayOfStrings do:		[ : each | self			forVariableNamed: each			onAny: aClass			readToDepth: anInteger ]! !!MaReadStrategy methodsFor: 'building' stamp: 'cmm 4/26/2010 21:21'!mergeSpecificationsFrom: aMaReadStrategy 	aMaReadStrategy depthSpecifications keysAndValuesDo: 		[ : eachClass : eachDictionary | 		self beNew.		depthSpecifications 			at: eachClass			put: eachDictionary ]! !!MaReadStrategy methodsFor: 'building' stamp: 'cmm 9/24/2009 16:21'!onAny: aClass readToDepth: anInteger 	self beNew.	^ depthSpecifications 		at: aClass		put: anInteger! !!MaReadStrategy methodsFor: 'accessing' stamp: 'cmm 4/7/2005 15:14'!isBasic	^ false! !!MaReadStrategy methodsFor: '*magma-server' stamp: 'cmm 10/28/2011 15:39'!depthOfAttribute: attributeIndex onClassWithId: classId version: versionNumber	"Answer the depth that the attribute at attributeIndex should be traversed into *from the current depth*."	^depths		at: { classId. versionNumber }		ifPresent:			[ :depth |			depth isInteger				ifTrue: [ depth ]				ifFalse: [ depth at: attributeIndex ifAbsent: [ 0 ] ] ]		ifAbsent: [ 0 ]! !MaObject subclass: #MaRootAnchor	instanceVariableNames: 'root definition'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MaRootAnchor commentStamp: 'cmm 12/22/2008 16:47' prior: 0!This class represents the real root of every repository.  The #root is the user-application domain root, the definition is a meta-object describing this repository itself.!!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:55'!definition	^ definition! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:56'!definition: aMagmaRepositoryDefinition	definition := aMagmaRepositoryDefinition! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:55'!root	^ root! !!MaRootAnchor methodsFor: 'building' stamp: 'cmm 12/28/2004 23:55'!root: anObject	root := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaRootAnchor class	instanceVariableNames: ''!!MaRootAnchor class methodsFor: 'creation'!object: anObject	^self new object: anObject! !MaObject subclass: #MagmaClientConnection	instanceVariableNames: 'sessionId userId maximumNumberOfChallengers currentReadStrategy maClientConnection isSystem challengingBytes'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MagmaClientConnection commentStamp: 'cmm 1/17/2014 13:24' prior: 0!MagmaClientConnection is used primarily by the server as an object that represents a single MagmaSession connected to it.But this object is also used by clients in cases where information about other connected clients is useful.  For example, when a commit-conflict occurs, MagmaCommitConflict is passed back to the client with information about the MagmaClientConnection(s) he's conflicting with.Instance VariableschallengingBytes	- xxxxxcurrentReadStrategy	- xxxxxisSystem	- xxxxxmaClientConnection	- xxxxxmaximumNumberOfChallengers	- xxxxxsessionId	- xxxxxuserId	- xxxxx!!MagmaClientConnection methodsFor: 'private' stamp: 'cmm 3/25/2013 20:41'!addChallengingBytes: anInteger 	challengingBytes := challengingBytes + anInteger! !!MagmaClientConnection methodsFor: 'private' stamp: 'cmm 3/25/2013 20:42'!resetChallengingBytes	challengingBytes := 0! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/25/2013 20:34'!challengingBytes	"The number of bytes that have been committed by others since this client last accessed the server."	^ challengingBytes! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 4/28/2003 16:48'!currentReadStrategy	^currentReadStrategy! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 4/28/2003 16:48'!currentReadStrategy: aMaReadStrategy	currentReadStrategy := aMaReadStrategy! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/25/2013 20:11'!info	^ maClientConnection info! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 11/7/2008 14:05'!isSystem	^isSystem! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 11/7/2008 14:05'!isSystem: aBoolean	isSystem := aBoolean! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 4/14/2013 15:36'!lastAccess	^ maClientConnection ifNotNil: [ maClientConnection lastAccess ]! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 9/20/2008 16:35'!maClientConnection	"The MaClientConnection from the Ma client server framework."	^maClientConnection! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 3/25/2013 20:10'!maClientConnection: aMaClientConnection	maClientConnection := aMaClientConnection! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!maximumNumberOfChallengers	^maximumNumberOfChallengers! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!maximumNumberOfChallengers: anInteger	maximumNumberOfChallengers := anInteger! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!sessionId	^sessionId! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!userId	^userId! !!MagmaClientConnection methodsFor: 'copying' stamp: 'cmm 7/31/2013 18:43'!informationalCopy	^ self copy postInformationalCopy! !!MagmaClientConnection methodsFor: 'copying' stamp: 'cmm 7/31/2013 18:42'!postInformationalCopy	maClientConnection := maClientConnection informationalCopy! !!MagmaClientConnection methodsFor: 'copying' stamp: 'cmm 9/25/2008 23:48'!postTrimmedCopy	currentReadStrategy := nil.	maClientConnection := nil! !!MagmaClientConnection methodsFor: 'copying' stamp: 'cmm 9/25/2008 23:48'!trimmedCopy	^ self copy postTrimmedCopy! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 3/25/2013 21:12'!initialize	super initialize.	challengingBytes := 0! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 11/7/2008 13:59'!sessionId: aUuid 	sessionId := aUuid! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 6/26/2002 00:21'!userId: aString	userId := aString! !!MagmaClientConnection methodsFor: 'maui' stamp: 'cmm 3/26/2013 12:30'!mauiDefaultColumns	^ #(sessionId userId lastAccess challengingBytes)! !!MagmaClientConnection methodsFor: 'maui' stamp: 'cmm 3/26/2013 12:30'!mauiSortableColumns	^ #(sessionId userId lastAccess challengingBytes)! !!MagmaClientConnection methodsFor: '*magma-server' stamp: 'cmm 2/21/2015 16:59'!isRemote	^ maClientConnection notNil! !!MagmaClientConnection methodsFor: '*magma-server' stamp: 'cmm 12/29/2014 18:08'!requestLifecycle	^ maClientConnection ifNotNil: [ maClientConnection lifecycle ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaClientConnection class	instanceVariableNames: ''!!MagmaClientConnection class methodsFor: 'creation' stamp: 'cmm 1/30/2014 17:32'!unknown	^ self new		 sessionId: 'unknown' ;		 userId: 'unknown' ;		 yourself! !!MagmaClientConnection class methodsFor: 'creation' stamp: 'cmm 11/7/2008 14:05'!userId: aString sessionId: sessionUuid maximumNumberOfChallengers: anInteger clientConnection: aMaClientConnection isSystem: aBoolean	^ self new		userId: aString ;		sessionId: sessionUuid ;		maximumNumberOfChallengers: anInteger ;		maClientConnection: aMaClientConnection ;		isSystem: aBoolean ;		yourself! !MaAttributableObject subclass: #MagmaPreferences	instanceVariableNames: ''	classVariableNames: 'Debug DebugProxies ShowStatusViaCursor'	poolDictionaries: ''	category: 'Magma-Client-API'!!MagmaPreferences commentStamp: 'cmm 1/25/2003 17:49' prior: 0!Each MagmaSession initializes its own preferences.  Get an instance of my by sending #preferences to a MagmaSession.Debug and DebugProxies are global preferences.!!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 7/17/2014 15:34'!allowLongCatchUp	"If the session should find itself more than 100 commits behind, whether it should automatically catch itself up or whether a MagmaTooFarBehindError should be signaled.	Most of the time, catching up from a long time ago is costly for both client and server, therefore the default is false.  Note however that MagmaTooFarBehindError is resumable."	^ self attributeNamed: #allowLongCatchUp! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 7/17/2014 15:34'!allowLongCatchUp: anInteger	"If the session should find itself more than 100 commits behind, whether it should automatically catch itself up or whether a MagmaTooFarBehindError should be signaled.	Most of the time, catching up from a long time ago is costly for both client and server, therefore the default is false.  Note however that MagmaTooFarBehindError is resumable."	self		attributeNamed: #allowLongCatchUp		put: anInteger! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:29'!allowWriteBarrier	^ self attributeNamed: #allowWriteBarrier! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:47'!allowWriteBarrier: aBoolean 	"Specify whether WriteBarrier should be used.  WriteBarrier changes the class of each materialized domain to a specialized subclass that overrides the mutating methods to call super, then signal a changed flag if the object changed."	aBoolean ifTrue:		[ self class canEnableWriteBarrier ifFalse: [ self class signalCannotEnableWriteBarrier ] ].	self		attributeNamed: #allowWriteBarrier		put: aBoolean! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 7/24/2018 20:47'!linkLocations	"A Dictionary keyed by MagmaId and valued by an OrderedCollection of MagmaLocations representing the preferred connection order."	^ self attributeNamed: #linkLocations! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 7/24/2018 20:47'!linkLocations: aDictionary 	"A Dictionary keyed by MagmaId and valued by an OrderedCollection of MagmaLocations representing the preferred connection order."	^ self		attributeNamed: #linkLocations		put: aDictionary! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:57'!retrySeconds	^ self attributeNamed: #retrySeconds! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:57'!retrySeconds: anInteger 	"For requests that can retry, the number of seconds to wait before retrying."	self		attributeNamed: #retrySeconds		put: anInteger! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:30'!signalProxyMaterializations	"When set to true, every time a proxy is materialized, a MagmaProxyMaterialization notification is signaled.  This is useful during development for performance tuning specifically for optimizing your read strategies."	^ self attributeNamed: #signalProxyMaterializations! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:30'!signalProxyMaterializations: aBoolean 	"Whether a MagmaProxyMaterialization should be signaled whenever a proxy is converted to a real object."	self		attributeNamed: #signalProxyMaterializations		put: aBoolean! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:57'!timeoutSeconds	"The number of seconds to wait for requests that cannot retry."	^ self attributeNamed: #timeoutSeconds! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 10/13/2012 22:57'!timeoutSeconds: anInteger 	"The number of seconds to wait for requests that cannot retry."	self		attributeNamed: #timeoutSeconds		put: anInteger! !!MagmaPreferences methodsFor: 'initializing' stamp: 'cmm 7/17/2014 15:28'!initialize	super initialize.	self 		signalProxyMaterializations: false ;		allowWriteBarrier: false ;		timeoutSeconds: 30 ;		retrySeconds: 30 ;		allowLongCatchUp: false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaPreferences class	instanceVariableNames: ''!!MagmaPreferences class methodsFor: 'write-barrier' stamp: 'cmm 11/26/2011 12:59'!canEnableWriteBarrier	^ true! !!MagmaPreferences class methodsFor: 'write-barrier' stamp: 'cmm 11/22/2011 22:27'!signalCannotEnableWriteBarrier	MagmaUserError signal: 'Cannot enable WriteBarrier.'! !!MagmaPreferences class methodsFor: 'debugging' stamp: 'cmm 8/10/2002 18:09'!debug	^Debug! !!MagmaPreferences class methodsFor: 'debugging' stamp: 'cmm 8/10/2002 18:10'!debug: aBoolean	Debug := aBoolean! !!MagmaPreferences class methodsFor: 'debugging' stamp: 'cmm 7/16/2002 00:24'!debugProxies	^DebugProxies! !!MagmaPreferences class methodsFor: 'debugging' stamp: 'cmm 7/25/2002 22:31'!debugProxies: aBoolean	DebugProxies := aBoolean! !!MagmaPreferences class methodsFor: 'debugging' stamp: 'cmm 5/22/2013 16:54'!debugProxiesWhile: aBlock 	| priorSetting |	priorSetting := DebugProxies.	self debugProxies: true.	aBlock ensure: [ self debugProxies: priorSetting ]! !!MagmaPreferences class methodsFor: 'initializing' stamp: 'cmm 9/3/2012 19:57'!initialize	super initialize.	self		debugProxies: false ;		debug: false ;		showStatusViaCursor: true! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:50'!readCursor	^ ShowStatusViaCursor 		ifTrue: [ Cursor read ]		ifFalse: [ self ]! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:44'!showStatusViaCursor 	^ ShowStatusViaCursor! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:44'!showStatusViaCursor: aBoolean 	ShowStatusViaCursor := aBoolean! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:46'!showWhile: aBlock 	"This class operates as a 'null cursor' that does not change the cursor, only evaluates aBlock."	^ aBlock value! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 3/7/2011 14:13'!suspendStatusViaCursorWhile: aBlock	| priorSetting |	priorSetting := self showStatusViaCursor.	self showStatusViaCursor: false.	aBlock ensure: [ self showStatusViaCursor: priorSetting ]! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:52'!waitCursor	^ ShowStatusViaCursor 		ifTrue: [ Cursor wait ]		ifFalse: [ self ]! !!MagmaPreferences class methodsFor: 'mouse cursor' stamp: 'cmm 6/17/2009 09:53'!writeCursor	^ ShowStatusViaCursor 		ifTrue: [ Cursor write ]		ifFalse: [ self ]! !!MagmaPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 20:56'!weakIdentityKeyDictionaryClass	^ MaObjectSerializerPreferences weakIdentityKeyDictionaryClass! !!MagmaPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 20:56'!weakIdentityKeyDictionaryClass: aClass 	MaObjectSerializerPreferences weakIdentityKeyDictionaryClass: aClass! !!MagmaPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 20:56'!weakValueDictionaryClass	^ MaObjectSerializerPreferences weakValueDictionaryClass! !!MagmaPreferences class methodsFor: 'special collections' stamp: 'cmm 5/13/2010 13:50'!weakValueDictionaryClass: aClass	MaObjectSerializerPreferences weakValueDictionaryClass: aClass! !MaAttributableObject subclass: #MagmaRepositoryDefinition	instanceVariableNames: 'magmaId classDefinitions symbols maximumNumberOfChallengers codeBase links locked'	classVariableNames: 'RunningTestCases'	poolDictionaries: ''	category: 'Magma-Client-API'!!MagmaRepositoryDefinition methodsFor: 'initialize' stamp: 'cmm 10/9/2009 16:21'!addMinimumClassesForOdbmsUsing: aMaObjectSerializer 	"When a MagmaRepository is initially created, it has no notion of MagmaLocations.  Only when it is initially deployed as a server will an instance of MagmaRemoteLocation be added to the MagmaNode, thereby causing those classes to be in the class-definitions.	But, if a new repository is created, then attempt to set the node, the required order of the special-oid processing, that the #refreshNode must occur before #refreshClassDefinitions, resulting in a 'class-definition not found' error will occur.	Therefore, the following ensures the necessary classes are part of the class-definitions, making this a non-issue."	aMaObjectSerializer classIdManager in: 		[ : classIdManager | 		{  MaServerLocation  } , MagmaLocation withAllSubclasses asArray do: 			[ : each | 			(classIdManager includesIdForClass: each) ifFalse: [ classIdManager addNewClass: each ] ].		self classDefinitions: classIdManager classDefinitionsById ]! !!MagmaRepositoryDefinition methodsFor: 'initialize' stamp: 'cmm 5/29/2002 22:43'!classDefinitions: aDictionary	classDefinitions := aDictionary! !!MagmaRepositoryDefinition methodsFor: 'initialize' stamp: 'cmm 6/4/2004 13:16'!classDefinitionsForId: anInteger	^ classDefinitions at: anInteger! !!MagmaRepositoryDefinition methodsFor: 'initialize' stamp: 'cmm 10/20/2014 13:00'!initialize	super initialize.	self classDefinitions: Dictionary new.	codeBase := MagmaRepositoryCodeBase new.	self initializeMagmaId.	maximumNumberOfChallengers := 1000.	links := Set new.	symbols := Set new.	locked := false! !!MagmaRepositoryDefinition methodsFor: 'initialize' stamp: 'cmm 11/13/2008 21:27'!initializeMagmaId	magmaId := MagmaId new! !!MagmaRepositoryDefinition methodsFor: 'classes' stamp: 'cmm 8/21/2002 21:58'!classDefinitions	"Key = classId, value = anOrderedCollection of MaOdbmsClassDefinition's."	^classDefinitions! !!MagmaRepositoryDefinition methodsFor: 'classes' stamp: 'cmm 5/1/2014 10:09'!classes	^ self classDefinitions collect: [ : each | each anyOne classObject ]! !!MagmaRepositoryDefinition methodsFor: 'code base' stamp: 'cmm 10/26/2004 23:41'!codeBase	^ codeBase! !!MagmaRepositoryDefinition methodsFor: 'links' stamp: 'cmm 8/11/2012 14:55'!ensureCanonicalizedMagmaId: aMagmaId 	"If aMagmaId is already present in one of my other links, use it instead."	^ aMagmaId = self magmaId 		ifTrue: [ self magmaId ]		ifFalse: 			[ self links 				detect: [ : each | each = aMagmaId ]				ifNone: [ self links add: aMagmaId ] ]! !!MagmaRepositoryDefinition methodsFor: 'links' stamp: 'cmm 11/18/2009 13:13'!hasCanonicalizedMagmaId: aMagmaId 	"If aMagmaId is already present in one of my other links, use it instead."	^ aMagmaId = self magmaId or: [ self links anySatisfy: [ : each | each = aMagmaId ] ]! !!MagmaRepositoryDefinition methodsFor: 'links' stamp: 'cmm 10/28/2010 18:35'!links	^ links! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 5/25/2014 13:42'!lock	locked := true! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 5/25/2014 13:41'!locked	^ locked ifNil: [ false ]! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 12/21/2008 23:42'!magmaId	"The #magmaId is an object which has identifying information about the repository."	^ magmaId! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 11/3/2008 10:38'!node	^ magmaId node! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 10/20/2014 13:01'!symbols	"All Symbols referenced in this repository.  It's helpful to canonicalize them here, so that clients will always know about them rather than creating new instances of Symbols in the DB just because they hadn't yet encountered a particular Symbol."	^ symbols ifNil: [ symbols := Set new ]! !!MagmaRepositoryDefinition methodsFor: 'settings' stamp: 'cmm 5/29/2002 22:43'!maximumNumberOfChallengers	"Answer the maximum number of commit entry's Magma should allow in each users session before that session will be terminated.  Commit entry's are records stored in the servers memory that record the objects changed by each user.  When a session is in a transaction, these entries 'pile up', consuming server memory.  Only when the client crosses a transaction boundary (i.e., begin, commit or abort) is the log for that session cleared."	^maximumNumberOfChallengers! !!MagmaRepositoryDefinition methodsFor: 'settings' stamp: 'cmm 5/29/2002 22:43'!maximumNumberOfChallengers: anInteger	maximumNumberOfChallengers := anInteger! !!MagmaRepositoryDefinition methodsFor: 'ui' stamp: 'cmm 6/17/2011 15:43'!uiFamily	^ self attributeNamed: #uiFamily! !!MagmaRepositoryDefinition methodsFor: 'ui' stamp: 'cmm 6/17/2011 15:46'!uiFamily: aMauiFamily 	"Argument says its a MauiFamily, but it could be any type of UI-family that responds to #merge: (which merges the panels of one family into the other)."	self		attributeNamed: #uiFamily		put: aMauiFamily! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaRepositoryDefinition class	instanceVariableNames: ''!!MagmaRepositoryDefinition class methodsFor: 'as yet unclassified' stamp: 'cmm 7/8/2009 18:35'!defaultMaximumNumberOfChallengers	"defaultMaximumNumberOfChallengers is used to manage server resources.  Since all commit records against a session build-up in memory until the session crosses a transaction boundary (browse references to MaTransactionLog>>'challengingEntries').  For now, we use this simple default."	^ 1000! !!MagmaRepositoryDefinition class methodsFor: 'as yet unclassified' stamp: 'cmm 11/7/2008 15:17'!runningTestCases	^ RunningTestCases ifNil: [ RunningTestCases := false ]! !!MagmaRepositoryDefinition class methodsFor: 'as yet unclassified' stamp: 'cmm 11/7/2008 15:17'!runningTestCases: aBoolean	RunningTestCases := aBoolean! !MaServerStat subclass: #MagmaServerStatistics	instanceVariableNames: 'flushTimeHistory'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MagmaServerStatistics commentStamp: 'cmm 5/5/2008 22:57' prior: 0!A MagmaServerStatistics knows considerable information about the performance of a listening MagmaServerConsole.See method comments for details about each staistic.!!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/17/2014 17:48'!countProcessingTimesChart	^ StackedPlotMorph new		 addPlot: (self newIngressPlotOn: #count) ;		 addPlot: (self newProcessingPlotOn: #count) ;		 addPlot: (self newEgressPlotOn: #count)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/18/2014 13:58'!countSizesChart	^ StackedPlotMorph new		 addPlot: (self newQueueSizesPlotOn: #count) ;		 addPlot: (self newRequestResponseSizesPlotOn: #count) ;		"connections plot must use total."		 addPlot: (self newConnectionsPlotOn: #total)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/21/2014 15:21'!maxSizesChart	^ StackedPlotMorph new		 addPlot: (self newQueueSizesPlotOn: #max) ;		 addPlot: (self newRequestResponseSizesPlotOn: #max) ;		 addPlot: (self newConnectionsPlotOn: #max)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/17/2014 17:41'!meanProcessingTimesChart	^ StackedPlotMorph new		 addPlot: (self newIngressPlotOn: #mean) ;		 addPlot: (self newProcessingPlotOn: #mean) ;		 addPlot: (self newEgressPlotOn: #mean)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/17/2014 18:07'!meanSizesChart	^ StackedPlotMorph new		 addPlot: (self newQueueSizesPlotOn: #mean) ;		 addPlot: (self newRequestResponseSizesPlotOn: #mean) ;		 addPlot: (self newConnectionsPlotOn: #mean)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/17/2014 17:45'!totalProcessingTimesChart	^ StackedPlotMorph new		 addPlot: (self newIngressPlotOn: #total) ;		 addPlot: (self newProcessingPlotOn: #total) ;		 addPlot: (self newEgressPlotOn: #total)! !!MagmaServerStatistics methodsFor: 'chart' stamp: 'cmm 8/17/2014 18:06'!totalSizesChart	^ StackedPlotMorph new		 addPlot: (self newQueueSizesPlotOn: #total) ;		 addPlot: (self newRequestResponseSizesPlotOn: #total) ;		 addPlot: (self newConnectionsPlotOn: #total)! !!MagmaServerStatistics methodsFor: 'historys' stamp: 'cmm 5/7/2008 17:37'!flushTimeHistory	"Several seconds after a commit the Magma server flushes it (and all other commits in that time) to disk in a secure, atomic way.  This history captures how much time is spent doing that."	^ flushTimeHistory! !!MagmaServerStatistics methodsFor: 'private' stamp: 'cmm 5/7/2008 17:31'!historysDo: aBlock 	super historysDo: aBlock.	aBlock value: flushTimeHistory! !!MagmaServerStatistics methodsFor: 'initialize-release' stamp: 'cmm 5/7/2008 17:37'!initialize	super initialize.	flushTimeHistory := MaStatHistory name: 'Flush-to-Disk Times'! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 18:05'!newConnectionsPlotOn: operatorSymbol	^ self newDateAndTimeBySizesPlot		 title: 'Connections / Disconnections' ;		 addSeries: ((numberOfClientConnectionsHistory seriesOn: operatorSymbol) color: Color green) ;		 addSeries: ((clientTimeoutsHistory seriesOn: operatorSymbol) color: Color red) ;		 yourself! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 17:53'!newEgressPlotOn: operatorSymbol	^ (operatorSymbol = #count		ifTrue: [ self newDateAndTimeBySizesPlot ]		ifFalse: [ self newDateAndTimeBySecondsPlot ])		title: 'Egress Times (', operatorSymbol asString, ')' ;		 addSeries: ((timeToSerializeHistory seriesOn: operatorSymbol) color: Color cyan twiceDarker) ;		 addSeries: ((timeToSendResponsesHistory seriesOn: operatorSymbol) color: (Color cyan muchLighter)) ;		 addSeries: ((timeToLoadBuffersHistory seriesOn: operatorSymbol) color: Color red muchDarker) ;		 yourself! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 17:49'!newIngressPlotOn: operator 	^ (operator = #count		ifTrue: [ self newDateAndTimeBySizesPlot ]		ifFalse: [ self newDateAndTimeBySecondsPlot ])		 title: 'Ingress Times (' , operator asString , ')' ;		 addSeries: ((timeWaitingInSocketQueueHistory seriesOn: operator) color: Color magenta twiceDarker) ;		 addSeries: ((extractTimeHistory seriesOn: operator) color: Color green twiceDarker) ;		 addSeries: ((timeWaitingInRequestQueueHistory seriesOn: operator) color: Color blue) ;		 addSeries: ((timeToMaterializeHistory seriesOn: operator) color: Color cyan) ;		 yourself! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 17:53'!newProcessingPlotOn: operatorSymbol	^ (operatorSymbol = #count		ifTrue: [ self newDateAndTimeBySizesPlot ]		ifFalse: [ self newDateAndTimeBySecondsPlot ])		title: 'Processing Times (', operatorSymbol asString, ')' ;		 addSeries: ((requestProcessingTimeHistory seriesOn: operatorSymbol) color: Color yellow twiceDarker) ;		 addSeries: ((idleTimeHistory seriesOn: operatorSymbol) color: Color green twiceDarker) ;		 addSeries: ((flushTimeHistory seriesOn: operatorSymbol) color: Color red twiceDarker) ;		 addSeries: ((houseCleaningTimeHistory seriesOn: operatorSymbol) color: Color red muchDarker) ;		 yourself! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 18:05'!newQueueSizesPlotOn: operatorSymbol	^ self newDateAndTimeBySizesPlot		 title: 'Queue Sizes' ;		 addSeries: ((socketsQueuedHistory seriesOn: operatorSymbol) color: Color blue) ;		 addSeries: ((requestsQueuedHistory seriesOn: operatorSymbol) color: Color blue muchLighter) ;		 yourself! !!MagmaServerStatistics methodsFor: 'chart-private' stamp: 'cmm 8/17/2014 18:09'!newRequestResponseSizesPlotOn: operatorSymbol	^ self newDateAndTimeBySizesPlot		 title: operatorSymbol, ' Bytes Received / Sent' ;		 addSeries: ((requestSizeHistory seriesOn: operatorSymbol) color: Color green) ;		 addSeries: ((responseSizeHistory seriesOn: operatorSymbol) color: Color red) ;		 yourself! !MaObject subclass: #MagmaSession	instanceVariableNames: 'id user serializer transaction readStrategy definition preferences anchor transactionLevel strongReferences cache guard statistics primaryLink secondaryLink allowFailover oidCount lastClean requiredProgress proxies immutabilityStrategy'	classVariableNames: 'CommitLogSerializer ConnectedSessions'	poolDictionaries: 'MaCoreConstants'	category: 'Magma-Client-API'!!MagmaSession commentStamp: 'cmm 2/25/2005 16:01' prior: 0!This is a clients primary interface to a Magma repository.!!MagmaSession methodsFor: 'transaction' stamp: 'cmm 1/16/2012 20:27'!abort	"Abort the current transaction.  Objects are updated to their persistent state in the repository."	"This guard is needed for when we initially connect to the repository because we can't abort before the connection is made."	guard critical:		[ self			 dropStrongReferences ;			 resetTransactionLevel.		transaction restore.		self isConnected ifTrue:			[ | request additional |			additional := Array streamContents:				[ : stream | transaction commitPackage objectsDo:					[ : each | | oid |					oid := serializer						oidFor: each						ifAbsent: [  ].					oid ifNotNil: [ stream nextPut: oid ] ] ].			request := MaAbortTransactionRequest new additionalBuffers: additional.			"Calls #abortTransactionFor:."			self				refreshViewUsing: (self submit: request)				includingLocal: true ] ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 3/18/2015 21:23'!begin	"Begin a new transaction.  To commit changes to the repository, a transaction is required.  After performing this message, changes may be made to objects, followed by a a #commit (or #commitAndBegin), which will cause any changes made to be saved to the repository and visible to others."	| refreshViewResult |	guard critical:		[ self incrementTransactionLevel.		self inNestedTransaction ifTrue: [ ^ self ].		self ensureConnected.		"Calls #newTransactionFor:."		refreshViewResult := [ self submit: MaTransactionRequest new ]			on: MagmaAlreadyInTransaction			do: [ : err | "This happens when the session got disconnected while in a transaction.  #ensureConnected, above, called #restoreTransaction which restored this sessions CommitLogEntry in the server." ]			on: Error			do:				[ : err | self decrementTransactionLevel.				err pass ].		refreshViewResult ifNotNil:			[ self				refreshViewUsing: refreshViewResult				includingLocal: false ] ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 4/30/2013 14:39'!changedObjects	"For debugging purposes:  Objects which have been changed, excluding MagmaCollection changes."	^ transaction changedObjects objects! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 12/22/2008 00:25'!commit	"Commit changes to persistent objects made since the last #begin or #commitAndBegin."	self commitAndBegin: false! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 6/17/2012 18:34'!commit: aBlock 	| result |	guard critical: 		[ self begin.		result := aBlock valueWhileObservingStateChange.		self commit ].	^ result! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 12/22/2008 00:26'!commitAndBegin	"Commit the current changes and, immediately begin a new transaction."	self commitAndBegin: true! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 10/20/2014 12:41'!commitAndBegin: aBoolean 	"Calls submitAll:for:beginAnother:"	| commitPackage commitResult |	guard critical:		[ self inNestedTransaction ifTrue:			[ "nested transaction commit, essentially does nothing"			aBoolean ifFalse: [ self decrementTransactionLevel ].			^ self ].		self inTransaction ifFalse: [ MagmaUserError signal: 'No transaction to commit.' ].		self statistics clientSideCommitTimeHistory addValue: (Time millisecondsToRun: [ commitPackage := self newCommitPackageFor: transaction ]).		serializer validateNextOid.		[ [ self			 ensureConnected ;			 dropStrongReferences.		commitResult := self submit:			(MaCommitRequest new				 package: commitPackage ;				 beginAnother: aBoolean ;				 yourself) ] ifCurtailed: [ self refreshDefinition ].		self resetTransactionLevel.		aBoolean ifTrue: [ self incrementTransactionLevel ].		self resetMagmaCollectionChanges ]			on: MagmaCommitError			do:				[ : exception | self					 bulkBecomeProxies ;					 refreshDefinition ;					 resetTransactionLevel.				aBoolean ifTrue: [ self incrementTransactionLevel ].				exception result populateConflictingObjectsFromOidsUsing: serializer.				self					refreshViewUsing: exception result					includingLocal: false.				exception handleOrPassUsing: self ].		(commitPackage hasNewIndexes or: [ commitPackage hasRemovedIndexes ])			ifTrue:				[ commitPackage hasRemovedIndexes ifTrue: [ "Give server time to flush so old index files will be deleted."					(Delay forSeconds: 5) wait ].				commitResult ifNotNil:					[ self						processNewAndRemovedIndexesIn: commitPackage						using: commitResult ] ]			ifFalse:				[ commitResult ifNotNil:					[ self						refreshViewUsing: commitResult						includingLocal: true ] ] ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 4/30/2014 20:47'!dirtyGraphDo: threeArgBlock	"Value threeArgBlock with every object that would be included in the next commit."	self changedObjects		maGraphDo: threeArgBlock		using: serializer traversalStrategy! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 12/26/2004 00:16'!inNestedTransaction	^ transactionLevel > 1! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 12/26/2004 00:20'!inTransaction	^ transactionLevel > 0! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 2/26/2009 10:52'!noteOldKeysFor: anObject 	"If anObject is in an indexed MagmaCollection and your program *is about to* change its keys, you must call this method or it will continue to be indexed under its old keys.  Emphasize, that you call this method *before* you change the keys, not after."	guard critical: [ transaction ensureOldHashesCapturedFor: anObject ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 2/3/2014 20:49'!refresh	"Update the state of all persistent objects known to by this session with changes by other sessions, without changing the status of the transaction."	"Calls #renewTransactionEntryFor:."	[ self safeRefresh ]		on: MagmaTooFarBehindConflict		do: [ : err | err retry ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 2/3/2014 20:47'!safeRefresh	"Update the state of all persistent objects known to by this session with changes by other sessions, without changing the status of the transaction."	"Calls #renewTransactionEntryFor:."	guard critical: 		[ self 			refreshViewUsing: (self submit: MaRefreshRequest new)			includingLocal: false ]! !!MagmaSession methodsFor: 'transaction' stamp: 'cmm 1/8/2009 11:21'!transactionLevel	^ transactionLevel! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/12/2013 20:19'!addProxy: aMagmaMutatingProxy 	"Add aMagmaMutatingProxy to a list that will be bulk-becomed at an appropriate time."	^ guard critical: [ proxies at: aMagmaMutatingProxy put: aMagmaMutatingProxy ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/30/2011 20:37'!addSystemImmutablesTo: aMaImmutabilityStrategy 	aMaImmutabilityStrategy				treatAny: MaClassDefinition		asImmutableIf: [ : aMaClassDefinition | true ] ;				treatObjectReferencedBy: 'instVarNames'		onAny: MaClassDefinition		asImmutableIf: [ : aMaClassDefinition | true ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/20/2014 21:41'!advanceUsing: aMaObjectSerializer 	"Advance the state of the cached model forward by a reasonably-sized chunk of commits.  The 'chunk of commits' is obtained directly from the commit-logs on the server.  If the commit-log files are no longer available on the server, signal a MagmaUnavailableCommitRecord."	| commitLogRecords result |	result := MaFailedCommitResult new.	commitLogRecords := self commitLogRecordsFrom: self commitNumber + 1.	commitLogRecords do:		[ : each | | commitLogEntry |		commitLogEntry := aMaObjectSerializer resetOidManager materializeGraph: each record.		self			advanceWith: commitLogEntry			accumulatingConflictsIn: result ].	self bulkBecomeProxies.	self inTransaction ifTrue: [ self checkIfTooFarBehind: result ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/17/2014 14:59'!advanceWith: aMaCommitLogEntry 	| result |	result := MaFailedCommitResult new.	self		advanceWith: aMaCommitLogEntry		accumulatingConflictsIn: result.	^ result! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/17/2014 16:24'!advanceWith: aMaCommitLogEntry accumulatingConflictsIn: aMaFailedCommitResult 	guard critical:		[ | buffers conflict |		buffers := OrderedCollection new.		conflict := MagmaCommitConflict connection: aMaCommitLogEntry connection.		aMaCommitLogEntry commitPackage objectsDo:			[ : eachBuffer | buffers add: eachBuffer copyWithSameBuffer.			self				check: eachBuffer				using: aMaCommitLogEntry connection				accumulatingConflictsInto: aMaFailedCommitResult ].		aMaFailedCommitResult populateConflictingObjectsFromOidsUsing: serializer.		self						refreshChangedObjects: buffers			includingLocal: false ;			 commitNumber: aMaCommitLogEntry result commitNumber ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/26/2009 11:01'!anchor	"Calls readAnchorFor:using: in server."	^ guard critical: 		[ anchor ifNil: 			[ | anch |			anch := self materializeAnchorFrom: (self secondarySubmit: (MaAnchorRequest new						readStrategy: self resetReadStrategy ;						yourself)).			"avoid the root getting garbage collected before we can capture the changes because the user wrote mySession commit: [ mySession root at: 'hello' put: 'world' ]."			anchor := self inTransaction ifTrue: 				[ "otherwise, nil it out"				anch ].			anch ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/16/2005 12:38'!assignPermanentOidsFrom: permanentOidsDictionary	permanentOidsDictionary ifNil: [ ^ self ].	permanentOidsDictionary keysAndValuesDo:		[ : eachTempOid : eachPermanentOid |		serializer			objectWithOid: eachTempOid			ifFound: 				[ : persistentObject | 				serializer					oidOf: persistentObject					is: eachPermanentOid.				persistentObject maIsLargeCollection ifTrue: [ persistentObject setOid: eachPermanentOid ] ]			ifAbsent: [ nil ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/20/2015 15:45'!bulkBecomeProxies	| allKnownProxies reified realObjects |	guard critical:		[ reified := OrderedCollection new.		allKnownProxies := proxies.		self resetProxies.		allKnownProxies do:			[ : each | each maIsMutatingProxy ifTrue:				[ each maRealObjectIsReified					ifTrue: [ reified add: each ]					ifFalse: [ self addProxy: each ] ] ].		realObjects := reified collect:			[ : each | each realObjectIfMutatingProxy ].		reified asArray			elementsForwardIdentityTo: realObjects asArray			copyHash: false.		immutabilityStrategy ifNotNil:			[ realObjects do:				[ : each | immutabilityStrategy					rememberImmutableReferencesFrom: each					for: transaction ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/25/2011 16:38'!canStubOut: anObject 	anObject maIsMutatingProxy ifTrue: [ ^ anObject maRealObjectIsReified ].	(self isPersistent: anObject) ifFalse: [ ^ false ].	anObject maOriginalClass = MaClassDefinition ifTrue: [ ^ false ].	anObject == serializer classDefinitionsById ifTrue: [ ^ false ].	^ serializer classDefinitionsById noneSatisfy:		[ : eachCollection | eachCollection == anObject ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/20/2014 20:20'!check: remoteObjectBuffer using: aMagmaClientConnection accumulatingConflictsInto: aMaFailedCommitResult 	| magmaStatClassIds |	magmaStatClassIds := self magmaStatClassIds.	(serializer		objectWithOid: remoteObjectBuffer oid		ifAbsent: [  ]) ifNotNil:		[ : proxy | proxy realObjectIfReified ifNotNil:			[ : obj | ((transaction didChange: obj) and:				[ (transaction					didChange: obj					from: remoteObjectBuffer) and: [ (magmaStatClassIds includes: remoteObjectBuffer classId) not ] ]) ifTrue:				[ aMaFailedCommitResult					recordObjectConflictWith: aMagmaClientConnection					on: remoteObjectBuffer oid ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/17/2014 16:26'!checkIfTooFarBehind: aMaFailedCommitResult 	aMaFailedCommitResult hasConflicts ifTrue:		[ (MagmaTooFarBehindConflict result: aMaFailedCommitResult) signal ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/14/2014 10:52'!clean	self statistics houseCleaningTimeHistory addValue:		(Time millisecondsToRun:			[ self				 bulkBecomeProxies ;				 finalizeOids ;				 resetLastClean ])! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/14/2014 10:52'!cleanIfTime	self isTimeToClean ifTrue: [ self clean ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 6/23/2013 15:07'!cleanUpWriteBarrier	self abort.	transaction		 writeBarrierStatusChangedFor: self ;		 cleanUpWriteBarrier! !!MagmaSession methodsFor: 'private' stamp: 'cmm 8/12/2010 23:34'!commitLogRecordAt: commitNumber 	"Calls commitRecordsFrom:"	| answerArray |	answerArray := self secondarySubmit:		(MaCommitLogRecordRequest new			 startingCommitNumber: commitNumber ;			 endingCommitNumber: commitNumber yourself).	^ answerArray		ifEmpty: [ MagmaUnavailableCommitRecord signal ]		ifNotEmpty: [ answerArray first ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/6/2008 16:30'!commitLogRecordsFrom: startingCommitNumber 	"Calls commitRecordsFrom:"	^ self secondarySubmit: 		(MaCommitLogRecordRequest new			startingCommitNumber: startingCommitNumber ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/15/2008 14:57'!commitNumber: anInteger 	transaction commitNumber: anInteger! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/14/2013 14:02'!critical: aBlock	^ guard critical: aBlock! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:44'!decrementTransactionLevel	transactionLevel := transactionLevel - 1! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/7/2011 11:08'!dropStrongReferences	anchor := nil.	strongReferences removeAll! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/8/2014 20:39'!ensureClassDefinitionsFullyMaterialized	serializer classDefinitionsById do: [ : eachColl | eachColl do: [ : eachDef | eachDef yourself ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/14/2009 12:41'!ensureCorrectNodeConfiguration	self ensureIsAdminSession.	"Calls #ensureCorrectNodeConfiguration."	self submit: MagmaEnsureCorrectNodeConfiguration new! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/17/2008 16:19'!ensureInRestoreMode	self serverPerform: #ensureInRestoreMode! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/26/2011 16:28'!ensureNodeFullyMaterialized	self node locations do:		[ : each | each yourself ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/23/2011 13:59'!ensureProxy: aMagmaMutatingProxy	(proxies includes: aMagmaMutatingProxy) ifFalse: [ proxies add: aMagmaMutatingProxy ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/1/2013 19:58'!ensureSecondaryLinkConfigured	"Private - If allowFailover is set, and a secondary server is available, initialize my secondaryLink accordingly."	(self node isNil or: [ (self node includesSecondary: (MagmaRemoteLocation location: secondaryLink location)) not ]) ifTrue:		[ self secondaryLocation:			(allowFailover				ifTrue:					[ self node isBackedUp						ifTrue: [ self node anySecondaryLocation ]						ifFalse: [ self node primaryLocation ] ]				ifFalse: [ MagmaRemoteLocation location: primaryLink location ]) ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/26/2013 13:01'!finalizeOids	guard critical:		[ serializer finalizeOids.		transaction finalizeOids.		immutabilityStrategy ifNotNil: [ immutabilityStrategy finalizeImmutables ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/26/2013 12:47'!forceClean	guard critical:		[ lastClean := 0.		self cleanIfTime ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/26/2009 00:23'!handleClassModification: aModifiedClassDefinitionEvent 	guard critical: 		[ aModifiedClassDefinitionEvent isModified ifFalse: [ ^ self ].		aModifiedClassDefinitionEvent item isMeta ifTrue: [ ^ self ].		serializer handleClassModification: aModifiedClassDefinitionEvent.		self prepareReadStrategy ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 8/22/2014 16:08'!handleFailedLink: failedMaNetworkServerLink 	"Handle the situation where aMaNetworkServerLink received a ConnectionRefused when trying to access it.  If it is a link to the primary, we set my primaryLink to the second server, if aMaNetworkServerLink is a link to a warm backup, set it to any other secondary or, if none available, the primary.  Answer the new link to try next."	| answer primaryFailed |	allowFailover ifFalse: [ ^ failedMaNetworkServerLink ].	self node ifNil: [ ^ failedMaNetworkServerLink ].	self isHighlyAvailable ifFalse: [ ^ failedMaNetworkServerLink ].	primaryFailed := false.	answer := failedMaNetworkServerLink == primaryLink 		ifTrue: 			[ primaryFailed := true.			"In case the node's 'locations' is a proxy, trying to access it would result in a stack-overflow.  So set it to secondaryLink first, in case the following line tries to cause a ReadRequest sent to the "			primaryLink := secondaryLink.			"primaryLink should be a link to the second location, so we don't have different clients with different notions about who should be the next primary.  If that is what secondaryLink already is, we don't need to re-init it."			primaryLink := self node nextPrimaryLocation 				ifNil: [ secondaryLink ]				ifNotNilDo: 					[ : nextLoc | 					secondaryLink location = nextLoc serverLocation 						ifTrue: [ secondaryLink ]						ifFalse: 							[ self node nextPrimaryLocation newServerLink								preferences: primaryLink preferences copy ;								yourself ] ] ]		ifFalse: 			[ "Secondary failed, look for a different secondary or, if none, use the primary."			| otherAvailableSecondarys |"A like-guard as in the primary-failure case, above.""secondaryLink:=primaryLink"			otherAvailableSecondarys := self node locations allButFirst.			secondaryLink := otherAvailableSecondarys 				maDetect: [ : each | (each serverLocation = secondaryLink location) not ]				ifFound: 					[ : foundLocation | 					foundLocation newServerLink						preferences: secondaryLink preferences copy ;						yourself ]				ifNone: [ primaryLink ] ].	"Tell whoever is primary now to update the Node."	primaryFailed ifTrue: 		[ "Inform the primary of the failed location so the node can be updated prior to attempting reconnection."		primaryLink submit: (MagmaNoteUnreachableServer new failedLocation: (self node locationMatching: failedMaNetworkServerLink location)) ].	^ answer! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/10/2014 13:44'!handleSpecialOidNotifications: aDictionary 	"aDictionary is keyed by selector Symbols, with Array's of ByteArray's as values.  The selectors indicate what should be done with those ByteArray's once materialized."	guard critical:		[ | didRefresh |		didRefresh := false.		"Refresh the node first, in case subsequent instructions require access to the server."		(aDictionary includesKey: #refreshNode) ifTrue:			[ self				 refreshSpecialObjectsUsing: (aDictionary at: #refreshNode) ;				 ensureNodeFullyMaterialized ].		((aDictionary includesKey: #refreshClassDefinitions) or: [ aDictionary includesKey: #refreshClassVersions ]) ifTrue:			[ didRefresh := true.			self				 refreshSpecialObjectsUsing: (aDictionary at: #refreshClassDefinitions) ;				 ensureClassDefinitionsFullyMaterialized ].		"Uncomment the next line when we decide to support lockable RepositoryDefinitions."		"		(aDictionary includesKey: #refreshDefinition) ifTrue: [ self refreshSpecialObjectsUsing: (aDictionary at: #refreshDefinition) ]."		didRefresh ifTrue: [ self prepareReadStrategy ] ]! !!MagmaSession methodsFor: 'private'!id	^id! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/16/2014 12:58'!id: aUUIDself maMarked: 'delete'.	id := aUUID! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:44'!incrementTransactionLevel	transactionLevel := transactionLevel + 1! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/4/2015 16:30'!initializePrimaryLocation	"Clients may send any request, including the initial connection request, to any respository in the node, primary or secondary.  Magma will adjust the receivers primaryLink and secondaryLink as necessary.  Whichever one the user connected to (primary or secondary), configure the other."	(allowFailover and: [ self isLocal not ]) ifTrue:		[ "did user connect to the primary?"		primaryLink location = self node primaryLocation serverLocation			ifTrue: [ self ensureSecondaryLinkConfigured ]			ifFalse:				[ "No, did they connect to one of the secondary locations?"				self node secondaryLocations ifNotEmpty:					[ : secondaryLocs | (secondaryLocs anySatisfy:						[ : each | each serverLocation = secondaryLink location ]) ifTrue: [ "Yes, we have some valid link, set my primaryLink to what its supposed to be."						self primaryLocation: self node primaryLocation ] ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/12/2009 13:19'!isMonitoringLargeCollection: aMagmaLargeCollection	^ transaction isMonitoring: aMagmaLargeCollection changes! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/12/2010 17:40'!isServerSession	^ (Smalltalk hasClassNamed: #MagmaRepositoryController) and: 		[ self userId = (Smalltalk classNamed: #MagmaRepositoryController) systemSessionUserId ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/24/2018 17:44'!isTimeToClean	^ guard critical:		[ (Time millisecondsSince: lastClean) > 60000 and:			[ proxies size > 1000 or: [ (Time millisecondsSince: lastClean) > (1000 * 60 * 5) ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/13/2014 15:03'!link: aMaServerLink 	primaryLink := secondaryLink := aMaServerLink.	primaryLink stat: self statistics.	secondaryLink stat: self statistics! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/18/2008 14:29'!linksDo: aBlock 	aBlock value: primaryLink.	secondaryLink ~~ primaryLink ifTrue: [ aBlock value: secondaryLink ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/5/2012 10:12'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self isLocal		ifTrue:			[ self location ifNotNilDo:				[ : loc | loc maPrintAbbreviatedOn: aStream ] ]		ifFalse:			[ primaryLink maPrintAbbreviatedOn: aStream.			self isHighlyAvailable ifTrue:				[ aStream space.				secondaryLink maPrintAbbreviatedOn: aStream ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/27/2013 17:43'!magmaSession	"For API compatibility with any object.  Any object knows its MagmaSession, but the session for any MagmaSession object is himself.  This method was added to allow MaInstaller to #close: down the session for any object, not just a session."	^ self! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/20/2014 20:18'!magmaStatClassIds	| ids |	ids := Set new.	self definition classDefinitions keysAndValuesDo:		[ : eachId : each | | candidate |		candidate := eachId.		each anyOne withAllSuperclassDefinitionsDo:			[ : eachDef | eachDef className = #MagmaStat ifTrue:				[ ids					 add: candidate ;					 add: eachDef id ] ] ].	^ ids! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/28/2005 00:17'!materializeAnchorFrom: aMaReadResult	^ self materializeObject: aMaReadResult byteArray! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/16/2013 10:27'!materializeObject: aByteArray 	"aByteArray is a MaGraphBuffer retrieved from the server.  Construct its object graph, noting each node in my serializer, linking up with previously materialized nodes by oid as appropriate."	"When not using WriteBarrier, postMats won't cause objects to be dirty, so let's not allow them to be when using WriteBarrier."	^ transaction suspendWriteBarrierModifiedsWhile: 		[ 		[ serializer 			materializeGraph: aByteArray			do: 				[ : eachObject : eachBuffer | 				transaction 					markRead: eachObject realObjectIfMutatingProxy					using: eachBuffer ]		"Handle MagmaSessionRequest to handle domains that reference the session directly." ] 			on: MagmaSessionRequest			do: [ : req | req handleAndResumeUsing: self ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/7/2008 17:03'!materializeObjectsIn: aMaCollectionSegment 	self statistics clientSideMcPageReadsTimeHistory addValue: (Time millisecondsToRun: 			[ aMaCollectionSegment objects doWithIndex: 				[ : eachHashAndBuffer : index | 				eachHashAndBuffer isVariableBinding 					ifTrue: 						[ aMaCollectionSegment objects 							at: index							put: eachHashAndBuffer key -> (self materializeObject: eachHashAndBuffer value) ]					ifFalse: 						[ "For member-index access, we only need the object buffers, there are no associated hashes, and I decided an ugly type-check was better than wasting bandwidth."						aMaCollectionSegment objects 							at: index							put: (self materializeObject: eachHashAndBuffer) ] ] ])! !!MagmaSession methodsFor: 'private' stamp: 'cmm 6/17/2011 16:03'!mcModelFavorDiskSpaceIfPossible	[ self mcModel favorDiskSpace.	MagmaNotification signal: 'Was able to favorDiskSpace.  This might be the first codeBackup and therefore might take a long time.' ]		on: MagmaUserError		do:			[ : err | "Ok, this permanent preference was already set."			err ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/20/2010 14:19'!newCommitPackageFor: aMaTransaction 	"It is possible to that we will serialize up to three times.  If we add a new LargeCollection that also adds instances of a new class, the first serialization will detect the new LargeCollection, the second notices the new classes, the third gets everything right.."	| commitPackage mustReserialize |	commitPackage := aMaTransaction changedObjects.	mustReserialize := commitPackage serializeObjectsUsing: self.	^ mustReserialize		ifTrue:			[ self				 prepareReadStrategy ;				 newCommitPackageFor: aMaTransaction ]		ifFalse: [ commitPackage ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/22/2008 13:47'!oidCount: anInteger 	oidCount := anInteger! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/8/2009 15:36'!prepareReadStrategy	readStrategy ifNotNil: [ readStrategy makeReadyForUseUsing: serializer classIdManager ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/22/2016 16:35'!primConnect	| repositoryCommitNumber resultArray startedClientSideConnectionProcessing connectionRequest connectedToPrimary |	((1 to: 100) collect:		[ : n | UUID new asString36 ]) asSet size = 100 ifFalse: [ self error: 'UUID broken - please delete UUIDPlugin and restart this image.' ].	self isConnected ifTrue: [ MagmaUserError signal: 'This session is already connected.' ].	"	Smalltalk initializeGarbageCollectorSettingsForMagma."	self statistics ensureActive.	self isLocal ifTrue: [ self ensureOpen ].	readStrategy ifNotNil: [ readStrategy beNew ].	"Calls #newSessionFor:sessionId:."	connectionRequest := MaRepositoryConnectionRequest new		 uuid: self uuid ;		 commitNumber: self commitNumber ;		 magmaVersion: self class magmaVersion ;		 userId: self userId ;		 sessionId: (id := UUID new) ;		 yourself.	resultArray := self submit: connectionRequest.	startedClientSideConnectionProcessing := Time millisecondClockValue.	self		 loadClassDefinitionsFrom: (resultArray at: 1) ;		 loadDefinitionFrom: (resultArray at: 2).	repositoryCommitNumber := resultArray at: 3.	connectedToPrimary := resultArray at: 4.	"We now have class-defs, make the readStrategy ready in case they've specified one before connection!!"	self prepareReadStrategy.	"Whichever one we already connected to, connect to the other one, so both servers can have a MagmaClientConnection for this session."	self initializePrimaryLocation.	self isHighlyAvailable ifTrue:		[ connectedToPrimary			ifTrue: [ self secondarySubmit: connectionRequest ]			ifFalse: [ self submit: connectionRequest ] ].	self commitNumber = 0		ifTrue: [ self commitNumber: repositoryCommitNumber ]		ifFalse: [ self statistics refreshAllTimeHistory addValue: (Time millisecondsToRun: [ self refreshTo: repositoryCommitNumber ]) ].	transaction registerForNotifications.	self initializeSystemChangeNotifications.	self statistics clientSideConnectionTimeHistory addValue: (Time millisecondsSince: startedClientSideConnectionProcessing).	self isServerSession ifFalse: [MagmaNotification signal: 'Connected to ' , self linkInformation , ' as ' , self userId , '...'].	"We've just connected.  If this session *was* in a transaction then begin one on the server."	self restoreTransaction! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/9/2012 14:56'!primaryLocation: aMagmaRemoteLocation 	"Set my primary (commit) location to the repository aMagmaRemoteLocation."	primaryLink location ~= aMagmaRemoteLocation serverLocation ifTrue:		[ | oldLink |		oldLink := primaryLink.		primaryLink disconnect.		primaryLink := aMagmaRemoteLocation newServerLink			 preferences: primaryLink preferences copy ;			 yourself.		(MagmaLinkChange			oldLink: oldLink			newLink: primaryLink) signal ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 9/22/2008 10:23'!processNewAndRemovedIndexesIn: aMagmaCommitPackage using: aMaCommitResult 	| backupPackage |	backupPackage := aMagmaCommitPackage copyWithNewLargeCollectionChanges.	transaction resetCommitPackage.	self 		refreshViewUsing: aMaCommitResult		includingLocal: false.	backupPackage newIndexesDo: 		[ : eachChanges | 		| objectOidsAlreadyIndexed |		objectOidsAlreadyIndexed := eachChanges added keys collect: 			[ : each | 			(MaOidCalculator isOidForNewObject: each) 				ifTrue: 					[ aMaCommitResult permanentOids 						at: each						ifAbsent: 							[ MagmaSoftwareError signal: 'error building index, expected to find permanent oid' ] ]				ifFalse: [ each ] ].		eachChanges isNewCollection ifFalse: 			[ eachChanges collection 				buildIndexes: (eachChanges addedIndexes collect: [ : each | eachChanges collection indexNamed: each attribute ])				ignoring: objectOidsAlreadyIndexed ] ].	backupPackage removedIndexesDo: [ : eachCollection : eachIndexes | eachCollection commitUnlock ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 9/27/2011 22:27'!read: oid 	"calls read:for:using: in server."	self cleanIfTime.	^ self secondarySubmit: 		(MaReadRequest new			oid: oid ;			readStrategy: self resetReadStrategy ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 4/22/2013 15:12'!realObjectFor: oid 	^ guard critical:		[ | result answer readTime |		readTime := Time millisecondsToRun:			[ result := self read: oid.			answer := self materializeObject: result byteArray ].		self statistics clientSideProxyMaterializationTimeHistory addValue: readTime.		readTime > 0 ifTrue:			[ "I don't like capturing this because it requires an enumeration of the buffers, which could be slowing things down.  Only uncomment if necessary."			"self statistics objectsReadPerSecond addValue: serializer graphBuffer objectCount * 1000 // readTime."			self statistics objectBytesReadPerSecond addValue: serializer graphBuffer bufferSize * 1000 // readTime ].		answer realObjectIfMutatingProxy ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/25/2010 13:27'!recordObjects: aCollection 	"aCollection of MaObjectBuffers."	aCollection do:		[ : each | serializer			objectWithOid: each oid			ifFound:				[ : object | object maIsMutatingProxy					ifTrue:						[ object maRealObjectIsReified ifTrue:							[ transaction								markRead: object realObjectIfMutatingProxy								using: each ] ]					ifFalse:						[ transaction							markRead: object							using: each ] ]			ifAbsent: [ "do nothing"				 ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/5/2016 10:10'!refresh: anObject 	"Update anObject with the contents of the repository.  Use sparingly and with caution!!"	| readResult graph |	((serializer hasOidFor: anObject) and: [( MaOidCalculator isOidForUserObject: (serializer oidFor: anObject)) not]) ifTrue: [  MagmaUserError signal: 'cannot refresh a non-persistent object.' ].	readResult := self read: (self oidFor: anObject).	graph := MaSerializedGraphBuffer byteArray: readResult byteArray.	self		refreshObject:			((MagmaRefreshEvent session: self)				 buffer: graph rootBuffer ;				 object: anObject ;				 yourself)		includingLocal: false! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/30/2014 17:32'!refreshAllWithOids: allKnownOids accumulatingConflictsIn: aMaFailedCommitResult 	"refreshAll:for: returns MaSerializedGraphBuffers but refreshChangedObjects: just wants the individual MaObjectBuffers.  Collect them up."	"Calls refreshAll:for:."	| objectBuffers myCommitNumber |	objectBuffers := (self secondarySubmit: (MaReadMultipleRequest new oids: allKnownOids)) collect:		[ : each | each buffers first ].	"Now select the ones which were changed by others."	myCommitNumber := self commitNumber.	objectBuffers := objectBuffers select:		[ : each | each commitNumber > myCommitNumber ].	objectBuffers sort:		[ : a : b | a commitNumber < b commitNumber ].	objectBuffers do:		[ : eachBuffer | self			check: eachBuffer			using: MagmaClientConnection unknown			accumulatingConflictsInto: aMaFailedCommitResult ].	aMaFailedCommitResult populateConflictingObjectsFromOidsUsing: serializer.	self		refreshChangedObjects: objectBuffers		includingLocal: false! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/13/2014 15:58'!refreshChangedObjects: changedObjects includingLocal: aBoolean	"changedObjects is a Collection of MaObjectBuffers that were written by other clients.  For each one that the receiver still knows its oid, set all of its instVars to the objects that map by its referenced oids.  If a referenced oid is not in the client, substitute with a proxy."	"Some Morphs cannot be refreshed while they're stepping in the world; therefore we provide this hack to ensure we only update them 'offline'; e.g., we delete, refresh, then add them back at the same position and index as they were.  The events restoreData is used to capture this temporary information."	| refreshEvents |	refreshEvents := OrderedCollection new.	transaction suspendWriteBarrierModifiedsWhile: 		[ changedObjects do: 			[ : eachObjectBuffer | 			| object |			object := serializer 				objectWithOid: eachObjectBuffer oid				ifAbsent: [ nil ].			(object == nil or: [ (object maIsMutatingProxy and: [ object maRealObjectIsReified not ]) or: [ object isImmutableInMagma ] ]) ifFalse: 				[ | event |				event := (MagmaRefreshEvent session: self)					buffer: eachObjectBuffer ;					object: object ;					yourself.				self refreshObject: event includingLocal: aBoolean.				object realObjectIfMutatingProxy wantsMagmaEvents ifTrue: [ refreshEvents add: event ] ] ] ].	refreshEvents do: 		[ : each | 		each object 			triggerEvent: #magmaRefreshed			with: each ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/25/2011 16:39'!refreshClassDefinitions	"This for a very specific scenario.  If the user attempts to commit a new or changed class and the commit fails for any reason, their classMaps (both persistent and non-persistent) need to be restored to their state without all the new classes because, if they then try to commit some of those same new classes again, it will not detect the new addition to the classDefinitions."	guard critical: 		[ transaction suspendWriteBarrierModifiedsWhile: 			[ self refresh: serializer classDefinitionsById.			serializer classDefinitionsById do: [ : eachDefinitions | self refresh: eachDefinitions ].			serializer classIdManager rebuildTransientClassMaps ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/13/2009 12:57'!refreshDefinition	"This for a very specific scenario.  If the user attempts to commit a new or changed class and the commit fails for any reason, their classMaps (both persistent and non-persistent) need to be restored to their state without all the new classes because, if they then try to commit some of those same new classes again, it will not detect the new addition to the classDefinitions."	guard critical: 		[ transaction suspendWriteBarrierModifiedsWhile: [ self refresh: definition ].		self refreshClassDefinitions ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/4/2014 15:33'!refreshMyKnownObjects	"Refresh all objects in the image retrieved by this session with their copies in the repository."	"When a session has been offline for sometime, many of the objects it has in its oid Dictionary's could be out of date, and doing an abort after reconnecting won't update them because refreshes are only performed from transient information in the server (the repository's 'transactionLog').	Therefore, enumerate all of my objects and refresh them."	| allKnownOids result |	result := MaFailedCommitResult new.	allKnownOids := OrderedCollection new: 1000.	serializer oidsAndObjectsDo:		[ : eachOid : eachObject | ((eachObject maIsMutatingProxy and: [ eachObject maRealObjectIsReified not ]) not and:			[ eachObject maIsForwardingProxy not and:				[ eachObject notNil and: [ eachObject isImmutableInMagma not ] ] ]) ifTrue:			[ allKnownOids add: eachOid.			allKnownOids size >= 1000 ifTrue:				[ self					refreshAllWithOids: allKnownOids					accumulatingConflictsIn: result.				allKnownOids removeAll ] ] ].	allKnownOids ifNotEmpty:		[ self			refreshAllWithOids: allKnownOids			accumulatingConflictsIn: result ].	self bulkBecomeProxies.	self inTransaction ifTrue: [ self checkIfTooFarBehind: result ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 9/17/2014 10:14'!refreshObject: aMagmaRefreshEvent includingLocal: aBoolean 	aMagmaRefreshEvent object wantsMagmaEvents ifTrue:		[ aMagmaRefreshEvent object			triggerEvent: #magmaAboutToRefresh			with: aMagmaRefreshEvent		"calls #aboutToRefreshFromMagma:" ].	aMagmaRefreshEvent buffer		refresh: aMagmaRefreshEvent object		using: self		includingLocal: aBoolean.	"We do this here instead of all the time in #markRead:using: because removeKey: is so slow."	transaction ensureOldHashesCleanedFor: aMagmaRefreshEvent object.	aMagmaRefreshEvent object realObjectIfMutatingProxy		postRefreshUsing: aMagmaRefreshEvent buffer		for: self! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/10/2014 16:58'!refreshSpecialObjectsUsing: anArrayOfByteArrays 	"each ByteArray is a graph buffer of either the entire classDefinitionsById, OR merely one of the OrderedCollections of the definitions for a particular id/class."	anArrayOfByteArrays do:		[ : each | | gb specialObject |		"Materialize the full-graph of each special-object."		specialObject := serializer materializeGraph: each.		gb := MaSerializedGraphBuffer byteArray: each.		self			refreshChangedObjects: gb buffers			includingLocal: false ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 8/22/2014 14:49'!refreshTo: repositoryCommitNumber 	"Refresh all objects in the image retrieved by this session with their copies in the repository."	"When a session has been offline for sometime, many of the objects it has in its oid Dictionary's could be out of date, and doing an abort after reconnecting won't update them because refreshes are only performed from transient information in the server (the repository's 'transactionLog').	Therefore, bring my view up to date."	guard critical:		[ self cachedObjectCount < 25000			ifTrue:				[ self refreshMyKnownObjects.				self commitNumber: repositoryCommitNumber ]			ifFalse:				[ (self remoteCommitNumber - self commitNumber < 100 or:					[ self preferences allowLongCatchUp = true or: [ MagmaTooFarBehindError signal ] ]) ifTrue:					[ [ self tryToRefreshTo: repositoryCommitNumber ]						on: MagmaUnavailableCommitRecord						do:							[ : err | self refreshMyKnownObjects ] ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/10/2014 16:50'!refreshViewUsing: aMaRefreshViewResult includingLocal: aBoolean 	"I have crossed a transaction boundary, either through abort, commit or begin."	guard critical:		[ self statistics refreshViewHistory addValue: (Time millisecondsToRun: [ aMaRefreshViewResult refresh: self includingLocal: aBoolean ]).		serializer resetNewObjects.		transaction resetNewLargeCollections.		aBoolean ifTrue:			[ transaction resetCommitPackage.			self resetMagmaCollectionChanges ].		self cleanIfTime ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/14/2009 14:55'!remotePrimitiveAttributes	"Calls #primitiveAttributes."	^ self submit: MaPrimitiveAttributesRequest new! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/22/2008 13:37'!remotePrimitiveAttributesDo: aBlock 	^ aBlock value: self remotePrimitiveAttributes! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/22/2008 15:46'!resetLastClean	lastClean := Time millisecondClockValue! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/6/2009 16:15'!resetReadStrategy	"We allow the user to define read strategies 'specifications' for classes that may not even exist in the repository.  So, classes that aren't known yet are remembered by the strategy."	^ guard critical: 		[ readStrategy 			ifNotNil: 				[ readStrategy isNew ifTrue: 					[ "do we have new depth specifications?"					"Must ensureConnected now instead of relying on a lazy connection because #resetReadStrategy copies my readStrategy.  We need the ReadStrategy *after* we have downloaded the class-definitions."					self ensureConnected.					[ readStrategy copyWithoutSpecifications ] ensure: [ readStrategy beOld ] ] ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:55'!resetTransactionLevel	transactionLevel := 0! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/18/2008 19:27'!restoreTransaction	self inTransaction ifTrue: 		[ | saveTransactionLevel |		saveTransactionLevel := transactionLevel.		"We must reset the transactionLevel so #begin will work."				[ 		[ self			resetTransactionLevel ;			begin ] 			on: MagmaAlreadyInTransaction			do: 				[ : err | 				"This could happen if the network couldn't deliver the response on a commit.  We're in the state we want, don't complain."				 ] ] ensure: [ transactionLevel := saveTransactionLevel ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 9/14/2011 18:14'!root: anObject 	anchor := self anchor.	anchor root ifNotNil: 		[ MagmaWarning signal: 'Are you sure you want to wipe out the entire database for ' , anObject printString , '?' ].	guard critical: [ anchor root: anObject ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/9/2012 14:57'!secondaryLocation: aMagmaRemoteLocation 	"Set my secondary (read) location to the repository aMagmaRemoteLocation."	secondaryLink location ~= aMagmaRemoteLocation serverLocation ifTrue:		[ | oldLink |		oldLink := secondaryLink.		secondaryLink == primaryLink ifFalse: [ secondaryLink disconnect ].		secondaryLink := primaryLink location = aMagmaRemoteLocation serverLocation			ifTrue: [ primaryLink ]			ifFalse:				[ aMagmaRemoteLocation newServerLink					 preferences: secondaryLink preferences copy ;					 yourself ].		(MagmaLinkChange			oldLink: oldLink			newLink: secondaryLink) signal ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 8/9/2014 19:11'!secondarySubmit: aMagmaRepositoryRequest 	"Submit aMagmaRepositoryRequest to the secondary server and answer the result."	^ [ aMagmaRepositoryRequest requiresConnection ifTrue: [ self ensureConnected ].	self		submit: aMagmaRepositoryRequest		to: secondaryLink ]		maOn: MagmaReadServerTooFarBehind		do:			[ : err | self isHighlyAvailable				ifTrue:					[ 1 second asDelay wait.					err retry ]				ifFalse: [ err pass ] ]		on: MagmaWrongServerError		do:			[ : err | allowFailover				ifTrue:					[ MagmaNotification signal: err asString , ' switching to ' , err correctServer asString.					self						 disconnect ;						 secondaryLocation: err correctServer.					err retry ]				ifFalse:					[ MagmaNotification signal: err asString.					err pass ] ]! !!MagmaSession methodsFor: 'private'!serializer	^serializer! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/31/2018 15:53'!setGlobalReadStrategy: aMaReadStrategy ifNotIn: aSet 	"Set my ReadStrategy, as well as all other sessions of my sessions linked to me."self maMarked: 'dev'.  "Was just looking at this code and thinking we should enumerate all MagmaSession instances which match my magmaId, or the magmaId's of any of my 'links'."	(aSet ifAbsentAdd: self) ifFalse: [ ^ self ].	self readStrategy: aMaReadStrategy copyForOtherSession.	self definition ifNotNilDo:		[ : def | def links do:			[ : each | each findSession				setGlobalReadStrategy: aMaReadStrategy copyForOtherSession				ifNotIn: aSet ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/22/2012 15:10'!setTimeoutSecondsTo: anInteger during: aBlock 	"Temporarily adjust my timeoutSeconds for evaluation of aBlock."	| oldTimeout |	guard critical: 		[ oldTimeout := self timeoutSeconds.		self timeoutSeconds: anInteger.		[ aBlock value ] ensure: [ self timeoutSeconds: oldTimeout ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 6/7/2005 12:50'!signalExceptionLike: anException 	| signalableError |	signalableError := anException maOriginalClass new 		copyAttributes:			(anException maOriginalClass allInstVarNames copyWithoutAll: #('signalContext' 'handlerContext' 'outerContext'))		from: anException.	"this is probably not necessary.."	signalableError signal! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/6/2008 16:27'!sizeOfLargeCollection: aMagmaCollection	"Calls sizeOfLargeCollection:"	self ensureConnected.  "Need this before we call oidFor:, below."	^ self secondarySubmit:		(MaLargeCollectionSizeRequest new 			collectionOid: (self oidFor: aMagmaCollection) ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 4/1/2012 18:34'!stopLoading: aMagmaCollection 	"If aMagmaCollection was created from a 'luxury' query, and it is still loading on the server, instruct the server to stop.  This can save many server resources for queries that are no longer needed.	If aMagmaCollection is not being loaded, or not created from a luxury query, this message has no effect.	This is an asynchronous message, so it returns instantly."	(MaOidCalculator isOidForNewObject: aMagmaCollection changes collectionOid) ifFalse: 		[ self submit: (MagmaReleaseReaderRequest new				collectionOid: aMagmaCollection changes collectionOid ;				yourself) ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/4/2005 16:35'!stronglyReference: anObject	strongReferences add: anObject! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/14/2011 15:05'!stubOutMissingVersions	"Stub out the missingVersions of my mcModel, if present."	self mcModel ifNotNilDo:		[ : mcModel | self stubOut: mcModel missingVersions ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 8/9/2014 19:11'!submit: aMagmaRepositoryRequest 	"Submit aMagmaRepositoryRequest and answer the result.  This is a core method."	^ [ self		submit: aMagmaRepositoryRequest		to: primaryLink ]		on: MagmaWrongServerError		do:			[ : err | allowFailover				ifTrue:					[ MagmaNotification signal: err asString , ' switching to ' , err correctServer asString.					self						 disconnect ;						 primaryLocation: err correctServer.					err retry ]				ifFalse:					[ MagmaNotification signal: err asString.					err pass ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 9/4/2014 14:28'!submit: aMagmaRepositoryRequest to: aMaServerLink 	"Submit aMagmaRepositoryRequest and answer the result.  This is a core method."	^ guard critical:		[ aMagmaRepositoryRequest waitCursor showWhile:			[ | retries link result priorLink newLink |			retries := 0.			link := aMaServerLink.			[ aMagmaRepositoryRequest requiresConnection ifTrue:				[ [ self ensureConnected ; ensureConnected ]					on: MagmaLinkChange					do:						[ : noti | link := noti linkToReplace: link.						noti resume ] ].			aMagmaRepositoryRequest prepareToSubmitFor: self.			link timeoutSeconds:				(aMagmaRepositoryRequest timesToRetry > 0					ifTrue: [ self retrySeconds + (self retrySeconds * retries) ]					ifFalse: [ self timeoutSeconds ]).			result := link submit: aMagmaRepositoryRequest.			result maIsException ifTrue: [ self signalExceptionLike: result ] ]				maOn: ConnectionTimedOut				do:					[ : err | "This occurs whenever we successfully sent a request out, but did not get a response back within the timeout period."					MagmaNotification signal: err asString , '.  Retry ' , retries asString , ' of ' , aMagmaRepositoryRequest timesToRetry asString , '.'.					retries >= aMagmaRepositoryRequest timesToRetry						ifTrue: [ err pass ]						ifFalse:							[ retries := retries + 1.							err retry ] ]				on: ConnectionClosed , MagmaSessionLost				do:					[ : err |					MagmaNotification signal: err asString , '.  Retrying unconditionally.'.					"It could just be that the server simply expired this session.  Try to reconnect to the same server."					aMagmaRepositoryRequest isConnect ifFalse: [ self disconnect ].					"Don't retry a begin, because we already restore transaction on the server as part of the connection process."					aMagmaRepositoryRequest isBegin						ifTrue:							[ MagmaNotification signal: err asString , '.  Reconnecting and restoring transaction...'.							self ensureConnected.							nil ]						ifFalse:							[ MagmaNotification signal: err asString , '.  Retrying ' , aMagmaRepositoryRequest asString , ' unconditionally.'.							err retry ] ]				on: ConnectionRefused				do:					[ : err | aMagmaRepositoryRequest isConnect ifFalse: [ self disconnect ].					priorLink := link.					newLink := self handleFailedLink: link.					"The server is down.  If we are HA, try another server."					newLink = priorLink						ifTrue:							[ MagmaNotification signal: err asString , '.  Backup server unavailable.'.							err pass ]						ifFalse:							[ MagmaNotification signal: err asString , '.  Retrying at ' , newLink asString.							aMagmaRepositoryRequest failedLocation: (MagmaRemoteLocation location: priorLink location).							link := newLink.							(MagmaLinkChange								oldLink: priorLink								newLink: newLink) signal.							err retry ] ].			(result isMagmaServerResult and: [ result hasServerNotifications ]) ifTrue: [ self handleSpecialOidNotifications: result serverNotifications ].			result ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/16/2014 13:57'!transaction	^ transaction! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/1/2009 17:18'!tryToRefreshTo: repositoryCommitNumber 	"If the server has the available commit-log records, answer the next few hundred of them and update this session.  If not, signal a MagmaUnavailableCommitRecord."	| commitLogSerializer lastPosition cn |	commitLogSerializer := self class newCommitLogSerializer.	lastPosition := -1.		[ cn := self commitNumber.	cn > lastPosition and: [ cn < repositoryCommitNumber ] ] whileTrue: 		[ lastPosition := cn.		self advanceUsing: commitLogSerializer ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/17/2005 14:33'!user	^ user! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/12/2008 20:30'!user: aMagmaUser	user := aMagmaUser! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/7/2010 11:13'!userId	^ self user ifNotNil: [ self user id ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 11/23/2010 14:39'!userId: aString	"Convenience method for setting userId, arbitrarily required by Magma.  Creating a session and setting the user is a more lazy way to access repositories, vs. a direct #connectAs:."	self user: (MagmaUser id: aString)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/18/2008 17:15'!uuid	^ self magmaId ifNotNilDo: [ : magId | magId uuid ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/8/2014 20:07'!veryDeepCopy	"Don't let it try."	^ self! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/28/2008 10:42'!warmBackupUpdatesFrom: startingCommitNumber for: backupLocation 	"Calls commitRecordsFrom:"	^ self submit: 		(MaWarmBackupUpdateRequest new			startingCommitNumber: startingCommitNumber ;			requestingLocation: backupLocation ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/25/2013 12:48'!write: aMaCommitLogRecord 	"Send aMaCommitLogRecord to the repository, instructing it to write it to its logs and apply it to its persistent graph."	"Calls write:logged:commitLogRecord:."	aMaCommitLogRecord resetChecksum.	self submit: 		(MaWriteRequest new			commitLogRecord: aMaCommitLogRecord ;			yourself)! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 11/6/2008 13:53'!allowFailover	"Answer whether this session will failover to access a secondary repository if necessary and available."	^ allowFailover! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/5/2009 18:30'!allowFailover: aBoolean 	"Set whether this session should talk to any and all nodes to ensure service is provided by multiple servers, improving system performance and continuity."	self isLocal ifTrue: 		[ MagmaUserError signal: 'Only applicable to multiserver on-line nodes.' ].	guard critical: 		[ allowFailover := aBoolean.		self ensureSecondaryLinkConfigured ]! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 10/2/2014 13:52'!beWarmBackup	self		 ensureIsAdminSession ;		 beWarmBackupFor: self node primaryLocation! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/14/2009 12:48'!beWarmBackupFor: aMagmaRemoteLocation 	"Instruct the server to be a warm-backup for the server running at aMagmaRemoteLocation."	self ensureIsAdminSession.	"Calls #beWarmBackupFor:."	self submit: 		(MagmaBeWarmBackupRequest new			primaryLocation: aMagmaRemoteLocation ;			yourself)! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 9/22/2009 20:35'!ensureIsAdminSession	self isLocal ifFalse: 		[ self allowFailover ifTrue: 			[ MagmaUserError signal: 'Use a #newAdminSession to perform admin requests, please.' ] ]! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/24/2009 14:48'!inRestoreMode	"Answer whether the primary server is in restoreMode."	self ensureIsAdminSession.	^ self remotePrimitiveAttributes at: #restoreMode! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 11/6/2008 13:15'!isHighlyAvailable	"Answer whether I am pointed to a secondary server for this repository which will be used automatically as necessary."	^ primaryLink ~= secondaryLink! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 12/22/2008 10:11'!primaryLocation	^ MagmaRemoteLocation location: primaryLink location! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 11/24/2009 20:32'!relinquishPrimaryDutyTo: secondaryLocation atCommitNumber: commitNumber branchCode: branchCode	self ensureIsAdminSession.	"Calls #executeSwapWith:commitNumber:branchCode:."	^ self submit:		(MagmaSwapPrimaryDutyRequest new			newPrimary: secondaryLocation ;			commitNumber: commitNumber ;			branchCode: branchCode ;			yourself)! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/14/2009 12:40'!removeWarmBackup: aMagmaRemoteLocation 	"Gracefully removes aMagmaRemoteLocation from the primary servers warm-backups, rather than shutting down abruptly and relying on error-handling."	self ensureIsAdminSession.	"Calls #removeSecondaryLocation:"	self submit: (MaRemoveSecondaryLocationRequest new locationToRemove: aMagmaRemoteLocation)! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/8/2009 14:25'!requiredProgress	"When using Magma in a multi-server configuration, it may be possible to occasionally find the secondary read-servers 'behind' the primary server.  Applications that cannot tolerate behind reads may specify the minimum requiredProgress for future reads."	^ requiredProgress! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/8/2009 14:24'!requiredProgress: commitNumber 	"When using Magma in a multi-server configuration, it may be possible to occasionally find the secondary read-servers 'behind' the primary server.  Applications that cannot tolerate behind reads may specify the minimum requiredProgress for future reads."	commitNumber isInteger ifFalse: [ MagmaUserError signal: 'Must specify an integral commitNumber.' ].	requiredProgress := commitNumber! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 8/4/2013 20:59'!resetNode	self commit:		[ self magmaId resetNode.		self definition links ifNotNil:			[ : links | links do:				[ : each | each resetNode ] ] ]! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 12/22/2008 10:11'!secondaryLocation	^ MagmaRemoteLocation location: secondaryLink location! !!MagmaSession methodsFor: 'high-availability' stamp: 'cmm 3/7/2009 14:16'!takeOverAsPrimary	self isLocal ifTrue: 		[ MagmaUserError signal: 'Only applicable for multiserver on-line nodes.' ].	self ensureIsAdminSession.	"Calls #relinquishPrimaryDutyTo:atCommitNumber:branchCode:, but also see the process method."	^ self submit: MagmaRequestSwapPrimaryDutyRequest new! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 8/7/2014 16:52'!allowLongCatchUp	"If the session should find itself more than 100 commits behind, whether it should automatically catch itself up or whether a MagmaTooFarBehindError should be signaled.	Most of the time, catching up from a long time ago is costly for both client and server, therefore the default is false.  Note however that MagmaTooFarBehindError is resumable."	^ preferences allowLongCatchUp! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 8/7/2014 16:52'!allowLongCatchUp: aBoolean	preferences allowLongCatchUp: aBoolean! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 1/16/2014 13:35'!allowWriteBarrier	"Answers whether the WriteBarrier option is enabled, which can enable much improved performance."	"Not guarded because this needs to perform and it seems very unlikely we would be flipping WB in a background process."	^ preferences allowWriteBarrier! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 6/21/2013 14:30'!allowWriteBarrier: aBoolean 	guard critical:		[ transaction validateWriteBarrier: aBoolean.		aBoolean			ifTrue:				[ preferences allowWriteBarrier ifFalse: [ transaction installWriteBarrierUsing: self ] ]			ifFalse:				[ preferences allowWriteBarrier ifTrue: [ self cleanUpWriteBarrier ] ].		preferences allowWriteBarrier: aBoolean ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/23/2003 13:08'!cachedObjectCount	"Answers how many persistent objects from this repository are in memory.  Your program should be careful not to reference too-large object structures at a time, or these cache Dictionaries will become large and slower."	^serializer oidCount! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 5/8/2003 13:48'!cachedObjectCountByClass	^serializer cachedObjectCountByClass! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 1/19/2012 20:12'!commitPackageCountByClass	"The number of objects in the commitPackage."	^ transaction commitPackageCountByClass! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/5/2008 10:09'!compressThreshold	"The maximum number of bytes a request will be before the client decides it should be compressed."	^ primaryLink compressThreshold! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/5/2008 10:09'!compressThreshold: anInteger 	"The maximum number of bytes a request will be before the client decides it should be compressed."	^ primaryLink compressThreshold: anInteger! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 9/1/2010 14:12'!globalReadStrategy: aMaReadStrategy 	"Set my ReadStrategy, as well as all other sessions of sessions I link to."	self		setGlobalReadStrategy: aMaReadStrategy		ifNotIn: Set new! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/13/2011 19:18'!immutabilityStrategy	^ immutabilityStrategy ifNil: [ MaImmutabilityStrategy new ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/30/2011 20:37'!immutabilityStrategy: aMaImmutabilityStrategy 	"Capture some of the immutables"	self addSystemImmutablesTo: aMaImmutabilityStrategy.	serializer		initializeImmutabilityStrategy: aMaImmutabilityStrategy		using: transaction.	immutabilityStrategy := aMaImmutabilityStrategy! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/13/2011 19:48'!mergeImmutabilityStrategy: aMaImmutabilityStrategy 	self immutabilityStrategy:		(immutabilityStrategy			ifNil: [ aMaImmutabilityStrategy ]			ifNotNil: [ immutabilityStrategy merge: aMaImmutabilityStrategy ])! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/12/2013 10:32'!readSetBufferByteCount	^ transaction readSetBufferByteCount! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 12/1/2011 12:51'!readSetCountByClass	"The number of objects in the readSet.  The cautionwith caching too many objects is that it can cause the readSet to be large, which will affect the speed of commits.There are several tools to deal with THAT:	 - implement #isImmutableInMagma to return true.  Instances of that object will not be put into the readSet.	 - Create a one-time ImmutabilityStrategy.  This is a more sophisticated way to describe immutability -- by using a Block.	 - Turn on the WriteBarrier.  This is, by far, the most effective solution to the problem.  It's totally transparent and free."	^ transaction readSetCountByClass! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 9/23/2004 15:59'!readStrategy	"Answers an object that defines how many levels deep to read when encountering various kinds of objects."	^ readStrategy! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 2/26/2009 00:22'!readStrategy: aMaReadStrategy 	"Once the readStrategy is set, aMaReadStrategy is converted to use class ids.."	aMaReadStrategy isBasic ifTrue: 		[ "basic read-strategies are not allowed because they circumvent the systemReadStrategy in the server."		MagmaUserError signal: 'Basic read-strategies are not allowed, use a MaReadStrategy.' ].	guard critical: 		[ readStrategy := aMaReadStrategy.		self prepareReadStrategy ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 10/13/2012 23:01'!retrySeconds	"Some requests will retry a few times, some won't.  For ones that will, this is, the number of seconds the client should wait for a response from the remote server before retrying."	^ preferences retrySeconds! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 10/13/2012 23:02'!retrySeconds: anInteger	"Some requests will retry a few times, some won't.  For ones that will, this is, the number of seconds the client should wait for a response from the remote server before retrying."	^ preferences retrySeconds: anInteger! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/24/2014 16:54'!serverStatisticsPrimary	"Answer the MagmaServerStatistics in the primary server.  Calls #serverStatistics."	^ self 		submit: MagmaServerStatisticsRequest new		to: primaryLink! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/24/2014 16:54'!serverStatisticsSecondary	"Answer the MagmaServerStatistics in the secondary server.  Calls #serverStatistics."	^ self 		submit: MagmaServerStatisticsRequest new		to: secondaryLink! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 5/7/2008 17:02'!statistics	^ statistics ifNil: [ statistics := MagmaSessionStatistics new ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 3/13/2013 15:14'!stubOut: anObject 	"Convert anObject to a proxy, potentially freeing the objects it references for garbage collection.  Useful for keeping memory consumption under control."	self stubOutAll: {anObject}! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 11/11/2014 12:58'!stubOutAll: aCollection 	"Convert aCollection of objects to proxies, potentially freeing the objects they reference for garbage collection.  Useful for keeping memory consumption under control."	guard critical:		[ | obj proxy stubbable objects stubs |		stubbable := aCollection select:			[ : each | self canStubOut: each ].		objects := OrderedCollection new: stubbable size.		stubs := OrderedCollection new: stubbable size.		stubbable do:			[ : each | each maIsMutatingProxy				ifTrue:					[ "We know the proxy has its real-object reified, because canStubOut: requires that."					obj := each realObjectIfMutatingProxy.					proxy := each.					proxy setRealObjectTo: nil.					self addProxy: each ]				ifFalse:					[ obj := each.					proxy := serializer proxyFor: (self oidFor: obj) ].			objects add: obj.			stubs add: proxy.			transaction remove: obj.			serializer cleanObject: obj ].		"Not sure this guard is actually necessary but..."		objects asArray			elementsForwardIdentityTo: stubs asArray			copyHash: false ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 10/13/2012 23:02'!timeoutSeconds	"For MagmaRemoteLocations only, the number of seconds the client should wait for a response from the remote server.  If, after that time, a response is not received, a MaNetworkError will be signaled."	^ preferences timeoutSeconds! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 10/13/2012 23:02'!timeoutSeconds: anInteger 	"For MagmaRemoteLocations only, specify the number of seconds the client should wait for a response from the remote server.  If, after that time, a response is not received, a MaNetworkError will be signaled."	preferences timeoutSeconds: anInteger.	primaryLink timeoutSeconds: anInteger.	secondaryLink timeoutSeconds: anInteger! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 8/18/2009 14:30'!useCompression: aBoolean 	self compressThreshold: (aBoolean 			ifTrue: [ MaClientSocket mtuSize ]			ifFalse: [ MaSerializedGraphBuffer unreasonablePhysicalSize * 2 ])! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 3/27/2010 21:36'!writeStatisticsToFile	| allStats filename |	filename := 'magma-statistics.obj'.	allStats := Dictionary new		at: #statistics			put: self statistics archivalCopy ;		yourself.	self isHighlyAvailable 		ifTrue: 			[ allStats				at: #serverStatisticsPrimary					put: self serverStatisticsPrimary archivalCopy ;				at: #serverStatisticsSecondary					put: self serverStatisticsSecondary archivalCopy ]		ifFalse: 			[ allStats 				at: 'server statistics'				put: self serverStatisticsPrimary ].	MaObjectSerializer new 		fileOut: allStats		toFileNamed: filename		in: FileDirectory default.	FileDirectory default 		maFileNamed: filename		do: [ : stream | stream compressFile ]! !!MagmaSession methodsFor: 'raw buffers' stamp: 'cmm 4/23/2014 17:18'!bufferFor: anObject 	^ transaction		bufferFor: anObject		ifAbsent:			[ (self isPersistent: anObject) ifTrue:				[ (self oidFor: anObject) ifNotNil:					[ : oid | self bufferForOid: oid ] ] ]! !!MagmaSession methodsFor: 'raw buffers' stamp: 'cmm 5/7/2014 16:28'!bufferForOid: oidInteger 	"Calls bufferFor: in the server."	^ self secondarySubmit: 		(MaRawBufferRequest new			oid: oidInteger ;			yourself)! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 4/23/2011 17:33'!cleanUp	self bulkBecomeProxies.	statistics ifNotNil: [ statistics release ].	transaction unregister! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 10/7/2010 22:17'!ensureConnected	"When stale proxies or MagmaCollections are provoked, ensure their session connects."	self isConnected ifFalse: 		[ user ifNil: [ user := MagmaUserRequiredNotification requestUserFor: self ].		user ifNil: [ MagmaUserError signal: 'A user to connect must be supplied.' ].		self connect: user ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 4/15/2013 18:15'!initialize	super initialize.	transaction := MaTransaction session: self.	preferences := MagmaPreferences new.	guard := Mutex new.	allowFailover := true.	oidCount := requiredProgress := 0.	strongReferences := OrderedCollection new.	self		resetProxies ;		resetLastClean ;		initializeSerializer ;		resetTransactionLevel ;		initializeCache! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 8/23/2007 12:26'!initializeCache	cache := Dictionary new! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 5/1/2014 22:00'!initializeSerializer	serializer := MaObjectSerializer new		bpMapIndex: (MaObjectBuffer indexOfBpMap: MagmaBufferPositionMap) ;		toCreateProxies: 			[ : oid | 			MagmaMutatingProxy 				session: self				oid: oid ] ;		classIdManager: MagmaClassIdManager new ;		oidManager: (MagmaOidManager new				statistics: self statistics ;				yourself) ;		yourself.	serializer traversalStrategy		traverseWhen: 			[ : path : parent : indexInteger | 			(path last 				maShouldTraverseWithPath: path				parent: parent				index: indexInteger) and: 				[ path size <= 2 or: 					[ "Because we're serializing an Array of only changed objects, we only need capture their first level, but don't forget the OC container is level 1."					MaOidCalculator isOidForNewObject: (self oidFor: path last) ] ] ] ;		valueWhen: 			[ : path : parent : index | 			(path last 				maShouldAppendWithPath: path				parent: parent				index: index) and: 				[ path size <= 2 or: [ MaOidCalculator isOidForNewObject: (self oidFor: path last) ] ] ].	serializer preferences		beforeSerializingAny: #MagmaForwardingProxy			do: [ : aMagmaForwardingProxy | aMagmaForwardingProxy ensureReferencePopulated ] ;		beforeSerializingAny: #Morph			do: 				[ : aMorph | 				"(sigh) Morphs keep their own #updateableActionMap, the map used to hold event-listener definitions.  Before, we were setting up these listeners on *materialization*, but this was causing them to be marked dirty immediately.  Therefore, we go ahead and set these listeners up 'permanently' upon serialization."				aMorph wantsMagmaEvents ifTrue: 					[ aMorph 						when: #magmaAboutToRefresh						send: #aboutToRefreshFromMagma:						to: aMorph.	"aMagmaRefreshEvent"					aMorph 						when: #magmaRefreshed						send: #refreshedFromMagma:						to: aMorph	"aMagmaRefreshEvent".					aMorph formerOwner: nil ] ] ;		afterMaterializingAny: #MagmaCoreLargeCollection			do: 				[ : aMagmaCollection | 				aMagmaCollection					initializeChangesUsing: aMagmaCollection ;					setOid: (serializer oidFor: aMagmaCollection) ].	MagmaCollectionReader withAllSubclasses do: 		[ : each | 		serializer preferences 			afterMaterializingAny: each name			do: 				[ : aMagmaCollectionReader | 				aMagmaCollectionReader					fixUpExpression ;					setUpListener ;					refresh ] ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 1/26/2005 16:36'!initializeSystemChangeNotifications	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Modified		using: #handleClassModification:.	SystemChangeNotifier uniqueInstance		notify: serializer classIdManager		ofSystemChangesOfItem: #class		change: #Renamed		using: #handleClassRename:! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 2/26/2009 10:26'!loadClassDefinitionsFrom: aByteArray 	guard critical: [ serializer classDefinitions: (self materializeObject: aByteArray) ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 2/26/2009 10:39'!loadDefinitionFrom: aByteArray 	guard critical: 		[ definition ifNotNil: 			[ self				stubOut: self node ;				stubOut: self magmaId ;				stubOut: definition ].		definition := self materializeObject: aByteArray ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/16/2014 12:57'!primDisconnect	"Calls removeSessionFor:"	guard critical: 		[ self isConnected ifTrue: 			[ MagmaNotification signal: 'disconnecting from ' , self linkInformation.			self linksDo: 				[ : eachLink | 				"Make reasonable attempt to clean my resources from server, if established."				(eachLink isConnected and: [ eachLink protocolEstablished ]) ifTrue: 					[ self 						submit: MaRepositoryDisconnectRequest new						to: eachLink ].				eachLink disconnect ].			id := nil.			self cleanUp			"The following commented out because now we keep transactions active!!"			"			resetTransactionLevel ;" ].		self			releaseSystemChangeNotifications ;			releaseActionMap		"			cleanUpWriteBarrier ;" ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 2/26/2009 10:42'!releaseSystemChangeNotifications	guard critical: 		[ SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: self ;			noMoreNotificationsFor: serializer classIdManager ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 11/11/2014 11:18'!resetProxies	proxies := MaWeakIdentityKeyDictionary new! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 2/26/2009 00:07'!closeRepository	self isLocal ifFalse: [ MaUserError signal: 'Only available for local connections.' ].	guard critical: 		[ self isConnected ifTrue: [ self disconnect ].		self repositoryController close ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 2/26/2009 00:06'!connect: aMagmaUser 	self isConnected ifTrue: [ MagmaUserError signal: 'Already connected.' ].	guard critical: 		[ user := aMagmaUser.		self primConnect.		self isServerSession ifFalse: 			[ (ConnectedSessions includes: self) ifFalse: 				[ ConnectedSessions					add: self ;					changed ] ] ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 3/11/2005 13:21'!connectAs: aString	self connect: (MagmaUser id: aString)! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/31/2013 09:59'!connections	"Answer information about all clients connected to this server.  Calls #connectionsList."	self ensureIsAdminSession.	^ self submit: MagmaConnectionsRequest new! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 2/26/2009 00:08'!disconnect	"Disconnect this session from the repository.  If the repository is a locally-connected one, it will remain open."	guard critical: 		[ ConnectedSessions			remove: self				ifAbsent: 					[ "do nothing"					 ] ;			changed.		self primDisconnect ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/14/2008 17:45'!disconnectAndClose	"Disconnect from the repository and, if it is a locally-connected one, close the repository."	self disconnect.	self isLocal ifTrue: [ self closeRepository ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 2/7/2016 15:36'!isConnected	"Answer whether I am *logically* connected to my repository.  This is independent of whether I have a physical socket connection.  Magma makes this irrelevant, since physical socket disconnections can occur based on timeouts, the reconnection to the Magma are reestablished automatically, as needed.""The above comment is wrong.  We nil out the id in primDisconnect. Perhaps we should be checking the 'definition' instead?"	^id notNil! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 11/5/2008 21:38'!isLocal	^ primaryLink isLocal and: [ primaryLink == secondaryLink ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 12/26/2004 23:08'!isRemote	^ self isLocal not! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 11/18/2008 12:08'!isSameRepositoryAs: anotherMagmaSession	^ anotherMagmaSession hasDefinition	and: [ definition magmaId = anotherMagmaSession magmaId ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 11/5/2008 10:09'!linkInformation	^ primaryLink linkInformation! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/24/2018 20:48'!prefer: aMagmaRemoteLocation for: aMagmaId 	preferences linkLocations ifNil: [ preferences linkLocations: Dictionary new ].	(preferences linkLocations		at: aMagmaId		ifAbsentPut: [ OrderedCollection new ]) add: aMagmaRemoteLocation! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/24/2018 22:04'!preferredLocationFor: aMagmaId 	"If one or more preferred linkLocations for aMagmaId have been specified, use the first one that reports on-line."	^ preferences linkLocations ifNotNil:		[ (preferences linkLocations			at: aMagmaId			ifAbsent: [ ^ nil ])			detect:				[ : each | "test the connection"				[ each newAdminSession remoteCommitNumber.				true ]					on: Error					do: [ : err | false ] ]			ifNone: [ nil ] ]! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 6/17/2011 15:57'!codeBackup	"Backup the code-packages current in use by this image.  This only copies versions, not dirty working-copies."	MagmaNotification signal: 'Code backup.'.	self 		mcModelFavorDiskSpaceIfPossible ;		ensureMostRecentMcVersionsSaved! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 6/17/2011 16:25'!fullBackup	"Calls #fullBackup."	self ensureIsAdminSession.	"Code backup is just regular commits to the repository, must use a normal session, not an admin session in case this is an HA node."	self location newSession		 connectAs: 'fullBackup' ;		 codeBackup ;		 uiBackup.	self modelBackup! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 5/15/2011 15:45'!isModelBackupRunning	^ self remotePrimitiveAttributes at: #isFullBackupRunning ! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 4/14/2011 14:17'!location	"Answer a new MagmaLocation that can be used later to access to this session without having to be concerned with directory-paths or ip addresses."	^ primaryLink ifNotNil:		[ self isLocal			ifTrue:				[ (self respondsTo: #repositoryController)					ifTrue: [ self repositoryController localLocation ]					ifFalse: [ MagmaEnvironmentError signal: 'The Magma server package should be loaded.' ] ]			ifFalse: [ MagmaRemoteLocation location: primaryLink location ] ]! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 5/15/2011 15:46'!modelBackup	"Backup the model, but not the code-packages in this image."	"Calls #fullBackup."	self modelBackupTo: nil! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 5/15/2011 15:47'!modelBackupTo: serverPathString 	"Backup the model, but not the code-packages in this image, to the specified fully-qualified serverPathString."	"Calls #fullBackupToServerPath:."	self ensureIsAdminSession.	^ self submit: 		(MagmaFullBackupRequest new			serverPath: serverPathString ;			yourself)! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 11/4/2008 18:28'!node	^ self definition ifNotNilDo: [ : def | def node ]! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 11/5/2008 21:07'!pathNamePrimary	^ self 		submit: MagmaPathNameRequest new		to: primaryLink! !!MagmaSession methodsFor: 'admin' stamp: 'cmm 11/5/2008 21:08'!pathNameSecondary	^ self 		submit: MagmaPathNameRequest new		to: secondaryLink! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 7/18/2008 13:17'!codeBase	"Answer the persistent codeBase object so that you may commit additions to it."	^ definition ifNotNil: [ definition codeBase ]! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 12/22/2012 15:10'!ensureMostRecentMcVersionsSaved	"Ensure all of the currently-loaded versions of MC packages are committed to this Magma repository."	self		setTimeoutSecondsTo: 90		during:			[ MCWorkingCopy allManagers				do:					[ : eachWorkingCopy | eachWorkingCopy ancestors do:						[ : eachVersionInfo | self commit:							[ (MCRepositoryGroup default versionWithInfo: eachVersionInfo)								ifNil: [ MagmaWarning signal: eachVersionInfo name , ' not found in RepositoryGroup default.' ]								ifNotNilDo:									[ : ver | self mcModel storeVersion: ver ] ] ] ]				displayingProgress:					[ : eachWorkingCopy | 'Saving ' , eachWorkingCopy name ] ]! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 2/26/2009 10:43'!getCode	"Answer the Dictionary of Streams that was manually installed in the server that can be browsed or filed-in to be able to connect to my repostory."	"Calls #codeBaseByteArray."	^ guard critical: 		[ | code classesAndCode |		classesAndCode := self secondarySubmit: MaDownloadCodeRequest new.		self loadClassDefinitionsFrom: classesAndCode first.		code := serializer materializeGraph: classesAndCode last.		code ]! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 1/22/2013 14:31'!mapLegacyInstancesOf: oldClassName to: newClass 	"If you renamed a class while not connected to the repository, use this method to migrate the persistent version in the repository to the new name and structure.  newClass must be present in the system.  Make a connection to the repository but send this message before accessing the root."	| oldDefs |	oldDefs := self definition classDefinitions		detect:			[ : eachDefinitions | eachDefinitions anySatisfy:				[ : eachDefinition | eachDefinition isKnownAs: oldClassName ] ]		ifNone: [ MagmaUserError signal: 'No old class named ' , oldClassName ].	(serializer classIdManager hasClassDefinitionFor: newClass) ifTrue: [ MagmaUserError signal: 'This operation cannot be performed because ' , newClass name , ' is already established.' ].	self commit:		[ oldDefs do:			[ : each | each beKnownAs: newClass name ] ]! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 3/6/2011 20:17'!mcModel	"Answer the persistent codeBase object so that you may commit additions to it."	^ self codeBase ifNotNilDo: [ : cb | cb mcModel ]! !!MagmaSession methodsFor: 'database' stamp: 'cmm 6/19/2013 14:15'!commitLogEntryAt: commitNumber	"The MaCommitLogEntry that contained this buffer."	^ (self commitLogRecordAt: commitNumber) ifNotNilDo: [ : cr | MagmaSession materializeCommitLogEntry: cr ]! !!MagmaSession methodsFor: 'database' stamp: 'cmm 2/26/2009 00:27'!commitNumber	"The commitNumber position this session is refreshed to."	^ guard critical: [ transaction commitNumber ]! !!MagmaSession methodsFor: 'database' stamp: 'cmm 6/19/2013 13:29'!commitPackageAt: commitNumber	"The MaCommitLogEntry that contained this buffer."	^ (self commitLogEntryAt: commitNumber) ifNotNilDo: [ : cle | cle commitPackage ]! !!MagmaSession methodsFor: 'database' stamp: 'cmm 12/26/2004 23:32'!definition	"Answers the repository definition, a MagmaRepositoryDefinition."	^ definition! !!MagmaSession methodsFor: 'database' stamp: 'cmm 7/15/2008 16:53'!magmaId	^ definition ifNotNil: [ definition magmaId ]! !!MagmaSession methodsFor: 'database' stamp: 'cmm 12/22/2008 13:23'!oidCount	"The number of oids allocated by this repository.  The total number of objects ever committed, even if some have since been garbage-collected."	^ oidCount! !!MagmaSession methodsFor: 'database' stamp: 'cmm 12/21/2008 23:02'!remoteBranchCode	"The branchCode is a private, internal Magma field used to identify whenever a backup copy of a repository is switched out of restoreMode.  Such a repository is now a 'branch' and can never again receive updates from its ancestral repository."	^ self remotePrimitiveAttributes at: #branchCode! !!MagmaSession methodsFor: 'database' stamp: 'cmm 12/21/2008 23:18'!remoteCommitNumber	"The commitNumber that the repository is at."	^ self remotePrimitiveAttributes at: #commitNumber! !!MagmaSession methodsFor: 'database' stamp: 'cmm 7/14/2008 23:22'!remoteMagmaId	"Calls #magmaId."	^ self submit: MagmaIdRequest new! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 5/1/2014 10:22'!firstPathToNewLinkOrType	self pathsToNewLinksAndTypesDo: [ : each | ^ each ].	^ nil! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 1/15/2007 17:53'!isImmutableInMagma 	^ true! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 1/15/2007 18:02'!maAsStorageObject	"If the user wishes to reference a session in their model, then it will always be restored to the session that actually materializes it.  There is no changed detection.."	^ MaStorageForMagmaSession new! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 1/15/2007 16:34'!maUsesStandardStorage	^ false! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 5/1/2014 10:19'!pathsToNewLinksAndTypes	| newClasses newLinks |	newClasses := Set new.	newLinks := Set new.	self pathsToNewLinksAndTypesDo:		[ : eachPath | eachPath isMagmaId			ifTrue: [ newLinks add: eachPath ]			ifFalse: [ newClasses add: eachPath ] ]! !!MagmaSession methodsFor: 'serialization' stamp: 'cmm 5/1/2014 10:18'!pathsToNewLinksAndTypesDo: aBlock	| classes links |	classes := self definition classes asSet.	links := self definition links asSet.	self dirtyGraphDo:		[ : path : parent : index |  "The same Symbol instances might exist in multiple Magma sessions, so disregard those."			path last isSymbol ifFalse:				[ | otherSess newClass |				otherSess := path last quickMagmaSession.				otherSess ifNotNil:					[ otherSess ~= self ifTrue:						[ (links includes: otherSess magmaId) ifFalse: [ aBlock value: path asArray ] ] ].				(classes includes: (newClass := path last maOriginalClass theNonMetaClass)) ifFalse: [ aBlock value: path asArray ] ]  ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 1/4/2010 15:08'!fractionLoaded: aMagmaCollection 	"Calls loadProgress."	^ self submit: (		(MaLoadProgressRequest new)			collectionOid: (self oidFor: aMagmaCollection) ;			yourself)! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 11/6/2008 16:24'!getTrunkFor: aMagmaCollection expression: aMaTerm 	"Calls getTrunkFor:expression:."	^ self secondarySubmit: 		(MaReaderTrunkRequest new			collectionOid: (self oidFor: aMagmaCollection) ;			expression: aMaTerm ;			yourself)! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 2/26/2009 10:44'!load: aMagmaCollection from: aMagmaCollectionReader makeDistinct: aBoolean 	"Calls registerAndLoad:using:from:forSession:distinct:"	| commitPackage refreshResult |	guard critical: 		[ commitPackage := MaCommitPackage new.		commitPackage addLargeCollectionChanges: aMagmaCollection changes.		"aMagmaCollection is a new object, so serializer will traverse it deeply enough."		serializer 			serializeGraph: aMagmaCollection			do: [ : eachObject | commitPackage addObject: eachObject ].		aMagmaCollection			setOid: (self oidFor: aMagmaCollection) ;			beNotPersistent.		commitPackage objects: (serializer serializeGraph: commitPackage objects).		refreshResult := self submit: (MaLoadFromReaderRequest new				commitPackage: commitPackage ;				expression: aMagmaCollectionReader expression ;				distinct: aBoolean ;				sourceCollectionOid: (self oidFor: aMagmaCollectionReader collection) ;				yourself).		self 			refreshViewUsing: refreshResult			includingLocal: false.		"set it up as if it was created through normal transaction mechanism"		aMagmaCollection session: self.		transaction monitorLargeCollectionChanges: aMagmaCollection changes ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 9/28/2008 20:58'!lockerOf: aMagmaCollection 	^ self submit: 		(MaGetMcLockerRequest new			mcOid: (self oidFor: aMagmaCollection) ;			yourself)! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 10/12/2009 13:08'!monitorLargeCollection: aMagmaCollection 	(aMagmaCollection session notNil and: [ aMagmaCollection session ~= self ]) ifTrue: 		[ MagmaUserError signal: 'LargeCollections cannot be shared with other repositories.' ].	aMagmaCollection setOid: (self oidFor: aMagmaCollection).	transaction monitorLargeCollectionChanges: aMagmaCollection changes! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 11/6/2008 16:26'!occurrencesOf: anObject in: aMagmaCollection 	"Calls numberOfEntriesFrom:to:inLargeCollection:on:."	| oid |	^ self secondarySubmit: 		(MaKeyIntervalInfoRequest new			collectionOid: (self oidFor: aMagmaCollection) ;			attribute: nil ;			lowKey: (oid := self oidFor: anObject) ;			highKey: oid ;			yourself)! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 2/26/2009 10:47'!refreshSegment: aMagmaCollectionReaderSegment of: aMagmaCollection where: aMaTerm pageSize: anInteger using: aMaReadStrategy loadObjects: aBoolean 	"Calls refreshSegmentIn:"	guard critical: 		[ | segment |		segment := self secondarySubmit: (MaRefreshSegmentRequest new				quantity: anInteger ;				collectionOid: (self oidFor: aMagmaCollection) ;				segment: aMagmaCollectionReaderSegment ;				expression: aMaTerm ;				readStrategy: aMaReadStrategy ;				loadObjects: aBoolean ;				exceptions: aMagmaCollection changes removedOids ;				yourself).		"Since we say we 'refresh' let's do that instead of returning the new one."		aMagmaCollectionReaderSegment refreshFrom: segment.		self materializeObjectsIn: aMagmaCollectionReaderSegment ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 10/10/2004 20:05'!resetMagmaCollectionChanges	transaction largeCollectionChanges do: [ :each | each reset ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 3/7/2011 11:36'!upTo: anInteger objectsIn: aMagmaCollection fromIndex: startIndex using: aMaReadStrategy 	"Answer a MaCollectionSegment or aMaIndexedCollectionSegment.  Calls upTo:oidsFromIndex:inLargeCollection:using:forSession: "	^ guard critical: 		[ | segmentResult |		segmentResult := self secondarySubmit: (MaSegmentByIndexRequest new				quantity: anInteger ;				collectionOid: (self oidFor: aMagmaCollection) ;				lowIndex: startIndex ;				readStrategy: aMaReadStrategy ;				yourself).		self materializeObjectsIn: segmentResult.		self inTransaction ifTrue: [ self stronglyReference: segmentResult ].		segmentResult ]! !!MagmaSession methodsFor: 'testing' stamp: 'cmm 7/18/2008 13:24'!hasDefinition	"Answer whether this MagmaSession instance has ever been connected to a repository.  Once connected to a particular repository, a MagmaSession may only reconnect to that repository, not to any other repository.  A new MagmaSession instance must be used to connect to a different repository."	^ definition notNil! !!MagmaSession methodsFor: 'testing' stamp: 'cmm 4/28/2014 10:08'!isDirty: anObject 	"Answer whether anObject is persistent in this session and changed from its last-read buffer state."	^ (anObject maIsLargeCollection and: [ anObject changes hasChanges ]) or: [ transaction didChange: anObject ]! !!MagmaSession methodsFor: 'testing' stamp: 'cmm 5/28/2014 14:09'!isPersistent: anObject 	"Answer whether anObject has been read from the persistent graph."	^ anObject maIsLargeCollection		ifTrue: [ anObject changes isNotPersistent not ]		ifFalse:			[ (anObject maIsMutatingProxy and: [ anObject mutatingProxySession = self ]) or:				[ (self serializer hasOidFor: anObject) and: [ (MaOidCalculator isOidForNewObject: (self oidFor: anObject)) not ] ] ]! !!MagmaSession methodsFor: 'maui support' stamp: 'cmm 9/16/2008 22:23'!maChooseNotificationHandlerUsing: aMauiMorph 	"This method is provided for Maui.  It allows a seamless UI transition for MagmaForwardingProxy's into the UI screens representing the other domain they exist in, so that the proper notificationHandler is set for them (used to intercept MagmaSessionRequests)."	^ aMauiMorph object magmaSession ifNil: [ self ]! !!MagmaSession methodsFor: 'maui support' stamp: 'cmm 2/12/2012 15:48'!mauiDefaultView	^ 'Main'! !!MagmaSession methodsFor: 'maui support' stamp: 'cmm 10/16/2010 16:40'!send: aMessage to: anObject 	"Allow me to be used as a MauiNotificationHandler."	"We have time here to make sure the receiver is the proper one to be handling the MagmaSessionRequests for anObject.  Do it just to be extra conservative."	| handlingSession |	handlingSession := anObject quickMagmaSession ifNil: [ self ].	^ [ aMessage sentTo: anObject ] 		on: MagmaSessionRequest		do: [ : req | req handleAndResumeUsing: handlingSession ]! !!MagmaSession methodsFor: 'maui support' stamp: 'cmm 3/17/2013 20:29'!uiBackup	MagmaNotification signal: 'User-interface backup.'.	(Smalltalk hasClassNamed: #MauiWorld) ifTrue:		[ | thisFamily persistentFamily |		thisFamily := (Smalltalk classNamed: #MauiWorld) current family.		persistentFamily := self definition uiFamily.		thisFamily ~= persistentFamily ifTrue:			[ self				 timeoutSeconds: 600 ;				 retrySeconds: 600 ;				 commit:					[ persistentFamily						ifNil: [ self definition uiFamily: thisFamily ]						ifNotNil: [ persistentFamily merge: thisFamily ] ] ;				 timeoutSeconds: 30 ] ]! !!MagmaSession methodsFor: 'maui support' stamp: 'cmm 11/13/2015 13:15'!uiRestore	"If Maui is loaded and an application UI panels were backed up with #uiBackup, merge those panels into the current MauiWorld's Family."	Smalltalk hasMaui		ifTrue:			[ self ensureConnected.			self definition uiFamily ifNotNil:				[ : family | (Smalltalk classNamed: #MauiWorld) current family merge: family ] ]		ifFalse: [ MagmaUserError signal: 'Maui is not installed.' ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 4/28/2007 19:30'!objectWithOid: anInteger 	^ self 		objectWithOid: anInteger		ifAbsent: 			[ MagmaInvalidOid signal: 'no object with oid ' , anInteger printString ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 2/26/2009 10:20'!objectWithOid: anInteger ifAbsent: aBlock 	"Answer the object or its proxy, the one in the repository whose oid is anInteger.  If no object with that oid exists, answer the value of aBlock."	^ guard critical: 		[ serializer 			objectWithOid: anInteger			ifAbsent: 				[ [ self realObjectFor: anInteger ] 					on: MagmaInvalidOid					do: 						[ : exc | 						"signaled in MaObjectFiler>>filePointerForOid:"						aBlock value ] ] ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 2/1/2005 22:58'!oidFor: anObject	^ serializer oidFor: anObject! !!MagmaSession methodsFor: 'accessing'!preferences	^preferences! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 7/16/2002 00:17'!preferences: aMagmaPreferences	preferences := aMagmaPreferences! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 11/13/2011 19:53'!root	"Answer the root of the domain."	^ self anchor root in:		[ : root | immutabilityStrategy ifNil: [ self immutabilityStrategy: root class immutabilityStrategy ].		root ]! !!MagmaSession methodsFor: 'server advanced' stamp: 'cmm 9/6/2007 21:45'!serverPerform: selectorSymbol 	"Tell the server to perform selectorSymbol.  The actual receiver of the perform request is the MagmaRepositoryController itself.	IMPORTANT:  Make absolutely certain the response object will not attempt to extend the protocol!!	IMPORTANT:  While this perform is executing on the server, all other requests are blocked, therefore be sure its execution will be very brief!!"	^ self 		serverPerform: selectorSymbol		withArguments: #()! !!MagmaSession methodsFor: 'server advanced' stamp: 'cmm 9/6/2007 21:34'!serverPerform: selectorSymbol withArguments: anArray 	"Tell the server to perform selectorSymbol with arguments specified in anArray.  The actual receiver of the perform request is the MagmaRepositoryController itself.	IMPORTANT:  Make absolutely certain you do not extend the #protocol (via anArray arguments OR the response)!!	IMPORTANT:  While this perform is executing on the server, all other requests are blocked, therefore be sure its execution will be very brief!!"	^ self submit: 		(MaServerPerformRequest new			selector: selectorSymbol ;			arguments: anArray ;			yourself)! !!MagmaSession methodsFor: 'server advanced' stamp: 'cmm 3/13/2009 13:55'!serverSave: saveOption andExit: exitOption 	"Tell the server to save and exit the image.  This is used for headless operation when the World menu cannot otherwise be obtained."	self ensureIsAdminSession.	^ 	[ self submit: (MaSaveAndExitImageRequest new			save: saveOption ;			exit: exitOption ;			yourself) ] 		on: NetworkError		do: 			[ : err | 			"we may expect a network error, because we just told it to shutdown."			false ]! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 8/23/2007 12:27'!cacheAt: nameString 	"Answer the object cached at nameString."	^ cache at: nameString! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 3/8/2008 18:05'!cacheAt: nameString put: anObject 	"Reference anObject at nameString to prevent it from being garbage-collected.  This is used for remote-performing on the server."	^ cache 		at: nameString		put: anObject! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 2/10/2009 10:56'!ensureOpen	self repositoryController ifNil: [ MagmaEnvironmentError signal: 'local repository not open.' ].	self isLocal ifFalse: [ MagmaUserError signal: 'Only available for local connections.' ].	self isOpen ifFalse: [ self repositoryController ensureOpen ]! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 1/16/2005 19:02'!initializeDefinition	definition := MagmaRepositoryDefinition new! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 1/13/2005 18:01'!isOpen	^ self isRemote 	or: [ "local" self repositoryController isOpen ]! !!MagmaSession methodsFor: '*magma-server' stamp: 'cmm 11/5/2008 10:09'!repositoryController	^ primaryLink localRequestServer processor! !!MagmaSession methodsFor: '*magma-tester' stamp: 'cmm 8/2/2011 14:20'!initializeTimeoutSeconds	self timeoutSeconds:		(MagmaPreferences debug			ifTrue: [ "2 days" 172800 ]			ifFalse: [ 30 ])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaSession class	instanceVariableNames: ''!!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 8/30/2010 19:09'!allClientInstances	^ self allSubInstances reject: [ : each | each isServerSession ]! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 6/19/2013 12:37'!commitLogSerializer	^ CommitLogSerializer ifNil: [ CommitLogSerializer := self newCommitLogSerializer ]! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 4/26/2010 22:21'!connectedSessions	"The MagmaSessions in this image, connected to some repository."	^ ConnectedSessions asArray sort: [ : a : b | a printString < b printString ]! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 1/24/2013 20:11'!magmaVersion	"Version 12 extended the MaRecoveryRecords #physicalSize to 4 bytes.	In version 13, the structure of MaCompiledMethodStorage was changed.  This was a manual domain conversion for each application.	Version 14 expands MaObjectBuffer >> #physicalSize to 4-bytes (plus 3 bytes of filler).	Version 15 was due to a totally new implementation of MagmaDictionary that no longer inherits from MagmaCollection.	Version 16 is to support CompiledMethods, MethodContexts and BlockClosures in Ma object serialization's native buffer format.  This resulted in Array's and all other isVariable classes to be moved to MaFixedObjectBuffer (which might be renamed to MaPointerObjectBuffer).	Version 17 renames MaClause to MagmaClause.  Please run upgradeTo17At:"	^ 17! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 5/6/2013 22:23'!protocol 	"This is the protocol needed to talk to a magma server."	^ { LargePositiveInteger. MaSerializedGraphBuffer.		MaByteObjectBuffer . MaVariableWordBuffer . MaVariableObjectBuffer . MaFixedObjectBuffer . MaStorageObjectBuffer . MaVariableBuffer.  MaCompiledMethodBuffer.  MaMethodContextBuffer },	"various requests"		{MaLargeCollectionSizeRequest . MaTransactionRequest . MaReadRequest . MaCommitRequest . MaCommitLogRecordRequest . MaGetMcLockerRequest . MaWriteRequest . MagmaPathNameRequest . MaAnchorRequest . MaSaveAndExitImageRequest . MaRepositoryConnectionRequest . MaLoadFromReaderRequest . MaRepositoryDisconnectRequest . MagmaFullBackupRequest . MagmaIdRequest . MaLargeCollectionSegmentRequest . MaAbortTransactionRequest . MaReaderTrunkRequest . MaWarmBackupUpdateRequest . MagmaSwapPrimaryDutyRequest . MaLoadProgressRequest . MaSegmentByIndexRequest . MagmaServerStatisticsRequest . MaServerPerformRequest . MaPrimitiveAttributesRequest . MaRefreshRequest . MaDownloadCodeRequest . MaRefreshSegmentRequest . MagmaEnsureCorrectNodeConfiguration . MaReadMultipleRequest . MaAbstractReadRequest . MaKeyIntervalInfoRequest . MagmaRequestSwapPrimaryDutyRequest . MagmaBeWarmBackupRequest . MagmaNoteUnreachableServer. MaRemoveSecondaryLocationRequest. MaRawBufferRequest. MagmaReleaseReaderRequest. MagmaConnectionsRequest },	"extra objects for some requests"		{ MaCommitPackage.  MaBasicReadStrategy.  MaReadStrategy },	"various results"		{ MagmaCollectionSegment . MaRefreshViewResult . MaReadResult . MagmaLargeCollectionSegment . MaCommitResult . MagmaCollectionReaderSegment . MaFailedCommitResult. MaClientConnection },	"extra objects for results"		{ MagmaId. UUID. MagmaNode. MaFailedCommitResult. MagmaClientConnection. MagmaCommitConflict. Fraction. MaServerLocation. MaCommitLogEntry. MaCommitLogRecord }, 		{MagmaLocalLocation . MagmaRemoteLocation . MagmaLocation},	"Statistics querys"		{ Interval. DateAndTime. Duration. MaHistoricalStat. MaStatHistory. MagmaServerStatistics },	"query expressions"		{ MagmaClause . MagmaExpression . MaQueryTrunkClause. MaQueryTrunk },	"MagmaCollections"		{MagmaSet . MagmaCollection. IdentityDictionary.  MaIdentityDictionary.  MagmaIndexDescription },	"large-collection changes"		{ MagmaCollectionChanges . MagmaArrayChanges . MagmaSetChanges },	"parts of MagmaCollectionChanges"		{ Association.  MaChangedKeySpecification },	"exceptions"		{ MaError. MaUnreadableRecoveryRecord . MagmaNoTransactionError . MaClientServerUserError . MaSoftwareError . MaObjectSerializationUserError . MagmaAlreadyInTransaction . MagmaWrongServerError . MaSpecialCollectionsSoftwareError . MagmaUnavailableCommitRecord . MagmaSoftwareError . MagmaDifferentBranch . MagmaSessionLost . MagmaEquivalentObjectNotInCollection . MaObjectSerializationSoftwareError . MaEnvironmentError . MagmaEnvironmentError . MagmaUserError . MaCorruptionError . MaUserError . MagmaCommitConflictError . MagmaCorruptionError . MagmaGarbageCollectedObject . MagmaDuplicateObjectInCollection . MagmaUnconnectableSessionError. MagmaWrongCommitNumber . MagmaInvalidIndexObject . MagmaInvalidOid . MagmaInvalidReference . MagmaCommitError . MaHashIndexUserError . MaMalformedRequestError . MagmaReadServerTooFarBehind }! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 1/17/2005 14:53'!disconnectAndCloseAllConnectedSessions	ConnectedSessions ifNotNil:		[ ConnectedSessions copy do: [ : each | each disconnectAndClose ] ]! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 6/22/2012 13:13'!initialize	HasMagma:=true.	self disconnectAndCloseAllConnectedSessions.	ConnectedSessions := OrderedCollection new.	Smalltalk addToShutDownList: self.	MaObjectBuffer 		bpMapsAt: MagmaBufferPositionMap indexPosition + 1		put: MagmaBufferPositionMap! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 9/24/2008 14:54'!shutDown: aboutToQuit 	super shutDown: aboutToQuit.	ConnectedSessions do: [ : each | each isConnected ifTrue: [ each primDisconnect ] ]! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 1/1/2009 17:24'!host: hostName port: anInteger 	"Connect to a Magma server running on host named hostName, listening on port anInteger."	^ self link: 		((MaNetworkServerLink 			host: hostName			port: anInteger)			protocol: self protocol ;			yourself)! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 12/26/2004 23:12'!link: aMaServerLink	^ self new		link: aMaServerLink ;		yourself! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 2/26/2009 21:33'!localPort: anInteger 	"Connect to a Magma server running on localhost, listening on port anInteger."	^ self 		host: 'localhost'		port: anInteger! !!MagmaSession class methodsFor: 'private' stamp: 'cmm 1/15/2007 18:44'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"A domain object referenced his own session, recover that with a reference to whatever session is materializing."	| answer |	MagmaSessionRequest 		signal: 'a session reference' 		do: [ : aMagmaSession | answer := aMagmaSession ].	^ answer! !!MagmaSession class methodsFor: 'private' stamp: 'cmm 6/19/2013 13:11'!materializeCommitLogEntry: aMaCommitLogRecord 	^ self commitLogSerializer resetOidManager materializeGraph: aMaCommitLogRecord record! !!MagmaSession class methodsFor: 'private' stamp: 'cmm 6/22/2009 19:31'!newCommitLogSerializer	"Unfortunately, for legacy support, we cannot use the #protocol API, because it sorts the classes by name."	| answer |	answer := MaObjectSerializer new.	{ 		Association.		UUID.		MaCommitLogEntry.		MaCommitPackage.		IdentityDictionary.		MaCommitResult.		MaSerializedGraphBuffer.		MaChangedKeySpecification.		LargePositiveInteger.		MagmaIndexDescription.		MagmaClientConnection.		MaObjectBuffer.		MaFixedObjectBuffer.		MaVariableBuffer.		MaByteObjectBuffer.		MaStorageObjectBuffer.		MaVariableObjectBuffer.		MaVariableWordBuffer.		MagmaArrayChanges.		MagmaCollectionChanges.		MagmaSetChanges.		MaIdentityDictionary	 } do: [ : each | answer classIdManager addNewClass: each ].	^ answer! !!MagmaSession class methodsFor: '*magma-server' stamp: 'cmm 6/6/2018 20:24'!cleanUp	"References to MagmaSessions get stuck in old MethodContext's, preventing garbage-collection.  Run this method and these instances will be cleaned."	| before after proxies reals |"	MagmaCollectionReader allSubInstances do:		[ : each | each magmaSession ifNotNil:			[ : sess | sess isConnected ifTrue: [ each release ] ] ]."	self disconnectAndCloseAllConnectedSessions.	WBMethodBuilder initialize.	MagmaRepositoryController initialize.	MCMagmaRepository allSubInstances do:		[ : each | each cleanUp ].	MaObjectRepository allInstances do:		[ : each | each unregisterAsMemoryHog ].	World cleanseStepList.	WorldState cleanUp.	Smalltalk garbageCollect.	before := self allSubInstances size.	Smalltalk hasMaui ifTrue:		[ (Smalltalk classNamed: #MauiWorld) current			 clipboard: nil ;			 rehashPlayers.		(Smalltalk classNamed: #MauiBlockMorph) allInstances do:			[ : each | each receiver isMauiPrototype ifTrue: [ each resetReceiver ] ] ].	(Smalltalk classNamed: #TeCellAddress) ifNotNilDo:		[ : teCellAddress | teCellAddress initializeReusableAddress ].	proxies := MagmaMutatingProxy allInstances select:		[ : each | each maRealObjectIsReified ].	reals := proxies collect:		[ : each | each realObjectIfMutatingProxy ].	proxies		elementsForwardIdentityTo: reals		copyHash: false.	Smalltalk garbageCollect.	self allSubInstances do:		[ : each | (PointerFinder pointersTo: each) do:			[ : referencer | (referencer class = Context and: [referencer isMethodContext]) ifTrue: [ referencer receiver: nil ] ] ].	Smalltalk garbageCollect.	after := self allSubInstances size.	(after > 0 and: [ Smalltalk hasMaui ]) ifTrue:		[ (Smalltalk classNamed: #MauiMorph) allSubInstances do:			[ : each | each object isMauiPrototype ifTrue: [ each resetObject ] ].		Smalltalk garbageCollect.		after := self allSubInstances size ].	SystemNavigation default allObjectsDo:		[ : e | ((e class inheritsFrom: Object) and: [ e isBehindWriteBarrier ]) ifTrue:			[ [ e primitiveChangeClassTo: e class superclass basicNew ]				on: Error				do:					[ : err | err ] ] ].	MaStatHistory cleanUp.	^ 'MagmaSession instances (before->after):  ' , (before -> after) printString! !!MagmaSession class methodsFor: '*magma-server' stamp: 'cmm 6/1/2010 15:41'!openLocal: pathStringOrMagmaLocalLocation 	| controller |	controller := MagmaRepositoryController openedOn: pathStringOrMagmaLocalLocation asMagmaLocalLocation.	controller restoreMode ifFalse: [ controller softBranch ].	^ self repositoryController: controller! !!MagmaSession class methodsFor: '*magma-server' stamp: 'cmm 12/26/2004 23:21'!repositoryController: aMagmaRepositoryController	"Use this constructor only for *additional* local connections, i.e., two or more sessions connected to the same local repository.  Use the same MagmaRepositoryController you used to create the original."	^ self link: (self newLocalLinkFor: aMagmaRepositoryController)! !!MagmaSession class methodsFor: '*magma-server' stamp: 'cmm 1/24/2013 20:27'!upgradeTo17At: aMagmaLocation 	"Upgrade the model for the changes in -cmm.63.  MaClause was renamed to MagmaClause."	| session |	aMagmaLocation isLocal ifTrue:		[ (MagmaRepositoryController open: aMagmaLocation) in:			[ : cont | cont restoreMode ifTrue: [ cont commitRestore ].			cont close ] ].	session := aMagmaLocation newSession		 allowWriteBarrier: false ;		 connectAs: 'upgrade to 17' ;		 yourself.	[ (session definition classDefinitions anySatisfy:		[ : each | each anyOne name = #MaClause ]) ifTrue:		[ session commit:			[ session				mapLegacyInstancesOf: #MaClause				to: MagmaClause ] ].	session repositoryController repository filer version: 17 ] ensure: [ session disconnectAndClose ]! !!MagmaSession class methodsFor: '*magma-server' stamp: 'cmm 5/2/2013 13:34'!upgradeTo18At: aMagmaLocalLocation 	| location traverser compressor session oidsBySymbol oidConversions |self maMarked: 'delete'.  "Decided not to automatically canoncicalize all Symbols into the RepositoryDefinition because, especially after having run a #codeBackup, it bloats the Symbols up to over 42K.  Otherwise there were just 109.	So then I thought about making it a settable option, but if the user is going to set the option they can just pre-commit their Symbols themself!!"location := aMagmaLocalLocation asMagmaLocalLocation.	self verifyRepositoryAt: location isVersion: 17.	traverser := MagmaFileTraverser for: location.	oidsBySymbol := Dictionary new.	traverser anchorGraphDo:		[ : eachBuffer | eachBuffer classId = 11 ifTrue:			[ (oidsBySymbol				at: eachBuffer asString				ifAbsentPut: [ OrderedCollection new ]) add: eachBuffer oid ] ].	"Interesting to see all the Symbols in the db and how many occurrences of each we had."oidsBySymbol do: [ : each | each sort ].oidsBySymbol explore.	oidConversions := Dictionary new.	oidsBySymbol keysAndValuesDo:		[ : eachSymbol : eachOids | eachOids size > 1 ifTrue:			[ eachOids withIndexDo:				[ : oid : index | index > 1 ifTrue:					[ oidConversions						at: oid						put: eachOids first ] ] ] ].self halt.	"commitRestore if necessary."	location isLocal ifTrue:		[ (MagmaRepositoryController open: location) in:			[ : cont | cont restoreMode ifTrue: [ cont commitRestore ].			cont close ] ].	"Now do a second pass where we replace all references to the Symbols to the canonicalized one."	compressor := (MagmaCompressor source: location) upgradeBlock:		[ : eachBuffer | eachBuffer isPointers ifTrue:			[ eachBuffer instVarsDoWithIndex:				[ : eachReferencedOid : index | oidConversions					at: eachReferencedOid					ifPresent:						[ : canonicalizedOid | eachBuffer							maInstVarAt: index							put: canonicalizedOid ]					ifAbsent: [  ] ] ] ].	compressor compressTo: location pathName, '-ver.18'.	session := location newSession		 allowWriteBarrier: false ;		 connectAs: 'upgrade to 18' ;		 yourself.	[ "Finally, populate the found Symbols into the RepositoryDefinition."	session definition symbols: oidsBySymbol keys asSet.	session repositoryController repository filer version: 18 ] ensure: [ session disconnectAndClose ]! !!MagmaSession class methodsFor: '*magma-server-private' stamp: 'cmm 2/8/2005 21:44'!newLocalLinkFor: aMagmaRepositoryController	^ MaLocalServerLink localRequestServer: (MaLocalRequestServer processor: aMagmaRepositoryController)! !MaClientStat subclass: #MagmaSessionStatistics	instanceVariableNames: 'clientSideConnectionTimeHistory refreshAllTimeHistory clientSideMcPageReadsTimeHistory clientSideProxyMaterializationTimeHistory clientSideCommitTimeHistory refreshViewHistory objectsReadPerSecond objectBytesReadPerSecond'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-API'!!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:07'!clientSideCommitTimeHistory	"The time this client spends serializing commit-packages, excluding the time spent waiting for a response (for that, see timeToSubmitHistoryFor: MaWriteRequest) and also excludes the time to refresh the client view, which happens for commits, aborts or begins and is captured in my #refreshViewHistory."	^clientSideCommitTimeHistory! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:09'!clientSideConnectionTimeHistory	"This stat represents the time for the client to connect, but without including the #refreshAll, which is captured separately in my #refreshAllTimeHistory."	^clientSideConnectionTimeHistory! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:15'!clientSideMcPageReadsTimeHistory	"The time loading pages of objects due to paging through a MagmaCollectionReader or enumerating an entire MagmaCollection.  This includes only the client-side materialization time, not the time waiting for the server to return the buffers.  For that, add in the time from my #timeToSubmitHistoryFor: MaRefreshSegmentRequest for reader pages or MaSegmentByIndexRequest for enumerating an entire collection."	^clientSideMcPageReadsTimeHistory! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:18'!clientSideProxyMaterializationTimeHistory	"The time spent materializing proxys.  This is especially useful for seeing how effective your readStrategies are.  If the counts and timings are very high on this stat then use a more aggressive readStrategy."	^clientSideProxyMaterializationTimeHistory! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 11/15/2010 14:10'!objectBytesReadPerSecond	"This stat represents the speed at which this client session is pulling objects from the server, including server round-trip time, in Bytes per second."	^objectBytesReadPerSecond! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 11/15/2010 14:11'!objectsReadPerSecond	"This stat represents the speed at which this client is reading objects from the server, including server round-trip time, in terms of the number of objects read per second."	^objectsReadPerSecond! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:28'!refreshAllTimeHistory	"When the images is saved while connected to a MagmaSession, the session is automatically disconnected and reconnected when the image starts again.  While disconnected, the in-image persistent objects become stale as commits by other users continue to occur to the repository.  All persistent in-image objects must be refreshed when reconnecting to the repository.  Currently this operation can take some time and is captured as a separate stat.  To find the total connection time, add this stat to my clientSideConnectionTimeHistory."	^refreshAllTimeHistory! !!MagmaSessionStatistics methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:24'!refreshViewHistory	"The time required to refresh the clients view of the repository.  This is ONLY the time spent on the client-side, it does not include the time waiting for the server to process the associated begin, commit or abort request.  For those times, see timeToSubmitHistoryFor: MaWriteRequest, MaTransactionRequest or MaAbortTransactionRequest."	^refreshViewHistory! !!MagmaSessionStatistics methodsFor: 'enumerate' stamp: 'cmm 11/15/2010 14:13'!historysDo: aBlock 	super historysDo: aBlock.	{ 		clientSideConnectionTimeHistory.		refreshAllTimeHistory.		clientSideMcPageReadsTimeHistory.		clientSideProxyMaterializationTimeHistory.		clientSideCommitTimeHistory.		objectsReadPerSecond.		objectBytesReadPerSecond.		refreshViewHistory	 } do: aBlock! !!MagmaSessionStatistics methodsFor: 'initialize-release' stamp: 'cmm 11/6/2013 21:27'!initialize	super initialize.	clientSideConnectionTimeHistory := MaStatHistory name: 'Connection Time'.	refreshAllTimeHistory := MaStatHistory name: 'Connection refresh time'.	clientSideMcPageReadsTimeHistory := MaStatHistory name: 'MagmaCollection Page Reads'.	clientSideProxyMaterializationTimeHistory := MaStatHistory name: 'Proxy Materializations'.	clientSideCommitTimeHistory := MaStatHistory name: 'Time to Serialize Commit Packages'.	objectsReadPerSecond := MaStatHistory name: 'Objects per second read'.	objectBytesReadPerSecond := MaStatHistory name: 'Bytes per second read'.	refreshViewHistory := MaStatHistory name: 'Time to Refresh View'! !!MagmaSessionStatistics methodsFor: 'initialize-release' stamp: 'cmm 12/22/2008 15:22'!release	self noteStop.	super release! !!MagmaSessionStatistics methodsFor: 'copying' stamp: 'cmm 12/22/2008 16:25'!postArchivalCopy	super postArchivalCopy.	self noteStop! !MagmaPreferences initialize!MagmaSession initialize!