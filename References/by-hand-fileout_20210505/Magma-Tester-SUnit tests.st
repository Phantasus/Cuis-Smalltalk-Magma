MaNetworkTestCase subclass: #MagmaTestCase	instanceVariableNames: 'magmaConsole peerConsole clientSession localRoot original34990 forwardRecoverySignaled potentiallyOpenSignaled timeToVerifyRestore shouldStopGeneratingSequenceNumbers sequenceNumbers dormantObject objectToAdvance forwardRecoveryRequirement shouldStopFlooding refreshTestFixture counterFixture blockTestFixture nonPersistentSamples samples samplesInMc fifthElement luxuryQueryReader statFixture'	classVariableNames: 'KeywordsSamples TestWithWriteBarrier'	poolDictionaries: ''	category: 'Magma-Tester-SUnit tests'!!MagmaTestCase commentStamp: '<historical>' prior: 0!This class tests Magma functionality.!!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 7/15/2009 12:24'!abort	clientSession ifNotNil: [ clientSession abort ]! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 6/13/2007 22:59'!assertForwardRecoverySignaled	self assert: forwardRecoverySignaled = true! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 2/9/2009 16:17'!assertNoMagmaCollectionIndexClass	self deny: (Smalltalk hasClassNamed: #MagmaCollectionIndex)! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 5/26/2010 12:27'!assertPotentiallyOpenSignaled	self assert: potentiallyOpenSignaled = true! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 11/5/2008 12:39'!close	clientSession ifNotNil: [ self clientSession disconnectAndClose ].	magmaConsole ifNotNil: [ self stopServer ].	peerConsole ifNotNil: [ self stopPeer ]! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 3/6/2009 11:12'!connectClients	self connectClients: self class magmaServerLocation! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 3/6/2009 11:11'!connectClients: aMagmaRemoteLocation 	self 		remotePerform: #connect:as:		withArguments: {  aMagmaRemoteLocation. 'client1'  }		in: 'client1'.	self 		remotePerform: #connect:as:		withArguments: {  aMagmaRemoteLocation. 'client2'  }		in: 'client2'! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 12/18/2002 22:40'!disconnectClients	self		remotePerform: #disconnect		in: 'client1'.	self		remotePerform: #disconnect		in: 'client2'! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 1/4/2013 16:27'!environmentDirectory	^ suite environmentDirectory! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 8/1/2011 18:03'!initialize	super initialize.	localRoot := Dictionary new.	timeToVerifyRestore := false.	forwardRecoverySignaled := potentiallyOpenSignaled := shouldStopFlooding := false.	blockTestFixture := { 'hello' }! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 3/12/2010 17:59'!restoreRenamedClasses	(Smalltalk hasClassNamed: #MagmaRenamedContact) ifTrue:		[ (Smalltalk classNamed: #MagmaRenamedContact) rename: #MagmaContact ]! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 8/17/2009 20:56'!startServer2	[ self startServer2On: self backupDirectory ] fork! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 3/4/2009 16:34'!startServer2On: aFileDirectory	magmaConsole := MagmaServerConsole new		open: aFileDirectory fullName ;		processOn: self class defaultServer2Port ;		yourself.	magmaConsole statistics snapshotInterval: (1 			to: 60*24			by: 1)! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 1/4/2013 16:27'!startServer: handleForwardRecovery 	magmaConsole := MagmaServerConsole new.	[ magmaConsole		 open: self environmentDirectory ;		 yourself ]		maOn: MagmaPotentiallyOpenError		do:			[ : err | potentiallyOpenSignaled := true.			err resume ]		on: MagmaForwardRecoveryNeeded		do:			[ : warning | forwardRecoverySignaled := true.			warning resume: handleForwardRecovery ].	magmaConsole processOn: self class defaultServerPort.	magmaConsole statistics snapshotInterval:		(1			to: 60 * 24			by: 1)! !!MagmaTestCase methodsFor: 'initialize-release' stamp: 'cmm 3/4/2009 15:28'!stopServer	magmaConsole shutdown! !!MagmaTestCase methodsFor: 'test keyword index' stamp: 'cmm 4/14/2005 17:29'!add: anAssociation to: aMagmaCollection smalltalkVersion: smalltalkIndex using: aMaKeywordIndexDefinition	aMagmaCollection add: anAssociation.	(aMaKeywordIndexDefinition indexObjectFor: anAssociation) do:		[ : eachWord |		| bag |		bag := 		smalltalkIndex			at: eachWord			ifAbsentPut: [ nil "we just need the entry-key, bag must be indexed at a different key" ].		"We never add anAssociation twice to the MagmaCollection, therefore we must be sure not to add it twice to the Smalltalk collection."		bag := 			smalltalkIndex				at: (aMaKeywordIndexDefinition indexHashForIndexObject: eachWord)				ifAbsentPut: [ Bag new ].		bag add: anAssociation ]! !!MagmaTestCase methodsFor: 'test keyword index' stamp: 'cmm 8/18/2009 21:38'!addKeywordIndexAndRemainingClassesUsing: smalltalkIndex 	"I run in client2."	| indexDef mc |	indexDef := self newKeywordIndex.	mc := clientSession abort root at: 'testKeywordIndex'.	clientSession commit: [ mc addIndex: indexDef ].	OrderedCollection withAllSubclassesDo: 		[ : each | 		clientSession commit: 			[ self notify: 'adding ' , each name.			self 				add: each maCommentKeywords -> each name				to: mc				smalltalkVersion: smalltalkIndex				using: indexDef ] ].	^ smalltalkIndex! !!MagmaTestCase methodsFor: 'test keyword index' stamp: 'cmm 8/18/2009 21:41'!createInitialCollectionOfClasses	"I'm running in client1"	| mc answer indexDef root |	mc := MagmaCollection new.	answer := Dictionary new.	indexDef := self newKeywordIndex.	root := clientSession root.	clientSession commit:		[ root			at: 'testKeywordIndex'			put: mc.		MaClientServerRequest withAllSubclasses do:			[ : each |			self				add: each maCommentKeywords -> each name				to: mc				smalltalkVersion: answer				using: indexDef ] ].	^ answer! !!MagmaTestCase methodsFor: 'test keyword index' stamp: 'cmm 10/6/2004 16:59'!testKeywordIndex	"Build a MagmaCollection of classes in the system, then add a keyword index by words in their class comments.  Build it as a Smalltalk structure as well, and use it to compare."	| smalltalkVersion |	smalltalkVersion := self		remotePerform: #createInitialCollectionOfClasses		in: 'client1'.	smalltalkVersion := self		remotePerform: #addKeywordIndexAndRemainingClassesUsing:		with: smalltalkVersion		in: 'client2'.	self		remotePerform: #verifyKeywordIndexUsing:		with: smalltalkVersion		in: 'client1'! !!MagmaTestCase methodsFor: 'test keyword index' stamp: 'cmm 6/15/2006 17:22'!verifyKeywordIndexUsing: smalltalkIndex 	"smalltalkIndex is a Dictionary of Bags.  Keys of the dictionary are the hash keys of the various keywords.  I run in client1."	| mc index |	clientSession abort.	mc := clientSession root at: 'testKeywordIndex'.	index := mc indexNamed: #key.	smalltalkIndex keysAndValuesDo: 		[ : eachWordOrHashInt : eachBag | 		eachWordOrHashInt isString ifTrue: 			[ | reader mcBag stBag |			self notify: 'verifying keyword ' , eachWordOrHashInt.			reader := mc where: 				[ : rdr | 				rdr 					read: #key					at: eachWordOrHashInt ].			mcBag := (reader asArray: reader size) asBag.			stBag := smalltalkIndex at: (index indexHashForIndexObject: eachWordOrHashInt).			self should: [ mcBag = stBag ] ] ]! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 6/5/2007 23:25'!addAll: aCollection at: aString 	self 		remotePerform: #addAllToLocalCollection:at:		withArguments: {  aCollection. aString  }		in: 'client1'.	^ self 		remotePerform: #addAllToLargeCollection:at:		withArguments: {  aCollection. aString  }		in: 'client2'! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 9/19/2008 16:51'!getSessionId	^ clientSession id! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 11/28/2011 22:49'!maAllowsWriteBarrier	"In one of the tests, an instance of MagmaTestCase, itself, gets serialized.  However, no object which refers to the MagmaSession should allow WB because, once my 'clientSession' is replaced with a new session, my old session and its WB becomes GC'd, so my methods start blowing up because their writeBarrier is nil."	^ false! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 8/5/2011 13:28'!maTransientVariables	"The test-case instance itself now can be potentially serialized due to MethodContext 'receiver's.."	^ (self class allInstVarNames copyWithoutAll: #('clientSession' 'blockTestFixture'))! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 10/26/2014 15:23'!newSessionAt: aMagmaLocation 	^ aMagmaLocation newSession		allowWriteBarrier: self class allowWriteBarrier ;		allowLongCatchUp: true ;		timeoutSeconds: 172800 "2 days" ;		yourself! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 1/2/2009 14:35'!performTest	super performTest.		[ self		initiateBackupIfTime ;		verifyRestoreIfTime ] 		on: MaNotification		do: 			[ : n | 			Transcript				cr ;				show: n messageText.			n resume ]! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 1/2/2013 19:32'!playerProtocol	^ super playerProtocol ,		(({#Bag. 		#Association. 		#UUID. 		#ReadWriteStream. 		#LargePositiveInteger. 		#MagmaRemoteLocation. 		#MaServerLocation. 		#MagmaPerson. 		#MaTestMailingAddress}			select:				[ : each | Smalltalk hasClassNamed: each ]			thenCollect:				[ : each | Smalltalk classNamed: each ]) ,			(self class withAllSubclasses asSortedCollection:				[ : a : b | a name < b name ]))! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 10/4/2004 16:44'!reverseString: aString	self notify: 'reversing ', aString.	1 to: aString size // 2 do:		[ :eachPosition |		aString 			swap: eachPosition 			with: (aString size - eachPosition + 1) ]! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 10/6/2004 15:54'!sampling: count in: aMagmaCollectionReader do: oneArgBlock	| increment |	increment := (aMagmaCollectionReader size / 2 / count) asInteger max: 1.	1 		to: aMagmaCollectionReader size // 2		by: increment		do:			[ : x |			oneArgBlock value: (aMagmaCollectionReader at: x) ]! !!MagmaTestCase methodsFor: 'private' stamp: 'cmm 7/15/2006 12:21'!verifyReaderMatchesLocalAt: rootKeyString on: indexAttribute 	| reader |	clientSession abort.	"refresh to get all changes."	reader := (clientSession root at: rootKeyString) where: 		[ : rdr | 		rdr 			read: indexAttribute			from: '0'			to: 'zzzzzzzzzzzzzz' ].	self 		verifyReader: reader		matchesElementsOf: (localRoot at: rootKeyString)! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 8/4/2009 11:14'!addAllToLargeCollection: aCollection at: aString 	| root |	self 		addAllToLocalCollection: aCollection		at: aString.	root := clientSession refresh root.	clientSession commit: 		[ aCollection do: 			[ : each | 			(root 				at: aString				ifAbsentPut: [ MagmaCollection new ]) add: each ] ].	^ clientSession oidFor: (root at: aString)! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 7/18/2002 15:40'!addAllToLocalCollection: aCollection at: aString	(localRoot		at: aString		ifAbsentPut: [ OrderedCollection new ])			addAll: aCollection.! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 10/20/2014 13:34'!beginTransaction	clientSession begin.	^ nil! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 5/23/2002 21:12'!clientSession	"accessible from client1 and client2"	^clientSession! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 5/7/2002 22:51'!commit	clientSession commit.	^nil! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 11/13/2011 20:15'!connect: aMagmaLocation as: aString 	self clientSession: aMagmaLocation newSession.	clientSession connect: (MagmaUser id: aString).	self assert: clientSession commitNumber > 0! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 6/18/2002 22:06'!disconnect	clientSession ifNotNil: [ clientSession disconnect ].	^nil! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 10/27/2014 09:27'!makeSureSymbolContainerMaterialized	clientSession begin.	clientSession definition symbols yourself.	localRoot := clientSession root.	(localRoot at: #testSymbolCanonicalization) yourself.	^ nil! !!MagmaTestCase methodsFor: 'client' stamp: 'cmm 12/7/2004 14:49'!verifyLargeCollectionAt: aString	| localCollection largeCollection |	clientSession abort.	localCollection :=		localRoot 			at: aString			ifAbsentPut: [ OrderedCollection new ].	largeCollection := self clientSession root at: aString.	self should: [ largeCollection size = localCollection size ].	largeCollection do: [ :each | self should: [ localCollection includes: each ] ].	localCollection do: [ :each | self should: [ (largeCollection includes: each) and: [ (largeCollection occurrencesOf: each) = 1 ] ] ]! !!MagmaTestCase methodsFor: 'test grow an object' stamp: 'cmm 12/15/2006 21:37'!addAndGrowObject	| c arr |	c := Set new addAll: (101 to: 108); yourself.	"Give it its own family, so we don't go trying to save the whole default family."	arr := Array		with: c		with: nil		with: self peopleSample1.	clientSession begin.	clientSession root at: 'testGrowObject' put: arr.	clientSession commit.	"grow the collection, forcing its buffer to be moved in the file.  Also tests commitAndBegin."	clientSession begin.	c addAll: (109 to: 259).	clientSession commitAndBegin.	(clientSession root at: 'testGrowObject') at: 2 put: '2'.	clientSession commit! !!MagmaTestCase methodsFor: 'test grow an object' stamp: 'cmm 8/7/2013 16:32'!ensureTooBigCommitFails	"The oid-space cannot handle more than 4M new objects in a single commit.  If it allowed it, it could possibly overrun into the already-allocated user objects space.  Make sure that can't happen.""Commented out because it takes too long to run.  Uncomment if you want to verify this test works.""	self		should:			[ clientSession commit:				[ clientSession root					at: 'testGrowObject'					put:						((1 to: 5 million) collect:							[ : n | Object new ]) ] ]		raise: MagmaUserError.	clientSession disconnect.	self		connect: clientSession location		as: clientSession userId"! !!MagmaTestCase methodsFor: 'test grow an object' stamp: 'cmm 12/15/2006 21:53'!readAndVerifyGrownObject	| arr |	arr := clientSession abort root at: 'testGrowObject'.	self should: [ arr first = (101 to: 259) asSet ].	self should: [ (arr at: 2) = '2' ].	self should: [ arr last maEquivalentForSerializationTest: self peopleSample1 ]! !!MagmaTestCase methodsFor: 'test grow an object' stamp: 'cmm 8/6/2013 13:51'!testGrowObject	"Magma has special-case code on the server (see MaObjectFiler>>#write:index:) that checks whether an object now takes up more space than it used to.  This can occur when a variable is added to a class, or when a Collection had to grow its internal Array.  This test exercises that code."	self		remotePerform: #addAndGrowObject		in: 'client1' ;		remotePerform: #readAndVerifyGrownObject		in: 'client2' ;		remotePerform: #ensureTooBigCommitFails		in: 'client1'! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 9/28/2009 09:24'!addContactMethodsAttribute	clientSession refresh.	MagmaTestObject 		subclass: #MagmaContact		instanceVariableNames: 'contactMethods name address unused'		classVariableNames: ''		poolDictionaries: ''		category: 'Magma tester-Test domains'! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 9/28/2009 11:26'!changeName	"This should warn us we're about to truncate data because this clients MagmaPerson doesn't have address."	clientSession refresh.	2 timesRepeat: 		[ self should: 			[ 			[ clientSession commit: [ (localRoot at: 'testClassSchemaUpgrades') name: 'Muller' ].			false ] 				on: MagmaTruncationWarning				do: 					[ : warning | 					clientSession abort.					(warning messageText findString: 'MagmaPerson') > 0 ] ] ].	"Now load the latest code committed by another client so we don't get that warning."	clientSession definition codeBase installClasses.	"gotta stub it out so it re-reads it, otherwise warning will continue.."	clientSession stubOut: (localRoot at: 'testClassSchemaUpgrades').	clientSession commit: [ (localRoot at: 'testClassSchemaUpgrades') name: 'Muller' ].	self maMarked: 'magic'.	"calling contactMethods works due to DNU override in MagmaTestObject"	self should: 		[ (localRoot at: 'testClassSchemaUpgrades') contactMethods = (Dictionary new				at: #address					put: '101 W. Meyer' ;				yourself) ]! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 7/7/2009 22:40'!commitInitialMagmaPerson	| session |	session := self newSessionAt: self class magmaServerLocation.	session connect: (MagmaUser id: 'conductor').	session commit: 		[ session root 			at: 'testClassSchemaUpgrades'			put: (MagmaPerson new					name: 'Mayer' ;					yourself) ].	session disconnect! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 9/28/2009 09:20'!readPerson	"Read an old version of the Person instance."	clientSession refresh.	localRoot 		at: 'testClassSchemaUpgrades'		put: (clientSession root at: 'testClassSchemaUpgrades')! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 3/12/2010 18:01'!setContactMethodsAndCode	clientSession commit: 		[ self maMarked: 'magic'.	"setting contactMethods: works due to DNU override in MagmaTestObject"		(clientSession root at: 'testClassSchemaUpgrades') contactMethods: (Dictionary new				at: #address					put: '101 W. Meyer' ;				yourself) ].	"Test renaming the class too."	clientSession commit: 		[ (Smalltalk classNamed: #MagmaContact) rename: #MagmaRenamedContact.		#(#MagmaRenamedContact #MagmaPerson ) do: [ : each | clientSession definition codeBase fileOutClass: (Smalltalk at: each) ] ]! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 7/7/2009 21:35'!testClassSchemaUpgrades	"This method tests Magma's ability to run with a class-definition out-of-sync with the repository, as well as performing a live upgrade of MagmaPerson.	- First, we commit initial MagmaPerson instances right here in the conductor image.	- client1 adds an 'contactMethods' attribute in the image only as the first instVar of the superclass (MagmaContact).	- client2 connects to the db, reads the MagmaPerson (without any contactMethods).	- client1 sets the contactMethods, commits the latest code and the MagmaPerson.	- client2 changes the name and commits, should get a commit-conflict, which causes the object to be refreshed (now known to be truncated).	- client2 changes the name again and commits, should get a warning that data will be lost.  client2 aborts the commit.	- client2 loads the latest code, since any commits are going to lose the address.	- client2 stubsOut: the MagmaPerson to force a refresh of that object and clear the truncation flag.	- client2 tries to change the name for a third time.  This time it should work.	- client2 verifies the address added by client1.	- client1 verifies the name change.	- delete domain classes off the server, shutdown and reopen and ensure they don't get recompiled."	self class allowWriteBarrier ifFalse: 		[ self			commitInitialMagmaPerson ;			remotePerform: #addContactMethodsAttribute				in: 'client1' ;			remotePerform: #readPerson				in: 'client2' ;			remotePerform: #setContactMethodsAndCode				in: 'client1' ;			remotePerform: #changeName				in: 'client2' ;			remotePerform: #verifyNameChange				in: 'client1' ]! !!MagmaTestCase methodsFor: 'test class schema upgrades' stamp: 'cmm 6/20/2004 22:35'!verifyNameChange	clientSession abort.	self should: [ (clientSession root at: 'testClassSchemaUpgrades') name = 'Muller' ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:28'!addCounterBlock	| block |	block := self counterBlock.	self assert: block value = 1.	clientSession commit:		[ clientSession root			at: #testCounterBlock			put: block ].	self assert: block value = 2.	self assert: block value = 3.	"Since it is persistent, aborting at this point should revert the count!!"	clientSession abort.	self assert: block value = 2! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:16'!addExternalRefsBlock	| blocks |	blocks := {self selfRefBlock. 	self instVarRefBlock}.	self assert: blocks first value = blocks second value.	clientSession commit:		[ clientSession root			at: #testExternalRefsBlock			put: blocks ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 14:07'!addExternalRefsBlock2	| block |	block := [ : arg | blockTestFixture := arg.	self blockTestFixture first ]."	self assert: (block value: {'world'}) = 'world'.	self assert: blockTestFixture first = 'world'."	clientSession commit:		[ clientSession root			at: #testExternalRefsBlock2			put: block ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:27'!addGlobalLookupBlock	clientSession commit:		[ clientSession root			at: #testGlobalLookupBlock			put: [ : nm | Smalltalk at: nm ] ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:03'!addSortBlock	clientSession commit: [ clientSession root at: #testSortBlock put: self sortBlock ].	"to be sure it survives a refresh-attempt"	clientSession commit: [ ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:25'!blockTestFixture	^ blockTestFixture! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:08'!counterBlock	| count |	count := 0.	^ [ count := count + 1 ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 12:18'!initializeBlockSamples	clientSession commit:		[ clientSession root			at: #testBlocks			put: MaFixtureFactory new blockSamples ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:13'!instVarRefBlock	^ [ clientSession id ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:12'!selfRefBlock	^ [ self getSessionId ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 11/12/2004 17:06'!sortBlock	^ [ : a : b | a name reverse asUppercase > b name reverse asUppercase ]! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 11:23'!testBlocks	self				remotePerform: #initializeBlockSamples		in: 'client1' ;				remotePerform: #verifyBlockSamples		in: 'client2'! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:14'!testCounterBlock	"Test a Block that refers to a temporary in its home method."	self		remotePerform: #addCounterBlock		in: 'client1'.	self		remotePerform: #verifyCounterBlock		in: 'client2'! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 14:34'!testExternalRefsBlock	"Test a Block that refers to a temporary in its home method.""	self		remotePerform: #addExternalRefsBlock		in: 'client1'.	self		remotePerform: #verifyExternalRefsBlock		in: 'client2'"! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 17:48'!testExternalRefsBlock2	"Test a Block that refers to a temporary in its home method.""	self		remotePerform: #addExternalRefsBlock2		in: 'client1'.	self		remotePerform: #verifyExternalRefsBlock2		in: 'client2'"! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:36'!testGlobalLookupBlock	"Test a block that refers to a global."	self		remotePerform: #addGlobalLookupBlock		in: 'client1'.	self		remotePerform: #verifyGlobalLookupBlock		in: 'client2'! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:12'!testSortBlock	"Test a two-argument Block."	self		remotePerform: #addSortBlock		in: 'client1'.	self		remotePerform: #verifySortBlock		in: 'client2'! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/4/2011 11:27'!verifyBlockSamples	clientSession refresh.	MaFixtureFactory new verifyBlockSamples: (clientSession root at: #testBlocks)! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:14'!verifyCounterBlock	clientSession refresh.	self assert: (clientSession root at: #testCounterBlock) value = 2! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:18'!verifyExternalRefsBlock	| blocks |	clientSession refresh.	blocks := clientSession root at: #testExternalRefsBlock.	self assert: blocks first value = blocks second value! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 18:32'!verifyExternalRefsBlock2	| block |	clientSession refresh.	block := clientSession root at: #testExternalRefsBlock2.	self assert: blockTestFixture = { 'hello' }.	self assert: (block value: { 1. 2. 3 }) = 1.	self assert: blockTestFixture = { 'hello' }! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/2/2011 10:31'!verifyGlobalLookupBlock	clientSession refresh.	self assert: (((clientSession root at: #testGlobalLookupBlock) value: #Object) = Object)! !!MagmaTestCase methodsFor: 'test blocks' stamp: 'cmm 8/1/2011 17:12'!verifySortBlock	| collection |	clientSession refresh.	collection := MaObject withAllSubclasses.	self should: 		[ "We have to convert each sortedCollection to Array's because BlockContexts do not support equality testing."		(collection asSortedCollection: self sortBlock) asArray = (collection asSortedCollection: (clientSession root at: #testSortBlock)) asArray ]! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 8/20/2006 21:39'!addIndex	clientSession commit:		[ (clientSession root at: 'testMajorFunctions') addIndex:			((MaSearchStringIndex attribute: #yourself)				keySize: 64 ;				beAscii ;				yourself) ]! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 8/4/2009 11:18'!changeIndexKeysInClient1	| reader changedKeys |	reader := (clientSession refresh root at: 'testMajorFunctions') where: 		[ : rdr | 		rdr 			read: #yourself			from: '0'			to: 'zzzzzzzzzzzzzzzzzzz' ].	changedKeys := OrderedCollection new.	self notify: 'in changeIndexKeysInClient1'.	self 		sampling: 20		in: reader		do: 			[ : eachKey | 			changedKeys add: eachKey.			self reverseString: ((localRoot at: 'testMajorFunctions') detect: [ : each | each = eachKey ]).			clientSession				noteOldKeysFor: eachKey ;				commit: [ self reverseString: eachKey ] ].	^ changedKeys! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 8/4/2009 11:17'!changeIndexKeysInClient2	| stringsChanged reader |	stringsChanged := OrderedCollection new.	self notify: 'in changeIndexKeysInClient2'.	reader := (clientSession refresh root at: 'testMajorFunctions') where: 		[ : rdr | 		rdr 			read: #yourself			from: '0'			to: 'zzzzzzzzzzzzzzzzzzzzzzz' ].	self 		sampling: 10		in: reader		do: 			[ : eachString | 			clientSession				noteOldKeysFor: eachString ;				commit: [ self reverseString: eachString ].			stringsChanged add: eachString ].	^ stringsChanged! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 11/23/2002 16:37'!removeFromLocalRoot: aCollection at: aString	(localRoot at: aString) removeAll: aCollection! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 8/17/2005 19:33'!removeIndex	| mc |	clientSession abort.	mc := clientSession root at: 'testMajorFunctions'.	clientSession commit: [ mc removeIndexNamed: #yourself ]! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 8/4/2009 11:13'!removeSomeEntriesInClient2Including: reversedString 	"Remove reversedString, as well as 20 additional entries using two different methods."	| stringsRemoved reader localCollection priorReaderSize root |	root := clientSession refresh root.	localCollection := localRoot at: 'testMajorFunctions'.	"First, remove reversedString."	stringsRemoved := OrderedCollection new.	reader := (root at: 'testMajorFunctions') where: 		[ : rdr | 		rdr 			read: #yourself			at: reversedString ].	clientSession abort.	self should: 		[ (reader asArray: 10) allSatisfy: 			[ : eachString | 			(eachString 				copyFrom: 1				to: (reader sortIndex meaningfulCharacters min: eachString size)) = (reversedString 					copyFrom: 1					to: (reader sortIndex meaningfulCharacters min: reversedString size)) ] ].	priorReaderSize := reader size.	stringsRemoved add: reader first.	localCollection remove: reader first.	clientSession commit: [ (root at: 'testMajorFunctions') remove: reader first ].	self should: [ reader refresh size = (priorReaderSize - 1) ].	reader := (root at: 'testMajorFunctions') read: #yourself.	"Remove 20 random entries, committing each time."	self 		sampling: 20		in: localCollection copy		do: 			[ : objectToRemove | 			stringsRemoved add: objectToRemove.			clientSession commit: [ (root at: 'testMajorFunctions') remove: objectToRemove ].			localCollection remove: objectToRemove ].	"Remove another 20 with a single commit."	clientSession commit: 		[ self 			sampling: 20			in: localCollection copy			do: 				[ : objectToRemove | 				stringsRemoved add: objectToRemove.				(root at: 'testMajorFunctions') remove: objectToRemove.				localCollection remove: objectToRemove ] ].	^ stringsRemoved! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 11/25/2002 01:06'!reverseLocalStrings: aCollection	"aCollection of strings that are already reversed, need to replace their normal counterparts in my local collection."	aCollection do:		[ :e |		| reversee |		(localRoot at: 'testMajorFunctions')			remove: e reverse;			add: e ]! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 6/6/2007 20:41'!testMajorFunctions	"This test builds a local Smalltalk collection and a MagmaCollection in parallel.  The local is built in client1.  Most of the MagmaCollection is built in client2.  At the end, client1 verifies the MagmaCollection against the local."	| tempSamples sample1 sample2 changedIndexKeys localEntriesToRemove stringsToReverse collectionOid |	tempSamples := (MaObject withAllSubclasses collect: [ : each | each name asString ]) asArray.	sample1 := tempSamples 		copyFrom: 1		to: tempSamples size // 2.	sample2 := tempSamples 		copyFrom: tempSamples size // 2 + 1		to: tempSamples size.	"client2 creates the collection, adds some objects."	collectionOid := self 		addAll: sample1		at: 'testMajorFunctions'.	"client1 adds an index."	self 		remotePerform: #addIndex		in: 'client1'.	"now client2 resumes adding with sample2."	self 		addAll: sample2		at: 'testMajorFunctions'.	changedIndexKeys := self 		remotePerform: #changeIndexKeysInClient1		in: 'client1'.	localEntriesToRemove := self 		remotePerform: #removeSomeEntriesInClient2Including:		with: changedIndexKeys first		in: 'client2'.	self 		remotePerform: #removeFromLocalRoot:at:		withArguments: {  localEntriesToRemove. 'testMajorFunctions'  }		in: 'client1'.	stringsToReverse := self 		remotePerform: #changeIndexKeysInClient2		in: 'client2'.	self 		remotePerform: #reverseLocalStrings:		with: stringsToReverse		in: 'client1'.	self 		remotePerform: #verifyReaderMatchesLocalAt:on:		withArguments: #('testMajorFunctions' #yourself )		in: 'client1'.	self 		remotePerform: #verifyIndexFilesFor:present:		withArguments: {collectionOid. true}		in: 'server'.	self 		remotePerform: #removeIndex		in: 'client2'.	"verify the actual collection in client1."	self 		remotePerform: #verifyLargeCollectionAt:		with: 'testMajorFunctions'		in: 'client2'.	"Make sure caches flushed."	(Delay forSeconds: 5) wait.	self 		remotePerform: #verifyIndexFilesFor:present:		withArguments: {collectionOid. false}		in: 'server'.! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 1/4/2013 17:33'!verifyIndexFilesFor: collectionOid present: aBoolean 	| description filename fact parts |	description := MagmaIndexDescription		attribute: #yourself		keySize: 64		recordSize: 8.	filename := (magmaConsole controller repository collectionManagerFor: collectionOid)		filenameFor: 'oids'		of: description.	parts := self environmentDirectory splitNameVersionExtensionFor: filename.	filename := parts first , '.1.' , parts last.	fact := magmaConsole controller repository directory fileExists: filename.	aBoolean		ifTrue: [ self assert: fact ]		ifFalse: [ self deny: fact ]! !!MagmaTestCase methodsFor: 'test major functions' stamp: 'cmm 7/15/2006 12:22'!verifyReader: aMagmaCollectionReader matchesElementsOf: localCollection 	"Because MagmaCollection indexes are sensitive only to the first few characters, test assertions were failing on multiple entries that were identical within the sensitive range because they were reversed.  This method compares the two in a way that allows this slight difference in order."	"quick test"	| sortedHashValues localEntries largeCollection index |	self should: [ aMagmaCollectionReader size = localCollection size ].	"build work collections, sortedHashValues and localEntries."	index := aMagmaCollectionReader sortIndex.	sortedHashValues := (localCollection collect: [ : each | index indexHashFor: each ]) asSortedCollection.	localEntries := Dictionary new.	localCollection do: 		[ : each | 		(localEntries 			at: (index indexHashFor: each)			ifAbsentPut: [ Bag new ]) add: each ].	"now verify the reader using at:"	1 		to: sortedHashValues size		do: 			[ : x1 | 			| indexHashFromMagmaCollection indexedObject |			indexedObject := aMagmaCollectionReader at: x1.			indexHashFromMagmaCollection := index indexHashFor: indexedObject.			self should: [ (sortedHashValues at: x1) = indexHashFromMagmaCollection ].			self should: 				[ ((localEntries at: indexHashFromMagmaCollection) occurrencesOf: indexedObject) = 1 ] ].	"verify reader"	largeCollection := OrderedCollection new.	aMagmaCollectionReader do: [ : each | largeCollection add: each ].	1 		to: sortedHashValues size		do: 			[ : x2 | 			self should: 				[ (sortedHashValues at: x2) = (index indexHashFor: (largeCollection at: x2)) ].			self should: 				[ ((localEntries at: (sortedHashValues at: x2)) occurrencesOf: (largeCollection at: x2)) = 1 ] ]! !!MagmaTestCase methodsFor: 'test add index and objects simultaneously' stamp: 'cmm 11/9/2011 21:57'!addIndexAndObjectsSimultaneously	| c |	c := MagmaCollection new		addIndex: (MaKeywordIndex attribute: #name) ;		yourself.	(MaFixtureFactory new newPersons: 1) do:		[ : each |		c add: each ].	clientSession commit:		[ clientSession root 			at: 'testAddIndexAndObjectsSimultaneously'			put: c ]! !!MagmaTestCase methodsFor: 'test add index and objects simultaneously' stamp: 'cmm 6/24/2007 23:22'!testAddIndexAndObjectsSimultaneously	"There was a bug once where adding an new index along with new objects would cause the new objects to be indexed twice.  This ensures that remains fixed."	self 		remotePerform: #addIndexAndObjectsSimultaneously		in: 'client1'.	timeToVerifyRestore := self 		remotePerform: #verifyAddedCollectionAndIndex		in: 'client2'! !!MagmaTestCase methodsFor: 'test add index and objects simultaneously' stamp: 'cmm 11/9/2011 21:59'!verifyAddedCollectionAndIndex	| reader |	clientSession abort.	reader := (clientSession root at: 'testAddIndexAndObjectsSimultaneously') where: 		[ : r | 		r 			read: #name			from: 'A' ].	self should: [ reader size = 1 ].	self addVerifyRestorePrerequisite: #verifyAddedCollectionAndIndex.	^ self calculateTimeToVerifyRestore! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 5/24/2010 16:38'!addIndexAndVerify	| mc |	self assert: original34990 key = 34990.	mc := clientSession root at: 'BuildIndexCommitConflictTest_mc'.	mc addIndex: (MaIntegerIndex attribute: #key).	clientSession commit.	"addIndex caused many transaction-boundary crossings."	self assert: original34990 key = 34991.	self assert: (mc where: [ : each | each key equals: 34990 ]) size = 0.	self assert: (mc where: [ : each | each key equals: 34991 ]) size = 1! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/22/2007 12:03'!changePerson1	| person |	clientSession begin.	person := (clientSession root at: 'people') first.	person name first: 'elizabeth'.	localRoot 		at: 'performCommitAndRefreshTest'		put: person! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2009 16:14'!commitAndHandleFailure	self should: 		[ 		[ clientSession commit.		false ] 			on: MagmaCommitConflictError			do: 				[ : exception | 				| fixture |				fixture := localRoot at: #testTransactions.				self					should: [ exception result commitConflicts size = 1 ] ;					should: 						[ exception result commitConflicts first conflictingConnection userId = 'client1' ] ;					should: 						[ exception result commitConflicts first conflictingObjects asArray = {  (3 -> 'Three' -> (3 -> 'Threee'))  } ] ;					should: [ (fixture at: 3) = (3 -> 'Three') ] ;					should: [ (fixture at: 4) = (4 -> 'Four') ].				true ] ].	"client2 has observed the changes, decides they are good and will commit her 4->'Four' change."	"But we have to do begin first because we are using a manual commit pattern.  If we had used commitAndBegin: true, then we would not need to do begin now."	clientSession		begin ;		commit! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2009 15:25'!createCommitConflictFixture	| fixture |	fixture := (1 to: 6) collect: [ : n | n -> n asWords ].	clientSession		abort ;		commit: 			[ clientSession root 				at: #testTransactions				put: fixture ].	localRoot 		at: #testTransactions		put: fixture	"avoid gc"! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 5/24/2010 16:37'!initializeBuildIndexCommitConflictTest	| objects |	objects := (100 		to: 35000		by: 5) collect: [ : n | n -> n asWords ].	clientSession commit: 		[ clientSession root			at: 'BuildIndexCommitConflictTest_objects'				put: objects ;			at: 'BuildIndexCommitConflictTest_mc'				put: 					(MagmaCollection new						addAll: objects ;						yourself) ].	clientSession begin.	"Prevent garbage collection."	original34990 := objects at: 6979! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 10/8/2012 13:52'!makeSameChangesAsOtherClient	| fixture |	clientSession begin.	fixture := clientSession root at: #testTransactions.	fixture do:		[ : eachAssoc | | val |		val := eachAssoc value.		eachAssoc			 value: eachAssoc key ;			 key: val ]! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/14/2007 22:22'!performBuildIndexCommitConflictTest	self		remotePerform: #initializeBuildIndexCommitConflictTest			in: 'client1' ;		remotePerform: #update34990			in: 'client2' ;		remotePerform: #addIndexAndVerify			in: 'client1'! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2009 15:32'!performCommitConflictTest	self		remotePerform: #createCommitConflictFixture			in: 'client2' ;		remotePerform: #updateThree			in: 'client1' ;		remotePerform: #updateThreeAndFour			in: 'client2' ;		remotePerform: #commit			in: 'client1' ;		remotePerform: #commitAndHandleFailure			in: 'client2' ;		remotePerform: #verifyHasClient2Changes			in: 'client1'! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 10/8/2012 13:50'!performPseudoConflictTest	"Test the servers ability to analyze the nature of a commit conflict so that, if the conflicting object was changed by more than one client to exactly the same structure, no conflict is raised."	self				remotePerform: #makeSameChangesAsOtherClient		in: 'client1' ;				remotePerform: #makeSameChangesAsOtherClient		in: 'client2' ;				remotePerform: #commit		in: 'client1' ;				remotePerform: #commit		in: 'client2'! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 7/7/2009 22:41'!testGetServerStatistics	"For now, just see if we can retrieve the console statistics"	| session serverStats |	session := self newSessionAt: self class magmaServerLocation.	serverStats := session serverStatisticsPrimary.	self assert: serverStats class = MagmaServerStatistics.	self assert: (serverStats historys allSatisfy: [ : each | (each instVarNamed: 'timer') isNil ])! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 10/8/2012 14:02'!testTransactions	"This tests Magma's transaction processing, its ability to detect and handle commit conflicts."	self		performCommitConflictTest ;		performBuildIndexCommitConflictTest ;		performPseudoConflictTest! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2007 23:55'!update34990	clientSession commit: 		[ ((clientSession root at: 'BuildIndexCommitConflictTest_objects') at: 6979) key: 34991 ]! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2009 15:47'!updateThree	| fixture |	clientSession		abort ;		begin.	fixture := localRoot 		at: #testTransactions		put: (clientSession root at: #testTransactions).	(fixture at: 3) value: 'Three'! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 7/10/2009 17:34'!updateThreeAndFour	| fixture |	fixture := localRoot at: #testTransactions.	(fixture at: 3) value: 'Threeeeee'.	clientSession abort.	self assert: (fixture at: 3) value = 'three'.	clientSession begin.	"Even if it was changed to the same value, it is still a commit-conflict.  It is quick and easy for server to detect commit-conflicts that way."	"We purposely mis-spell it so that, after client2 commitAndHandleFailure, each client can verify final state:  correctly-spelled Three."	(fixture at: 3) value: 'Threee'.	(fixture at: 4) value: 'Four'! !!MagmaTestCase methodsFor: 'test transactions' stamp: 'cmm 6/4/2009 16:24'!verifyHasClient2Changes	| fixture |	fixture := localRoot at: #testTransactions.	self assert: (fixture at: 4) = (4 -> 'four').	clientSession abort.	self assert: (fixture at: 4) = (4 -> 'Four')! !!MagmaTestCase methodsFor: 'test commit object knot' stamp: 'cmm 10/22/2004 15:55'!addKnot	| root |	root := clientSession root.	clientSession commit:		[ | knot |		knot := root			at: 'a knotty object'			put: MaFixtureFactory new knot.		root			at: 'knotty object sizes'			put: (knot collect: [ : e | e size ]) ].	^nil! !!MagmaTestCase methodsFor: 'test commit object knot' stamp: 'cmm 9/13/2004 00:23'!verifyKnot	| sizes |	self clientSession abort.  "refresh view"	sizes := self clientSession root at: 'knotty object sizes'.	(self clientSession root at: 'a knotty object') withIndexDo:		[ : e : index |		e printString.		self should: [ e size = (sizes at: index) size ] ].	^nil! !!MagmaTestCase methodsFor: 'test commit object knot' stamp: 'cmm 9/13/2004 14:52'!xtestCommitKnot	"This method tests Magma's ability to commit a tangled knot of an	object structure by one client, then retrieved and compared, as	best as possible, against a dynamically created version of the	same knot in client2 (see MaObjectGraphComparer for this)."	self remotePerform: #addKnot in: 'client1'.	self remotePerform: #verifyKnot in: 'client2'! !!MagmaTestCase methodsFor: 'test Symbol canonicalization' stamp: 'cmm 10/20/2014 17:50'!addNewSymbolViaPath1	self deny: (clientSession definition symbols includes: #newSymbol19283746).	clientSession commit:		[ (clientSession root at: #testSymbolCanonicalization) first			instVarNamed: 'unused'			put: #newSymbol19283746 ].	self assert: (clientSession definition symbols includes: #newSymbol19283746)! !!MagmaTestCase methodsFor: 'test Symbol canonicalization' stamp: 'cmm 10/27/2014 09:56'!addNewSymbolViaPath2AndVerify	| persons |	self		 deny: (clientSession definition symbols includes: #newSymbol19283746) ;		 assert: (MaOidCalculator isOidForNewObject: (clientSession oidFor: #newSymbol19283746)).	persons := localRoot at: #testSymbolCanonicalization."	self assert: (persons first instVarNamed: 'unused') maIsMutatingProxy."	persons last		instVarNamed: 'unused'		put: #newSymbol19283746.	clientSession commit.	self assert: (clientSession definition symbols includes: #newSymbol19283746).	localRoot := Dictionary new! !!MagmaTestCase methodsFor: 'test Symbol canonicalization' stamp: 'cmm 10/20/2014 17:50'!initSymbolContainer	self deny: (clientSession definition symbols includes: #newSymbol19283746).	clientSession commit:		[ clientSession root			at: #testSymbolCanonicalization			put: {MagmaContact new.  MagmaContact new} ]! !!MagmaTestCase methodsFor: 'test Symbol canonicalization' stamp: 'cmm 10/20/2014 13:39'!oidOfNewSymbol	^ clientSession oidFor: #newSymbol19283746! !!MagmaTestCase methodsFor: 'test Symbol canonicalization' stamp: 'cmm 10/27/2014 09:25'!testSymbolCanonicalization	self		remotePerform: #initSymbolContainer in: 'client1' ;		remotePerform: #makeSureSymbolContainerMaterialized in: 'client2' ;		remotePerform: #addNewSymbolViaPath1 in: 'client1' ;		remotePerform: #addNewSymbolViaPath2AndVerify in: 'client2'.	self assert:		(self			remotePerform: #oidOfNewSymbol in: 'client1')			= (self remotePerform: #oidOfNewSymbol in: 'client2')! !!MagmaTestCase methodsFor: 'test concurrency' stamp: 'cmm 7/16/2009 16:05'!addObjectsForConcurrencyTest	| oc mc |	clientSession refresh.	oc := clientSession root at: 'testConcurrency_oc'.	mc := clientSession root at: 'testConcurrency_mc'.	"Add the skipped element."	clientSession commit: [ mc add: (oc at: 5) ]! !!MagmaTestCase methodsFor: 'test concurrency' stamp: 'cmm 6/4/2009 15:11'!changeAddedObjects	"If this doesn't signal a commit error, then verifyFifthElement better work."	| commitConflicts |	[ clientSession noteOldKeysFor: fifthElement.	fifthElement key: 14.	clientSession commit ] 		on: MagmaCommitConflictError		do: [ : err | commitConflicts := err result commitConflicts ].	self assert: commitConflicts notNil.	self assert: commitConflicts size = 1.	self assert: commitConflicts anyOne conflictingObjects size = 1.	self assert: commitConflicts anyOne conflictingObjects anyOne key == fifthElement! !!MagmaTestCase methodsFor: 'test concurrency' stamp: 'cmm 5/24/2010 16:37'!initializeIndexedCollectionForConcurrencyTest	| mc oc |	oc := OrderedCollection new.	mc := MagmaCollection new		addIndex: (MaIntegerIndex attribute: #key) ;		yourself.	1 		to: 500		by: 3		do: 			[ : n | 			n -> n asWords in: 				[ : obj | 				"skip the fifth element for the MagmaCollection, we'll add it later."				n = 13 ifFalse: [ mc add: obj ].				oc add: obj ] ].	clientSession commit: 		[ clientSession root			at: 'testConcurrency_mc'				put: mc ;			at: 'testConcurrency_oc'				put: oc ].	fifthElement := oc at: 5.	clientSession begin! !!MagmaTestCase methodsFor: 'test concurrency' stamp: 'cmm 8/14/2007 21:12'!testConcurrency	"This tests the ability of Magma to correctly detect a commit conflict when an already-persistent object is added or removed, and another client then changes its indexed values."	self 		remotePerform: #initializeIndexedCollectionForConcurrencyTest in: 'client1' ;		remotePerform: #addObjectsForConcurrencyTest in: 'client2' ;		remotePerform: #changeAddedObjects in: 'client1' ;		remotePerform: #verifyFifthElement in: 'client2'! !!MagmaTestCase methodsFor: 'test concurrency' stamp: 'cmm 8/18/2007 20:07'!verifyFifthElement	| mc reader |	mc := clientSession abort root at: 'testConcurrency_mc'.	reader := mc where: [ : each | each key = 14 ].	self assert: reader isEmpty.	reader := mc where: [ : each | each key = 13 ].	self assert: reader size = 1! !!MagmaTestCase methodsFor: 'test objects' stamp: 'cmm 7/30/2015 23:36'!addSamples	clientSession commit: 		[ clientSession root 			at: 'samples'			put: MaFixtureFactory new samples ].	"Test that all kinds of the samples can withstand the potential refresh or not."	clientSession abort! !!MagmaTestCase methodsFor: 'test objects' stamp: 'cmm 10/22/2004 15:55'!peopleSample1	^MaFixtureFactory current newPersons: 3! !!MagmaTestCase methodsFor: 'test objects' stamp: 'cmm 9/13/2004 00:21'!testSamples	self remotePerform: #addSamples in: 'client1'.	self remotePerform: #verifySamples in: 'client2'! !!MagmaTestCase methodsFor: 'test objects' stamp: 'cmm 2/3/2005 23:59'!verifySamples	| newSamples materializedSamples |	clientSession abort.	newSamples := MaFixtureFactory new samples.	(materializedSamples := clientSession root at: 'samples') keysAndValuesDo:		[ : eachSelector : eachSamples |		eachSamples with: (newSamples at: eachSelector) do:			[ : eachMaterialized : eachNew |			self should: [ eachMaterialized maEquivalentForSerializationTest: eachNew ] ] ].	(newSamples at: #specialGlobalCollections)		with: (materializedSamples at: #specialGlobalCollections)		do:			[ : eachInImage : eachMaterialized |			self should: [ eachInImage == eachMaterialized ] ]! !!MagmaTestCase methodsFor: 'test querys - persistent populated' stamp: 'cmm 8/6/2006 23:08'!addSomeRemoveSome: aCollectionOrMagmaCollection 	"For the most-effective tests, we should combine all the most complicated scenarios."	self initializeNonPersistentSamples.	"add some non-persistent objects"	aCollectionOrMagmaCollection addAll: nonPersistentSamples.	"remove some persistent members"	(1 		to: samples size		by: 29) do: [ : n | aCollectionOrMagmaCollection remove: (self sampleAt: n) ].	"remove some of the non-persistent members (that we added in step1)"	1 		to: nonPersistentSamples size		by: 29		do: [ : n | aCollectionOrMagmaCollection remove: (nonPersistentSamples at: n) ]! !!MagmaTestCase methodsFor: 'test querys - persistent populated' stamp: 'cmm 12/23/2012 17:45'!createPersistentPopulated	| mc |	self initializeSamples.	mc := self newMc.	clientSession commit: 		[ clientSession root 			at: 'testPersistentPopulated'			put: mc ].	"This commit can take a bit on a slow machine."	clientSession 		setTimeoutSecondsTo: 240		during: [ clientSession commit: [ self load: mc ] ].	samplesInMc := samples copy asSet! !!MagmaTestCase methodsFor: 'test querys - persistent populated' stamp: 'cmm 8/4/2009 11:20'!testPersistentPopulated	self		remotePerform: #createPersistentPopulated			in: 'client1' ;		remotePerform: #updateAndVerify			in: 'client2'! !!MagmaTestCase methodsFor: 'test querys - persistent populated' stamp: 'cmm 8/4/2009 11:20'!updateAndVerify	| mc oc |	mc := clientSession refresh root at: 'testPersistentPopulated'.	samplesInMc := (mc asArray: mc size) asSet.	self		initializeSamples ;		initializeNonPersistentSamples.	samplesInMc addAll: nonPersistentSamples.	oc := OrderedCollection new: samples size.	self		load: oc ;		addSomeRemoveSome: mc ;		addSomeRemoveSome: oc.	"changeSomeKeysIn: mc do: [ : each | clientSession noteOldKeysFor: each ] ;		changeSomeKeysIn: oc do: [ : each | ];"	self 		verifyMc: mc		against: oc! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/6/2005 23:11'!addToMcFrom: aClass at: aString	| mc |	mc := clientSession root at: aString.	aClass withAllSubclassesDo: [ : each | clientSession commit: [ mc add: each maCommentKeywords -> each name ] ]! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/8/2005 21:39'!buildExistingObjectsForCommitDisaster	clientSession commit:		[ clientSession root			at: 'existing-objects for commitDisaster'			put:				((500 to: 600) collect: [ : e | e printString -> Object new ]).		clientSession root			at: 'object to grow for commitDisaster'			put: ((OrderedCollection new: 2) add: 1; add: 2; yourself) ]! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/7/2005 13:11'!buildIndexedMagmaCollectionFrom: aClass at: aString	| indexDef mc |	mc := MagmaCollection new.	indexDef := self newKeywordIndex.	mc addIndex: indexDef.	clientSession commit: [ clientSession root at: aString put: mc ].	self		addToMcFrom: aClass		at: aString! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/6/2005 23:05'!buildMagmaArray	| ma |	ma := MagmaArray new.	1 to: 100 do: [ : e | ma at: e put: e printString ].	clientSession commit:		[ clientSession root			at: 'existing-MagmaArray for commitDisaster'			put: ma ]! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 9/12/2007 21:52'!cacheFlushFrequency: numberOfSeconds 	magmaConsole controller cacheFlushFrequency: numberOfSeconds! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 1/4/2013 16:27'!captureFileChecksumsWithCopy: aBoolean 	| answer |	magmaConsole shutdown.	(aBoolean and: [ MagmaServerPreferences debugRecovery ]) ifTrue: [ self copyDb ].	answer := self fileChecksums.	magmaConsole open: self environmentDirectory.	magmaConsole processOn: self class defaultServerPort.	^ answer! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 5/25/2007 00:04'!commitDisaster	"simulate an outage at the worst-possible time; after a commit which includes added and removed keys of an existing MagmaCollection (with index) and MagmaArray, some, new objects, a new class-def so it changes that part of its definition too, and a new MagmaArray (to test it removes files).  Just after has written the applied the commit to all the various files, it then exits the image without saving and without having written the end-apply tag record.  This will exercise all file types."	| existingCollection reader newStuff existingArray |	clientSession begin.	existingCollection := clientSession root at: 'existing-collection for commitDisaster'.	reader := existingCollection where: 		[ : rdr | 		rdr 			read: #key			from: 'x'			to: 'z' ].	self should: [ reader size > 1	"let's ensure at least a couple of removes to test" ].	"remove a bunch.."	reader asOrderedCollection do: [ : each | existingCollection remove: each ].	"now add a bunch of new stuff."	Number withAllSubclassesDo: 		[ : each | 		existingCollection add: each maCommentKeywords -> each name ].	"Update the MagmaArray, extending its length.."	existingArray := clientSession root at: 'existing-MagmaArray for commitDisaster'.	50 		to: 150		do: 			[ : each | 			existingArray 				at: each				put: '#' , each printString ].	"Create some new objects."	newStuff := OrderedCollection new.	newStuff		add: MagmaArray new ;		add: ((1 to: 100) collect: 				[ : each | 				"at the time this test runs, this should be a new class too."				Object new ]).	"Update some old objects."	(clientSession root at: 'existing-objects for commitDisaster') do: 		[ : eachAssociation | 		| temp |		temp := eachAssociation key.		eachAssociation key: eachAssociation value.		eachAssociation value: temp ].	(clientSession root at: 'object to grow for commitDisaster') addAll: (3 to: 10).	"Now do the fatal commit.."	clientSession root 		at: 'this key should NOT exist!!'		put: newStuff.	clientSession commit! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 7/16/2007 22:09'!copyDb	"This method is used only to assist with debugging problems with recovery."	| location targetDir |	location := magmaConsole controller localLocation.	targetDir := FileDirectory on: (location directory containingDirectory fullNameFor: location directory localName , 'Copy').	targetDir assureExistence.	[ MagmaRepositoryController delete: targetDir pathName ] 		on: MagmaDeleteWarning		do: [ : warning | warning resume ].	location fileNames do: 		[ : each | 		location directory 			maCopyFileNamed: each			toDirectory: targetDir ]! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/13/2007 21:16'!fileChecksums	| answer location sha |	answer := Dictionary new.	sha := SecureHashAlgorithm new.	location := magmaConsole controller localLocation.	location fileNames do: 		[ : eachFilename | 		| file |		({  '.images'.  MaRecoveryManager commitLogExtension } anySatisfy: [ : eachExtension | eachFilename endsWith: eachExtension ]) ifFalse: 			[ file := (location directory readOnlyFileNamed: eachFilename) binary.			answer 				at: eachFilename				put: (sha hashStream: file).			file close ] ].	^ answer! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 8/17/2005 19:10'!newKeywordIndex	^ MaKeywordIndex attribute: #key  "key of an Association"! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 6/6/2005 21:59'!setSimulateServerOutage: aBoolean	MaObjectRepository simulateOutage: true! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 9/15/2013 16:43'!testRollbackRecovery	"- shutdown server.  Wait for shutdown.	- build a Dictionary of filenames and their contents-hash using SecureHashAlgorithm.	- simulate an outage in the middle of a juicy commit which includes added and removed keys to an existing MagmaCollection, and MagmaArray, new objects, a new class-def, and a new MagmaCollection (so we test it remove files.	- wait for server to stop responding	- restart server image, recovery will happen AUTOMATICALLY!!	- wait for server to respond.	- shutdown server.	- use same method to build another Dictionary of the filenames->contents-hashes	- assert: the first Dictionary = the second."	| initialHashes postHashes |	self		remotePerform: #buildIndexedMagmaCollectionFrom:at:		withArguments: {Collection. 			'existing-collection for commitDisaster'}		in: 'client1'.	self		remotePerform: #buildExistingObjectsForCommitDisaster		in: 'client2'.	self		remotePerform: #buildMagmaArray		in: 'client1'.	self disconnectClients.	initialHashes := self		remotePerform: #captureFileChecksumsWithCopy:		with: true		in: 'server'.	self connectClients.	self		remotePerform: #setSimulateServerOutage:		withArguments: {true}		in: 'server'.	self		remotePerform: #commitDisaster		in: 'client2'.	self waitForServerDown: 'server'.	(self playerLinkNamed: 'server')		 disconnect ;		 launch ;		 waitForReady.	self		remotePerform: #startServer:		with: true		in: 'server'.	self		remotePerform: #assertPotentiallyOpenSignaled		in: 'server'.	postHashes := self		remotePerform: #captureFileChecksumsWithCopy:		with: false		in: 'server'.	self assert: initialHashes = postHashes.	"Since we killed the server, we know we must reconnect the clients."	self		 disconnectClients ;		 connectClients.	self suite initiateBackupPrereqsCompleted add: #testRollbackRecovery! !!MagmaTestCase methodsFor: 'test rollback recovery' stamp: 'cmm 1/5/2013 10:31'!waitForServerDown: serverNameString 	| player |	player := suite orchestra playerNamed: serverNameString.	[ (Delay forSeconds: 2) wait.	player isReady ] whileTrue: [ MaTestCaseNotification signal: 'Waiting for server to shutdown..' ]! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/3/2013 14:41'!addVerifyRestorePrerequisite: aSymbol 	self suite verifyRestorePreqreqsCompleted add: aSymbol! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/4/2013 16:21'!backupDirectory	^ self environmentDirectory / '_test_magma_backup'! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/3/2013 14:41'!calculateTimeToVerifyRestore	^ self requiredPrereqsToVerifyRestore = self suite verifyRestorePreqreqsCompleted! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 10/26/2014 15:24'!clientSession: aMagmaSession 	clientSession := aMagmaSession.	clientSession		allowWriteBarrier: self class allowWriteBarrier ;		immutabilityStrategy: MaImmutabilityStrategy new ;		allowLongCatchUp: true ;		timeoutSeconds: 172800 "2 days"! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 8/1/2007 22:16'!copyCommitLogsToBackup	| sourceDir targetDir |	magmaConsole controller archiveCommitLog.	sourceDir := magmaConsole controller commitLogDirectory.	targetDir := (FileDirectory on: (self backupDirectory fullNameFor: MaRecoveryManager commitLogDirectoryName)) assureExistence.	sourceDir fileNames do: 		[ : each | 		sourceDir 			maCopyFileNamed: each			toDirectory: targetDir ].	^ magmaConsole controller commitNumber! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 3/5/2009 12:43'!fullBackup	self fullBackupTo: self backupDirectory fullName! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 5/15/2011 15:49'!fullBackupTo: pathName 	self class magmaServerLocation newAdminSession modelBackupTo: pathName! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/3/2013 14:31'!initiateBackupIfTime	self suite initiateBackupPrereqsCompleted = self requiredPrereqsToInitiateBackup ifTrue: 		[ self fullBackup.			"Prevent any other backups from being initiated."		self suite initiateBackupPrereqsCompleted add: 'backup initiated' ]! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/4/2013 16:20'!maintDirectory	^ self environmentDirectory / '_test_magma_maint'! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 6/24/2007 23:23'!noteVerifyPersistentResultSetComplete	self addVerifyRestorePrerequisite: #verifyPersistentResultSet.	^ self calculateTimeToVerifyRestore ! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 12/29/2008 13:01'!requiredPrereqsToInitiateBackup	"To do the backup/restore test, we commence the backup only after all of my server-killing-tests are complete because otherwise the backup could be aborted in the middle."	^ Set 		with: #testRollbackRecovery		with: #testForwardRecovery! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 7/1/2007 21:58'!requiredPrereqsToVerifyRestore	"Answer the tests which must have completed before verifyRestore can be run."	^ #(		#verifyCollectionAndReader		#verifyAddedCollectionAndIndex		#verifyPersistentResultSet	) asSet! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 1/18/2014 18:00'!restoreVerifications	"Answer the selectors of the verification methods we will use to ensure the restored backup looks equivalent to the original."	^ self requiredPrereqsToVerifyRestore , #(			#verifySamples			#verifyTestSet			#verifyDoubleUpdate			#verifyMagmaCollectionAndIndexCreatedSimultaneously			#verifyUpdateByteObjects			#readAndVerifyGrownObject			#verifyReferenceToSession			#verifyMagmaStatFinalState		)! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 7/7/2009 22:43'!verifyRestore	"A backup was performed a long time ago at the beginning of the test suite.  Since then, commit.log files have been written.  Now lets apply all of those files to the backup and verify lots of things are correct just like they are in the original."	"Close the current commit log, so we know it we'll be caught up to the second."	| backupSession verifier recoveryOccurred correctCommitNumber |	recoveryOccurred := false.	correctCommitNumber := self 		remotePerform: #copyCommitLogsToBackup		in: 'server'."Encountered situation where, even though destination files were closed, they were not yet flushed, resulting in a recovery failure.  Give it five seconds, should be more than enough time."(Delay forSeconds: 5) wait.	[ backupSession := MagmaSession openLocal: self backupDirectory fullName ] 		on: MagmaForwardRecoveryNeeded		do: 			[ : warning | 			recoveryOccurred := true.			warning resume: true ].	self assert: recoveryOccurred.	self assert: correctCommitNumber = backupSession repositoryController commitNumber.	backupSession connectAs: 'restore verifier'.	self 		should: [ backupSession begin ]		raise: MagmaUserError.	backupSession abort.	verifier := self class new clientSession: backupSession.	self restoreVerifications do: [ : each | verifier perform: each ].	backupSession repositoryController commitRestore.	backupSession		begin ;		commit.	"Ok, I'm satisfied."	backupSession disconnectAndClose! !!MagmaTestCase methodsFor: 'test backup/restore' stamp: 'cmm 2/24/2009 15:44'!verifyRestoreIfTime"	timeToVerifyRestore ifTrue: [ self verifyRestore ]."	timeToVerifyRestore ifTrue: [ self verifyHaFunctionality ]! !!MagmaTestCase methodsFor: 'test advance' stamp: 'cmm 12/22/2008 17:01'!advanceAndVerify	clientSession tryToRefreshTo: clientSession remoteCommitNumber.	self assert: objectToAdvance first = 'object changed'! !!MagmaTestCase methodsFor: 'test advance' stamp: 'cmm 8/13/2008 00:12'!changeObjectToAdvance	clientSession commit: [ (clientSession root at: #testAdvance) at: 1 put: 'object changed' ]! !!MagmaTestCase methodsFor: 'test advance' stamp: 'cmm 8/13/2008 00:10'!initTestAdvance	clientSession commit: 		[ clientSession root 			at: #testAdvance			put: (Array with: String new) ]! !!MagmaTestCase methodsFor: 'test advance' stamp: 'cmm 8/4/2009 11:24'!referenceObjectToAdvance	objectToAdvance := (clientSession refresh root at: #testAdvance) ! !!MagmaTestCase methodsFor: 'test advance' stamp: 'cmm 8/13/2008 00:05'!testAdvance	self		remotePerform: #initTestAdvance			in: 'client1' ;		remotePerform: #referenceObjectToAdvance			in: 'client2' ;		remotePerform: #changeObjectToAdvance			in: 'client1' ;		remotePerform: #advanceAndVerify			in: 'client2'! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:23'!assertMc: aMagmaCollectionReader equals: anOrderedCollection 	| sc |	[ aMagmaCollectionReader sortComplete ] whileFalse: 		[ self notify: 'sort is ' , (aMagmaCollectionReader fractionSorted * 100 asFloat truncateTo: 1) asString , ' complete.'.		(Delay forSeconds: 1) wait ].	sc := anOrderedCollection asSortedCollection: aMagmaCollectionReader sortBlock.	self 		verifyOrder: aMagmaCollectionReader		against: sc! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/18/2006 22:56'!assertMc: aMagmaCollectionReader includesAll: anOrderedCollection 	"We cannot assume sizes will be equal because select: does not include element once for each qualifying clause like readers do.."	self assert: ((aMagmaCollectionReader asArray: aMagmaCollectionReader size) maIncludesAll: anOrderedCollection)! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:23'!load: aCollection 	self 		load: aCollection		from: 1		to: samples size! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:24'!load: aCollection from: startIndex to: endIndex	startIndex to: endIndex do:		[ : x |		aCollection add: (samples at: x) ]! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:23'!newMc	"Create a new MagmaCollection with the four indexes used for all the tests."	^ MagmaCollection new		addIndex: (MaIntegerIndex attribute: #first) ;		addIndex: (MaDateIndex attribute: #second) ;		addIndex: (MaKeywordIndex attribute: #third) ;		yourself! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:23'!random	"Use a specific random so we get consistent results."	^ Random seed: 51969! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/18/2006 22:56'!verifyMc: aMagmaCollection against: anOrderedCollection 	self 		assertMc: aMagmaCollection		includesAll: anOrderedCollection.	self whereAndSelectBlockPairs do: 		[ : eachPair | 		self 			verifyWhere: eachPair first			from: aMagmaCollection			withSelect: eachPair second			from: anOrderedCollection ]! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/11/2006 23:24'!verifyOrder: aMagmaCollectionReader against: aSortedCollection 	self assert: aMagmaCollectionReader size = aSortedCollection size.	self assert: (aMagmaCollectionReader asArray: aMagmaCollectionReader lastKnownSize) = aSortedCollection asArray! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 7/18/2006 22:56'!verifyWhere: mcSelectBlock from: aMagmaCollection withSelect: ocSelectBlock from: anOrderedCollection 	| reader subcollection |	reader := aMagmaCollection where: mcSelectBlock.	subcollection := anOrderedCollection select: ocSelectBlock.	reader isSorted 		ifTrue: 			[ self 				assertMc: reader				equals: subcollection ]		ifFalse: 			[ self 				assertMc: reader				includesAll: subcollection.			#(#first #second ) do: 				[ : each | 				| sortedReader |				sortedReader := reader 					sortBy: each					makeDistinct: true.				self 					assertMc: sortedReader					equals: subcollection.				sortedReader descend.				self 					assertMc: sortedReader					equals: subcollection ] ]! !!MagmaTestCase methodsFor: 'private-querys tests' stamp: 'cmm 8/21/2006 12:17'!whereAndSelectBlockPairs	"Answer a collection of two-element Arrays.  The first-element of each Array is the where block, the second is the corresponding select block.  These are used to verify MagmaCollection(Readers) against the Smalltalk collections."	^ { 		(Array 			with: 				[ : reader | 				(reader 					read: #first					from: 3999					to: 4999) & (reader 						read: #second						from: '3/1/2006' asDate						to: '4/1/2015' asDate) ]			with: 				[ : each | 				(each first 					between: 3999					and: 4999) & (each second 						between: '3/1/2006' asDate						and: '4/1/2015' asDate) ]).		"disjunction, > one-page of results"		(Array 			with: 				[ : reader | 				(reader 					read: #first					from: 3999					to: 4999) | (reader 						read: #second						from: '3/1/2006' asDate						to: '4/1/2015' asDate) ]			with: 				[ : each | 				(each first 					between: 3999					and: 4999) | (each second 						between: '3/1/2006' asDate						and: '4/1/2015' asDate) ]).		"0 results"		(Array 			with: [ : reader | reader read: #first at: 3005 ]			with: [ : each | each = 3005 ]).		"complex (MaExpression composition), with keywords"		(Array 			with: 				[ : reader | 				(reader 					read: #third					from: 'ma'					to: 'p') | ((reader 						read: #first						from: 3999						to: 4999) | (reader 							read: #second							from: '3/1/2006' asDate							to: '4/1/2015' asDate)) ]			with: 				[ : each | 				(each third anySatisfy: 					[ : any | 					"sigh, must match keyword index strippage of out-off-range characters.."					(any asUppercase select: [ : e | e asciiValue between: 33 and: 96])						between: 'MA'						and: 'P' ]) | ((each first 						between: 3999						and: 4999) | (each second 							between: '3/1/2006' asDate							and: '4/1/2015' asDate)) ])	 }! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 12/13/2016 20:44'!assertTypes: aMagmaStat 	self		 assert:		(#(#deltaSum #sum #max #min #last ) allSatisfy:			[ : each | (aMagmaStat perform: each) isFloat ]) ;		 assert: aMagmaStat count isInteger ;		 deny: aMagmaStat count > SmallInteger legacyMaxVal ;		 assert: aMagmaStat deltaCount isInteger ;		 deny: aMagmaStat deltaCount isLarge! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/16/2014 17:49'!createStat5And6ThenAdd7Locally	| stat |	stat := MagmaStat new		 addValue: 5 ;		 addValue: 6 ;		 yourself.	self		 assert: (stat equals: (self newStat: #(5 6 ))) ;		 assertTypes: stat.	clientSession commit:		[ clientSession root			at: #testMagmaStat			put: stat ].	self		 assert: (stat equals: (self newStat: #(5 6 ))) ;		 assert: stat deltaSum = 0 ;		 assert: stat deltaCount = 0.0 ;		 assertTypes: stat.	stat addValue: 7.	self		 assert: (stat equals: (self newStat: #(5 6 7 ))) ;		 assert: stat deltaSum = 7.0 ;		 assert: stat deltaCount = 1 ;		 assertTypes: stat.	clientSession begin.	self		 assert: (stat equals: (self newStat: #(5 6 7 ))) ;		 assert: stat deltaSum = 7.0 ;		 assert: stat deltaCount = 1 ;		 assertTypes: stat! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/4/2014 15:02'!newStat: anArray 	^ anArray		inject: MagmaStat new		into: [ : stat : each | stat addValue: each ]! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/4/2014 11:09'!statFixture	^ statFixture ifNil: [ statFixture := clientSession root at: #testMagmaStat ]! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/4/2014 22:46'!testMagmaStat	"- make sure no commit-conflict.- verify value"	self		remotePerform: #createStat5And6ThenAdd7Locally			in: 'client1' ;		remotePerform: #validateStatAndSubtract10			in: 'client2' ;		remotePerform: #validateMergeStat			in: 'client1' ;		remotePerform: #validateStatAfterRefreshAndAbort			in: 'client2'! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/19/2014 19:18'!validateMergeStat	| stat |	stat := self statFixture.	self		assert: (stat equals: (self newStat: #(5 6 7 ))) ;		assert: stat deltaCount = 1 ;		assert: stat deltaSum = 7.0 ;		assertTypes: stat..	clientSession commitAndBegin.	self		assert: (stat equals: (self newStat: #(5 6 -10 7))) ;		assert: stat deltaCount = 0 ;		assert: stat deltaSum = 0.0 ;		assertTypes: stat.	stat merge: (self newStat: #(1 2 3 4 )).	self		assert: (stat equals: (self newStat: #(5 6 "7 is last value added" -10 1 2 3 4 7))) ;		assert: stat deltaCount = 4 ;		assert: stat deltaSum = 10.0 ;		assertTypes: stat.	clientSession commit.	self		assert: (stat equals: (self newStat: #(5 6 "7 is last value added" -10 1 2 3 4 7))) ;		assert: stat deltaCount = 0 ;		assert: stat deltaSum = 0.0 ;		assertTypes: stat.	"Later want to create a new statFixture rather than keep using this one."	statFixture := nil! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/19/2014 19:18'!validateStatAfterRefreshAndAbort	"Refreshing a MagmaStat behaves as expected:  local changes are kept, remote changes are merged.  So, the (1 2 3 4) should be 'integrated' after the refresh."	| stat |	stat := self statFixture.	self		 assert: (stat equals: (self newStat: #(5 6 -10 ))) ;		 assert: stat deltaCount = 0 ;		 assert: stat deltaSum = 0.0 ;		 assertTypes: stat.	self statFixture		 addValue: -13 ;		 addValue: -14.	self		 assert: (self statFixture equals: (self newStat: #(5 6 -10 -13 -14 ))) ;		 assert: stat deltaCount = 2 ;		 assert: stat deltaSum = -27.0 ;		 assertTypes: stat.	clientSession refresh.	self		 assert: (stat equals: (self newStat: #(5 6 -10 1 2 3 4 7 -13 -14 ))) ;		 assert: stat deltaCount = 2 ;		 assert: stat deltaSum = -27.0 ;		 assertTypes: stat.	clientSession abort.	self verifyMagmaStatFinalState.	statFixture := nil! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/16/2014 17:49'!validateStatAndSubtract10	"We never crossed a transaction boundary, so we're still just 5 6 7."	| stat |	clientSession begin.	stat := self statFixture.	self		 assert: (stat equals: (self newStat: #(5 6 ))) ;		 assert: stat deltaSum = 0.0 ;		 assert: stat deltaCount = 0 ;		 assertTypes: stat.	stat addValue: -10.0.	self		 assert: (stat equals: (self newStat: #(5 6 -10 ))) ;		 assert: stat deltaSum = -10.0 ;		 assert: stat deltaCount = 1 ;		 assertTypes: stat.	clientSession commit! !!MagmaTestCase methodsFor: 'test MagmaStat' stamp: 'cmm 1/18/2014 18:00'!verifyMagmaStatFinalState	| stat |	stat := self statFixture.	self		 assert: (stat equals: (self newStat: #(5 6 -10 1 2 3 4 7 ))) ;		 assert: stat deltaCount = 0 ;		 assert: stat deltaSum = 0.0 ;		 assertTypes: stat! !!MagmaTestCase methodsFor: 'testBecome' stamp: 'cmm 12/7/2004 14:42'!become	clientSession commit:		[ | array |		(clientSession root at: #testBecomeToTransient) become: { 'new'. 'becomed'. 'array' }.		array := (clientSession root at: #testBecomeToPersistent).		array first become: array last ]! !!MagmaTestCase methodsFor: 'testBecome' stamp: 'cmm 12/7/2004 21:01'!setUpTestBecome	clientSession commit:		[ { localRoot.  clientSession root } do:			[ : each |			each at: #testBecomeToTransient put: { 'non becomed array' }.			each at: #testBecomeToPersistent put: { 'becomer'.  'becomee with different size' } ] ]! !!MagmaTestCase methodsFor: 'testBecome' stamp: 'cmm 12/7/2004 14:42'!verifyBecome	clientSession abort.	self assert: (clientSession root at: #testBecomeToTransient) = { 'new'. 'becomed'. 'array' }.	"remote becomes cannot be detected from transient objects."	self assert: (localRoot at: #testBecomeToTransient) = { 'become to transient' }.	self assert: (clientSession root at: #testBecomeToPersistent) = { 'becomee with different size'.  'becomee with different size' }! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 12/23/2012 17:45'!buildLargeMc	| mc r |	r := Random seed: Time millisecondClockValue.	mc := MagmaCollection new		addIndex: (MaIntegerIndex attribute: #key) ;		addIndex: (MaIntegerIndex attribute: #value) ;		yourself.	"ensure we will have duplicates"	10 thousand timesRepeat: [ mc add: (r nextInt: 5000) -> (r nextInt: 5000) ].	clientSession 		setTimeoutSecondsTo: 5*60		during: 			[ clientSession commit: 				[ clientSession root 					at: #testReleaseReader					put: mc ] ]! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 11/4/2014 20:50'!releaseLuxuryQuery	"Assert still loading."	| finalProgress |	finalProgress := luxuryQueryReader fractionSorted.	self		 assert: finalProgress > 0 ;		 assert: finalProgress < 1.	luxuryQueryReader release.	finalProgress := luxuryQueryReader fractionSorted.	"Wait a few seconds, ensure it does not progress further."	(Delay forSeconds: 5) wait.	self assert: luxuryQueryReader fractionSorted = finalProgress! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 11/10/2010 14:14'!startLuxuryQuery	| mc collectionOid |	clientSession refresh.	mc := clientSession root at: #testReleaseReader.	luxuryQueryReader := mc 		where: 			[ : reader | 			(reader 				read: #key				from: 0				to: 2500) | (reader 					read: #value					from: 0					to: 2500) ]		distinct: true		sortBy: #key		descending: false.	self deny: (MaOidCalculator isOidForNewObject: (collectionOid := clientSession oidFor: luxuryQueryReader collection)).	^ collectionOid! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 1/7/2010 14:55'!testReleaseReader	| collectionOid |	self 		remotePerform: #buildLargeMc		in: 'client1'.	collectionOid := self 		remotePerform: #startLuxuryQuery		in: 'client2'.	self 		remotePerform: #verifyQueryRunning:		with: collectionOid		in: 'server'.	self 		remotePerform: #releaseLuxuryQuery		in: 'client2'.	self 		remotePerform: #verifyQueryCanceled:		with: collectionOid		in: 'server'! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 1/7/2010 13:02'!verifyQueryCanceled: collectionOid 	"The removal of the manager cannot occur until after the next flush.  So, wait *another* 5 seconds just to be extra sure it should have run by now."	(Delay forSeconds: 5) wait.	self deny: (magmaConsole controller repository hasCollectionManagerFor: collectionOid)! !!MagmaTestCase methodsFor: 'test query cancel' stamp: 'cmm 1/5/2010 16:35'!verifyQueryRunning: collectionOid 	| repository collectionManager |	repository := magmaConsole controller repository.	collectionManager := repository 		collectionManagerFor: collectionOid		ifAbsent: [ nil ].	self		assert: collectionManager notNil ;		assert: collectionManager isLoading! !!MagmaTestCase methodsFor: 'test refreshAll' stamp: 'cmm 7/15/2009 14:52'!cacheDormantAndDisconnect	clientSession abort.	dormantObject := clientSession root at: #testRefreshAll.	"Ensure not proxies."	dormantObject do: [ : e | e printString ].	clientSession disconnect! !!MagmaTestCase methodsFor: 'test refreshAll' stamp: 'cmm 9/7/2008 18:12'!createObjectToBeDormantInImage	clientSession commit: 		[ clientSession root 			at: #testRefreshAll			put: { 					((1 to: 10) collect: [ : n | n asWords asLowercase ]).					((11 to: 20) collect: [ : n | n asWords asLowercase ])				 } ]! !!MagmaTestCase methodsFor: 'test refreshAll' stamp: 'cmm 9/7/2008 18:16'!reconnectAndVerifyDormantUpdated	clientSession connectAs: 'client2'.	self should: ((dormantObject at: 1) at: 5) = 'FIVE'.	self should: ((dormantObject at: 2) at: 5) = 'FIFTEEN'.! !!MagmaTestCase methodsFor: 'test refreshAll' stamp: 'cmm 2/11/2008 22:19'!testRefreshAll	self 		remotePerform: #createObjectToBeDormantInImage		in: 'client1'.	self 		remotePerform: #cacheDormantAndDisconnect		in: 'client2'.	self 		remotePerform: #updateDormantObject		in: 'client1'.	self 		remotePerform: #reconnectAndVerifyDormantUpdated		in: 'client2'! !!MagmaTestCase methodsFor: 'test refreshAll' stamp: 'cmm 9/7/2008 18:16'!updateDormantObject	clientSession commit: 		[ | arr |		arr := clientSession root at: #testRefreshAll.		(arr at: 1) 			at: 5			put: 'FIVE'.		(arr at: 2) 			at: 5			put: 'FIFTEEN' ]! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 9/10/2009 20:53'!changeAtIndex50	| ma |	clientSession commit: 		[ (ma := clientSession root at: 'testMagmaArray') 			at: 50			put: 'Fifty (50)' ].	self assert: (ma at: 9) = (9 raisedTo: 2)! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 3/22/2005 13:59'!changeOthers	| ma |	ma := clientSession root at: 'testMagmaArray'.	1 to: 49 do: [ : n | ma at: n put: ((ma at: n) asNumber raisedTo: 2) ].	51 to: 100 do: [ : n | ma at: n put: ((ma at: n) asNumber raisedTo: 2) ].	clientSession commit.  "should be no commit-conflict because client1 only changed index 50."	clientSession begin "prepare for next test"! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 3/20/2005 21:41'!changeSome	clientSession commit:		[ (clientSession root at: 'testMagmaArray')			at: 50			put: 'Fifty' ]! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 3/6/2011 21:37'!createEmptyMagmaArray	clientSession commit:		[ clientSession root			at: #testEmptyMagmaArray			put: MagmaArray new ]! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 3/20/2005 21:37'!createMagmaArray	| ma |	ma := MagmaArray new.	1 to: 100 do: [ : n | ma at: n put: n printString ].	clientSession commit:		[ clientSession root			at: 'testMagmaArray'			put: ma ]! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 5/4/2011 14:42'!testEmptyMagmaArray	self assert: MagmaArray new isEmpty.	self		remotePerform: #createEmptyMagmaArray in: 'client1' ;		remotePerform: #verifyEmptyMagmaArray in: 'client2'		! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 3/20/2005 21:55'!testMagmaArray	self		remotePerform: #createMagmaArray in: 'client1' ;		remotePerform: #verifyMagmaArray in: 'client2' ;		remotePerform: #changeSome in: 'client1' ;		remotePerform: #changeOthers in: 'client2' ;		remotePerform: #changeAtIndex50 in: 'client1' ;		remotePerform: #tryChangingIndex50 in: 'client2'! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 4/15/2011 15:21'!tryChangingIndex50	| ma |	ma := clientSession root at: 'testMagmaArray'.	1 		to: 50		do: 			[ : n | 			ma 				at: n				put: 'this string should not be persistent!!' ].	self should: 		[ 		[ clientSession commit.		false ] 			on: MagmaCommitConflictError			do: 				[ : err | 				self should: [ err result commitConflicts size = 1 ].				self should: 					[ err result commitConflicts first conflictingConnection userId = 'client1' ].				self should: [ err result commitConflicts first conflictingObjects size = 1 ].				self should: 					[ err result commitConflicts first conflictingObjects anySatisfy: [ : each | each key = ma yourself ] ].				true ] ]! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 5/10/2011 17:37'!verifyEmptyMagmaArray	clientSession refresh.	self assert: (clientSession root at: #testEmptyMagmaArray) isEmpty! !!MagmaTestCase methodsFor: 'test MagmaArray' stamp: 'cmm 9/10/2009 20:45'!verifyMagmaArray	| ma |	clientSession abort.	ma := clientSession root at: 'testMagmaArray'.	1 		to: 100		do: [ : n | self should: [ (ma at: n) = n printString ] ].	clientSession begin! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 1/20/2014 21:21'!client2CommitAnyway	"Client 2 should now be kicked off, even if isConnected doesn't know it.  This tests the auto-reconnection."	| arr didRaise |	arr := self getMisbehaveFixture.	self		 assert: clientSession isConnected ;		 assert: clientSession inTransaction ;		 assert: (arr at: 1) value = true ;		 assert: (arr at: 2) value = 'client2 desired change' ;		 assert: (arr at: 3) value = 'client2 gonna-fail change' ;		assert: (((arr at: 4) at: 1) sum = (0-2000) ) ;		assert: (((arr at: 4) at: 2) sum = (0-2000) ) ;		assert: (((arr at: 4) at: 3) sum = (0-2000) ).	didRaise := false.	[ clientSession commit ]		on: MagmaTooFarBehindConflict		do:			[ : err | didRaise := true.			self				 assert: err result conflictingObjects size = 1 ;				 assert: err result conflictingObjects first value value = 'client2 gonna-fail change' ;				 assert: err result conflictingObjects first key value = 'client1 value wins' ;				 assert: err result conflictingObjects first key == (arr at: 3) ;				 assert: (arr at: 1) = ('client1' -> 'client1 final value') ;				assert: (((arr at: 4) at: 1) sum = (1000-2000) ) ;				assert: (((arr at: 4) at: 2) sum = (2000-2000) ) ;				assert: (((arr at: 4) at: 3) sum = (3000-2000) ).			clientSession begin.			err retry ].	self		 assert: didRaise ;		 assert: clientSession isConnected ;		 deny: clientSession inTransaction ;		 assert: (arr at: 1) value = 'client1 final value' ;		 assert: (arr at: 2) value = 'client2 desired change' ;		 assert: (arr at: 3) value = 'client1 value wins' ;		assert: (((arr at: 4) at: 1) sum = (1000-2000) ) ;		assert: (((arr at: 4) at: 2) sum = (2000-2000) ) ;		assert: (((arr at: 4) at: 3) sum = (3000-2000) )! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 1/20/2014 21:17'!do1001Commits	"Client 1 goes crazy on commits, causing client2 to get bumped."	| arr adminSession client2Connections |	arr := self getMisbehaveFixture.	MagmaRepositoryDefinition defaultMaximumNumberOfChallengers timesRepeat:		[ clientSession commit:			[ (arr at: 4) withIndexDo:				[ : eachStat : index | eachStat addValue: index ] ] ].	adminSession := clientSession location newAdminSession.	client2Connections := adminSession connections select: [ : each | each userId = 'client2' ].	self		 assert: client2Connections size = 1 ;		 assert: client2Connections first challengingBytes > 0.	"This one should cause the server to terminate the client2 session."	clientSession commit:		[ (arr at: 1) value: 'client1 final value'.		(arr at: 3) value: 'client1 value wins' ].	client2Connections := adminSession connections select: [ : each | each userId = 'client2' ].	self assert: client2Connections size = 0.	self		 assert: ((arr at: 4) at: 1) sum = 1000 ;		 assert: ((arr at: 4) at: 2) sum = 2000 ;		 assert: ((arr at: 4) at: 3) sum = 3000! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 9/19/2008 10:40'!getMisbehaveFixture	^ clientSession root at: #testMisbehavingSession! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 1/19/2014 21:41'!initTestMisbehavingSession	"Make a three-element Array of Associations for each client to play with.  Position 1 is for client1, position 2 is for client2, position 3 will be the conflicting element (client1 will win)."	clientSession commit: 		[ clientSession root 			at: #testMisbehavingSession			put: { 					('client1' -> true).					('client2' -> 'this should not be here at the end of the test!!').					('conflict' -> 'initial value').					{ MagmaStat new. MagmaStat new. MagmaStat new}				 } ]! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 9/20/2008 13:43'!repositoryHasConnectionFor: sessionId 	^ (magmaConsole controller repository 		sessionWithId: sessionId		ifAbsent: [ nil ]) notNil! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 9/23/2008 16:45'!testMisbehavingSession	"Make sure the server will protect itself from misbehaving clients."	| client2Id |	self		remotePerform: #initTestMisbehavingSession			in: 'client1' ;		remotePerform: #updateAt2Badly			in: 'client2' ;		remotePerform: #do1001Commits			in: 'client1'.	client2Id := self 		remotePerform: #getSessionId		in: 'client2'.	self deny: (self 			remotePerform: #repositoryHasConnectionFor:			with: client2Id			in: 'server').	self		remotePerform: #client2CommitAnyway			in: 'client2' ;		remotePerform: #verifyClient2Change			in: 'client1'! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 1/20/2014 21:28'!updateAt2Badly	"Client 2 updates its portion, but doesn't commit."	| arr |	clientSession begin.	arr := self getMisbehaveFixture.	(arr at: 2) value: 'client2 desired change'.	(arr at: 3) value: 'client2 gonna-fail change'.	(arr at: 4) withIndexDo:		[ : eachStat : index | eachStat addValue: 0 - 2000 ].	self		 assert: ((arr at: 4) at: 1) sum = (0 - 2000) ;		 assert: ((arr at: 4) at: 2) sum = (0 - 2000) ;		 assert: ((arr at: 4) at: 3) sum = (0 - 2000)! !!MagmaTestCase methodsFor: 'test misbehaving client' stamp: 'cmm 1/20/2014 21:31'!verifyClient2Change	| arr |	clientSession abort.	arr := self getMisbehaveFixture.	self		 assert: (arr at: 1) value = 'client1 final value' ;		 assert: (arr at: 2) value = 'client2 desired change' ;		 assert: (arr at: 3) value = 'client1 value wins' ;		 assert: ((arr at: 4) at: 1) sum = (1000 - 2000) ;		 assert: ((arr at: 4) at: 2) sum = (2000 - 2000) ;		 assert: ((arr at: 4) at: 3) sum = (3000 - 2000)! !!MagmaTestCase methodsFor: 'test forwarding proxys' stamp: 'cmm 7/24/2018 15:41'!commitForwardingProxy	| sessionB fwProxy verifierSession |	sessionB := MagmaSession		host: NetNameResolver maLocalHostName		port: self peerPort.	sessionB allowWriteBarrier: self class allowWriteBarrier.	sessionB connectAs: 'peer creator'.	fwProxy := sessionB root asMagmaForwardingProxy.	clientSession commit:		[ clientSession root			at: #testForwardingProxy			put: fwProxy ].	sessionB disconnect.	self assert:		(clientSession definition links anySatisfy:			[ : each | each == fwProxy fpRemoteMagmaId ]).	verifierSession := self newSessionAt: clientSession location.	verifierSession connectAs: 'verifier'.	self		 assert: (verifierSession definition links anySatisfy: [ : each | each = fwProxy fpRemoteMagmaId ]) ;		 assert: (verifierSession definition links anySatisfy: [ : each | each == (verifierSession root at: #testForwardingProxy) fpRemoteMagmaId ]).	verifierSession disconnect.	"Above assertion should NOT cause sessionB to reconnect."	self deny: sessionB isConnected! !!MagmaTestCase methodsFor: 'test forwarding proxys' stamp: 'cmm 7/7/2009 22:12'!testForwardingProxy	self		createPeer ;		remotePerform: #startPeer in: 'server' ;		remotePerform: #commitForwardingProxy in: 'client1';		remotePerform: #verifySharedPageCache in: 'client2' "Don't stop the peer because a later test could cause an activation of the FP that references the object here, which would lead to a ConnectionTimedOut."";		remotePerform: #stopPeer in: 'server'"! !!MagmaTestCase methodsFor: 'test forwarding proxys' stamp: 'cmm 7/15/2009 14:29'!verifySharedPageCache	"Ensure that, if two separate MagmaForwardingProxies refer to the same oid assert that, when the realObject is first materialized in one, that it is the identical (==) realObject of the other."	| otherSession forwardingProxy otherForwardingProxy |	clientSession abort.	forwardingProxy := clientSession root at: #testForwardingProxy.	otherSession := self newSessionAt: self class magmaServerLocation.	otherSession connectAs: 'spcVerifier'.	otherForwardingProxy := otherSession root at: #testForwardingProxy.	self		deny: forwardingProxy == otherForwardingProxy ;		assert: forwardingProxy = otherForwardingProxy ;		assert: forwardingProxy realObject == otherForwardingProxy realObject.	otherSession disconnect! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 4/12/2005 17:41'!commitMcForNpMcTest	| mc |	mc := MagmaCollection new.	mc		add: 'one' ;		add: 'two' ;		add: 'three'.	clientSession commit:		[ clientSession root at: 'testNpIntegrationForMagmaCollections' put: mc ]! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 7/16/2006 13:05'!commitReaderForNpIntegrationTest	| mc reader |	mc := self newIndexedMagmaCollection.	reader := mc where: 		[ : rdr | 		rdr 			read: #key			from: 'c' "first in reader = charlie denise"			to: 'oz' "last in reader = nancy oprah" ].	reader pageSize: 2.	"test with pagesize smaller than sample-range."	clientSession commit: 		[ clientSession root 			at: 'testNpIntegrationForReaders'			put: reader ]! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 7/16/2006 13:00'!createMagmaArrayForNpTest	| arr |	arr := MagmaArray new.	arr at: 5 put: 'five'.	clientSession commit:		[ clientSession root 			at: 'testNpIntegrationForMagmaArrays'			put: arr ]! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 2/19/2008 12:56'!newIndexedMagmaCollection	| mc |	mc := MagmaCollection new		addIndex: (MaKeywordIndex attribute: #key) ;		yourself.	{ 'alpha beta'.	'charlie denise'.	'edward frank'.	'tom dick harry'.	'jack karen'.	'larry greg'.	'nancy ozzie'.	'peter queso'.	'randy steve'.	'tina uma'.	'vivian wilbur'.	'xavier yo-yo-ma'.	'zebra zzzzzzz' } do: [ : each | mc add: each substrings -> Object new ].	^ mc! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 7/15/2006 15:19'!testNonPersistentReader	| mc reader |	mc := self newIndexedMagmaCollection.	reader := mc where: 		[ : rdr | 		rdr 			read: #key			from: 'c'			to: 'oz' ].	reader pageSize: 2.	"test with pagesize smaller than sample-range."	self verifyReaderForNpIntegrationTest: reader! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 4/12/2005 17:19'!testNpIntegrationForMagmaArrays	| arr |	"First, test a completely non-persistent MagmaArray."	arr := MagmaArray new.	arr at: 5 put: 'five'.	self should: [ arr size = 5 ].	self should: [ (arr at: 5) = 'five' ].	self should: [ (arr at: 1) = nil ].	self		should: [ arr at: 6 ]		raise: Error.	self		remotePerform: #createMagmaArrayForNpTest in: 'client1' ;		remotePerform: #verifyMagmaArrayForNpTest in: 'client2'! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 4/12/2005 17:30'!testNpIntegrationForMagmaCollections	self		remotePerform: #commitMcForNpMcTest in: 'client1' ;		remotePerform: #verifyMcForNpMcTest in: 'client2'! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 4/12/2005 17:37'!testNpIntegrationForReaders	self		remotePerform: #commitReaderForNpIntegrationTest in: 'client1' ;		remotePerform: #verifyReaderForNpIntegrationTest in: 'client2'! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 8/4/2009 11:18'!verifyMagmaArrayForNpTest	| arr |	arr := clientSession refresh root at: 'testNpIntegrationForMagmaArrays'.	arr 		at: 1		put: 'one'.	self should: [ arr size = 5 ].	arr 		at: 501		put: 'five-hundred, one'.	self should: [ arr size = 501 ].	self should: [ (arr select: [ : e | e notNil ]) size = 3 ].	6 		to: 500		do: [ : n | self should: [ (arr at: n) = nil ] ]! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 8/2/2009 18:45'!verifyMcForNpMcTest	| mc |	clientSession refresh.	mc := clientSession root at: 'testNpIntegrationForMagmaCollections'.	mc		add: 'four' ;		add: 'five'.	self should: [ mc size = 5 ].	self should: [ (mc asArray: 5) asSet = #('one' 'two' 'three' 'four' 'five' ) asSet ]! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 8/3/2009 22:00'!verifyReaderForNpIntegrationTest	clientSession refresh.	self verifyReaderForNpIntegrationTest: (clientSession root at: 'testNpIntegrationForReaders')! !!MagmaTestCase methodsFor: 'test non-persistent integration' stamp: 'cmm 2/19/2008 22:11'!verifyReaderForNpIntegrationTest: aMagmaCollectionReader	| toBeRemoved |"Here are what the Reader contents.  The indented are the ones added afterward and now integrated.	1 capper2 charlie denise	3 a b connie4 charlie denise5 tom dick harry	6 millie dora7 edward frank8 edward frank9 larry greg10 tom dick harry11 jack karen	12 jackie kennedy13 jack karen	14 jackie kennedy15 larry greg	16 millie dora17 nancy ozzie	18 zebra oolong"	"First, add some out of the range."	aMagmaCollectionReader collection		add: #('abba' 'baab')->Object new ;		add: #('yappo' 'zulu')->Object new.	self should: [ aMagmaCollectionReader collection size = 15 ].	"Original sizes should be intact."	self should: [ aMagmaCollectionReader size = 11 ].	self should: [ (aMagmaCollectionReader at: 1) key = #('charlie' 'denise') ].	self should: [ (aMagmaCollectionReader at: 2) key = #('charlie' 'denise') ].	self should: [ (aMagmaCollectionReader at: 10) key = #('larry' 'greg') ].	self should: [ (aMagmaCollectionReader at: 11) key = #('nancy' 'ozzie') ].	"Now add some within the aMagmaCollectionReaders selected range."	aMagmaCollectionReader collection		add: #('a' 'b' 'connie')->Object new ;  "connie is the in-range keyword here"		add: #('millie' 'dora')->Object new ;		add: #('jackie' 'kennedy')->Object new.	"All three of the above should now be seamlessly merged in the aMagmaCollectionReader."	self should: [ (aMagmaCollectionReader at: 1) key = #('charlie' 'denise') ].	"'connie' is the qualifying key here, not a and b."	self should: [ (aMagmaCollectionReader at: 2) key = #('a' 'b' 'connie') ].	self should: [ (aMagmaCollectionReader at: 3) key = #('charlie' 'denise') ].	self should: [ (toBeRemoved := aMagmaCollectionReader at: 4) key = #('tom' 'dick' 'harry') ].	self should: [ (aMagmaCollectionReader at: 5) key = #('millie' 'dora') ].	self should: [ (aMagmaCollectionReader at: 6) key = #('edward' 'frank') ].	self should: [ (aMagmaCollectionReader at: 7) key = #('edward' 'frank') ].	self should: [ (aMagmaCollectionReader at: 8) key = #('larry' 'greg') ].	self should: [ (aMagmaCollectionReader at: 9) key = #('tom' 'dick' 'harry') ].	self should: [ (aMagmaCollectionReader at: 10) key = #('jack' 'karen') ].	self should: [ (aMagmaCollectionReader at: 11) key = #('jackie' 'kennedy') ].	self should: [ (aMagmaCollectionReader at: 12) key = #('jack' 'karen') ].	self should: [ (aMagmaCollectionReader at: 13) key = #('jackie' 'kennedy') ].	self should: [ (aMagmaCollectionReader at: 14) key = #('larry' 'greg') ].	self should: [ (aMagmaCollectionReader at: 15) key = #('millie' 'dora') ].	self should: [ (aMagmaCollectionReader at: 16) key = #('nancy' 'ozzie') ].		"Now add to before the first persistent and see if it can correctly interleave."	aMagmaCollectionReader collection add: #('capper')->Object new.  "<- within the range, but before charlie."	self should: [ aMagmaCollectionReader size = 17 ].	self should: [ (aMagmaCollectionReader at: 1) key = #('capper') ].	"Now add to after the last persistent and see if it can correctly interleave."	aMagmaCollectionReader collection add: #('zebra' 'oolong')->Object new.  "<- oolong within the range, but after nancy."	self should: [ aMagmaCollectionReader size = 18 ].	self should: [ (aMagmaCollectionReader at: 18) key = #('zebra' 'oolong') ].	"Now lets remove from what would be prior to our current page."	aMagmaCollectionReader collection remove: toBeRemoved.	self should: [ aMagmaCollectionReader collection size = 19 ].	self should: [ aMagmaCollectionReader size = 16 ].	self should: [ (aMagmaCollectionReader at: 3) key = #('a' 'b' 'connie') ].	self should: [ (aMagmaCollectionReader at: 5) key = #('millie' 'dora') ].	self should: [ (aMagmaCollectionReader at: 11) key = #('jack' 'karen') ].	self should: [ (aMagmaCollectionReader at: 16) key = #('zebra' 'oolong') ]! !!MagmaTestCase methodsFor: 'test storing a session' stamp: 'cmm 1/15/2007 18:38'!commitReferenceToSession	clientSession commit:		[ clientSession root			at: 'testStoringMagmaSession' 			put: clientSession ]! !!MagmaTestCase methodsFor: 'test storing a session' stamp: 'cmm 1/15/2007 18:37'!testStoringMagmaSession	self		remotePerform: #commitReferenceToSession		in: 'client1'.	self		remotePerform: #verifyReferenceToSession		in: 'client2'! !!MagmaTestCase methodsFor: 'test storing a session' stamp: 'cmm 2/16/2011 23:17'!verifyReferenceToSession	clientSession abort.	self assert: (clientSession root at: 'testStoringMagmaSession') yourself == clientSession! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/10/2011 20:09'!commitWithImmutabilityStrategy	| array |	clientSession immutabilityStrategy				treatObjectReferencedBy: 'value'		onAny: Association		asImmutableIf:			[ : assoc | assoc key isString and: [ assoc key beginsWith: 'immutable'] ] ;				treatObjectReferencedBy: 'birthday'		onAny: MagmaPerson		asImmutableIf:			[ : person | person name beginsWith: 'immutable' ].	array := clientSession refresh root at: #testImmutabilityStrategyByReference.	self		 assert: array first key maIsMutatingProxy not ;		 assert: array first value maIsMutatingProxy not ;		 assert: array second key maIsMutatingProxy not ;		 assert: array second value birthday maIsMutatingProxy.	clientSession commit:		[ array first value at: 1 put: $H.		array second value birthday makeUTC.		array third value at: 1 put: $A ]! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/10/2011 20:33'!commitWithImmutabilityStrategyByClass	| array |	clientSession immutabilityStrategy		treatAny: String		asImmutableIf:			[ : string | string beginsWith: 'class-level immutable' ].	array := clientSession refresh root at: #testImmutabilityStrategyByClass.	clientSession commit:		[ array first			at: 1			put: $X.		array second			at: 1			put: $M.		array			at: 3			put: 'replacement string' ]! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 2/10/2012 17:18'!setupTestImmutabilityStrategy	| sess |	sess := self class magmaServerLocation newSession.	sess connectAs: 'testImmutabilityStrategyByReference'.	sess commit:		[ sess root			at: #testImmutabilityStrategyByReference			put: {'immutable: no proxy' -> 'an immutable string'. 				'immutable: proxy' ->					(MagmaPerson new						 name: 'immutable b-day' ;						 birthday: (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours) asDate ;						 yourself).				'arvo'->'alina'} ].	sess disconnect! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/10/2011 20:20'!setupTestImmutabilityStrategyByClass	clientSession commit:		[ clientSession root			at: #testImmutabilityStrategyByClass			put: {'class-level immutable string'. 				'mutable string'.				'replace this string'} ]! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/10/2011 20:15'!testImmutabilityStrategyByClass	self				remotePerform: #setupTestImmutabilityStrategyByClass		in: 'client1' ;				remotePerform: #commitWithImmutabilityStrategyByClass		in: 'client2' ;				remotePerform: #verifyByClassNotCommitted		in: 'client1'! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/9/2011 23:03'!testImmutabilityStrategyByReference	self		 setupTestImmutabilityStrategy ;				remotePerform: #commitWithImmutabilityStrategy		in: 'client1' ;				remotePerform: #verifyNotCommitted		in: 'client2'! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 11/10/2011 20:20'!verifyByClassNotCommitted	| array |	clientSession refresh.	array := clientSession root at: #testImmutabilityStrategyByClass.	self		 assert: array first value = 'class-level immutable string' ;		 assert: array second value = 'Mutable string' ;		 assert: array third = 'replacement string'! !!MagmaTestCase methodsFor: 'test immutable strategy' stamp: 'cmm 2/10/2012 17:23'!verifyNotCommitted	| array |	clientSession refresh.	array := clientSession root at: #testImmutabilityStrategyByReference.	self		 assert: array first value = 'an immutable string' ;		 assert: array second value birthday start offset = 2 hours ;		 assert: array third value = 'Alina'! !!MagmaTestCase methodsFor: 'test compress' stamp: 'cmm 1/3/2013 21:47'!compressedRepositoryDirectory	^ FileDirectory default / '_test_magma_compressed'! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 5/20/2010 16:16'!counterFixture	^ counterFixture ifNil: [ counterFixture := clientSession root at: 'testMagmaCounter' ]! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 1/9/2014 15:13'!createCounter	clientSession commit:		[ clientSession root			at: 'testMagmaCounter'			put:				(MagmaCounter new					 increment: 10 ;					 yourself).		self			 assert: self counterFixture value = 10 ;			 assert: self counterFixture delta = 10 ].	self		 assert: self counterFixture value = 10 ;		 assert: self counterFixture delta = 0! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 1/9/2014 14:50'!finalValidateCounter	| counter |	(counter := self counterFixture) increment: 5.	self		 assert: counter value = 50 ;		 assert: counter delta = 5.	clientSession commit.	"but client1 had decremented by 15, now we can see that."	self		 assert: counter value = 35 ;		 assert: counter delta = 0! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 7/20/2007 11:59'!testMagmaCounter	"- make sure no commit-conflict.- verify value"	self		remotePerform: #createCounter			in: 'client1' ;		remotePerform: #validateAndIncrementCounter			in: 'client2' ;		remotePerform: #validateAndDecrementCounter			in: 'client1' ;		remotePerform: #finalValidateCounter			in: 'client2'! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 1/9/2014 14:49'!validateAndDecrementCounter	| counter |	clientSession begin.	counter := self counterFixture.	self		 assert: counter value = 45 ;		 assert: counter delta = 0.	counter		 decrement: 15 ;		 assert: counter delta = -15 ;		 assert: counter value = 30.	clientSession commit.	self		 assert: counter value = 30 ;		 assert: counter delta = 0! !!MagmaTestCase methodsFor: 'test MagmaCounter' stamp: 'cmm 1/9/2014 14:48'!validateAndIncrementCounter	| counter |	clientSession begin.	counter := self counterFixture.	self		 assert: counter value = 10 ;		 assert: counter delta = 0.	counter increment: 35.	self		 assert: counter value = 45 ;		 assert: counter delta = 35.	clientSession commitAndBegin.	self		 assert: counter value = 45 ;		 assert: counter delta = 0! !!MagmaTestCase methodsFor: 'test MagmaSet' stamp: 'cmm 8/20/2006 21:39'!createAndPopulateMagmaSet	| newSet |	clientSession commit: 		[ clientSession root 			at: 'testMagmaSet'			put: (				MagmaSet new					addIndex: (MaSearchStringIndex attribute: #key) beAscii ;					equivalenceAttributes: #(key) ;					yourself) ].	newSet := clientSession root at: 'testMagmaSet'.	self		should: [ newSet isEmpty ] ;		shouldnt: [ newSet includes: 3 -> 4 ].	self 		should: [ newSet add: Object new ]		raise: MagmaUserError.	self 		should: [ newSet remove: 3 -> 4 ]		raise: MagmaEquivalentObjectNotInCollection.	self magmaSetEntries do: [ : eachAssociation | clientSession commit: [ newSet add: eachAssociation ] ]! !!MagmaTestCase methodsFor: 'test MagmaSet' stamp: 'cmm 2/2/2005 00:22'!magmaSetEntries	^ { 'one'->1.	'two'->2.	'three'->3 }! !!MagmaTestCase methodsFor: 'test MagmaSet' stamp: 'cmm 8/19/2007 11:54'!testMagmaSet	self		remotePerform: #createAndPopulateMagmaSet		in: 'client1'.	self		remotePerform: #verifyMagmaSet		in: 'client2'.	self		remotePerform: #verifyReducedMagmaSet		in: 'client1'.! !!MagmaTestCase methodsFor: 'test MagmaSet' stamp: 'cmm 8/4/2009 11:11'!verifyMagmaSet	| ms newEntries |	ms := clientSession refresh root at: 'testMagmaSet'.	newEntries := self magmaSetEntries.	self should: [ ms size = newEntries size ].	newEntries do:		[ : each |		self should: [ ms includes: each ] ].	self shouldnt: [ ms includes: 'three'-> 'different value' ].	self shouldnt: [ ms includes: 'four'->4 ].	self shouldnt: [ ms includes: Object new ].	self		should: [ ms add: 'one'->1 ]		raise: MagmaDuplicateObjectInCollection.	"Do a simple remove test too."	newEntries do:		[ : each | 		clientSession commit: [ ms remove: each ] ].	self should: [ ms isEmpty ]! !!MagmaTestCase methodsFor: 'test MagmaSet' stamp: 'cmm 2/2/2005 09:30'!verifyReducedMagmaSet	self should: [ (clientSession root at: 'testMagmaSet') isEmpty ]! !!MagmaTestCase methodsFor: 'test persistent reader' stamp: 'cmm 7/19/2007 22:40'!createCollectionAndReader	| collection reader |	collection := (MagmaCollection new)		addIndex: (MaByteSequenceIndex attribute: #key) ;		yourself.	reader := collection where: 		[ : rdr | 		rdr 			read: #key			from: 'M'			upTo: 'N' ].	{  MaObject. Collection  } do: 		[ : eachRoot | 		eachRoot withAllSubclassesDo: 			[ : each | 			collection add: each name asString -> each hash	"meaningless for this test, other than let's not add the entire image to the class-definitions please" ] ].	clientSession commit: 		[ clientSession root 			at: 'testPersistentReader.collection'			put: collection.		clientSession root 			at: 'testPersistentReader.reader'			put: reader ]! !!MagmaTestCase methodsFor: 'test persistent reader' stamp: 'cmm 6/24/2007 23:22'!testPersistentReader	self 		remotePerform: #createCollectionAndReader		in: 'client1'.	timeToVerifyRestore := self 		remotePerform: #verifyCollectionAndReader		in: 'client2'! !!MagmaTestCase methodsFor: 'test persistent reader' stamp: 'cmm 7/19/2007 23:15'!verifyCollectionAndReader	| reader |	clientSession abort.	reader := clientSession root at: 'testPersistentReader.reader'.	self assert: reader notEmpty.	self should: [ reader allSatisfy: [ : eachName | eachName key first = $M ] ].	self addVerifyRestorePrerequisite: #verifyCollectionAndReader.	^ self calculateTimeToVerifyRestore ! !!MagmaTestCase methodsFor: 'test querys - persistent empty' stamp: 'cmm 7/16/2006 20:27'!createEmpty	clientSession commit: 		[ clientSession root 			at: 'testPersistentEmpty'			put: self newMc ]! !!MagmaTestCase methodsFor: 'test querys - persistent empty' stamp: 'cmm 7/1/2007 21:59'!testPersistentEmpty	self 		remotePerform: #createEmpty		in: 'client1'.	self 		remotePerform: #verifyEmpty		in: 'client2'! !!MagmaTestCase methodsFor: 'test querys - persistent empty' stamp: 'cmm 7/1/2007 21:59'!verifyEmpty	| mc |	clientSession abort.	mc := clientSession root at: 'testPersistentEmpty'.	self 		verifyMc: mc		against: OrderedCollection new! !!MagmaTestCase methodsFor: 'test querys - persistent result sets' stamp: 'cmm 10/8/2006 15:54'!createInitialIndexedCollection	| mc array |	mc := (MagmaCollection new)		addIndex: (MaIntegerIndex attribute: #first) ;		yourself.	"Array of 1-element Array's."	array := (1 to: 100) collect: [ : n | Array with: n ].	mc addAll: array.	"add some duplicates"	(array 		copyFrom: 51		to: 60) do: [ : each | mc add: each ].	clientSession commit: 		[ clientSession root 			at: 'testPersistentResultSet-originalCollection'			put: mc ]! !!MagmaTestCase methodsFor: 'test querys - persistent result sets' stamp: 'cmm 11/9/2006 18:13'!createTransientResultSetAndVerify	| sourceMc firstReader firstMc newReader secondReader |	clientSession abort.	sourceMc := clientSession root at: 'testPersistentResultSet-originalCollection'.	"Note this is the non-blocking where.."	firstReader := sourceMc 		where: 			[ : rdr | 			rdr 				read: #first				from: 41				to: 70 ]		distinct: true		sortBy: #first		descending: false.	"And, immediately, begin a (blocking) query where it creates, yet, another new non-persistent subcollection off the first non-persistent collection!!"	secondReader := firstReader 		where: 			[ : rdr | 			rdr 				read: #first				from: 1				to: 50 ]		distinct: true		sortedBy: #first		descending: true.	self assert: secondReader size = 10.	self assert: secondReader collection size = 10.	self assert: secondReader first = {  50  }.	self assert: secondReader last = {  41  }.	self deny: (clientSession isPersistent: secondReader).	"Do some queries against the first reader."	firstMc := firstReader collection.	self assert: firstReader size = 30.	self assert: firstMc ~~ sourceMc.	self assert: firstMc size = 30.	"an additional where query (which won't create a new underlying collection) against the first non-persistent collection."	newReader := firstReader where: 		[ : rdr | 		rdr 			read: #first			from: 45			to: 54 ].	self assert: secondReader collection ~~ newReader collection.	self assert: newReader size = 10.	self assert: newReader first = {  45  }.	self assert: newReader last = {  54  }.	"Now persist the second result-set so client1 can do some assertions."	clientSession commit: 		[ clientSession root 			at: 'testPersistentResultSet-secondReader'			put: secondReader ].	self assert: (clientSession isPersistent: secondReader)! !!MagmaTestCase methodsFor: 'test querys - persistent result sets' stamp: 'cmm 6/24/2007 23:22'!testPersistentResultSet	"When creating a distinct result-set, we have to create a file on the server.  But that file must have a unique-name, not a transient-oid name, and the user could make it persistent anyway.  Be sure this works."	self 		remotePerform: #createInitialIndexedCollection		in: 'client1'.	self 		remotePerform: #createTransientResultSetAndVerify		in: 'client2'.	self 		remotePerform: #verifyPersistentResultSet		in: 'client1'.	timeToVerifyRestore := self 		remotePerform: #noteVerifyPersistentResultSetComplete		in: 'client2'! !!MagmaTestCase methodsFor: 'test querys - persistent result sets' stamp: 'cmm 10/8/2006 16:02'!verifyPersistentResultSet	| secondReader secondMc |	clientSession abort.	secondReader := clientSession root at: 'testPersistentResultSet-secondReader'.	secondMc := secondReader collection.	self assert: secondReader size = 10.	self assert: secondMc size = 10.	self assert: secondReader first = {50}.	self assert: secondReader last = {41}.! !!MagmaTestCase methodsFor: 'test stale collections' stamp: 'cmm 12/29/2004 09:53'!createMagmaCollection	| mc |	mc := MagmaCollection new.	MaTestCase withAllSubclasses do: [ : each | mc add: each ].	clientSession commit:		[ clientSession root			at: 'testStaleCollections'			put: mc ].	localRoot		at: 'testStaleCollections'		put: mc! !!MagmaTestCase methodsFor: 'test stale collections' stamp: 'cmm 12/28/2004 13:16'!readMagmaCollection	clientSession abort.	localRoot		at: 'testStaleCollections'		put: (clientSession root at: 'testStaleCollections')! !!MagmaTestCase methodsFor: 'test stale collections' stamp: 'cmm 2/13/2008 21:10'!testStaleCollections	self		remotePerform: #createMagmaCollection		in: 'client1'.	self		remotePerform: #readMagmaCollection		in: 'client2'.	self disconnectClients.	self		remotePerform: #verifyMagmaCollection		in: 'client1'.	self		remotePerform: #verifyMagmaCollection		in: 'client2'! !!MagmaTestCase methodsFor: 'test stale collections' stamp: 'cmm 10/18/2014 13:45'!verifyMagmaCollection	| persistent compare |	Smalltalk garbageCollect.	compare := MaTestCase withAllSubclasses asSet.	persistent := localRoot at: 'testStaleCollections'.	self		 assert: persistent asArray asSet = compare ;		 assert: compare size = persistent size ;		 assert: (persistent count: [ : each | true ]) = persistent size! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:07'!createMagmaCollectionAndIndexSimultaneously	| root mc |	root := clientSession root.	mc := MagmaCollection new.	mc addIndex: (MaDateIndex attribute: #date).	clientSession commit: 		[ root 			at: 'testCreateMagmaCollectionAndIndexSimultaneously'			put: mc ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:25'!performDoubleUpdate	| root |	root := clientSession root.	clientSession commit: 		[ root 			at: 'testDoubleUpdate'			put: 3 -> 4 ].	clientSession commit: 		[ root 			at: 'testDoubleUpdate'			put: 'three' -> 'four' ].	clientSession commit: 		[ root 			at: 'testDoubleUpdate'			put: 5 -> 6 ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:27'!performSetUpStaleProxyAutoReconnect	clientSession abort commit: 		[ clientSession root 			at: 'testStaleProxyAutoReconnect'			put: (MagmaPerson new					name: 'Benny' ;					address: '10 Volcanoes Drive' ;					yourself) ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 11/13/2011 20:17'!performUpdateByteObjects	| root |	clientSession immutabilityStrategy: Object immutabilityStrategy.	root := clientSession root.	clientSession		 abort ;		 commit:			[ (root at: 'testUpdateByteObjects') first				at: 1				put: $H.			(root at: 'testUpdateByteObjects') last				at: 1				put: $H asciiValue ].	clientSession immutabilityStrategy: MaImmutabilityStrategy new! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:30'!prepareUpdateByteObjects	| root |	root := clientSession root.	clientSession commit: 		[ root 			at: 'testUpdateByteObjects'			put: (Array 					with: 'hello world'					with: 'hello world' asByteArray) ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 3/25/2013 09:50'!testConnectionsAccess	| conns |	conns := self class magmaServerLocation connections.	self		 assert:			(conns anySatisfy:				[ : each | each userId = 'client1' ]) ;		 assert:			(conns anySatisfy:				[ : each | each userId = 'client2' ]) ;		assert: (conns allSatisfy: [ : each | each lastAccess notNil ])! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:21'!testCreateMagmaCollectionAndIndexSimultaneously	self 		remotePerform: #createMagmaCollectionAndIndexSimultaneously		in: 'client1'.	self 		remotePerform: #verifyMagmaCollectionAndIndexCreatedSimultaneously		in: 'client2'! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:25'!testDoubleUpdate	"Make sure that when an object link is updated more than once before another client refreshes it, that it refreshes correctly."	self 		remotePerform: #performDoubleUpdate		in: 'client1'.	self 		remotePerform: #verifyDoubleUpdate		in: 'client2'! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:29'!testStaleProxyAutoReconnect	"When a session disconnects, any existing proxies that are hit later will first look for an existing session connected to the same server, or, if not found there, try to reconnect the one it has."	self 		remotePerform: #performSetUpStaleProxyAutoReconnect		in: 'client1'.	self 		remotePerform: #verifySetUpStaleProxyAutoReconnect		in: 'client2'! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/22/2007 11:21'!testUpdateByteObjects	"Make sure that when an object link is updated more than once before another client refreshes it, that it refreshes correctly."	"Client1, commit a couple of byte objects."	self 		remotePerform: #prepareUpdateByteObjects		in: 'client1'.	"Client2, commit an update the byte objects.."	self 		remotePerform: #performUpdateByteObjects		in: 'client2'.	"client1, verify the byte objects.."	self 		remotePerform: #verifyUpdateByteObjects		in: 'client1'! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:25'!verifyDoubleUpdate	clientSession abort.	self should: [ (clientSession root at: 'testDoubleUpdate') = (5 -> 6) ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 6/21/2007 00:21'!verifyMagmaCollectionAndIndexCreatedSimultaneously	clientSession abort.	self should: 		[ (clientSession root at: 'testCreateMagmaCollectionAndIndexSimultaneously') indexes notEmpty ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 2/13/2008 21:00'!verifySetUpStaleProxyAutoReconnect	localRoot 		at: 'testStaleProxyAutoReconnect'		put: (clientSession abort root at: 'testStaleProxyAutoReconnect').	self should: [ (localRoot at: 'testStaleProxyAutoReconnect') name maIsMutatingProxy ].	clientSession disconnect.	self should: 		[ (localRoot at: 'testStaleProxyAutoReconnect') name asUppercase = 'BENNY' ]! !!MagmaTestCase methodsFor: 'other small tests' stamp: 'cmm 11/13/2011 16:04'!verifyUpdateByteObjects	clientSession abort.	self should: [ (clientSession root at: 'testUpdateByteObjects') first first == $h ].	self should: 		[ (clientSession root at: 'testUpdateByteObjects') last first == $H asciiValue ]! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 1/3/2013 17:55'!createPeer	suite		createRepository: self peerPath		root: self remoteObject! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 1/3/2013 17:51'!peerPath	^ FileDirectory default fullNameFor: '_test_magma_peer'! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 1/15/2005 13:46'!peerPort	^ 51069! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 1/15/2005 15:39'!remoteObject	^ Object -> (Set withAll: 'a collection of strings' substrings)! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 7/18/2005 13:21'!startPeer	peerConsole :=		MagmaServerConsole new 			open: self peerPath ;			processOn: self peerPort ;			yourself! !!MagmaTestCase methodsFor: 'peer' stamp: 'cmm 1/15/2005 13:49'!stopPeer	peerConsole shutdown! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 9/6/2007 21:46'!createSequenceNumberGenerator	clientSession serverPerform: #initializeSequenceNumberGenerator! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 9/6/2007 21:45'!getNextSequenceNumber	^ clientSession serverPerform: #getNextSequenceNumber! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 8/23/2007 13:07'!getSequenceNumbers	^ sequenceNumbers ! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 8/23/2007 13:08'!getServerCounterValue	clientSession abort.	^ (clientSession root at: #testSequenceNumberGenerator) value! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 12/19/2012 14:08'!startGeneratingSequenceNumbers	shouldStopGeneratingSequenceNumbers := false.	sequenceNumbers := OrderedCollection new.	[ [ shouldStopGeneratingSequenceNumbers ] whileFalse:		[ sequenceNumbers add: self getNextSequenceNumber.		sequenceNumbers size \\ 100 = 0 ifTrue: [ clientSession refresh ] ].	shouldStopGeneratingSequenceNumbers := 'done' ] fork name: 'generating sequence numbers'! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 8/23/2007 12:59'!stopGeneratingSequenceNumbers	shouldStopGeneratingSequenceNumbers := true! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 8/23/2007 13:08'!testSequenceNumberGenerator	self 		remotePerform: #createSequenceNumberGenerator in: 'client2' ;		remotePerform: #startGeneratingSequenceNumbers in: 'client1' ;		remotePerform: #startGeneratingSequenceNumbers in: 'client2'.	(Delay forSeconds: 10) wait.	self		remotePerform: #stopGeneratingSequenceNumbers in: 'client1' ;		remotePerform: #stopGeneratingSequenceNumbers in: 'client2' ;		verifySequenceNumbers! !!MagmaTestCase methodsFor: 'test sequence-number generator' stamp: 'cmm 8/23/2007 16:03'!verifySequenceNumbers	| client1Numbers client2Numbers serverCounterValue |	serverCounterValue := self remotePerform: #getServerCounterValue in: 'client1'.	client1Numbers := self remotePerform: #getSequenceNumbers in: 'client1'.	client2Numbers := self remotePerform: #getSequenceNumbers in: 'client2'.	self assert: (1 to: serverCounterValue by: 1) asArray = ((client1Numbers, client2Numbers) asSortedCollection asArray)! !!MagmaTestCase methodsFor: 'test Set' stamp: 'cmm 11/30/2004 21:21'!createTestSet	clientSession commit:		[ clientSession root			at: 'testSet'			put: (Set with: (StringHolder new contents: 'proxied string'; yourself)) ]! !!MagmaTestCase methodsFor: 'test Set' stamp: 'cmm 11/25/2004 19:57'!testSet	"Set and Dictionary are special because their instances are serialized in their logical form.  For Dictionary, a MaVariableObjectBuffer with oids paired for key, value, key, value,... etc."	self		remotePerform: #createTestSet		in: 'client1'.	self		remotePerform: #verifyTestSet		in: 'client2'.! !!MagmaTestCase methodsFor: 'test Set' stamp: 'cmm 6/16/2005 11:49'!verifyTestSet	"Sets and Dictionary's are supposed to read one-level deep no matter what."	| holder |	holder := (clientSession abort root at: 'testSet') anyOne.	self 		should: [ holder species = StringHolder ] ;		should: [ holder contents maIsMutatingProxy ] ;		should: [ holder contents = 'proxied string' ]! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 3/1/2009 14:12'!ensureClientHighlyAvailable	"Clients at this point are committing to primary.  Force HA recognition by attempting read from primary."	clientSession root.	self assert: clientSession isHighlyAvailable! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 2/25/2009 17:34'!ensureClientsHighlyAvailable	#('client1' 'client2' ) do: 		[ : each | 		self 			remotePerform: #ensureClientHighlyAvailable			in: each ]! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 3/5/2009 13:37'!startServerOnCompressed	self startServer2On: self compressedRepositoryDirectory! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 1/5/2013 10:30'!verifyAddToNode	"HA Use-Case 1:  secondary started other is primary :	Prestate:  Primary only	- secondary server started on 51970	- secondary catches itself up to primary	- primary adds secondary as a warm-backup	Poststate:  standard HA configuration, 51969:51970"	"A backup was performed a long time ago at the beginning of the test suite (see #initiateBackupIfTime).  Since then, commit.log files have been written.  Now we will start a server on that backup and apply those backup records and verify lots of things are correct in the restored object model."	| backupSession verifier |	self		setUpForwardRecoveryTest ;		startClientFloodingProcesses: true.	MaTestCaseNotification signal: 'Beginning HA Use-Case 1:  Add a server to the Node.'.	self 		remotePerform: #startServer2		in: 'server2'.	backupSession := self newSessionAt: self class magmaServerLocation.	backupSession connectAs: 'restore verifier'.	[ backupSession isHighlyAvailable ] whileFalse: 		[ MaTestCaseNotification signal: 'waiting for standard HA configuration...'.		(Delay forSeconds: 10) wait.		backupSession root ].	MaTestCaseNotification signal: backupSession printString , ' is now highly-available...'.	self ensureClientsHighlyAvailable.	"We are connected to the entire node, so we can do an abort without error."	backupSession abort.	verifier := self class new clientSession: backupSession; suite: suite; yourself.	self restoreVerifications do: 		[ : each | 		MaTestCaseNotification signal: 'executing ' , each , ' using session to warm-backup...'.		verifier perform: each ].	backupSession disconnect.	MaTestCaseNotification signal: 'Completed HA Use-Case 1.'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 3/5/2009 16:14'!verifyHaFunctionality	self		verifyAddToNode ;		verifyPrimaryFailure ;		verifyRestartFormerPrimary ;		verifyQuickSwapFunction ;		verifyNodeCanMaintain ;		verifySecondaryFailure! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 4/8/2015 20:11'!verifyHandlesFailedServer: playerName 	| monitoringSession |	monitoringSession := self newSessionAt: self class magmaServerLocation.	monitoringSession connectAs: 'HA monitor in #' , thisContext selector.	"First assert isHighlyAvailable.  We have flood processes running."	self assert: monitoringSession isHighlyAvailable.		[ self 		remotePerform: #killVm		in: playerName ] 		on: NetworkError		do: 			[ : err | 			"nothing expected because we're killing the server."			 ].	self waitForServerDown: playerName.	"Invoke a request to the primary to force monitoringSession to realize it is no longer HA."		[ playerName = 'server' 		ifTrue: [ monitoringSession abort ]		ifFalse: [ monitoringSession root ].	monitoringSession isHighlyAvailable ] whileTrue: [ (Delay forSeconds: 2) wait ].	monitoringSession disconnect! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 1/5/2013 10:30'!verifyNodeCanMaintain	"UC 5:  Perform garbage-collection without stopping Node.	Prestate:  standard HA configuration	- start client flooding processes	- fullBackup the primary 'server'	- Use MagmaCompressor to compress the copy, off-line.	- Stop existing secondary 'server2' gracefully.  We are down to just the primary 'server' briefly. (In a production world, you would not have to stop the existing server).	- restart 'server2' on the new compressed backup.	- 'server2' catches itself back up, reestablishes as a warm-backup.	- perform same object-structure verifications from prior tests.	- stop flood progress.	- verify flood progress.	Poststate: standard HA configuration"	| session verifier |	MaTestCaseNotification signal: 'Beginning HA Use-Case 5:  Perform garbage-collection without stopping the Node...'.	self		 setUpForwardRecoveryTest ;		 startClientFloodingProcesses: false.	self		remotePerform: #fullBackupTo:		with: self maintDirectory pathName		in: 'client1'.	self		remotePerform: #waitForBackupDone		in: 'server'.	[ MagmaRepositoryController delete: self compressedRepositoryDirectory pathName ]		on: MagmaDeleteWarning		do:			[ : warning | warning resume ].	(MagmaCompressor source: (MagmaLocalLocation path: self maintDirectory pathName)) compressTo: self compressedRepositoryDirectory pathName.	self		remotePerform: #stopServer		in: 'server2'.	self		remotePerform: #startServerOnCompressed		in: 'server2'.	MaTestCaseNotification signal: 'Waiting for compressed server to catch up.'.	session := self newSessionAt: self class magmaServerLocation.	session connectAs: 'compressed repository verifier'.	[ session isHighlyAvailable ] whileFalse:		[ 5 seconds asDelay wait.		session root ].	MaTestCaseNotification signal: session printString , ' is now highly-available.'.	verifier := self class new clientSession: session; suite: suite; yourself.	self restoreVerifications do:		[ : each | MaTestCaseNotification signal: 'executing ' , each , ' using session to warm-backup...'.		verifier perform: each ].	session disconnect.	self verifyFloodProgress.	MaTestCaseNotification signal: 'Completed HA Use-Case 5:  Perform garbage-collection without stopping the Node...'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 1/5/2013 10:30'!verifyPrimaryFailure	"UC 2:  primary killed other is secondary :	Prestate:  standard HA configuration	- clients are performing rapid sequential add to collections	- conductor kills primary.	- clients continue committing to secondary.	- Verification is performed.	Poststate:  Secondary became primary"	MaTestCaseNotification signal: 'Beginning HA Use-Case 2:  Primary failure.'."Might be good to actually verify clients are still adding strings here by connecting a separate session and observing the string collections increasing in size."	self		 verifyHandlesFailedServer: 'server' ;		 stopFloodProcesses ;		 verifyFloodProgress: self class magmaServer2Location.	MaTestCaseNotification signal: 'Completed HA Use-Case 2:  Primary failure.'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 7/21/2015 19:15'!verifyQuickSwapFunction	"UC 4:  intentionally 'swap' servers instantly:	Prestate:  reversed HA configuration, clients are still flooding from UC3.	- client sends #takeOverAsPrimary to secondaryServer.	- System performs a controlled swap while two clients flooding.  Clients will not even notice.	Poststate:  standard HA configuration"	| adminSession lesserSize verificationSession |	MaTestCaseNotification signal: 'Beginning HA Use-Case 4:  Invoke a deliberate takeover of primary duty.'.	adminSession := self class magmaServerLocation newAdminSession.	adminSession connectAs: 'admin'.	self assert: adminSession node primaryLocation = self class magmaServer2Location.	adminSession takeOverAsPrimary.	verificationSession := self newSessionAt: adminSession location.	verificationSession connectAs: 'check flood processes still running'.	lesserSize := (verificationSession root at: #testForwardRecovery) first size.	(Delay forSeconds: 30) wait.	"Make sure flood processes still progressing after the #takeOverAsPrimary!!"	self should: [ (verificationSession refresh root at: #testForwardRecovery) first size > lesserSize ].	verificationSession disconnect.	self verifyFloodProgress.	MaTestCaseNotification signal: 'Completed HA Use-Case 4:  Invokes a deliberate swap of primary duty..'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 1/5/2013 10:31'!verifyRestartFormerPrimary	"UC 3:  primary started other is primary :	Prestate:  Secondary became primary.  Old primary will now start back up and:		- determine it has been 'taken-over', and therefore should reattach itself as a warm-backup.		- it downloads the commit-log records from the primary, bringing itself up to date.		- when it catches up, the primary is established in the Node as a warm-backup.	Poststate:  reversed HA configuration"	| backupSession |	MaTestCaseNotification signal: 'Beginning HA Use-Case 3:  A former primary rejoins the node..'.	"Let's flood with commits while the former primary tries to catch up."	self		setUpForwardRecoveryTest ;		startClientFloodingProcesses: false.	self launchPrimaryServerPlayer.	self 		remotePerform: #startServer:		withArguments: {  false "don't recover from commit-log files" }		in: 'server'.	self 		remotePerform: #assertPotentiallyOpenSignaled 		in: 'server'.	backupSession := self newSessionAt: self class magmaServer2Location.	backupSession connectAs: 'session waiting for former primary to catch back up'.		[ backupSession		root ;		isHighlyAvailable ] whileFalse: 		[ MaTestCaseNotification signal: 'waiting for reversed HA configuration...'.		(Delay forSeconds: 5) wait ].	self assert: backupSession node primaryLocation port = self class defaultServer2Port.	MaTestCaseNotification signal: 'Completed HA Use-Case 3:  A former primary rejoins the node..'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 9/9/2014 16:10'!verifySecondaryFailure	"UC 6:  secondary killed other is primary :	Prestate:  standard HA configuration	- clients begin performing rapid sequential add to collections	- conductor kills secondary.	- clients don't notice.	- Verification is performed.	Poststate:  Primary only"	| verificationSession lesserSize |	MaTestCaseNotification signal: 'Beginning HA Use-Case 6:  Secondary failure.'.	MaTestCaseNotification signal: 'Retesting MagmaStat capability under HA.'.	self		 testMagmaStat ;		 testMisbehavingSession ;		 setUpForwardRecoveryTest ;		 startClientFloodingProcesses: false.	self verifyHandlesFailedServer: 'server2'.	"For a secondary failure, clients should not even notice."	verificationSession := self newSessionAt: self class magmaServerLocation.	verificationSession connectAs: 'check flood processes still running'.	lesserSize := (verificationSession root at: #testForwardRecovery) first size.	(Delay forSeconds: 10) wait.	"Make sure flood processes still progressing after the #takeOverAsPrimary!!"	self assert: (verificationSession refresh root at: #testForwardRecovery) first size > lesserSize.	verificationSession disconnect.	self verifyFloodProgress.	MaTestCaseNotification signal: 'Completed HA Use-Case 6:  Secondary failure.'! !!MagmaTestCase methodsFor: 'test high-availability function' stamp: 'cmm 3/4/2009 16:25'!waitForBackupDone	[ magmaConsole controller isFullBackupRunning ] whileTrue: [ 5 seconds asDelay wait ]! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 3/4/2009 13:09'!forwardRecoveryRequirement: aCollection	forwardRecoveryRequirement := aCollection! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 8/17/2009 10:29'!initializeForwardRecoveryFixture	clientSession		commit: 			[ clientSession root 				at: #testForwardRecovery				put: { 						(OrderedCollection new: 1).						(OrderedCollection new: 1)					 } ]! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 4/10/2015 11:04'!killVm	self assertNoMagmaCollectionIndexClass.	MagmaServerPreferences debugRecovery ifTrue: [ self halt: 'About to kill this image' ].	Smalltalk crashVm! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 9/15/2013 16:43'!launchPrimaryServerPlayer	(self playerLinkNamed: 'server')		 launch ;		 waitForReady! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 2/26/2009 19:49'!remoteStringCollection	clientSession abort.	^ (clientSession root at: #testForwardRecovery) at: clientSession userId last digitValue! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 3/5/2009 16:29'!setUpForwardRecoveryTest 	self		deny: forwardRecoverySignaled ;		remotePerform: #initializeForwardRecoveryFixture			in: 'client1'.	(Delay forSeconds: 6) wait	"for flushCache of setup"! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 10/26/2014 15:24'!startAddStrings: expectNetworkError 	| oc serverDown counter |	oc := self remoteStringCollection.	serverDown := false.	forwardRecoveryRequirement := OrderedCollection new.	counter := 50000 atRandom.	clientSession		 begin ;		 timeoutSeconds: 10.	shouldStopFlooding := false.	[ [ [ serverDown or: [ shouldStopFlooding ] ] whileFalse:		[ oc add: counter printString.		[ clientSession commitAndBegin.		"When the server is ripped down, the last commit, above, either succeeded or it didn't, so we must be forgiving by one when we verify."		forwardRecoveryRequirement add: counter printString.		counter := counter + 1 ]			on: NetworkError			do:				[ : err | oc size < 3 ifTrue: [ self halt: 'Why the network error?' ].				expectNetworkError					ifTrue: [ serverDown := true ]					ifFalse: [ err pass ] ] ] ] ensure: [ clientSession timeoutSeconds: 172800 "2 days" ] ] newProcess		 name: thisContext selector ;		 resume! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 3/16/2009 17:57'!startClientFloodingProcesses: expectNetworkError 	{  'client1'. 'client2'  } do: 		[ : each | 		self 			remotePerform: #startAddStrings:			with: expectNetworkError			in: each ]! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 12/29/2008 14:03'!stopFloodProcess	shouldStopFlooding := true! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 12/30/2008 18:29'!stopFloodProcesses	{  'client1'. 'client2'  } do: [ : each | self remotePerform: #stopFloodProcess in: each ]! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 4/8/2015 20:11'!testForwardRecovery	"- kickoff background process in both clients that add strings to their own OrderedCollection.		root			'testDisasterRecovery' -> Array (2-elements)				1->OC1				2->OC2	- each client keeps track of how far it is.	- Delay for a few seconds while they chug.	- kill the server, wait for shutdown.	- client error-handling (NetworkError) has ended their add loop.  Last successful string is known in memory.	- restart server image, recovery will happen automatically	- wait for server to respond	- disconnectClients; connectClients	- clients verify their own OC against in-memory progress."	"for flushCache of setup"	"Our socket to communicate with the test-player hosting the server is now invalid, but the auto-retry logic should establish a new one automatically."	self setUpForwardRecoveryTest.	"Make sure cache won't flush because we're testing the restoration from the commit-log."	self 		remotePerform: #cacheFlushFrequency:		with: 9999999		in: 'server'.	self startClientFloodingProcesses: true.	"Let them chug for 10 seconds."	(Delay forMilliseconds: 10000) wait.		[ self 		remotePerform: #killVm		in: 'server' ] 		on: NetworkError		do: 			[ : err | 			"nothing, expected because we're killing the server."			 ].	self waitForServerDown: 'server'.	(Delay forSeconds: 15) wait.	"to give time for clients network timeout to expire."	self launchPrimaryServerPlayer.	self 		remotePerform: #startServer:		withArguments: {  true  }		in: 'server'.	self 		remotePerform: #assertForwardRecoverySignaled		in: 'server'.	self 		remotePerform: #assertPotentiallyOpenSignaled		in: 'server'.	self verifyFloodProgress.	self suite initiateBackupPrereqsCompleted add: #testForwardRecovery! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 10/26/2014 15:23'!verifyAddedStrings	clientSession timeoutSeconds: 172800 "2 days".	"We can't know whether the last commit actually succeeded and on its way back before the server was killed.  If it did, then the local will be one behind the remote.  Otherwise, they'll be equal."	self assert: forwardRecoveryRequirement size > 3.	self assert: (self remoteStringCollection size - forwardRecoveryRequirement size 			between: -1			and: 1)! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 12/8/2012 14:30'!verifyFloodProgress	"Get entirely new MagmaSession client instances, to be sure we aren't reading cached data."	self		 stopFloodProcesses ;		 verifyFloodProgress: self class magmaServerLocation! !!MagmaTestCase methodsFor: 'test forward recovery' stamp: 'cmm 3/6/2009 11:12'!verifyFloodProgress: aMagmaServerLocation 	"Get entirely new MagmaSession client instances, to be sure we aren't reading cached data."	self		disconnectClients ;		connectClients: aMagmaServerLocation.	{  'client1'. 'client2'  } do: 		[ : each | 		self 			remotePerform: #verifyAddedStrings			in: each ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/14/2011 15:59'!hashTableKeys	^  	{DateAndTime epoch. 	DateAndTime		year: 1969		month: 5		day: 10		hour: 11		minute: 52. 	DateAndTime		year: 2924		month: 12		day: 29		hour: 4		minute: 59.	"Intentional duplicate."	DateAndTime		year: 1969		month: 5		day: 10		hour: 11		minute: 52 } , 	((DateAndTime year: 1999 month: 12 day: 31 hour: 23 minute: 59) 		to: (DateAndTime year: 2010 month: 1 day: 1 hour: 0 minute: 0) 		by: 22 hours+37 minutes+11 seconds) dateAndTimes shuffled! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:25'!initializeHashTable	| hashTable |	clientSession begin.	clientSession root		at: #testMagmaHashTable		put: (hashTable := MagmaHashTable index: (MaDateAndTimeIndex attribute: #key)).	self assert: hashTable isEmpty.	self		 populateHashTable ;		 verifyHashTable.	clientSession commit! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:51'!initializeSolHashTable	clientSession commit:		[ clientSession root			at: #testMagmaSolHashTable			put: MagmaSolHashTable new ].	clientSession commit: [ self populateSolHashTable ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:13'!populateHashTable	| hashTable |	hashTable := clientSession root at: #testMagmaHashTable.	self hashTableKeys do:		[ : each | hashTable add: each -> each printString ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:55'!populateSolHashTable	clientSession refresh.	self populateSolHashTable: (clientSession root at: #testMagmaSolHashTable)! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 16:10'!populateSolHashTable: aMagmaSolHashTable 	| r largest |	r := self random.	largest := (1 bitShift: aMagmaSolHashTable keyBits) - 1.	10000 timesRepeat:		[ | n |		n := r nextInt: largest.		aMagmaSolHashTable			add: n asWords			at: n ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 18:22'!removeOddEntries	clientSession		 refresh ;		 commit: [ self removeOddEntries: (clientSession root at: #testMagmaSolHashTable) ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:54'!removeOddEntries: aMagmaSolHashTable	| r largest |	r := self random.	largest := (1 bitShift: aMagmaSolHashTable keyBits) - 1.	1		to: 10000		do:			[ : c | | n |			n := r nextInt: largest.			c odd ifTrue:				[ aMagmaSolHashTable					remove: n asWords					at: n					ifAbsent: [ self error: 'expected to remove' ] ] ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 14:46'!testMagmaHashTable	self 		remotePerform: #initializeHashTable in: 'client1' ;		remotePerform: #verifyHashTable in: 'client2'! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:51'!testMagmaSolHashTable	self				remotePerform: #initializeSolHashTable		in: 'client1' ;				remotePerform: #verifySolHashTable		in: 'client2' ;				remotePerform: #removeOddEntries		in: 'client2' ;				remotePerform: #verifySolHashTableWithRemovedEntries		in: 'client1'! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 16:20'!testNonPersistentSolHashTables	self		 verifyNonPersistentSolHashTable:			(SOLHashTable				loadFactor: 1				segBits: 2				keyBits: 28) ;		 verifyNonPersistentSolHashTable: MagmaSolHashTable new! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:33'!verifyHashTable	| tbl |	clientSession refresh.	tbl := clientSession root at: #testMagmaHashTable.	self assert: tbl notEmpty.	self hashTableKeys do:		[ : each | | all |		all := tbl allAt: each.		each =			(DateAndTime				year: 1969				month: 5				day: 10				hour: 11				minute: 52)			ifTrue:				[ self					 assert: all size = 2 ;					 assert: all asSet size = 1 ;					 assert: all anyOne = (self hashTableKeys second -> self hashTableKeys second printString) ]			ifFalse:				[ self					 assert: all size = 1 ;					 assert: all anyOne = (each -> each printString) ] ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 16:20'!verifyNonPersistentSolHashTable: aSOLHashTable	self		 populateSolHashTable: aSOLHashTable ;		 verifySolHashTable: aSOLHashTable ;		 removeOddEntries: aSOLHashTable ;		 verifySolHashTableWithRemovedEntries: aSOLHashTable! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:53'!verifySolHashTable	clientSession refresh.	self verifySolHashTable: (clientSession root at: #testMagmaSolHashTable)! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:59'!verifySolHashTable: aMagmaSolHashTable	| r largest |	r := self random.	largest := (1 bitShift: aMagmaSolHashTable keyBits) - 1.	10000 timesRepeat:		[ | n | self assert:			((aMagmaSolHashTable allAt: (n := r nextInt: largest)) allSatisfy:				[ : each | each = n asWords ]) ]! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 15:57'!verifySolHashTableWithRemovedEntries	clientSession refresh.	self verifySolHashTableWithRemovedEntries: (clientSession root at: #testMagmaSolHashTable)! !!MagmaTestCase methodsFor: 'test MagmaHashTable' stamp: 'cmm 4/13/2011 16:23'!verifySolHashTableWithRemovedEntries: aMagmaSolHashTable	| r largest |	r := self random.	largest := (1 bitShift: aMagmaSolHashTable keyBits) - 1.	1		to: 10000		do:			[ : c | | n |			n := r nextInt: largest.			c odd				ifTrue: [ self assert: (aMagmaSolHashTable allAt: n) isEmpty ]				ifFalse:					[ self assert:						((aMagmaSolHashTable allAt: n) allSatisfy:							[ : each | each = n asWords ]) ] ]! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 11/2/2010 15:06'!initializeMagmaDictionary: className 	| d |	d := (Smalltalk classNamed: className) new.	200		to: 500		do:			[ : n | d				at: n asWords				put: n ].	self verifyMagmaDictBeforeUpdates: d.	clientSession commit:		[ clientSession root			at: ('test' , className) asSymbol			put: d ].	self verifyMagmaDictBeforeUpdates: d! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 7/23/2011 15:23'!testMagmaDictionary	self		 testMagmaDictionaryClass: #MagmaDictionary ;				remotePerform: #verifyEnumerationOfMagmaDictionary		in: 'client1'! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 11/2/2010 16:10'!testMagmaDictionaryClass: className	self				remotePerform: #initializeMagmaDictionary:		with: className		in: 'client1' ;				remotePerform: #verifyMagmaDictionaryAccess:		with: className		in: 'client2' ;				remotePerform: #verifyMagmaDictionaryUpdates:		with: className		in: 'client1'! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 11/2/2010 16:11'!testPreallocatedMagmaDictionary	self testMagmaDictionaryClass: #MagmaPreallocatedDictionary! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 7/23/2011 16:15'!verifyEnumerationOfMagmaDictionary	| magmaDict dict s1 s2 |	clientSession refresh.	magmaDict := clientSession root at: #testMagmaDictionary.	dict := Dictionary new.	magmaDict keysAndValuesDo:		[ : eachKey : eachVal | dict			at: eachKey			put: eachVal ].	self		 assert:		(magmaDict collect:			[ : each | each isNumber ifTrue: [ each squared ] ]) asArray asSet =			(dict collect:				[ : each | each isNumber ifTrue: [ each squared ] ]) asArray asSet ;		 assert:		(magmaDict select:			[ : each | each isNumber and: [ each odd ] ]) asArray asSet =			(dict select:				[ : each | each isNumber and: [ each odd ] ]) asArray asSet.	s1 := Set new.	s2 := Set new.	magmaDict do:		[ : each | s1 add: each ].	dict do:		[ : each | s2 add: each ].	self assert: s1 = s2! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 7/19/2010 16:01'!verifyMagmaDictAfterUpdates: aMagmaDictionary 	"Make sure still the correct size."	self assert: aMagmaDictionary lastKnownSize = 303.	"verify access before and after page-switch."	self		 assert: (aMagmaDictionary at: 450 asWords) = 450 asWords asUppercase ;		 assert: (aMagmaDictionary at: 350 asWords hash) = 'other 350' ;		 assert: (aMagmaDictionary at: 350 asWords) = 350 ;		 assert: (aMagmaDictionary at: 650 asWords) = 650 ;		 assert: (aMagmaDictionary at: 250 asWords) = 250 ;		 assert: (aMagmaDictionary at: 650 asWords) = 650 ;		 assert: (aMagmaDictionary at: 450 asWords) = 450 asWords asUppercase ;		 assert: (aMagmaDictionary at: 350 asWords) = 350 ;		 assert: (aMagmaDictionary at: 350 asWords hash) = 'other 350'.	self		 assert: aMagmaDictionary lastKnownSize = 303 ;		 assert: aMagmaDictionary size = 303! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 7/19/2010 15:02'!verifyMagmaDictBeforeUpdates: aMagmaDictionary	self assert: aMagmaDictionary size = 301.	200		to: 500		do:			[ : n | (aMagmaDictionary at: n asWords) = n ].	self deny: (aMagmaDictionary includesKey: 600)! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 11/2/2010 15:07'!verifyMagmaDictionaryAccess: className	| dict |	clientSession begin.	dict := clientSession root at: ('test', className) asSymbol.	self verifyMagmaDictBeforeUpdates: dict.	"Replace a value...  Add a value."	dict				at: 450 asWords		put: 450 asWords asUppercase ;				at: 650 asWords		put: 650.	"Test two objects with same hash, one persistent, one not, then both persistent."	self assert: 350 asWords hash = 350 asWords hash hash.	dict		at: 350 asWords hash		put: 'other 350'.	"anInteger"	self verifyMagmaDictAfterUpdates: dict.	clientSession commit! !!MagmaTestCase methodsFor: 'test MagmaDictionary' stamp: 'cmm 11/2/2010 15:07'!verifyMagmaDictionaryUpdates: className	clientSession refresh.	self verifyMagmaDictAfterUpdates: (clientSession root at: ('test' , className) asSymbol)! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 8/12/2007 20:29'!initializeNonPersistentSamples	"Lets have 100 non-persistent samples interleaved with the persistent ones.."	| firsts seconds thirds r |	nonPersistentSamples := OrderedCollection new.	firsts := (5 		to: 1000		by: 10) asArray shuffledBy: self random.	seconds := ((2453905 		to: 2454895		by: 10) collect: [ : e | Date julianDayNumber: e ]) shuffledBy: self random.	r := self random.	thirds := (1 to: 100) collect: [ : n | (r nextInt: (1 bitShift: 128)) asWords subStrings ].	1 to: firsts size do: 		[ : n | 		nonPersistentSamples add: {  (firsts at: n). (seconds at: n). (thirds at: n)  } ]! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 7/30/2006 16:45'!initializeSamples	"Build a collection of four-element Array's."	| firsts seconds thirds r|	r := self random.	samples := OrderedCollection new: 1000.	firsts := (1 		to: 10000		by: 10) asArray shuffledBy: r.	seconds := ((2453900 		to: 2463899		by: 10) collect: [ : e | Date julianDayNumber: e ]) shuffledBy: r.	thirds := self keywordsSamples.	1 		to: firsts size		do: 			[ : n | 			samples add: { 					(firsts at: n).					(seconds at: n).					(thirds at: n)				 } ]! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 8/14/2009 17:51'!keywordsSamples	^ KeywordsSamples ifNil: 		[ | cmInstances |		KeywordsSamples := OrderedCollection new.		cmInstances := CompiledMethod allInstances readStream.		[ cmInstances atEnd or: [ KeywordsSamples size >= 1000 ] ] whileFalse: 			[ | nextInstance |			nextInstance := cmInstances next.			nextInstance isInstalled ifTrue:				[ KeywordsSamples add: nextInstance maSourceString subStrings asSet asArray ] ].		self assert: KeywordsSamples size = 1000.		KeywordsSamples ]! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 7/11/2006 23:25'!persistentSamples	^ (1 to: 100) collect: [ : n | self sampleAt: n ]! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 8/6/2006 23:08'!sampleAt: indexInteger 	^ samplesInMc detect: [ : e | e = (samples at: indexInteger) ]! !!MagmaTestCase methodsFor: 'private-samples' stamp: 'cmm 7/11/2006 23:25'!samplesOf: attribute	^ samples collect: [ : e | e perform: attribute ]! !!MagmaTestCase methodsFor: 'loading code' stamp: 'cmm 1/1/2013 14:25'!loadCodeFrom: aPositionableStream 	aPositionableStream position: 0.	aPositionableStream		maFileInAnnouncing: 'loading code from conductor..'		logged: false! !!MagmaTestCase methodsFor: 'loading code' stamp: 'cmm 5/1/2003 17:12'!pushClass: aClass	self playersDo: [ :each | each name ~= 'server' ifTrue: [ each pushClass: aClass ] ]! !!MagmaTestCase methodsFor: 'loading code' stamp: 'cmm 11/9/2011 16:19'!removeDomainClasses	#(#MagmaPerson) do: [ : each | Smalltalk removeClassNamed: each ]! !!MagmaTestCase methodsFor: 'test local sessions' stamp: 'cmm 2/10/2009 10:32'!localDbName	^ '_testDb'! !!MagmaTestCase methodsFor: 'test local sessions' stamp: 'cmm 7/7/2009 22:46'!runLocalSessionsConcurrencyDetection	| session1 session2 location |	location := MagmaLocalLocation path: self localDbName.	"Quick test of MagmaLocalLocation #=, get the controller by looking it up that way."	session1 := MagmaSession repositoryController: (MagmaRepositoryController controllerOpenedOn: location).	session1 allowWriteBarrier: self class allowWriteBarrier.	session1 connectAs: 'session1'.	session2 := MagmaSession repositoryController: session1 repositoryController.	session2 connectAs: 'session2'.		[ session1 begin.	session1 root 		at: #foo		put: #bar.	session2 commit: 		[ session2 root 			at: #foo			put: #baz ].	self 		should: [ session1 commit ]		raise: MagmaCommitConflictError ] ensure: 		[ session1 disconnectAndClose.		session2 disconnectAndClose ]! !!MagmaTestCase methodsFor: 'test local sessions' stamp: 'cmm 7/7/2009 22:46'!runTestAdvanceIntoNewClassDefinitions	"Test whether #advanceUsing: can withstand new class-definitions."	| dbName s1 s2 c |	dbName := self localDbName.	s1 := MagmaSession openLocal: dbName.	s1 connectAs: 's1'.	s2 := MagmaSession openLocal: dbName.	s2 allowWriteBarrier: self class allowWriteBarrier.	s2 connectAs: 's2'.	c := s2 root.	"prevent gc"		[ s1 commit: 		[ s1 root 			at: 'hello'			put: Morph new ].	s2 tryToRefreshTo: s1 commitNumber ] ensure: 		[ s1 disconnect.		s2 disconnect ]! !!MagmaTestCase methodsFor: 'test local sessions' stamp: 'cmm 2/10/2009 11:00'!testLocallyConnectedSessions	"Test whether #advanceUsing: can withstand new class-definitions."	| dbName |	dbName := self localDbName.		[ MagmaRepositoryController		delete: dbName ;		create: dbName			root: Dictionary new ] 		on: MagmaDeleteWarning		do: [ : warn | warn resume ].	self		runTestAdvanceIntoNewClassDefinitions ;		runLocalSessionsConcurrencyDetection! !!MagmaTestCase methodsFor: 'test floats' stamp: 'cmm 1/16/2015 16:10'!longTestHashKey32	| currentHash priorHash |	priorHash := nil.	Float lowestToHighest32BitFloatsDo:		[ : float | currentHash := float hashKey32.		(priorHash ~~ nil and: [ float ~= 0.0 ]) ifTrue: [ self assert: currentHash > priorHash ].		priorHash := currentHash ]! !!MagmaTestCase methodsFor: 'test refresh' stamp: 'cmm 7/15/2009 14:33'!makeChanges	| oc mc |	clientSession abort.	refreshTestFixture := clientSession root at: #testRefresh.	oc := refreshTestFixture first.	mc := refreshTestFixture second.	clientSession commit: 		[ oc add: Object new.		mc add: Object new ]! !!MagmaTestCase methodsFor: 'test refresh' stamp: 'cmm 1/8/2009 07:28'!refreshViewAndCommit	"#refresh only wipes out changes made by other sessions.  MagmaCollection changes are never wiped out."	refreshTestFixture second add: Object new.	clientSession refresh.	self		assert: refreshTestFixture first notEmpty ;		assert: refreshTestFixture second size = 2.	refreshTestFixture first add: Object new.	clientSession commit! !!MagmaTestCase methodsFor: 'test refresh' stamp: 'cmm 1/8/2009 09:22'!setUpTestRefresh	refreshTestFixture := { 		(OrderedCollection new).		(MagmaCollection new)	 }.	clientSession		commit: 			[ clientSession root 				at: #testRefresh				put: refreshTestFixture ] ;		begin! !!MagmaTestCase methodsFor: 'test refresh' stamp: 'cmm 1/8/2009 07:30'!testRefresh	"client1 creates an Array with an OC, MC, and gets into a transaction.  client2 makes changes to the object, client1 refreshes to get those changes, then commits his own.  Finally, client2 verifies the changes client1 made."	self		remotePerform: #setUpTestRefresh			in: 'client1' ;		remotePerform: #makeChanges			in: 'client2' ;		remotePerform: #refreshViewAndCommit			in: 'client1' ;		remotePerform: #verifyTestRefresh			in: 'client2'! !!MagmaTestCase methodsFor: 'test refresh' stamp: 'cmm 1/8/2009 12:03'!verifyTestRefresh	self assert: refreshTestFixture first size = 1.	clientSession refresh.	self		assert: refreshTestFixture first size = 2 ;		assert: refreshTestFixture second size = 2! !!MagmaTestCase methodsFor: 'test connectionless requests' stamp: 'cmm 7/7/2009 21:51'!performDisconnectReconnect	"Just disconnecting and reconnecting would force the magmaId to be validated."	self assert: clientSession isConnected.	clientSession		disconnect ;		connectAs: clientSession userId.	self assert: clientSession magmaId maOriginalClass = MagmaId.	self assert: clientSession isConnected! !!MagmaTestCase methodsFor: 'test connectionless requests' stamp: 'cmm 7/15/2008 17:12'!testDisconnectReconnect	"Just disconnecting and reconnecting would force the magmaId to be validated."	self 		remotePerform: #performDisconnectReconnect		in: 'client1'! !!MagmaTestCase methodsFor: 'test ReadStrategy' stamp: 'cmm 9/26/2009 14:50'!setUpReadStrategyTest	| person spouse |	person := MagmaPerson new		name: 'John Doe' ;		birthday: Date today ;		address: (MaTestMailingAddress new				street: '37 W Broadway' ;				zip: 11011) ;		yourself.	spouse := MagmaPerson new		name: 'Jane Doe' ;		birthday: Date today - 3 days ;		address: (MaTestMailingAddress new				street: '101 Main' ;				zip: 11011) ;		yourself.	person marry: spouse.	clientSession commit: 		[ clientSession root 			at: #testReadStrategy			put: person ]! !!MagmaTestCase methodsFor: 'test ReadStrategy' stamp: 'cmm 9/26/2009 10:43'!testReadStrategy	self		remotePerform: #setUpReadStrategyTest			in: 'client1' ;		remotePerform: #verifyReadStrategyFunctionality			in: 'client2'! !!MagmaTestCase methodsFor: 'test ReadStrategy' stamp: 'cmm 10/25/2010 13:27'!verifyReadStrategyFunctionality	| rs verifier john jane |	"Test dynamic type-test on server (to go one deeper for spouse)."	rs := (MaReadStrategy minimumDepth: 0)		forVariableNamed: 'spouse'			onAny: MagmaPerson			readToDepth: 1 ;		yourself.	"Test inheritance of deeper depths from superclasses."	#(#MagmaContact #MagmaRenamedContact ) do: 		[ : each | 		(Smalltalk hasClassNamed: each) ifTrue: 			[ rs 				forVariableNamed: 'address'				onAny: (Smalltalk classNamed: each)				readToDepth: 1 ] ].	verifier := 	[ : person | 	self		assert: ((person maIsMutatingProxy and: [ person maRealObjectIsReified]) or: [ person maIsMutatingProxy not ]) ;		assert: (person name maIsMutatingProxy and: [ person name maRealObjectIsReified not ]);		assert: (person birthday maIsMutatingProxy and: [ person birthday maRealObjectIsReified not ]);		assert: ((person address maIsMutatingProxy and: [ person address maRealObjectIsReified ]) or: [ person address maIsMutatingProxy not ]) ;		assert: ((person spouse maIsMutatingProxy and: [ person spouse maRealObjectIsReified ]) or: [ person spouse maIsMutatingProxy not ]) ].	clientSession readStrategy: rs.	john := clientSession refresh root at: #testReadStrategy.	verifier value: john.	jane := john spouse.	verifier value: jane.	clientSession readStrategy: MaReadStrategy new! !!MagmaTestCase methodsFor: 'testMultiKeywordMatching' stamp: 'cmm 7/5/2008 20:18'!setUpTestMultiKeywordMatching	clientSession		abort ;		commit: 			[ | c |			clientSession root 				at: #testMultiKeywordMatching				put: (c := MagmaCollection new						addIndex: self newKeywordIndex ;						yourself).			1 				to: 1000				do: [ : n | c add: n asWords subStrings -> n ] ]! !!MagmaTestCase methodsFor: 'testMultiKeywordMatching' stamp: 'cmm 7/5/2008 19:35'!testMultiKeywordMatching	self		remotePerform: #setUpTestMultiKeywordMatching			in: 'client1' ;		remotePerform: #verifyMultiKeywordQueries			in: 'client2'! !!MagmaTestCase methodsFor: 'testMultiKeywordMatching' stamp: 'cmm 7/5/2008 21:05'!verifyMultiKeywordQueries	| mc mcBeginsWithQueryResult smalltalkBeginsWithQueryResult mcEntireWordQueryResults smalltalkEntireWordQueryResult index |	clientSession abort.	mc := clientSession root at: #testMultiKeywordMatching.	index := mc indexes first.	mcBeginsWithQueryResult := (mc where: [ : each | each key includesAllPrefixes: #('th' 'fo' ) ]) asArray asBag.	smalltalkBeginsWithQueryResult := ((1 to: 1000) collect: [ : n | n asWords subStrings -> n ]) asBag select: 		[ : eachAssoc | 		#('th' 'fo' ) allSatisfy: 			[ : eachPrefix | 			eachAssoc key anySatisfy: 				[ : eachString | 				eachString 					maBeginsWith: eachPrefix					caseSensitive: false ] ] ].	"Compare Bags because consistent order is not required."	self assert: mcBeginsWithQueryResult = smalltalkBeginsWithQueryResult.	"Now ensure entire keywords search works equally well."	mcEntireWordQueryResults := (mc where: [ : each | each key includesAllOf: #('three' 'seven' ) ]) asArray asBag.	smalltalkEntireWordQueryResult := ((1 to: 1000) collect: [ : n | n asWords subStrings -> n ]) asBag select: 		[ : eachAssoc | 		#('three' 'seven' ) allSatisfy: 			[ : eachPrefix | 			eachAssoc key anySatisfy: 				[ : eachString | 				(eachString first: (index meaningfulCharacters min: eachString size)) asLowercase = eachPrefix ] ] ].	self assert: mcEntireWordQueryResults = smalltalkEntireWordQueryResult! !!MagmaTestCase methodsFor: 'test client identity-dict' stamp: 'cmm 2/20/2011 16:33'!setUpTestPersistentObjectsInIdentityDict	clientSession commit:		[ clientSession root			at: #testPersistentObjectsInIdentityDict			put: IdentityDictionary new ]! !!MagmaTestCase methodsFor: 'test client identity-dict' stamp: 'cmm 2/20/2011 16:33'!testPersistentObjectsInIdentityDict	"I sense that, now that we've removed MagmaMutatingProxy>>#identityHash, whether we can actually have Magma objects in a IdentityDictionary."	self				remotePerform: #setUpTestPersistentObjectsInIdentityDict		in: 'client1' ;				remotePerform: #updateIdentityDict		in: 'client2' ;				remotePerform: #verifyIdentityDict		in: 'client1'! !!MagmaTestCase methodsFor: 'test client identity-dict' stamp: 'cmm 2/20/2011 16:33'!updateIdentityDict	"Replace all of the objects with new objects, to force them as proxies in the other client when it refreshes."	| ids |	clientSession refresh.	ids := clientSession root at: #testPersistentObjectsInIdentityDict.	clientSession commit:		[ 1			to: 1000			do:				[ : n | ids at: Object new put: nil ] ]! !!MagmaTestCase methodsFor: 'test client identity-dict' stamp: 'cmm 8/7/2013 15:01'!verifyIdentityDict	"Now that client2 has updated them all, we should have all proxies in our IdentityDictionary."	| idd |	clientSession refresh.	idd := clientSession root at: #testPersistentObjectsInIdentityDict.	"Unfortunately, Rehash is required before using id-Dictionary's with Magma because the objects were originally put in by their proxy ."	idd rehash.	"Now verify the same after bulkBecome..."	"	clientSession bulkBecomeProxies."	idd keysDo:		[ : each | self assert: (idd includesKey: each) ]! !!MagmaTestCase methodsFor: 'test changed detection' stamp: 'cmm 6/17/2012 19:05'!setupChangedDetection	clientSession commit:		[ clientSession root			at: #testChangedDetection			put: (MagmaPerson new name: 'original-name') ]! !!MagmaTestCase methodsFor: 'test changed detection' stamp: 'cmm 7/19/2012 11:09'!slyUpdate	clientSession refresh.	[ (clientSession root at: #testChangedDetection) name: 'updated-name' ]		on: MagmaSessionRequest		do:			[ : req | req handleAndResumeUsing: clientSession ]! !!MagmaTestCase methodsFor: 'test changed detection' stamp: 'cmm 6/18/2012 09:59'!testChangedDetection	"There is a special case when using the WriteBarrier for which it requires special handling by Magma for it to detect change to the object.  See #valueWhileObservingStateChange for details."	self				remotePerform: #setupChangedDetection		in: 'client1' ;				remotePerform: #slyUpdate		in: 'client2' ;				remotePerform: #verifySlyUpdate		in: 'client1'! !!MagmaTestCase methodsFor: 'test changed detection' stamp: 'cmm 6/17/2012 19:07'!verifySlyUpdate	clientSession refresh.	self should: [ (clientSession root at: #testChangedDetection) name = 'updated-name' ]! !!MagmaTestCase methodsFor: 'test MaLargeArrayOfNumbers' stamp: 'cmm 3/6/2009 17:03'!testLargeCollectionOfIntegers	| lci filename |	filename := FileDirectory default fullNameFor: '_test_magma_largeArray.idx'.	"ensure deleted.."	FileDirectory default 		deleteFileNamed: '_test_magma_largeArray.idx'		ifAbsent: 			[ "no problemo"			 ].	lci := MaLargeArrayOfNumbers 		createNamed: filename		bitSize: MaObjectFiler maxDbSize.	lci 		at: 10000		put: 33.	1 		to: 9999		do: [ : n | self assert: (lci at: n) = 0 ]! !!MagmaTestCase methodsFor: 'test node equivalence' stamp: 'cmm 7/24/2018 15:41'!testNodeEquivalence	| equivalentLocations |	equivalentLocations := { 		(MagmaRemoteLocation 			host: NetNameResolver maLocalHostName			port: 123).		(MagmaRemoteLocation 			host: NetNameResolver localHostAddress maAsIpString			port: 123).		(MagmaRemoteLocation 			host: '127.0.0.1'			port: 123).		(MagmaRemoteLocation 			host: '127.0.1.1'			port: 123).		(MagmaRemoteLocation 			host: 'localhost'			port: 123).	 }.	self assert: (equivalentLocations collect: [ : each | each hash ]) asSet size = 1.	self assert: equivalentLocations asSet size = 1! !!MagmaTestCase methodsFor: 'test querys - non-persistent empty' stamp: 'cmm 7/11/2006 23:22'!testNonPersistentEmpty	| mc oc |	mc := self newMc.	oc := OrderedCollection new.	self 		verifyMc: mc		against: oc! !!MagmaTestCase methodsFor: 'test querys - non-persistent populated' stamp: 'cmm 8/7/2006 00:02'!testNonPersistentPopulated	| mc oc |	self initializeSamples.	mc := self newMc.	self load: mc.	samplesInMc := (mc asArray: mc size) asSet.	oc := OrderedCollection new: samples size.	"Make a new copy of the samples because dressUp will modify the objects in-place, we want to do that independently for the mc and oc."	self initializeSamples.	self load: oc.	self 		verifyMc: mc		against: oc.	self		addSomeRemoveSome: mc ;		addSomeRemoveSome: oc.	self 		verifyMc: mc		against: oc! !!MagmaTestCase methodsFor: 'test become' stamp: 'cmm 1/15/2005 13:47'!xtestBecomeself maMarked: 'dev'.  "This test fails.  Magma is not expecting differently shaped objects when it refreshes its objects.  For the future..  maybe."	self		remotePerform: #setUpTestBecome		in: 'client1'.	self		remotePerform: #become		in: 'client2'.	self		remotePerform: #verifyBecome		in: 'client1'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaTestCase class	instanceVariableNames: ''!!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 3/29/2010 16:52'!allowWriteBarrier	"Indicates whether all client sessions will be initialized with their #allowWriteBarrier: true."	^ TestWithWriteBarrier ifNil: 		[ self allowWriteBarrier: MagmaPreferences canEnableWriteBarrier.		TestWithWriteBarrier ]! !!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 1/16/2014 14:55'!allowWriteBarrier: aBoolean 	(aBoolean==true and: [ MagmaPreferences canEnableWriteBarrier not ]) ifTrue: [ MagmaPreferences signalCannotEnableWriteBarrier ].	TestWithWriteBarrier := aBoolean ! !!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 1/8/2009 13:54'!defaultServer2Port	^ 51970! !!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 2/6/2009 10:10'!defaultServerPort	^ 51969! !!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 7/24/2018 15:41'!magmaServer2Location	^ MagmaRemoteLocation 		host: NetNameResolver maLocalHostName		port: self defaultServer2Port! !!MagmaTestCase class methodsFor: 'accessing' stamp: 'cmm 7/24/2018 15:41'!magmaServerLocation	^ MagmaRemoteLocation 		host: NetNameResolver maLocalHostName		port: self defaultServerPort! !!MagmaTestCase class methodsFor: 'create suite' stamp: 'cmm 1/2/2013 20:33'!buildSuite	| suite |	suite := super buildSuite.	#(#testAddIndexAndObjectsSimultaneously #testConcurrency #testEmptyMagmaArray #testKeywordIndex #testMagmaArray #testMagmaDictionary #testMagmaHashTable #testMagmaSet #testMagmaSolHashTable #testMajorFunctions #testMultiKeywordMatching #testNonPersistentEmpty #testNonPersistentPopulated #testNonPersistentReader #testNonPersistentSolHashTables #testNpIntegrationForMagmaArrays #testNpIntegrationForMagmaCollections #testNpIntegrationForReaders #testPersistentEmpty #testPersistentPopulated #testPersistentReader #testPersistentResultSet #testPreallocatedMagmaDictionary #testReleaseReader #testStaleCollections ) do:		[ : eachSelector | suite tests add:			(suite tests remove:				(suite tests detect:					[ : each | each selector = eachSelector ])) ].	^ suite! !!MagmaTestCase class methodsFor: 'create suite' stamp: 'cmm 1/3/2013 14:10'!suiteClass	^ MagmaTestSuite! !!MagmaTestCase class methodsFor: 'initialize-release' stamp: 'cmm 2/9/2009 10:35'!initialize	super initialize.	Smalltalk addToStartUpList: self! !!MagmaTestCase class methodsFor: 'framework' stamp: 'cmm 1/2/2013 16:21'!shouldInheritSelectors 	^ false! !MaNetworkTestSuite subclass: #MagmaTestSuite	instanceVariableNames: 'initiateBackupPrereqsCompleted verifyRestorePreqreqsCompleted'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Tester-SUnit tests'!!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 7/16/2007 22:10'!createRepository: aString root: anObject 	[ MagmaRepositoryController		delete: aString ;		create: aString			root: anObject ] 		on: MagmaDeleteWarning		do: [ : warning | warning resume ]! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 7/24/2008 10:17'!dontAcceptChangeLogging	"This method answers the source code to compile a new method on MaObject class so that, when the 'Magma server' package is unloaded, it won't thrash the hard drive so much."	^ 'acceptsLoggingOfCompilation	^ false'! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 1/9/2009 10:11'!ensureNoContactMethodsAttribute	MagmaTestObject 		subclass: #MagmaContact		instanceVariableNames: 'name address unused'		classVariableNames: ''		poolDictionaries: ''		category: 'Magma tester-Test domains'! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 1/1/2013 14:59'!playerNames	^ #('client1' 'client2' 'server' 'server2' )! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 1/3/2013 17:29'!removeServerPackage	Utilities setAuthorInitials: self class name.	MaObject class compile: self dontAcceptChangeLogging.	(MCPackage named: 'Magma-Server') workingCopy unload.	MaObject class removeSelector: #acceptsLoggingOfCompilation.	self assert: (Smalltalk hasClassNamed: #MagmaServerConsole) not! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 10/13/2014 13:24'!setUp"Force pre-initialization of keywordsSamples to ensure uniform across all images."self tests anyOne keywordsSamples.	initiateBackupPrereqsCompleted := Set new.	verifyRestorePreqreqsCompleted := Set new.	"Prevent accidental explosion of launching images!!."	MagmaRepositoryDefinition runningTestCases		ifTrue: [ MagmaUserError signal: 'Already running test cases.' ]		ifFalse: [ MagmaRepositoryDefinition runningTestCases: true ].	MagmaSession cleanUp.	(MagmaSession allInstances anySatisfy:		[ : each | each isLocal ]) ifTrue: [ self halt: 'Must not have any local MagmaSessions when running tests.' ].	MagmaPreferences debug: true.	"Make sure multiple files get tested by reducing it way down."	MaAtomicFileStream maxPhysicalFileSize: 30000.	"Make sure we test recovery requiring it to allocate extra space for recovery records."	MaRecoveryManager defaultRecordSize: 25.	super setUp.	orchestra isConductorImage		ifTrue:			[ self				createRepository: self environmentDirectory				root: Dictionary new.			self ensureNoContactMethodsAttribute.			orchestra				 pushClass: (Smalltalk classNamed: #MagmaContact) ;				 pushClass: (Smalltalk classNamed: #MagmaPerson).			(orchestra playerNamed: 'server')				 remotePerform: #removeDomainClasses ;								remotePerform: #startServer:				with: true.			tests anyOne connectClients ]		ifFalse:			[ (#('server' 'server2' ) anySatisfy:				[ : each | (orchestra playerNamed: each) isHome ]) ifTrue: [ (Smalltalk at: #MagmaCollectionIndex) maRecursiveRemove ].			#('client1' 'client2' ) do:				[ : each | (orchestra playerNamed: each) isHome ifTrue: [ self removeServerPackage ] ] ]! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 1/3/2013 17:17'!tearDown	orchestra isConductorImage ifTrue:		[ "'server2'"		#('server' ) do:			[ : each | tests anyOne				remotePerform: #assertNoMagmaCollectionIndexClass				in: each ].		tests anyOne			 disconnectClients ;						remotePerform: #stopServer			in: 'server'.		super tearDown ]! !!MagmaTestSuite methodsFor: 'setup-teardown' stamp: 'cmm 8/22/2013 14:40'!validateProtocol	"With the new fixed protocol, it is easy to forget when we start using a new class.  This method performs some quick checks but cannot guarantee the protocol is 100% correct."	| expectedClasses otherSubclasses |	expectedClasses := { 		(MaObjectBuffer withAllSubclasses).		(MagmaRepositoryRequest withAllSubclasses).		(MagmaServerResult withAllSubclasses).		(MagmaLocation withAllSubclasses).		(MaTerm withAllSubclasses).		(MagmaCollection withAllSubclasses).		(MaError withAllSubclasses)	 } 		inject: OrderedCollection new		into: [ : coll : each | coll addAll: each ].	otherSubclasses := { 		#MauiSoftwareError.		#MakoUserError.		#MauiUserError.		#MagmaToolsUserError.		#MakoSoftwareError.		#MakoInvalidAccessAttemptError.		#MakoEnvironmentError.		#TephraUserError.  #TephraEnvironmentError.		#MagmaPotentiallyOpenError	 } 		select: [ : each | Smalltalk hasClassNamed: each ]		thenCollect: [ : each | Smalltalk classNamed: each ].	expectedClasses removeAll: otherSubclasses.	(expectedClasses difference: MagmaSession protocol) in: 		[ : missing | 		missing ifNotEmpty: 			[ MagmaWarning signal: missing asArray asString , ' appear to be missing from the protocol.' ] ]! !!MagmaTestSuite methodsFor: 'accessing' stamp: 'cmm 1/4/2013 17:20'!environmentDirectory	^ FileDirectory default / '_test_magma'! !!MagmaTestSuite methodsFor: 'accessing' stamp: 'cmm 1/3/2013 14:30'!initiateBackupPrereqsCompleted	^ initiateBackupPrereqsCompleted! !!MagmaTestSuite methodsFor: 'accessing' stamp: 'cmm 1/3/2013 14:30'!initiateBackupPrereqsCompleted: aSet 	initiateBackupPrereqsCompleted := aSet! !!MagmaTestSuite methodsFor: 'accessing' stamp: 'cmm 1/3/2013 14:30'!verifyRestorePreqreqsCompleted	^ verifyRestorePreqreqsCompleted! !!MagmaTestSuite methodsFor: 'accessing' stamp: 'cmm 1/3/2013 14:30'!verifyRestorePreqreqsCompleted: aSet 	verifyRestorePreqreqsCompleted := aSet! !!MagmaTestSuite methodsFor: 'overriding' stamp: 'cmm 3/22/2013 10:44'!startingPort	"Pick a port number range that won't conflict with the defaults, in case another application is running."	^ 44430! !!MagmaTestSuite methodsFor: 'overriding' stamp: 'cmm 2/6/2009 17:20'!suiteName	^ 'magma'! !MagmaTestCase initialize!