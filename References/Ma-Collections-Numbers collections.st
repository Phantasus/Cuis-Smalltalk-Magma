MaObject subclass: #MaHashIndexHeader	instanceVariableNames: 'byteArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaHashIndexHeader methodsFor: 'initialize' stamp: 'cmm 4/4/2007 23:45'!byteArray: aByteArray	byteArray := aByteArray! !!MaHashIndexHeader methodsFor: 'initialize' stamp: 'cmm 4/4/2007 23:44'!initialize	super initialize.	byteArray := ByteArray new: self class headerSize! !!MaHashIndexHeader methodsFor: 'initialize' stamp: 'cmm 4/4/2007 23:58'!keySize: anInteger 	byteArray 		maUint: 16		at: (self positionOfKeySizeForVersion: self class version)		put: anInteger! !!MaHashIndexHeader methodsFor: 'initialize' stamp: 'cmm 4/5/2007 00:00'!recordSize: anInteger 	byteArray 		maUint: 8		at: (self positionOfRecordSizeForVersion: self class version)		put: anInteger! !!MaHashIndexHeader methodsFor: 'initialize' stamp: 'cmm 4/5/2007 00:01'!valueSize: anInteger 	byteArray 		maUint: 16		at: (self positionOfValueSizeForVersion: self class version)		put: anInteger! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 4/5/2007 00:02'!headerBytesForKeySize: keySize valueSize: valueSize recordSize: hashRecordSize 	self		keySize: keySize ;		valueSize: valueSize ;		recordSize: hashRecordSize.	^ byteArray! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 4/8/2007 20:13'!headerSize	^ self version = 1 		ifTrue: [ 3 ]		ifFalse: [ 100 ]! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 4/8/2007 19:58'!keySize	^ self version in: 		[ : version | 		| modifier |		modifier := version = 1 			ifTrue: [ 1 ]			ifFalse: [ 0 ].		(byteArray 			maUint: (self sizeOfKeySizeForVersion: version)			at: (self positionOfKeySizeForVersion: version)) + modifier ]! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:10'!recordSize	^ byteArray byteAt: (self positionOfRecordSizeForVersion: self version) + 1! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 4/8/2007 20:07'!valueSize	^ self version in: 		[ : version | 		| modifier |		modifier := version = 1 			ifTrue: [ 1 ]			ifFalse: [ 0 ].		(byteArray 			maUint: (self sizeOfValueSizeForVersion: version)			at: (self positionOfValueSizeForVersion: version)) + modifier ]! !!MaHashIndexHeader methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:11'!version	^ (byteArray byteAt: self positionOfVersion1Indicator + 1) = 0		ifTrue: [ byteArray byteAt: self positionOfVersion + 1 ]		ifFalse: [ 1 ]! !!MaHashIndexHeader methodsFor: 'printing' stamp: 'cmm 4/8/2007 19:56'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	self 		maPrintAttributes: #(				#version				#keySize				#valueSize				#recordSize			)		on: aStream! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/4/2007 23:57'!positionOfKeySizeForVersion: anInteger 	^ anInteger = 1 		ifTrue: [ 0 ]		ifFalse: [ 2 ]! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/5/2007 00:00'!positionOfRecordSizeForVersion: anInteger 	^ anInteger = 1 		ifTrue: [ 2 ]		ifFalse: [ 6 ]! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/5/2007 00:01'!positionOfValueSizeForVersion: anInteger 	^ anInteger = 1 		ifTrue: [ 1 ]		ifFalse: [ 4 ]! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/4/2007 23:51'!positionOfVersion	"Position of the version for version 2+ HashIndexes."	^ 1! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/4/2007 23:50'!positionOfVersion1Indicator	"The first version of MaHashIndex did not have the foresight to include a version indicator.  However, position 0 of the header is the keySize, which can never be 0.  Therefore, version 2+ reserves position 0 for the 'version 1 indicator', which, if 0, is NOT version 1, if it is >0, it *is* verison 1."	^ 0! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/5/2007 00:07'!sizeOfKeySizeForVersion: anInteger 	^ anInteger = 1 		ifTrue: [ 8 ]		ifFalse: [ 16 ]! !!MaHashIndexHeader methodsFor: 'private' stamp: 'cmm 4/5/2007 00:07'!sizeOfValueSizeForVersion: anInteger 	^ anInteger = 1 		ifTrue: [ 8 ]		ifFalse: [ 16 ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaHashIndexHeader class	instanceVariableNames: ''!!MaHashIndexHeader class methodsFor: 'accessing' stamp: 'cmm 4/5/2007 00:10'!currentVersion	^ 2! !!MaHashIndexHeader class methodsFor: 'accessing' stamp: 'cmm 4/4/2007 23:45'!headerSize	"Header consists of:		version:  8 bits		keySize:  16 bits		valueSize: 16 bits		recordSize: 8 bits"	^ 100! !!MaHashIndexHeader class methodsFor: 'accessing' stamp: 'cmm 4/5/2007 00:11'!version	"The highest version this HashIndex can support."	^ 2! !MaObject subclass: #MaIntervalCollection	instanceVariableNames: 'intervals proximityThreshold'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaIntervalCollection commentStamp: 'cmm 6/4/2005 00:48' prior: 0!This class keeps track of a collection of intervals.As intervals are added that intersect or are within the proximityThresholdof existing intervals, the existing interval is enlarged to include for the new interval.If an interval is removed in the middle of a large interval such thata "hole" is created, a new interval will be created and the other onewill be adjusted so that they will represent only the valid ranges.For example:	if an instance of this class has 1..10	and we add: 8..15, then this class will have a single interval from 1..15	Then remove 5..11..  Assuming a proximityThreshold of 1, this class will have the following two intervals:		1..4		12..15Use a proximityThreshold of 0 to track the real-numbers..!!MaIntervalCollection methodsFor: 'add / remove' stamp: 'cmm 6/13/2005 15:43'!addFrom: low to: high	| intersecting lowestLow highestHigh |	low > high ifTrue: [ self error: 'low should be lower than high' ].	intersecting := self intervalsIntersecting: (self expandedFrom: low to: high).	lowestLow := low.	highestHigh := high.	intersecting do:		[ : each |		lowestLow := lowestLow min: each first.		highestHigh := highestHigh max: each last ].	intervals		removeAll: intersecting ;		add: (lowestLow to: highestHigh)! !!MaIntervalCollection methodsFor: 'add / remove' stamp: 'cmm 6/4/2005 18:19'!removeFrom: low to: high"Removing is a two-step process:1) remove intervals completely contained by input2) adjust intersecting intervals	- each intersects input-low only, set its high to input-low	- each intersects input-high only, set its low to input-high	- each intersects input-low and input-high, set its high to inputs-low and addFrom: inputs-high to its original high"	(self intervalsInside: (low to: high)) do: [ : each | intervals remove: each ].	(self intervalsIntersecting: (self expandedFrom: low to: high))		do: 			[ : each |  | eachIntersectsLow eachIntersectsHigh |			eachIntersectsLow := low between: each first and: each last.			eachIntersectsHigh := high between: each first and: each last.			{ eachIntersectsLow. eachIntersectsHigh } caseOf:				{ [ { true. false } ] -> [ each setFrom: each first to: high by: each increment ].				[ { false. true } ] -> [ each setFrom: low to: each last by: each increment ].				[ { true. true } ] -> 					[ | oldHigh |					oldHigh := each last.					each setFrom: each first to: low by: each increment.					self addFrom: high to: oldHigh ] } ]! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:04'!expandedFrom: low to: high	^ low-proximityThreshold to: high+proximityThreshold! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:08'!initialize	super initialize.	intervals := SortedCollection sortBlock: [ : a : b | a first < b first ].	proximityThreshold := 1! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 17:22'!intervalsInside: anInterval	^ intervals select: [ : each | anInterval maEnvelopes: each ]! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:04'!intervalsIntersecting: anInterval	^ intervals select: [ : each | each maIntersects: anInterval ]! !!MaIntervalCollection methodsFor: 'testing' stamp: 'cmm 6/4/2005 01:07'!includes: aNumber	^ intervals anySatisfy: [ : each | each includes: aNumber ]! !!MaIntervalCollection methodsFor: 'enumerating' stamp: 'cmm 4/12/2006 10:48'!intervalsDo: aBlock	intervals do: aBlock! !!MaIntervalCollection methodsFor: 'printing' stamp: 'cmm 6/4/2005 18:04'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	intervals do:		[ : each |		aStream 			maPrint: each first ;			maPrint: '..' ;			maPrint: each last ;			space ]! !!MaIntervalCollection methodsFor: 'copying' stamp: 'cmm 10/19/2005 10:05'!postCopy	super postCopy.	intervals := intervals copy! !MaObject subclass: #MaLargeArrayOfRecords	instanceVariableNames: 'broker'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaLargeArrayOfRecords commentStamp: 'cmm 3/18/2007 23:38' prior: 0!I represent large Array of ByteArray "records".  I am capable of being truly large when my 'broker' is a MaFileRecordBroker, and I am mostly used with such a broker, even though my default is an MaInImageRecordBroker.!!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 6/14/2005 10:41'!close	broker close! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:37'!create: aReadWriteStream	broker := 		(MaFileRecordBroker headerSize: self headerSize)			recordSize: broker recordSize ;			yourself.	broker create: aReadWriteStream.	self writeHeader! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/22/2005 21:24'!delete	broker delete! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/23/2005 17:35'!initialize	super initialize.	broker := MaInImageRecordBroker new! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 6/14/2005 10:10'!open: aReadWriteStream	broker := MaFileRecordBroker headerSize: self headerSize.	broker open: aReadWriteStream.	self readHeader! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/19/2005 10:13'!readHeader	| headerBytes |	headerBytes := ByteArray new: self headerSize.	broker readHeaderInto: headerBytes.	self initializeFromHeader: headerBytes! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/18/2005 15:53'!writeHeader	broker writeHeaderFrom: self newHeaderBytes! !!MaLargeArrayOfRecords methodsFor: 'access' stamp: 'cmm 6/6/2005 12:31'!filename	^ broker filename! !!MaLargeArrayOfRecords methodsFor: 'access' stamp: 'cmm 7/6/2005 22:52'!filesDo: oneArgBlock	broker filesDo: oneArgBlock! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 7/18/2005 13:27'!headerSize	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 5/18/2005 16:22'!initializeFromHeader: aByteArray	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 6/30/2005 23:14'!newHeaderBytes	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: '*magma-server' stamp: 'cmm 10/22/2006 15:07'!filePool: aMaFileStreamPool	broker filePool: aMaFileStreamPool! !!MaLargeArrayOfRecords methodsFor: '*magma-server-recovery' stamp: 'cmm 6/5/2005 18:24'!unapplyUsing: aMaApplyRecord	broker unapplyUsing: aMaApplyRecord! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLargeArrayOfRecords class	instanceVariableNames: ''!!MaLargeArrayOfRecords class methodsFor: 'create' stamp: 'cmm 6/14/2005 10:34'!open: aReadWriteStream	^ self new open: aReadWriteStream! !!MaLargeArrayOfRecords class methodsFor: 'create' stamp: 'cmm 12/3/2011 15:56'!openNamed: filenameString 	| file |	(StandardFileStream isAFileNamed: filenameString) ifFalse: [ MaEnvironmentError signal: filenameString , ' does not exist.' ].	file := StandardFileStream fileNamed: filenameString.	(file isNil or: [ file closed ]) ifTrue: [ MaEnvironmentError signal: 'Could not create ' , filenameString ].	^ self open: file binary! !MaLargeArrayOfRecords subclass: #MaLargeArrayOfNumbers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaLargeArrayOfNumbers commentStamp: 'cmm 3/18/2007 22:59' prior: 0!MaLargeArrayOfNumbers is an auto-growing, never-shrinking array of numbers.  All numbers have the same number of bits available to represent them.!!MaLargeArrayOfNumbers methodsFor: 'accessing'!add: anInteger	^self		at: self size + 1		put: anInteger! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 3/15/2005 21:42'!at: index	^ self		at: index		ifAbsent: [ self error: 'index out of bounds' ]! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 3/20/2007 21:42'!at: logicalIndex ifAbsent: aBlock 	| bytes |	(self includesKey: logicalIndex) ifFalse: [ ^ aBlock value ].	broker 		readInto: (bytes := self newRecordBytes)		at: logicalIndex - 1.	^ bytes 		maUint: broker recordSize * 8		at: 0! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 3/20/2007 21:49'!at: logicalIndex put: anInteger 	| bytes |	logicalIndex > self maxSize ifTrue: [ MaUserError signal: 'Out of range.' ].	bytes := self newRecordBytes.	bytes		maUint: broker recordSize * 8		at: 0		put: anInteger.	broker 		writeFrom: bytes		at: logicalIndex - 1.	^ anInteger! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:39'!maxSize	^ self maxFileSize // broker recordSize! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/17/2005 23:39'!size	^ broker size! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 4/13/2005 15:27'!upTo: countInteger startingAt: startInteger	| answer size targetX |	size := self size.	startInteger > size ifTrue: [ ^ #() ].	answer := Array new: (countInteger min: size-startInteger+1).	targetX := 0.	startInteger to: (startInteger+countInteger-1 min: size) do:		[ : sourceX |		answer			at: (targetX := targetX + 1)			put: (self at: sourceX) ].	^ answer! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 3/20/2007 21:36'!byteSize: anInteger 	broker		headerSize: self headerSize ;		recordSize: anInteger! !!MaLargeArrayOfNumbers methodsFor: 'private'!headerSize	"Header consists of:		number of bits per Integer in the receiver."	^1! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 3/15/2005 21:40'!maxFileSize	^ 2000000000! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 3/20/2007 21:40'!newRecordBytes	^ ByteArray new: broker recordSize! !!MaLargeArrayOfNumbers methodsFor: 'testing' stamp: 'cmm 6/4/2005 18:38'!includesKey: anInteger	^ anInteger		between: 1		and: self size! !!MaLargeArrayOfNumbers methodsFor: 'initialize' stamp: 'cmm 3/20/2007 21:34'!initializeFromHeader: aByteArray 	broker recordSize:		(aByteArray 			maUint: 8			at: 0)! !!MaLargeArrayOfNumbers methodsFor: 'initialize' stamp: 'cmm 5/19/2005 10:43'!newHeaderBytes	"Answer a new ByteArray containing the header for the receiver.	This is only used when creating the an instance of this class with	the create: constructor."	^(ByteArray new: self headerSize)		maUint: 8		at: 0		put: broker recordSize;		yourself! !!MaLargeArrayOfNumbers methodsFor: 'printing' stamp: 'cmm 2/5/2003 00:25'!maPrintAbbreviatedOn: aStream	1		to: (self size min: 100)		do:			[ :each |			aStream				space;				maPrint: (self at: each ifAbsent: [ 'error at: ', each printString ]) ].	self size > 100 ifTrue: [ aStream nextPutAll: ' ...' ]! !!MaLargeArrayOfNumbers methodsFor: '*magma-server' stamp: 'cmm 3/22/2005 18:07'!do: aBlock for: aMagmaFileTraverser using: aMaReadStrategy	1 to: self size do:		[ : x |  | oid |		(oid := self at: x) ~= 0			ifTrue:				[ aMagmaFileTraverser					graphFrom: oid					do: aBlock					using: aMaReadStrategy ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaLargeArrayOfNumbers class	instanceVariableNames: ''!!MaLargeArrayOfNumbers class methodsFor: 'utilities' stamp: 'cmm 6/13/2005 23:09'!create: aReadWriteStream bitSize: anInteger	^ (self newWithBitSize: anInteger)		create: aReadWriteStream ;		yourself! !!MaLargeArrayOfNumbers class methodsFor: 'utilities' stamp: 'cmm 12/3/2011 15:56'!createNamed: filenameString bitSize: anInteger 	| file |	(StandardFileStream isAFileNamed: filenameString) ifTrue: [ MaEnvironmentError signal: filenameString , ' already exists.' ].	file := StandardFileStream fileNamed: filenameString.	(file isNil or: [ file closed ]) ifTrue: [ MaEnvironmentError signal: 'Could not create ' , filenameString ].	^ self		create: file		bitSize: anInteger! !!MaLargeArrayOfNumbers class methodsFor: 'creation' stamp: 'cmm 5/23/2005 17:45'!newWithBitSize: anInteger	^ self new		byteSize: anInteger / 8 ;		yourself! !!MaLargeArrayOfNumbers class methodsFor: 'accessing' stamp: 'cmm 3/20/2005 19:23'!suggestedFileExtension	^ 'idx'! !MaLargeArrayOfRecords subclass: #MaMagnitudeIndex	instanceVariableNames: 'keySize valueSize nextRecordNumber highestPossibleKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaMagnitudeIndex commentStamp: '<historical>' prior: 0!keySize in bits.!!MaMagnitudeIndex methodsFor: 'building'!add: oidInteger at: keyInteger	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 12/1/2014 15:54'!highestPossibleKey	^ highestPossibleKey ifNil: [ highestPossibleKey := (1 bitShift: keySize) - 1 ]! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 5/23/2005 23:13'!initialize	super initialize.	nextRecordNumber := 0! !!MaMagnitudeIndex methodsFor: 'accessing'!keySize	^keySize! !!MaMagnitudeIndex methodsFor: 'accessing'!lowestPossibleKey	^0! !!MaMagnitudeIndex methodsFor: 'accessing'!recordSize	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 4/28/2005 21:12'!valueSize	^ valueSize! !!MaMagnitudeIndex methodsFor: 'private'!keySize: numberOfBitsInteger	keySize := numberOfBitsInteger! !!MaMagnitudeIndex methodsFor: 'private' stamp: 'cmm 8/22/2005 09:24'!open: aReadWriteStream	super open: aReadWriteStream.	nextRecordNumber := broker nextRecordNumber.	nextRecordNumber isInteger		ifFalse:			[ MaSpecialCollectionsSoftwareError signal: 'Invalid index size.  Requires maintenance tool.' ]! !!MaMagnitudeIndex methodsFor: 'framework' stamp: 'cmm 12/23/2002 22:16'!size	self subclassResponsibility! !MaMagnitudeIndex subclass: #MaHashIndex	instanceVariableNames: 'hashRecordSize record recordFactory guard'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Numbers collections'!!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 12/5/2014 13:40'!add: valueInteger at: keyInteger 	"Find the record which either has space for keyInteger or is as far zoomed-in as possible (with either space for keyInteger or not).  If a record already contains another key greater than keyInteger, that entry must be 'pushed' down so we can maintain key order.  Additionally, we must increment the numberOfChildren for each record to the path of where we finally add."	guard critical: 		[ | currentKeyToWrite currentValueToWrite hasSpace reachedBottom |		keyInteger > self highestPossibleKey ifTrue:			[ MaHashIndexUserError signal: keyInteger printString, ' is larger than the highestPossibleKey.' ].		currentKeyToWrite := keyInteger.		currentValueToWrite := valueInteger.		self selectRoot.		hasSpace := false.		reachedBottom := false.		[ hasSpace | reachedBottom ] whileFalse: 			[ | highestBax keyToMove valueToMove childRecordNumber |			highestBax := record highestByteArrayIndexFor: currentKeyToWrite.			((hasSpace := record canAdd: currentKeyToWrite) or: 				[ (keyToMove := record keyAtByteArrayIndex: highestBax) > currentKeyToWrite ]) 				ifTrue: 					[ hasSpace ifFalse: 						[ valueToMove := record valueAtByteArrayIndex: highestBax.						record vacateSlotAtByteArrayIndex: highestBax ].					record incrementNumberOfChildrenAtByteArrayIndex: (record 							atKey: currentKeyToWrite							put: currentValueToWrite) ]				ifFalse: [ record incrementNumberOfChildrenAtByteArrayIndex: highestBax ].			self writeRecord: record.			valueToMove notNil ifTrue: 				[ "we will need to push this key/value pair down"				currentKeyToWrite := keyToMove.				currentValueToWrite := valueToMove ].			childRecordNumber := record recordNumberCloserTo: currentKeyToWrite.			reachedBottom := childRecordNumber = 0.			reachedBottom ifFalse: [ self selectRecord: childRecordNumber ] ].		(reachedBottom and: [ hasSpace not ]) ifTrue: 			[ self selectNewRecordFor: currentKeyToWrite.			record incrementNumberOfChildrenAtByteArrayIndex: (record 					atKey: currentKeyToWrite					put: currentValueToWrite).			self writeRecord ] ]! !!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 3/26/2006 19:22'!at: key put: value	"For collection api compatibility."	self		add: value		at: key.	^ value! !!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 9/1/2006 18:45'!remove: valueInteger at: keyInteger 	"Answer a boolean indicating whether anything was removed."	guard critical: 		[ | currentBaxToFill sourceBax parentRecord childRecord baxFilled |		(self 			includesValue: valueInteger			at: keyInteger) ifFalse: [ ^ false ].		self 			navigateToward: keyInteger			until: 				[ : eachRecord | 				(currentBaxToFill := eachRecord 					removeKey: keyInteger					withValue: valueInteger) notNil ]			do: 				[ : eachRecord | 				"No need for beforeImageSignal here because we already signaled it in the until block."				eachRecord decrementNumberOfChildrenAtKey: keyInteger.				self writeRecord ].		self writeRecord.		"get out if we can.."		currentBaxToFill ifNil: [ ^ true ].		(record hasChildAtByteArrayIndex: currentBaxToFill) ifFalse: [ ^ true ].		"Now pull up child record entries into the newly vacated slot because add looks for the first available slot that is eligible for the key it is adding, which *could* be greater than the key of the next child (meaning we'd then be out of order)."		sourceBax := 0.	"non-nil"		parentRecord := record independentCopy.		childRecord := record independentCopy.				[ sourceBax notNil and: [ parentRecord hasChildAtHighestByteArrayIndexForBax: currentBaxToFill ] ] whileTrue: 			[ | highestByteArrayIndexForBaxToFill |			highestByteArrayIndexForBaxToFill := parentRecord highestByteArrayIndexForAnyKeyAt: currentBaxToFill.			self 				readRecord: childRecord				at: (parentRecord recordNumberAtByteArrayIndex: highestByteArrayIndexForBaxToFill).			sourceBax := childRecord byteArrayIndexOfLowestEntry.			sourceBax ifNotNil: 				[ baxFilled := parentRecord 					atKey: (childRecord keyAtByteArrayIndex: sourceBax)					put: (childRecord valueAtByteArrayIndex: sourceBax).				baxFilled ~= highestByteArrayIndexForBaxToFill ifTrue: 					[ parentRecord incrementNumberOfChildrenAtByteArrayIndex: baxFilled.					parentRecord decrementNumberOfChildrenAtByteArrayIndex: highestByteArrayIndexForBaxToFill ].				childRecord					decrementNumberOfChildrenAtByteArrayIndex: sourceBax ;					vacateSlotAtByteArrayIndex: sourceBax.				self					writeRecord: parentRecord ;					writeRecord: childRecord.				parentRecord populateFrom: childRecord.				currentBaxToFill := sourceBax ] ].		^ true ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:48'!allRecordsDo: twoArgBlock 	guard critical: 		[ self selectRoot.		self 			recordsFrom: record independentCopy			do: twoArgBlock ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'sig 7/20/2007 11:14'!do: aBlock for: aMagmaFileTraverser using: aMaReadStrategy	self		entriesFromIndex: 1		do:			[ :eachRecord :recordPosition :levels |			aMagmaFileTraverser				graphFrom: (eachRecord keyAtByteArrayIndex: recordPosition)				do: aBlock				using: aMaReadStrategy ]		until:			[ :eachRecord :recordPosition :levels | false ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 9/9/2006 23:42'!findAnomalies	| answer |	answer := Dictionary new.	self allRecordsDo:		[ :eachParentRec :eachChildRec |		(eachChildRec 			addAnomaliesTo: answer 			usingParent: eachParentRec) ifTrue:				[ MaNotification new					tag: answer;					signal ] ].	^answer! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 7/2/2005 17:06'!hasAnomalies	^ self findAnomalies notEmpty! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 11/4/2014 15:19'!recordsDo: twoArgBlock level: level byteArrayIndex: anInteger self maMarked: 'delete'.	guard critical: 		[ | parent |		recordFactory 			put: record			atLevel: level			byteArrayIndex: anInteger.		parent := recordFactory recordAtLevel: level.		twoArgBlock 			value: parent			value: level.		parent 			byteArrayIndexesFrom: 0			do: 				[ : eachBax | 				(parent hasChildAtByteArrayIndex: eachBax) ifTrue: 					[ self selectRecord: (parent recordNumberAtByteArrayIndex: eachBax).					self 						recordsDo: twoArgBlock						level: level + 1						byteArrayIndex: anInteger ] ] ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:49'!recordsFrom: aMaHashIndexRecord do: twoArgBlock 	guard critical: 		[ | childRec |		aMaHashIndexRecord 			byteArrayIndexesFrom: 0			do: 				[ : eachBax | 				(aMaHashIndexRecord hasChildAtByteArrayIndex: eachBax) ifTrue: 					[ childRec := aMaHashIndexRecord independentCopy.					self 						readRecord: childRec						at: (aMaHashIndexRecord recordNumberAtByteArrayIndex: eachBax).					twoArgBlock 						value: aMaHashIndexRecord						value: childRec.					self 						recordsFrom: childRec						do: twoArgBlock ] ] ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 11/3/2014 20:07'!upTo: countInteger keysFrom: startKey 	guard critical: 		[ | result answerIndex |		result := Array new: countInteger.		answerIndex := 1.		self 			entriesFrom: startKey			do: 				[ : currentRecord : index : level | 				(currentRecord hasEntryAtByteArrayIndex: index) ifTrue: 					[ result 						at: answerIndex						put: (currentRecord keyAtByteArrayIndex: index).					answerIndex := answerIndex + 1 ] ]			until: [ : currentRecord : index : level | answerIndex > countInteger ].		"Need to check in case of a small index (say only 9 entries?)."		^ answerIndex <= countInteger 			ifTrue: 				[ result 					copyFrom: 1					to: answerIndex - 1 ]			ifFalse: [ result ] ]! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 7/18/2005 13:22'!createRecord	record :=		(MaHashIndexRecord			keySize: keySize			valueSize: valueSize			numberOfSlots: hashRecordSize)				beFrom: 0				to: (2 raisedTo: keySize) - 1;				recordNumber: 0 ;				yourself.	broker recordSize: record bufferSize! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 9/23/2008 14:25'!initialize	super initialize.	guard := Mutex new! !!MaHashIndex methodsFor: 'initializing'!initializeRecordFactory	recordFactory := MaHashIndexRecordFactory index: self! !!MaHashIndex methodsFor: 'initializing'!initializeRecords	self		createRecord;		initializeRecordFactory! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 5/23/2005 17:54'!keySize: keySizeInteger valueSize: valueSizeInteger hashRecordSize: recordSizeInteger	keySize := keySizeInteger.	valueSize := valueSizeInteger.	hashRecordSize := recordSizeInteger.	self initializeRecords! !!MaHashIndex methodsFor: 'enumerating'!entriesFrom: keyInteger do: threeArgBlock until: conditionBlock	"The first two arguments of threeArgBlock and conditionBlock are the record and the	internal index position needed to access the of each entry in those records via	keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.	The third argument is the levels from the root record, where the root is level 1.	This is used to reference into the receivers preMadeRecords, a performance optimization."	^self		slotsFrom: keyInteger		do:			[ :currentRecord :byteArrayIndex :level |			(currentRecord hasEntryAtByteArrayIndex: byteArrayIndex)				ifTrue:					[ threeArgBlock						value: currentRecord						value: byteArrayIndex						value: level ] ]		until: conditionBlock! !!MaHashIndex methodsFor: 'enumerating'!entriesFromIndex: globalIndex do: threeArgBlock until: conditionBlock	^self		slotsFromIndex: globalIndex		do:			[ :currentRecord :byteArrayIndex :level |			(currentRecord hasEntryAtByteArrayIndex: byteArrayIndex)				ifTrue:					[ threeArgBlock						value: currentRecord						value: byteArrayIndex						value: level ] ]		until: conditionBlock! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/4/2006 12:53'!keysAndValuesFrom: lowKey startingAt: anInteger do: twoArgBlock until: conditionBlock 	"Value twoArgBlock with each key and value pair, until conditionBlock is false for same key-value pair, starting at anInteger after the lowest index of lowKey."	| lowest currentIndex |	currentIndex := 0.	lowest := self 		indexOfLowest: lowKey		exactKey: false.	lowest > 0 ifTrue: 		[ self 			entriesFromIndex: lowest + anInteger - 1			do: 				[ : currentRecord : byteArrayIndex : level | 				currentIndex := currentIndex + 1.				twoArgBlock 					value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)					value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]			until: 				[ : currentRecord : byteArrayIndex : level | 				conditionBlock 					value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)					value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ] ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/12/2006 22:46'!slotsFrom: keyInteger do: threeArgBlock until: conditionBlock 	"The first two arguments of threeArgBlock and conditionBlock are the record and the internal index position needed to access the of each entry in those records via keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.  The third argument is the levels from the root record, where the root is level 1.  This is used to reference into the receivers preMadeRecords, a performance optimization."	guard critical: 		[ | level startingEntryIndex |		(level := self selectFirstRecordWithKeyEqualOrGreaterThan: keyInteger) isNil ifTrue: [ ^ self ].		"For inverted records, it is possible the entryIndex for keyInteger will be consumed by the next lower key.  Unfortunately, we have to check."		startingEntryIndex := record slotIndexFor: keyInteger.		(record keyAtSlotIndex: startingEntryIndex) < keyInteger ifTrue: [ startingEntryIndex := startingEntryIndex + 1 ].		self 			traverseSlotsFromRecord: record			index: startingEntryIndex			do: threeArgBlock			until: conditionBlock			level: level ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/12/2006 22:46'!slotsFromIndex: globalIndex do: threeArgBlock until: conditionBlock 	"The first two arguments of threeArgBlock and conditionBlock are the record and the internal index position needed to access the of each entry in those records via keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.  The third argument is the levels from the root record, where the root is level 1.  This is used to reference into the receivers preMadeRecords, a performance optimization."	guard critical: 		[ | byteArrayIndexAndLevelArray |		(byteArrayIndexAndLevelArray := self selectRecordAt: globalIndex) isNil ifTrue: [ ^ self ].		self 			traverseSlotsFromRecord: record			index: (record slotIndexForBax: byteArrayIndexAndLevelArray first)			do: threeArgBlock			until: conditionBlock			level: byteArrayIndexAndLevelArray last ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 4/12/2006 21:53'!upTo: countInteger keysAndValuesFrom: lowKey to: highKey startingAt: index do: twoArgBlock	"Answer the specified number of values starting at logical-position index within the lowKey to highKey range, value twoArgBlock with each key-value pair in that range."	| lowest currentIndex |	currentIndex := 0.	lowest := self indexOfLowest: lowKey exactKey: false.	lowest > 0		ifTrue:			[ self				entriesFromIndex: lowest + index - 1				do:					[ : currentRecord : byteArrayIndex : level |					currentIndex := currentIndex + 1.					twoArgBlock						value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)						value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]				until:					[  : currentRecord : byteArrayIndex : level |					currentIndex = countInteger					or: [ (currentRecord keyAtByteArrayIndex: byteArrayIndex) > highKey ] ] ]! !!MaHashIndex methodsFor: 'private'!getNextRecordNumber	^nextRecordNumber := nextRecordNumber + 1! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/5/2007 00:13'!headerSize	^ MaHashIndexHeader headerSize! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 6/12/2006 17:26'!indexOfLowest: keyInteger exactKey: aBoolean 	"If aBoolean is true, answer 0 if we don't find an exact key.  If false answer the index of the first equal or higher key."	| total index |	^ guard critical: 		[ total := 0.		self 			navigateToward: keyInteger			until: 				[ : currentRecord | 				| foundRecord |				foundRecord := false.				currentRecord 					eligibleByteArrayIndexesFor: keyInteger					do: 						[ : each | 						((currentRecord hasEntryAtByteArrayIndex: each) and: [ (currentRecord keyAtByteArrayIndex: each) >= keyInteger ]) ifTrue: [ foundRecord := true ] ].				total := total + (record numberOfChildrenBefore: keyInteger).				foundRecord ]			do: 				[ : currentRecord | "nada" ].		"We now have the correct potential record selected and a correct total number of entries that occur before the entry that would contain keyInteger.  Now determine whether we should answer it or nil"		index := total + 1.		aBoolean 			ifTrue: 				[ (record hasEntryForKey: keyInteger) 					ifTrue: [ ^ index ]					ifFalse: [ 0 ] ]			ifFalse: 				[ index > self size 					ifTrue: [ 0 ]					ifFalse: [ index ] ] ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/8/2007 20:13'!initializeFromHeader: aByteArray	| header |	header := MaHashIndexHeader new byteArray: aByteArray.	self		keySize: header keySize		valueSize: header valueSize		hashRecordSize: header recordSize.	broker 		headerSize: header headerSize ;		recordSize: record bufferSize! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/4/2014 11:13'!navigateToward: keyInteger until: untilBlock do: doBlock	"Select records between the root and the one that can contain keyInteger and value one-argument doBlock on each of those records until the one-argument untilBlock values true or we cannot navigate any closer to keyInteger."	| level |	level := 1.	self selectRoot.	[ | goalRecordReached bax |	bax := record highestByteArrayIndexFor: keyInteger.	recordFactory		put: record		atLevel: level		byteArrayIndex: bax.	goalRecordReached := untilBlock value: record.	goalRecordReached not and: [ (record numberOfChildrenAtByteArrayIndex: bax) > 1 ] ]		whileTrue:			[ doBlock value: record.			self selectRecord: (record recordNumberCloserTo: keyInteger).			level := level + 1 ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/5/2007 00:02'!newHeaderBytes	^ MaHashIndexHeader new 		headerBytesForKeySize: keySize		valueSize: valueSize		recordSize: hashRecordSize! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 7/1/2005 16:54'!numberOfSlots	^ record numberOfSlots! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/27/2011 20:05'!readRecord: aMaHashIndexRecord at: recordIndex 	broker 		readInto: aMaHashIndexRecord byteArray		at: recordIndex.	^ aMaHashIndexRecord		resetForNewKeyRange ;		recordNumber: recordIndex ;		yourself! !!MaHashIndex methodsFor: 'private'!recordSize	^record bufferSize! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 7/1/2005 17:10'!selectFirstRecordWithKeyEqualOrGreaterThan: keyInteger	"If keyInteger is larger than every key in the index, answer nil, otherwise answer the level of the record with the answer."	| level searchedLevel |	level := 1.	self		navigateToward: keyInteger		until:			[ : currentRecord |			currentRecord				eligibleByteArrayIndexesFor: keyInteger				do:					[ : each |					((currentRecord hasEntryAtByteArrayIndex: each)						and: [ (currentRecord keyAtByteArrayIndex: each) >= keyInteger ])							ifTrue:								[ ^ level ] ].			false ]		do: [ :currentRecord | level := level + 1 ].	"Though we have arrived at the record which would contain keyInteger,	in case it does not have entries whose keys are >= keyInteger,	look for the next higher key."	self		traverseSlotsFromRecord: record		index: (record slotIndexFor: keyInteger)		do: [ : currentRecord : byteArrayIndex : currentLevel | "nothing" ]		until:			[ : currentRecord : byteArrayIndex : currentLevel |			searchedLevel := currentLevel.			currentRecord hasEntryAtByteArrayIndex: byteArrayIndex ]		level: level.	^ searchedLevel! !!MaHashIndex methodsFor: 'private'!selectNewRecordFor: keyInteger	"We need to make sure we reference the new record from the	current record."	self setUpNewRecordFor: keyInteger.	"Reference new record and write before selecting the new record."	record		recordNumberAtSlotForKey: keyInteger		put: recordFactory preMadeNewRecord recordNumber.	self		writeRecord; "replace record that now references newRecord.."		selectPreMadeNewRecord! !!MaHashIndex methodsFor: 'private'!selectPreMadeNewRecord	record populateFrom: recordFactory preMadeNewRecord! !!MaHashIndex methodsFor: 'private'!selectRecord: anInteger	self		readRecord: record		at: anInteger! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/30/2002 13:03'!selectRecordAt: globalIndex	"Answer the level and the byteArrayIndex of the selected record, or nil if out of bounds.	Since the caller of this method is going to call traverseSlotsFromRecord:index:do:until:level:,	we must be sure to populate the receivers path."	| level byteArrayIndex currentGlobalPosition outOfBounds |	self selectRoot.	level := 1.	currentGlobalPosition := 0.  "0-based"	outOfBounds := false.	[		byteArrayIndex :=			record				byteArrayIndexContainingGlobalIndex: globalIndex				base: currentGlobalPosition.		byteArrayIndex isNil			ifTrue:				[ outOfBounds := true.				false ]			ifFalse:				[ currentGlobalPosition :=					currentGlobalPosition +						(record numberOfChildrenBeforeByteArrayIndex: byteArrayIndex).				(record hasEntryAtByteArrayIndex: byteArrayIndex)					ifTrue: [ currentGlobalPosition := currentGlobalPosition + 1 ].				(currentGlobalPosition < globalIndex) and:					[ "this should never be false if above is true"					record hasChildAtByteArrayIndex: byteArrayIndex ] ] ]						whileTrue:							[ recordFactory								put: record								atLevel: level								byteArrayIndex: byteArrayIndex.							self selectRecord:								(record recordNumberAtByteArrayIndex: byteArrayIndex).							level := level + 1 ].	^outOfBounds		ifTrue:			[ nil ]		ifFalse:			[ Array				with: byteArrayIndex				with: level ]! !!MaHashIndex methodsFor: 'private'!selectRoot	self selectRecord: 0! !!MaHashIndex methodsFor: 'private'!setUpNewRecordFor: keyInteger	recordFactory preMadeNewRecord		beZoomedInToward: keyInteger			from: record;		recordNumber: self getNextRecordNumber! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/29/2002 22:46'!traverseSlotsFromParentRecord: aMaHashIndexRecord index: entryIndex do: threeArgBlock until: conditionBlock level: levelInteger	"levelInteger is 1 for the root record."	| conditionMet |	conditionMet := false.	aMaHashIndexRecord		byteArrayIndexesFrom: entryIndex		do:			[ :index | | nextToRead |			conditionMet				ifFalse:					[ nextToRead := aMaHashIndexRecord recordNumberAtByteArrayIndex: index.					(conditionBlock						value: aMaHashIndexRecord						value: index						value: levelInteger)							ifTrue:								[ conditionMet := true ]							ifFalse:								[ threeArgBlock									value: aMaHashIndexRecord									value: index									value: levelInteger ] ].			conditionMet				ifFalse:					[ nextToRead > 0						ifTrue:							[ | currentRecord |							currentRecord := recordFactory recordAtLevel: levelInteger + 1.							self								readRecord: currentRecord								at: nextToRead.							conditionMet :=								self									traverseSlotsFromParentRecord: currentRecord									index: 0									do: threeArgBlock									until: conditionBlock									level: levelInteger + 1 ] ] ].	^conditionMet! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/29/2002 22:46'!traverseSlotsFromRecord: aMaHashIndexRecord index: entryIndex do: threeArgBlock until: conditionBlock level: levelInteger	"levelInteger is 1 for the root record."	| done |	done :=		self			traverseSlotsFromParentRecord: aMaHashIndexRecord			index: entryIndex			do: threeArgBlock			until: conditionBlock			level: levelInteger.	(done not and: [ levelInteger > 1 ])		ifTrue:			[ | nextStart |			nextStart := recordFactory recordAtLevel: levelInteger - 1.			self				readRecord: nextStart				at: (recordFactory recordNumberAtLevel: levelInteger - 1).			self				traverseSlotsFromRecord: nextStart				index: (recordFactory entryIndexAtLevel: levelInteger - 1) + 1				do: threeArgBlock				until: conditionBlock				level: levelInteger - 1 ]! !!MaHashIndex methodsFor: 'private'!writeNewRoot	self writeRecord! !!MaHashIndex methodsFor: 'private'!writeRecord	self writeRecord: record! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 3/20/2007 21:30'!writeRecord: aMaHashIndexRecord 	broker 		writeFrom: aMaHashIndexRecord byteArray		at: aMaHashIndexRecord recordNumber! !!MaHashIndex methodsFor: 'accessing'!hashRecordSize	^hashRecordSize! !!MaHashIndex methodsFor: 'accessing'!indexOf: keyInteger	^self		indexOfLowest: keyInteger		exactKey: true! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:27'!indexOfHighest: keyInteger 	"If keyInteger is present, answer the index of its last occurrence.  Otherwise, answer the index of the next lower key.  If keyInteger is lower than all keys in the receiver, answer 0."	| lowestIndexOfNextHigherKey |	^ guard critical: 		[ keyInteger >= self highestPossibleKey ifTrue: [ ^ self size ].		lowestIndexOfNextHigherKey := self 			indexOfLowest: keyInteger + 1			exactKey: false.		lowestIndexOfNextHigherKey = 1 ifTrue: [ ^ 0 ].	"lower than all"		lowestIndexOfNextHigherKey = 0 			ifTrue: [ self size ]			ifFalse: [ lowestIndexOfNextHigherKey - 1 max: 1 ] ]! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:28'!numberOfEntriesFrom: lowKey to: highKey 	"Inclusive of lowKey and highKey, if those keys exist.	If lowKey does not exist, we count from the next higher key.	If highKey doesn't exist, we count up to the next highestKey."	^ guard critical: 		[ | lowest |		(lowest := self 			indexOfLowest: lowKey			exactKey: false) = 0 ifTrue: [ ^ 0 ].		(self indexOfHighest: highKey) - lowest + 1 ]! !!MaHashIndex methodsFor: 'accessing'!occurrencesOf: keyInteger	^self		numberOfEntriesFrom: keyInteger		to: keyInteger! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:26'!size	^ guard critical: 		[ self selectRoot.		record numberOfChildren ]! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 4/17/2005 22:13'!upTo: countInteger at: keyInteger	^ self		upTo: countInteger		keysAndValuesFrom: keyInteger		to: keyInteger		startingAt: 1! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 11/16/2007 16:36'!upTo: countInteger keysAndValuesFrom: lowKey to: highKey startingAt: index 	"Answer the specified number of values starting at logical-position index *within* the lowKey to highKey range."	^ guard critical: 		[ | answerIndex keys values |		answerIndex := 0.		keys := Array new: countInteger.		values := Array new: countInteger.		self 			upTo: countInteger			keysAndValuesFrom: lowKey			to: highKey			startingAt: index			do: 				[ : eachKey : eachValue | 				keys 					at: (answerIndex := answerIndex + 1)					put: eachKey.				values 					at: answerIndex					put: eachValue ].		answerIndex = 0 			ifTrue: 				[ {  #(). #()  } ]			ifFalse: 				[ answerIndex < countInteger 					ifTrue: 						[ { 							(keys 								copyFrom: 1								to: answerIndex).							(values 								copyFrom: 1								to: answerIndex)						 } ]					ifFalse: 						[ {  keys. values  } ] ] ]! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 11/16/2007 16:36'!upTo: countInteger keysAndValuesFromIndex: lowIndex 	^ guard critical: 		[ | answerIndex keys values |		keys := Array new: countInteger.		values := Array new: countInteger.		answerIndex := 0.		self 			entriesFromIndex: lowIndex			do: 				[ : currentRecord : byteArrayIndex : level | 				keys 					at: (answerIndex := answerIndex + 1)					put: (currentRecord keyAtByteArrayIndex: byteArrayIndex).				values 					at: answerIndex					put: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]			until: [ : currentRecord : index : level | answerIndex = countInteger ].		answerIndex = 0 			ifTrue: 				[ {  #(). #()  } ]			ifFalse: 				[ answerIndex < countInteger 					ifTrue: 						[ { 							(keys 								copyFrom: 1								to: answerIndex).							(values 								copyFrom: 1								to: answerIndex)						 } ]					ifFalse: 						[ {  keys. values  } ] ] ]! !!MaHashIndex methodsFor: 'testing' stamp: 'cmm 6/12/2006 22:50'!includesKey: anInteger 	^ guard critical: 		[ self selectFirstRecordWithKeyEqualOrGreaterThan: anInteger.		record hasEntryForKey: anInteger ]! !!MaHashIndex methodsFor: 'testing' stamp: 'cmm 4/28/2005 21:55'!includesValue: valueInteger at: keyInteger	| hasEntry key |	self		entriesFrom: keyInteger		do:			[ : eachRecord : eachByteArrayIndex : level |			(hasEntry and:				[ key = keyInteger					and: [ (eachRecord valueAtByteArrayIndex: eachByteArrayIndex) = valueInteger ] ])						ifTrue:							[ ^ true ] ]		until:			[ : eachRecord : eachByteArrayIndex : level |			"Until we're on an entry that could not possibly hold keyInteger."			((hasEntry := eachRecord hasEntryAtByteArrayIndex: eachByteArrayIndex)				and: [ (key := eachRecord keyAtByteArrayIndex: eachByteArrayIndex) > keyInteger ])					or: [ eachByteArrayIndex > (eachRecord highestByteArrayIndexFor: keyInteger) ] ].	^ false! !!MaHashIndex methodsFor: 'analyzing' stamp: 'cmm 7/20/2011 15:34'!keyCounts	"Answer a Bag of the keys of the receiver."	| counts c |	counts := Bag new.	c := 0.	'enumerating ' , self filename 		displayProgressFrom: 0		to: self size		during: 			[ : bar | 			self 				entriesFrom: 0				do: 					[ : rec : bax : lvl | 					bar value: (c := c + 1).					counts add: (rec keyAtByteArrayIndex: bax) ]				until: [ : rec : bax : lvl | false ] ].	^ counts! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaHashIndex class	instanceVariableNames: ''!!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 6/13/2005 23:07'!create: aReadWriteStream keySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger	^ (self		newWithKeySize: numberOfBitsInteger		valueSize: valueSize		recordSize: entriesInteger)		create: aReadWriteStream ;		yourself! !!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 12/3/2011 15:56'!createNamed: filenameString keySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger 	| file |	(StandardFileStream isAFileNamed: filenameString) ifTrue: [ MaEnvironmentError signal: filenameString , ' already exists.' ].	file := StandardFileStream fileNamed: filenameString.	(file isNil or: [ file closed ]) ifTrue: [ MaEnvironmentError signal: 'Could not create ' , filenameString ].	^ self		create: file binary		keySize: numberOfBitsInteger		valueSize: valueSize		recordSize: entriesInteger! !!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 3/17/2011 22:43'!newWithKeySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger	"Use this constructor only when you want to create in-memory cached-hash-index."	(self validRecordSizes includes: entriesInteger) 		ifFalse: [ MaUserError signal: 'recordSize must be one of ', self validRecordSizes printString ].	(self validKeySizes includes: numberOfBitsInteger) 		ifFalse: [ MaUserError signal: 'keySize must be one of ', self validKeySizes printString ].	^ self new		keySize: numberOfBitsInteger		valueSize: valueSize		hashRecordSize: entriesInteger ;		writeNewRoot ;		yourself! !!MaHashIndex class methodsFor: 'creation'!suggestedFileExtension	^'hdx'! !!MaHashIndex class methodsFor: 'accessing' stamp: 'cmm 11/17/2010 10:41'!validKeySizes	"Record sizes must be a power of 2 so that slots in every MaHashIndexRecord will be uniformely sized."	^ 16		to: 4096		by: 8! !!MaHashIndex class methodsFor: 'accessing' stamp: 'cmm 8/17/2005 21:21'!validRecordSizes	"Record sizes must be a power of 2 so that slots in every MaHashIndexRecord will be uniformely sized."	^ #(2 4 8 16 32 64 128)! !