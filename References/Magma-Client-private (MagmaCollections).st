MaObject subclass: #MaQueryTrunk	instanceVariableNames: 'clauses'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MaQueryTrunk commentStamp: '<historical>' prior: 0!My ranges represent the shortest path through the query.!!MaQueryTrunk methodsFor: 'initializing' stamp: 'cmm 5/31/2006 20:19'!addClause: aMaQueryTrunkClause 	^ clauses add: aMaQueryTrunkClause! !!MaQueryTrunk methodsFor: 'initializing' stamp: 'cmm 5/31/2006 20:36'!initialize	super initialize.	clauses := OrderedCollection new! !!MaQueryTrunk methodsFor: 'accessing' stamp: 'cmm 7/2/2006 21:12'!sortAttribute	"My clauses are reduced to just the ones that must be enumerated to find the result.  If that reduction was down to one then the order will be per that indexed attribute."	^ clauses size = 1 ifTrue: [ clauses first attribute ]! !!MaQueryTrunk methodsFor: 'accessing' stamp: 'cmm 5/31/2006 20:11'!trunkSize	^ clauses inject: 0 into: [ : sum : each | sum + each lastKnownSize ]! !!MaQueryTrunk methodsFor: 'enumerating' stamp: 'cmm 5/31/2006 21:58'!trunkDo: aBlock	clauses do: aBlock! !MaObject subclass: #MaTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MaTerm methodsFor: 'expressions' stamp: 'brp 4/9/2006 11:36'!& aMaTerm	^ self connect: aMaTerm operator: #&! !!MaTerm methodsFor: 'expressions' stamp: 'cmm 4/13/2006 22:48'!normalize	"do nothing by default"! !!MaTerm methodsFor: 'expressions' stamp: 'brp 4/9/2006 11:36'!| aMaTerm	^ self connect: aMaTerm operator: #|! !!MaTerm methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	self subclassResponsibility! !!MaTerm methodsFor: 'private' stamp: 'cmm 1/20/2013 17:28'!connect: aMaTerm operator: aSymbol 	self subclassResponsibility! !!MaTerm methodsFor: 'copying' stamp: 'cmm 6/29/2012 10:38'!copy	^ self veryDeepCopy! !!MaTerm methodsFor: 'evaluate' stamp: 'cmm 12/13/2009 21:02'!evaluate: aTeCellAddress	self subclassResponsibility! !!MaTerm methodsFor: 'testing' stamp: 'cmm 5/30/2006 22:00'!hasDisjunctions	^ false! !!MaTerm methodsFor: 'testing' stamp: 'cmm 6/5/2007 15:57'!isClause	^ false! !!MaTerm methodsFor: 'testing' stamp: 'brp 4/9/2006 11:51'!isExpression	^ false! !!MaTerm methodsFor: 'testing' stamp: 'cmm 7/19/2007 22:20'!validateUsing: aMagmaCollectionReader	self subclassResponsibility ! !!MaTerm methodsFor: 'printing' stamp: 'cmm 1/31/2013 15:12'!printOn: aStream	self maPrintAbbreviatedOn: aStream! !!MaTerm methodsFor: '*magma-server-private' stamp: 'cmm 8/12/2007 20:41'!shouldInclude: oid using: aMagmaCollectionManager 	self subclassResponsibility ! !Association subclass: #MagmaDictionaryAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaDictionaryAssociation methodsFor: 'as yet unclassified' stamp: 'cmm 7/16/2010 16:07'!= aLookupKey 	^ self species = aLookupKey species and: [ key = aLookupKey key ]! !MaObject subclass: #MagmaIndexDescription	instanceVariableNames: 'attribute keySize recordSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!attribute	^attribute! !!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!attribute: aSymbol	attribute := aSymbol! !!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!keySize	^keySize! !!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!keySize: anInteger	keySize := anInteger! !!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!recordSize	^recordSize! !!MagmaIndexDescription methodsFor: 'accessing' stamp: 'cmm 5/28/2007 10:22'!recordSize: anInteger	recordSize := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaIndexDescription class	instanceVariableNames: ''!!MagmaIndexDescription class methodsFor: 'create' stamp: 'cmm 8/14/2007 23:02'!attribute: aSymbol keySize: keySize recordSize: recordSize 	^ self new		attribute: aSymbol ;		keySize: keySize ;		recordSize: recordSize ;		yourself! !MagmaCollectionOptimizedReader subclass: #MagmaSetReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaSetReader methodsFor: 'as yet unclassified' stamp: 'cmm 7/19/2010 16:37'!mergeChanges	"With a MagmaDictionary or MagmaSet, there is no need to mergeChanges, because we check the locally added changes directly first."! !!MagmaSetReader methodsFor: 'as yet unclassified' stamp: 'cmm 7/19/2010 16:36'!setUpListener	"The purpose of this is to force aMagmaCollectionReader to nil-out its segments whenever any object is added or removed to the receiver, so that we can enjoy the side-effect of any objects added since then, merged back in.	However, MagmaSet and MagmaDictionary don't need the local changes merged, because they are only accessed one object at a time; (e.g., #includes: or #at:ifAbsent:) direct.  They need to be fast and this helps."! !MaTerm subclass: #MagmaTerm	instanceVariableNames: 'reader'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaTerm methodsFor: 'testing' stamp: 'cmm 2/18/2008 17:04'!ascendingSortBlock	"This is used for sorting 'objects' in MagmaCollectionReaderSegment."	^ [ : a : b | a key < b key ]! !!MagmaTerm methodsFor: 'private' stamp: 'cmm 1/20/2013 18:49'!connect: aMaTerm operator: aSymbol 	| expression |	expression := (MagmaExpression reader: reader)		operator: aSymbol ;		addTerm: self ;		addTerm: aMaTerm ;		yourself.	reader expression: expression.	^ expression! !!MagmaTerm methodsFor: 'private' stamp: 'cmm 12/9/2014 14:33'!reader	^ reader! !!MagmaTerm methodsFor: 'private' stamp: 'cmm 5/28/2006 22:03'!reader: aMagmaExpressionReader 	reader := aMagmaExpressionReader ! !!MagmaTerm methodsFor: 'evaluate' stamp: 'cmm 7/16/2006 17:17'!evaluate: anObject 	^ (self evaluationCount: anObject) > 0! !!MagmaTerm methodsFor: 'evaluate' stamp: 'cmm 7/15/2006 14:51'!evaluationCount: anObject	self subclassResponsibility ! !!MagmaTerm methodsFor: 'serialization' stamp: 'cmm 8/5/2011 13:26'!maTransientVariables	^ #('reader')! !!MagmaTerm methodsFor: 'copying' stamp: 'cmm 1/30/2013 16:07'!veryDeepInner: aDeepCopier 	"Overridden or else DeepCopier will clone all variables, but we want to share them."	super veryDeepInner: aDeepCopier! !!MagmaTerm methodsFor: '*magma-server-private' stamp: 'cmm 8/12/2007 20:39'!addMinimumEnumerationsTo: aMaQueryTrunk using: aMagmaLargeCollectionManager 	self subclassResponsibility! !!MagmaTerm methodsFor: '*magma-server-private' stamp: 'cmm 8/12/2007 20:40'!minimumSearchSpaceSizeUsing: aMagmaCollectionManager	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaTerm class	instanceVariableNames: ''!!MagmaTerm class methodsFor: 'create' stamp: 'cmm 11/26/2007 09:20'!reader: aMagmaCollectionReader 	^ self new		reader: aMagmaCollectionReader ;		yourself! !MagmaTerm subclass: #MagmaClause	instanceVariableNames: 'attribute lowKey highKey'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:09'!< anObject	self upTo: anObject! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:09'!<= anObject	self to: anObject! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 5/30/2006 21:34'!> anObject	lowKey := (self index indexHashForIndexObject: anObject)+1.	highKey := self index highestPossibleKey! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 5/30/2006 21:34'!>= anObject	self from: anObject! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:08'!at: anObject 	self 		from: anObject		to: anObject! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:07'!between: lowObject and: highObject 	self 		from: lowObject		to: highObject! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:08'!equals: anObject 	self 		from: anObject		to: anObject! !!MagmaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: anObject	lowKey := self index indexHashForIndexObject: anObject.	highKey := self index highestPossibleKey ! !!MagmaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: lowObject to: highObject	lowKey := self index indexHashForIndexObject: lowObject.	highKey := self index indexHashForIndexObject: highObject! !!MagmaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: lowObject upTo: highObject	lowKey := self index indexHashForIndexObject: lowObject.	highKey := (self index indexHashForIndexObject: highObject) - 1 max: 0.! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:19'!in: aCollection	self includesAnyOf: aCollection! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 1/20/2013 18:49'!includesAllOf: aCollection 	aCollection 		ifEmpty: 			[ lowKey := self index lowestPossibleKey.			highKey := self index highestPossibleKey ]		ifNotEmpty: 			[ aCollection size = 1 				ifTrue: [ self at: aCollection anyOne ]				ifFalse: 					[ | expression |					expression := (MagmaExpression reader: reader)						operator: #& ;						yourself.					aCollection do: [ : each | expression addTerm: (self copy at: each) ].					self						ensureFilteredReader ;						become: expression ] ]! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 1/20/2013 18:49'!includesAllPrefixes: aCollection 	"A special purpose operator for MaKeywordIndexes.  Same as includesAllOf: except allows keywords to be searched by aCollection of specified *prefixes* instead of requiring the client to guess entire keywords exactly."	aCollection 		ifEmpty: 			[ lowKey := self index lowestPossibleKey.			highKey := self index highestPossibleKey ]		ifNotEmpty: 			[ aCollection size = 1 				ifTrue: 					[ self 						from: aCollection anyOne						to: aCollection anyOne maAlphabeticalNext ]				ifFalse: 					[ | expression |					expression := (MagmaExpression reader: reader)						operator: #& ;						yourself.					aCollection do: 						[ : eachString | 						expression addTerm: (self copy 								from: eachString								to: eachString maAlphabeticalNext) ].					self						ensureFilteredReader ;						become: expression ] ]! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 1/20/2013 18:49'!includesAnyOf: aCollection 	aCollection 		ifEmpty: 			[ "Must always answer false to match Collection behavior."			self beAlwaysFalse ]		ifNotEmpty: 			[ aCollection size = 1 				ifTrue: [ self at: aCollection anyOne ]				ifFalse: 					[ | expression |					expression := (MagmaExpression reader: reader)						operator: #| ;						yourself.					aCollection do: [ : each | expression addTerm: (self copy at: each) ].					self						ensureFilteredReader ;						become: expression ] ]! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 1/20/2013 18:49'!includesAnyPrefix: aCollection 	"A special purpose operator for MaKeywordIndexes.  Same as includesAnyOf: except allows keywords to be searched by aCollection of specified *prefixes* instead of requiring the client to guess entire keywords exactly."	aCollection 		ifEmpty: [ self beAlwaysFalse ]		ifNotEmpty: 			[ aCollection size = 1 				ifTrue: 					[ self 						from: aCollection anyOne						to: aCollection anyOne maAlphabeticalNext ]				ifFalse: 					[ | expression |					expression := (MagmaExpression reader: reader)						operator: #| ;						yourself.					aCollection do: 						[ : eachString | 						expression addTerm: (self copy 								from: eachString								to: eachString maAlphabeticalNext) ].					self						ensureFilteredReader ;						become: expression ] ]! !!MagmaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!to: anObject	lowKey := 0.	highKey := self index indexHashForIndexObject: anObject.! !!MagmaClause methodsFor: 'operators' stamp: 'cmm 6/13/2006 20:55'!upTo: highObject	lowKey := 0.	highKey := (self index indexHashForIndexObject: highObject) - 1 max: 0.! !!MagmaClause methodsFor: 'comparing' stamp: 'cmm 1/28/2013 17:40'!= anObject 	^ (anObject isKindOf: self maOriginalClass) 		ifFalse: [ self equals: anObject ]		ifTrue: 			[ self == anObject			or: [ anObject maOriginalClass = self maOriginalClass 			and: [ attribute = anObject attribute 			and: [ lowKey = anObject lowKey 			and: [ highKey = anObject highKey ] ] ] ] ]! !!MagmaClause methodsFor: 'comparing' stamp: 'cmm 4/10/2006 22:45'!hash	"try to be fast and avoid tons of collisions"	^ attribute hash bitOr: (lowKey bitOr: highKey)! !!MagmaClause methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	aCollection add: self! !!MagmaClause methodsFor: 'private' stamp: 'cmm 7/5/2008 21:31'!beAlwaysFalse	"Force me to evaluate false."	highKey := 1.	lowKey := 0! !!MagmaClause methodsFor: 'private' stamp: 'cmm 3/25/2008 22:35'!connect: aMaTerm operator: aSymbol 	| answer |	answer := super 		connect: aMaTerm		operator: aSymbol.	self ensureFilteredReader.	^ answer! !!MagmaClause methodsFor: 'private' stamp: 'cmm 3/25/2008 22:35'!ensureFilteredReader	reader isFiltered ifFalse: 		[ reader removeListener.		reader become: reader asFilteredReader.		reader setUpListener ]! !!MagmaClause methodsFor: 'private' stamp: 'cmm 7/5/2008 21:31'!isAlwaysFalse	"Needed to guarantee a clause will report false.  See #beFalse."	^ lowKey > highKey! !!MagmaClause methodsFor: 'converting' stamp: 'cmm 6/3/2006 14:46'!asTrunkClause	^ MaQueryTrunkClause new		attribute: attribute ;		lowKey: lowKey ;		highKey: highKey ;		yourself! !!MagmaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:39'!attribute	^ attribute! !!MagmaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:38'!attribute: aByteSymbol 	attribute := aByteSymbol! !!MagmaClause methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:10'!highKey	^ highKey! !!MagmaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:15'!index	^ reader indexNamed: attribute ! !!MagmaClause methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:09'!lowKey	^ lowKey! !!MagmaClause methodsFor: 'evaluating' stamp: 'cmm 12/8/2014 14:59'!evaluationCount: anObject 	^ (self index indexHashesFor: anObject) count: 		[ : each | 		each 			between: lowKey			and: highKey ]! !!MagmaClause methodsFor: 'evaluating' stamp: 'cmm 12/31/2014 14:41'!qualifyingHashesOf: anObject 	| answer |	"Initial size of 1 to support scaling of Tephra cubes with many dimensions."	answer := OrderedCollection new: 1.	(self index indexHashesFor: anObject) do: 		[ : each | 		(each 			between: lowKey			and: highKey) ifTrue: [ answer add: attribute -> each ] ].	^ answer! !!MagmaClause methodsFor: 'initialize-release' stamp: 'brp 4/6/2006 11:22'!highKey: anInteger	highKey := anInteger! !!MagmaClause methodsFor: 'initialize-release' stamp: 'brp 4/6/2006 11:23'!lowKey: anInteger	lowKey := anInteger! !!MagmaClause methodsFor: 'testing' stamp: 'cmm 6/5/2007 15:57'!isClause	^ true! !!MagmaClause methodsFor: 'testing' stamp: 'cmm 7/19/2007 22:21'!validateUsing: aMagmaCollectionReader 	(aMagmaCollectionReader collection hasIndexNamed: attribute) ifFalse: 		[ MagmaUserError signal: attribute , ' is not an indexed attribute of this collection.' ]! !!MagmaClause methodsFor: 'printing' stamp: 'cmm 6/3/2006 16:57'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(; 		nextPutAll: attribute ; 		space;		print: self lowKey;		nextPutAll: '..' ;		print: self highKey;		nextPut: $)! !!MagmaClause methodsFor: '*magma-server-private' stamp: 'cmm 7/5/2008 21:31'!addMinimumEnumerationsTo: aMaQueryTrunk using: aMagmaLargeCollectionManager 	aMaQueryTrunk addClause: (self asTrunkClause lastKnownSize: (self isAlwaysFalse 				ifTrue: [ 0 ]				ifFalse: 					[ (aMagmaLargeCollectionManager oidsIndexForAttribute: attribute) 						numberOfEntriesFrom: lowKey						to: highKey ]))! !!MagmaClause methodsFor: '*magma-server-private' stamp: 'cmm 7/5/2008 21:31'!minimumSearchSpaceSizeUsing: aMagmaCollectionManager 	^ self isAlwaysFalse 		ifTrue: [ 0 ]		ifFalse: 			[ (aMagmaCollectionManager oidsIndexForAttribute: attribute) 				numberOfEntriesFrom: lowKey				to: highKey ]! !!MagmaClause methodsFor: '*magma-server-private' stamp: 'cmm 7/5/2008 21:31'!shouldInclude: oid using: aMagmaCollectionManager 	"in the keys indexes, the oid is the key, the key is the value."	self isAlwaysFalse ifTrue: [ ^ false ].	(aMagmaCollectionManager keysIndexForAttribute: attribute) 		entriesFrom: oid		do: 			[ : eachRecord : bax : level | 			((eachRecord valueAtByteArrayIndex: bax) 				between: lowKey				and: highKey) ifTrue: 				[ "key"				^ true ] ]		until: [ : eachRecord : bax : level | (eachRecord keyAtByteArrayIndex: bax) > oid ].	^ false! !MagmaClause subclass: #MaQueryTrunkClause	instanceVariableNames: 'lastKnownSize'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MaQueryTrunkClause commentStamp: 'cmm 6/5/2007 10:46' prior: 0!I represent the "normalized" clauses of an expression.  Some queries may specify the same attribute more than once, sometimes even with overlapping key ranges.  In this case there is no reason to search the overlapping keyspaces more than once.!!MaQueryTrunkClause methodsFor: 'accessing' stamp: 'cmm 6/3/2006 14:34'!lastKnownSize	^ lastKnownSize! !!MaQueryTrunkClause methodsFor: 'accessing' stamp: 'cmm 6/3/2006 16:56'!lastKnownSize: anInteger	lastKnownSize := anInteger! !MagmaTerm subclass: #MagmaExpression	instanceVariableNames: 'operator terms'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-private (MagmaCollections)'!!MagmaExpression methodsFor: 'comparing' stamp: 'cmm 4/10/2006 22:10'!= aMaExpression	aMaExpression maOriginalClass = self maOriginalClass ifFalse: [ ^ false ].	^ operator = aMaExpression operator	and: [ self terms = aMaExpression terms ]! !!MagmaExpression methodsFor: 'comparing' stamp: 'cmm 3/7/2014 10:49'!hash	^operator hash bitXor: self terms hash! !!MagmaExpression methodsFor: 'accessing' stamp: 'cmm 1/20/2013 18:34'!addTerm: aMaTerm 	terms		add: aMaTerm ;		changed.	^ aMaTerm! !!MagmaExpression methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:07'!operator	^ operator! !!MagmaExpression methodsFor: 'accessing' stamp: 'brp 4/9/2006 11:22'!operator: aSymbol	operator := aSymbol! !!MagmaExpression methodsFor: 'accessing' stamp: 'brp 4/9/2006 11:58'!terms	^ terms ifNil: [ terms := OrderedCollection new ]! !!MagmaExpression methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	aCollection addAll: self terms! !!MagmaExpression methodsFor: 'private' stamp: 'cmm 10/8/2006 20:51'!normalizeOverlappingValues	"We don't do this because this is how we do keyword searches:		myCollection where: [ :rdr | (rdr read: #keywords at: 'term1') | (rdr read: #keywords at: 'term2')]"! !!MagmaExpression methodsFor: 'private' stamp: 'cmm 1/21/2013 21:21'!normalizePrecedence	"Collate conditions with like operators."	self terms do:		[ : t | t normalize ].	((self terms select:		[ : t | t isExpression ]) allSatisfy:		[ : t | t operator = self operator ]) ifTrue:		[ | all |		all := OrderedCollection new.		self terms do:			[ : t | t addTermsTo: all ].		terms := all ].	terms := self terms asArray! !!MagmaExpression methodsFor: 'private' stamp: 'cmm 3/8/2013 18:11'!reader: aMagmaCollectionReader 	reader := aMagmaCollectionReader.	self terms do: [ : each | each reader: aMagmaCollectionReader ]! !!MagmaExpression methodsFor: 'enumerating' stamp: 'cmm 1/21/2013 20:58'!do: aBlock	"depth-first traversal"self maMarked: 'delete'.	self terms do: [ :t | t do: aBlock ].	aBlock value: self! !!MagmaExpression methodsFor: 'evaluating' stamp: 'cmm 7/16/2006 11:25'!evaluationCount: anObject 	"Answer how many hashes cause anObject to qualify for the reiver expression."	^ self isConjunction 		ifTrue: 			[ self terms 				inject: self terms size				into: [ : min : eachTerm | min min: (eachTerm evaluationCount: anObject) ] ]		ifFalse: 			[ self terms 				inject: 0				into: [ : sum : eachTerm | sum + (eachTerm evaluationCount: anObject) ] ]! !!MagmaExpression methodsFor: 'evaluating' stamp: 'cmm 2/18/2008 14:31'!qualifyingHashesOf: anObject 	"Answer an OrderedCollection of Associations detailing which indexes and hashes cause anObject to qualify for the receiver expression.  An empty OC means anObject does not qualify."	| answer |	answer := OrderedCollection new.	self isConjunction 		ifTrue: 			[ | subQualifyingHashes |			subQualifyingHashes := OrderedCollection new.			self terms do: 				[ : each | 				subQualifyingHashes := each qualifyingHashesOf: anObject.				subQualifyingHashes ifEmpty: [ ^ OrderedCollection new ] ].			answer addAll: subQualifyingHashes ]		ifFalse: 			[ | subQualifyingHashes |			subQualifyingHashes := OrderedCollection new.			self terms do: 				[ : each | 				subQualifyingHashes := each qualifyingHashesOf: anObject.				answer addAll: subQualifyingHashes ] ].	^ answer! !!MagmaExpression methodsFor: 'testing' stamp: 'cmm 4/10/2006 21:53'!isConjunction	^ operator = #&! !!MagmaExpression methodsFor: 'testing' stamp: 'cmm 4/10/2006 21:55'!isDisjunction	^ operator = #|! !!MagmaExpression methodsFor: 'testing' stamp: 'brp 4/9/2006 11:52'!isExpression	^ true! !!MagmaExpression methodsFor: 'testing' stamp: 'cmm 7/19/2007 22:22'!validateUsing: aMagmaCollectionReader 	terms do: [ : each | each validateUsing: aMagmaCollectionReader ]! !!MagmaExpression methodsFor: 'expressions' stamp: 'cmm 4/13/2006 23:10'!normalize	super normalize.	self 		normalizePrecedence ;		normalizeOverlappingValues! !!MagmaExpression methodsFor: 'printing' stamp: 'brp 4/9/2006 11:22'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self operator; nextPut: $)! !!MagmaExpression methodsFor: 'copying' stamp: 'cmm 1/30/2013 16:08'!veryDeepInner: aDeepCopier 	super veryDeepInner: aDeepCopier.	operator := operator veryDeepCopyWith: aDeepCopier.	terms := terms veryDeepCopyWith: aDeepCopier! !!MagmaExpression methodsFor: '*magma-server-private' stamp: 'cmm 5/31/2006 20:23'!addMinimumEnumerationsTo: aMaQueryTrunk using: aMagmaLargeCollectionManager 	"For each OR'd condition, we must add a new range to aMaQueryTrunk.  Within each OR, we select the shortest ANDed condition to add to aMaQueryTrunk."	self isConjunction 		ifTrue: 			[ | smallest smallestSize |			smallest := smallestSize := nil.			self terms do: 				[ : each | 				| eachSize |				eachSize := each minimumSearchSpaceSizeUsing: aMagmaLargeCollectionManager.				(smallest isNil or: [ eachSize < smallestSize ]) ifTrue: 					[ smallest := each.					smallestSize := eachSize ] ].			smallest 				addMinimumEnumerationsTo: aMaQueryTrunk				using: aMagmaLargeCollectionManager ]		ifFalse: 			[ self terms do: 				[ : each | 				each 					addMinimumEnumerationsTo: aMaQueryTrunk					using: aMagmaLargeCollectionManager ] ]! !!MagmaExpression methodsFor: '*magma-server-private' stamp: 'cmm 10/8/2006 21:04'!minimumSearchSpaceSizeUsing: aMaLargeCollectionManager 	| calculateSizeBlock |	calculateSizeBlock := 	[ : each | 	each minimumSearchSpaceSizeUsing: aMaLargeCollectionManager ].	^ self isConjunction 		ifTrue: [ (self terms collect: calculateSizeBlock) min ]		ifFalse: [ self terms detectSum: calculateSizeBlock ]! !!MagmaExpression methodsFor: '*magma-server-private' stamp: 'cmm 4/12/2006 00:22'!shouldInclude: oid using: aMagmaCollectionManager 	^ self isConjunction 		ifTrue: 			[ self terms allSatisfy: 				[ : each | 				each 					shouldInclude: oid					using: aMagmaCollectionManager ] ]		ifFalse: 			[ self terms anySatisfy: 				[ : each | 				each 					shouldInclude: oid					using: aMagmaCollectionManager ] ]! !