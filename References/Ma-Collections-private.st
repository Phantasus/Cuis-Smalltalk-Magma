MaObject subclass: #MaFixedLengthRecord	instanceVariableNames: 'byteArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-private'!!MaFixedLengthRecord methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:52'!byteArray	^ byteArray! !!MaFixedLengthRecord methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:52'!byteArray: aByteArray	byteArray := aByteArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaFixedLengthRecord class	instanceVariableNames: ''!!MaFixedLengthRecord class methodsFor: 'create' stamp: 'cmm 5/19/2005 11:05'!new: anInteger	^ self new		byteArray: (ByteArray new: anInteger) ;		yourself! !MaFixedLengthRecord subclass: #MaHashIndexRecord	instanceVariableNames: 'recordNumber lowKey highKey keySize valueSize numberOfSlots entrySize entryWeight canHoldDuplicateKeys'	classVariableNames: ''	poolDictionaries: 'MaHashIndexRecordConstants'	category: 'Ma-Collections-private'!!MaHashIndexRecord commentStamp: 'cmm 4/28/2005 21:25' prior: 0!keySize and valueSize are specified in bits.entrySize is in bytes.!!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 12/6/2002 00:05'!addAnomaliesTo: aDictionary usingParent: parentRecord	| originalCount |	originalCount := aDictionary size.	self		addChildCountAnomaliesTo: aDictionary		using: parentRecord.	^aDictionary size > originalCount! !!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 12/6/2002 00:04'!addChildCountAnomaliesTo: aDictionary using: parentRecord	| bax parentNumberOfChildren isCorrect |	bax := self baxInParent: parentRecord for: self.	parentNumberOfChildren := (parentRecord numberOfChildrenAtByteArrayIndex: bax).	isCorrect := (self lowKey = self highKey or: [ self numberOfChildren = 0 ])		ifTrue: 			[ "it's possible for the record not to have an entry in the parent under this condition."			(parentRecord hasEntryAtByteArrayIndex: bax)				ifTrue: [ (parentNumberOfChildren - 1) = self numberOfChildren ]				ifFalse: [ parentNumberOfChildren = self numberOfChildren ] ]		ifFalse:			[ (parentNumberOfChildren - 1) = self numberOfChildren ].	isCorrect ifFalse:		[ (aDictionary			at: 'number of children discrepency'			ifAbsentPut: [ OrderedCollection new ]) add: { parentRecord.  self } ]! !!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 11/29/2002 23:39'!baxInParent: parentRecord for: childRecord	parentRecord		byteArrayIndexesFrom: 0		do:			[ :bax |			(parentRecord recordNumberAtByteArrayIndex: bax) = childRecord recordNumber				ifTrue: [ ^bax ] ].	self error: 'I am not child of parentRecord'! !!MaHashIndexRecord methodsFor: 'printing'!allNumberOfChildren	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self numberOfChildrenAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 10/1/2013 11:20'!dumpEntriesTo: aStream 	self 		byteArrayIndexesFrom: 0		do: 			[ : eachBax | 			(self numberOfChildrenAtByteArrayIndex: eachBax) > 0 ifTrue: 				[ | x |				x := self slotIndexForBax: eachBax.				aStream					cr ;					space ;					space ;					maPrint: 'x:' ;					maPrint: x ;					maPrint: ' [' ;					maPrint: (self lowestKeyAtIndex: x) ;					maPrint: '..' ;					maPrint: (self highestKeyAtIndex: x) ;					maPrint: ']' ;					maPrint: ' bx:' ;					maPrint: (self byteArrayIndexFor: x).				(self hasSlotAvailableAtByteArrayIndex: eachBax) ifTrue: [ aStream nextPutAll: ' *empty slot* ' ].				aStream					maPrint: ' k:' ;					maPrint: (self keyAtByteArrayIndex: eachBax) ;					maPrint: ' v:' ;					maPrint: (self valueAtByteArrayIndex: eachBax) ;					maPrint: ' r:' ;					maPrint: (self recordNumberAtByteArrayIndex: eachBax) ;					maPrint: ' c:' ;					maPrint: (self numberOfChildrenAtByteArrayIndex: eachBax) ;					flush ] ]! !!MaHashIndexRecord methodsFor: 'printing'!keys	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self keyAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 9/10/2006 14:17'!maPrintAbbreviatedOn: aStream	self		maPrintAttributes: #(recordNumber lowKey highKey entryWeight possibleKeys canHoldDuplicateKeys)		on: aStream.	aStream cr; maPrint: 'entries:'.	self dumpEntriesTo: aStream! !!MaHashIndexRecord methodsFor: 'printing'!recordNumbers	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self recordNumberAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 4/28/2005 21:52'!values	"This is intended to be used only for printing!!"	^ (self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ : index | self valueAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/1/2006 18:47'!atKey: keyInteger put: valueInteger 	"The receiver has been verified for some available slot for keyInteger."	self 		eligibleByteArrayIndexesFor: keyInteger		reverseDo: 			[ : index | 			(self hasSlotAvailableAtByteArrayIndex: index) ifTrue: 				[ self 					keyAtByteArrayIndex: index					put: keyInteger.				self 					valueAtByteArrayIndex: index					put: valueInteger.				self occupySlotAtByteArrayIndex: index.				^ index ] ].	MaSoftwareError signal: 'I should have been verified for an available slot.'! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 11/27/2011 20:03'!beFrom: lowKeyInteger to: highKeyInteger 	self		 lowKey: lowKeyInteger ;		 highKey: highKeyInteger ;		 resetForNewKeyRange! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 7/1/2005 17:09'!beZoomedInToward: keyInteger from: aMaHashIndexRecord	"Set the receivers low and highIndex to the correct range that can	accomodate the index where keyInteger belongs in aMaHashIndexRecord."	| index |	index := aMaHashIndexRecord slotIndexFor: keyInteger.	self		beFrom: (aMaHashIndexRecord lowestKeyAtIndex: index)		to: (aMaHashIndexRecord highestKeyAtIndex: index)! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/10/2006 20:54'!decrementNumberOfChildrenAtByteArrayIndex: anInteger	| currentNumberOfChildren |	currentNumberOfChildren := self numberOfChildrenAtByteArrayIndex: anInteger.	currentNumberOfChildren = 0 ifTrue: [MaSoftwareError signal].	self		numberOfChildrenAtByteArrayIndex: anInteger		put: currentNumberOfChildren - 1! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 11/30/2002 23:51'!decrementNumberOfChildrenAtKey: keyInteger	self decrementNumberOfChildrenAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!highKey: anInteger	^byteArray		maUint: keySize		at: (keySize / 8)		put: anInteger! !!MaHashIndexRecord methodsFor: 'building'!incrementNumberOfChildrenAtByteArrayIndex: anInteger	| currentNumberOfChildren |	currentNumberOfChildren := self numberOfChildrenAtByteArrayIndex: anInteger.	self		numberOfChildrenAtByteArrayIndex: anInteger		put: currentNumberOfChildren + 1! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!keyAtByteArrayIndex: index put: anInteger	^byteArray		maUint: keySize		at: index + self keyEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 11/4/2014 14:42'!keySize: keyBits valueSize: valueBits numberOfSlots: numberOfSlotsInteger	keySize := keyBits.	valueSize := valueBits.	numberOfSlots := numberOfSlotsInteger.	"Each entry consists of:  value, record number, key, number of child entries."	entrySize := SizeOfControlFieldInBytes + (valueSize/8) + SizeOfRecordNumberInBytes + ((keySize / 8) * 2).	byteArray := ByteArray new: self headerSize + (entrySize * numberOfSlotsInteger)! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!lowKey: anInteger	^byteArray		maUint: keySize		at: 0		put: anInteger! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 11/27/2011 20:05'!populateFrom: aMaHashIndexRecord	byteArray		replaceFrom: 1		to: byteArray size		with: aMaHashIndexRecord byteArray.	recordNumber := aMaHashIndexRecord recordNumber.	self resetForNewKeyRange! !!MaHashIndexRecord methodsFor: 'building'!recordNumber: anInteger	recordNumber := anInteger! !!MaHashIndexRecord methodsFor: 'building'!recordNumberAtSlotForKey: keyInteger put: recordNumberInteger	self		recordNumberAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)		put: recordNumberInteger! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/10/2006 20:56'!removeKey: keyInteger withValue: valueInteger 	self 		eligibleByteArrayIndexesFor: keyInteger		do: 			[ : each | 			((self keyAtByteArrayIndex: each) = keyInteger 			and: [ (self valueAtByteArrayIndex: each) = valueInteger			and: [ self hasEntryAtByteArrayIndex: each ] ]) ifTrue: 				[ self					vacateSlotAtByteArrayIndex: each ;					decrementNumberOfChildrenAtByteArrayIndex: each.				^ each ] ].	^ nil! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 7/1/2005 17:00'!baxMap	| map |	map := OrderedCollection new.	self		byteArrayIndexesFrom: 0		do: [ :each | map add: (self slotIndexForBax: each) -> each ].	^map asArray! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 3/9/2004 23:53'!dumpEntries	self dumpEntriesTo: Transcript! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 4/28/2005 21:47'!dumpStructureTo: aStream	self		maPrintAttributes: #(			recordNumber lowKey highKey canHoldDuplicateKeys keys recordNumbers values			allNumberOfChildren possibleKeys)		on: aStream! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 7/1/2005 16:51'!possibleKeys	| answer |	answer := WriteStream on: (String new: numberOfSlots * 2).	0		to: numberOfSlots - 1		do:			[ : index |  | low high |			low := self lowestKeyAtIndex: index.			high := self highestKeyAtIndex: index.			answer nextPutAll: ' | '.			low = high				ifTrue:					[ answer maPrint: low ]				ifFalse:					[ answer						maPrint: low;						maPrint: '..';						maPrint: high ] ].	^ answer contents! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 3/11/2004 21:41'!structure	^ String streamContents: [ : stream | self dumpStructureTo: stream ]! !!MaHashIndexRecord methodsFor: 'accessing'!bufferSize	^byteArray size! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/22/2002 00:12'!byteArrayIndexContainingGlobalIndex: anInteger base: baseInteger	"baseInteger is 0-based."	| count |	count := baseInteger.	self		byteArrayIndexesFrom: 0		do:			[ :each |			count := count + (self numberOfChildrenAtByteArrayIndex: each).			count >= anInteger ifTrue: [ ^each ] ].	^nil! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/27/2002 14:55'!byteArrayIndexOfLowestEntry	"Answers nil if no entries on this record."	self		byteArrayIndexesFrom: 0		do:			[ :each | (self hasEntryAtByteArrayIndex: each) ifTrue: [ ^each ] ].	^nil! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!highKey	^byteArray		maUint: keySize		at: keySize / 8! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:12'!highestByteArrayIndexFor: keyInteger	"This will vary from the lowestByteArrayIndexFor: keyInteger only when the receiver canHoldDuplicateKeys."	^ self byteArrayIndexFor: (self highestSlotIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:00'!highestByteArrayIndexForAnyKeyAt: byteArrayIndex	"this is for records that canHoldDuplicateKeys when we need to find the next child record number, since that is stored at the highestByteArrayIndexFor: that key."	^self highestByteArrayIndexFor: (self lowestKeyAtIndex: (self slotIndexForBax: byteArrayIndex))! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 3/12/2004 10:51'!highestKeyAtIndex: anInteger	^canHoldDuplicateKeys		ifTrue:			[ self lowestKeyAtIndex: anInteger ]		ifFalse:			[ (self lowestKeyAtIndex: anInteger + 1) - 1 ]! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/4/2014 14:07'!highestPossibleKey	^ (1 bitShift: keySize) - 1! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!keyAtByteArrayIndex: anInteger	^byteArray		maUint: keySize		at: anInteger + self keyEntryOffset! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/4/2014 15:50'!keyAtHighestSlotFor: keyIntegerself maMarked: 'delete'.	^self keyAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:13'!keyAtSlotIndex: anInteger	^ self keyAtByteArrayIndex: (self byteArrayIndexFor: anInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 3/11/2004 21:53'!keySize	^ keySize! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!lowKey	^byteArray		maUint: keySize		at: 0! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 12/29/2005 22:59'!lowestPossibleKey	^ 0! !!MaHashIndexRecord methodsFor: 'accessing'!numberOfChildren	| total |	total := 0.	self		byteArrayIndexesFrom: 0		do: [ :index | total := total + (self numberOfChildrenAtByteArrayIndex: index) ].	^total! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:08'!numberOfChildrenBefore: keyInteger	| lastByteArrayIndex entryIndex totalInSlotsBeforeKey |	entryIndex := self slotIndexFor: keyInteger.	lastByteArrayIndex := self byteArrayIndexFor: entryIndex.	totalInSlotsBeforeKey := self numberOfChildrenBeforeByteArrayIndex: lastByteArrayIndex.	^((self keyAtByteArrayIndex: lastByteArrayIndex) < keyInteger		and: [ self hasEntryAtByteArrayIndex: lastByteArrayIndex ])			ifTrue:				[ (lastByteArrayIndex = (self highestByteArrayIndexFor: keyInteger))					ifTrue: [ totalInSlotsBeforeKey + 1 ]					ifFalse: [ totalInSlotsBeforeKey + (self numberOfChildrenAtByteArrayIndex: lastByteArrayIndex) ] ]			ifFalse: [ totalInSlotsBeforeKey ]! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/22/2002 00:13'!numberOfChildrenBeforeByteArrayIndex: anInteger	| total |	total := 0.	self		byteArrayIndexesFrom: 0		do:			[ :each |			each = anInteger ifTrue: [ ^total ].			total := total + (self numberOfChildrenAtByteArrayIndex: each) ].	self error: anInteger printString, ' is not a valid byteArrayIndex.'! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 16:51'!numberOfSlots	^ numberOfSlots! !!MaHashIndexRecord methodsFor: 'accessing'!recordNumber	^recordNumber! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:14'!recordNumberAtByteArrayIndex: anInteger 	^ byteArray"		maUint: SizeOfRecordNumberInBits"		maUnsigned32At: anInteger + self recordNumberEntryOffset + 1! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 12/1/2002 20:57'!recordNumberAtHighestByteArrayIndexForBax: anInteger	^self recordNumberAtByteArrayIndex: (self highestByteArrayIndexForAnyKeyAt: anInteger)! !!MaHashIndexRecord methodsFor: 'accessing'!recordNumberCloserTo: keyInteger	^self recordNumberAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 8/17/2005 19:18'!slotIndexFor: keyInteger	"The lowest slot index in which keyInteger can reside."	^ (keyInteger - lowKey) * numberOfSlots // entryWeight! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 16:59'!slotIndexForBax: anInteger	"Bax means 'byteArrayIndex'."	^(anInteger - self headerSize) / entrySize! !!MaHashIndexRecord methodsFor: 'private'!byteArrayIndexFor: entryIndex	^entryIndex * entrySize + self headerSize! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/8/2015 20:41'!controlAtByteArrayIndex: anInteger	^ byteArray "		maUint: SizeOfControlFieldInBits"		byteAt: anInteger+1 "+ ControlEntryOffset"  "<-- avoid extra send for performance"! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:35'!controlAtByteArrayIndex: index put: anInteger	^ byteArray 		maUint: SizeOfControlFieldInBits		at: index "+ ControlEntryOffset"		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 3/12/2004 15:37'!entryWeight	^ entryWeight! !!MaHashIndexRecord methodsFor: 'private'!headerSize	"Low and high keys.	^(keySize / 8) * 2  simplified to / 4 for max performance."	^keySize / 4! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 17:11'!highestSlotIndexFor: keyInteger	^ canHoldDuplicateKeys		ifTrue:			[ (self slotIndexFor: keyInteger + 1) - 1 ]		ifFalse:			[ self slotIndexFor: keyInteger ]! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:51'!keyEntryOffset	^ self recordNumberEntryOffset + SizeOfRecordNumberInBytes! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 17:08'!lowestByteArrayIndexFor: keyInteger	^self byteArrayIndexFor: (self slotIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 16:51'!lowestKeyAtIndex: entryIndex	"Answer the lowest-possible key that can be stored at entryIndex."	^ lowKey + (entryIndex * entryWeight // numberOfSlots)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 1/27/2003 23:51'!numberOfChildrenAtByteArrayIndex: anInteger	^byteArray		maUint: keySize		at: anInteger + self numberOfChildrenEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 1/27/2003 23:57'!numberOfChildrenAtByteArrayIndex: index put: anInteger	^byteArray		maUint: keySize		at: index + self numberOfChildrenEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 12/30/2002 21:20'!numberOfChildrenEntryOffset	^self keyEntryOffset + (keySize / 8)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:49'!occupySlotAtByteArrayIndex: anInteger 	| controlValue |	controlValue := self controlAtByteArrayIndex: anInteger.	self		controlAtByteArrayIndex: anInteger		put: (controlValue maBitSet: SlotFilledControlBit)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 12/29/2005 23:00'!postInitialize	self		beFrom: self lowestPossibleKey 		to: self highestPossibleKey! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:47'!recordNumberAtByteArrayIndex: index put: anInteger	^ byteArray		maUint: SizeOfRecordNumberInBits		at: index + self recordNumberEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:35'!recordNumberEntryOffset	^ ValueEntryOffset + (valueSize/8 "bits")! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/27/2011 20:03'!resetForNewKeyRange	lowKey := self lowKey.	highKey := self highKey.	canHoldDuplicateKeys := (highKey - lowKey + 1) < numberOfSlots.	entryWeight := highKey - lowKey + 1! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 16:51'!setLowKey: lowKeyInteger highKey: highKeyInteger	lowKey := self lowKey.	highKey := self highKey.	canHoldDuplicateKeys := (highKey - lowKey + 1) < numberOfSlots.	entryWeight := highKey - lowKey + 1! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:50'!vacateSlotAtByteArrayIndex: anInteger 	| controlValue |	controlValue := self controlAtByteArrayIndex: anInteger.	self		controlAtByteArrayIndex: anInteger		put: (controlValue maBitClear: SlotFilledControlBit)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:36'!valueAtByteArrayIndex: anInteger 	^ byteArray		maUint: valueSize		at: anInteger + ValueEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 11/4/2014 14:36'!valueAtByteArrayIndex: index put: anInteger 	^ byteArray		maUint: valueSize		at: index + ValueEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 10/23/2014 17:12'!valueEntryOffset	^ "self controlEntryOffset + self sizeOfControlFieldInBytes" 1! !!MaHashIndexRecord methodsFor: 'actions' stamp: 'cmm 7/1/2005 16:51'!byteArrayIndexesFrom: startingEntryIndex do: oneArgBlock	self		byteArrayIndexesFrom: startingEntryIndex		to: numberOfSlots - 1		do: oneArgBlock! !!MaHashIndexRecord methodsFor: 'actions'!byteArrayIndexesFrom: startingEntryIndex to: endingEntryIndex do: oneArgBlock	(self byteArrayIndexFor: startingEntryIndex)		to: (self byteArrayIndexFor: endingEntryIndex)		by: entrySize		do: oneArgBlock! !!MaHashIndexRecord methodsFor: 'actions'!eligibleByteArrayIndexesFor: keyInteger do: oneArgBlock	(self lowestByteArrayIndexFor: keyInteger)		to: (self highestByteArrayIndexFor: keyInteger)		by: entrySize		do: [ :index | oneArgBlock value: index ]! !!MaHashIndexRecord methodsFor: 'actions' stamp: 'cmm 3/10/2004 01:00'!eligibleByteArrayIndexesFor: keyInteger reverseDo: oneArgBlock	(self highestByteArrayIndexFor: keyInteger)		to: (self lowestByteArrayIndexFor: keyInteger)		by: 0-entrySize		do: [ :index | oneArgBlock value: index ]! !!MaHashIndexRecord methodsFor: 'testing'!canAdd: keyInteger	self		eligibleByteArrayIndexesFor: keyInteger		do: [ :index | (self hasSlotAvailableAtByteArrayIndex: index) ifTrue: [ ^true ] ].	^false! !!MaHashIndexRecord methodsFor: 'testing'!canHoldDuplicateKeys	^canHoldDuplicateKeys! !!MaHashIndexRecord methodsFor: 'testing'!hasChildAtByteArrayIndex: byteArrayIndex	^(self recordNumberAtByteArrayIndex: byteArrayIndex) > 0! !!MaHashIndexRecord methodsFor: 'testing' stamp: 'cmm 12/1/2002 21:44'!hasChildAtHighestByteArrayIndexForBax: byteArrayIndex	^(self recordNumberAtHighestByteArrayIndexForBax: byteArrayIndex) > 0! !!MaHashIndexRecord methodsFor: 'testing'!hasEntryAtByteArrayIndex: anInteger	^(self hasSlotAvailableAtByteArrayIndex: anInteger) not! !!MaHashIndexRecord methodsFor: 'testing'!hasEntryForKey: keyInteger	"Answer whether keyInteger resides in an entry of the receiver."	self		eligibleByteArrayIndexesFor: keyInteger		do:			[ :index |			((self hasEntryAtByteArrayIndex: index)				and: [ (self keyAtByteArrayIndex: index) = keyInteger ])					ifTrue:						[ ^true ] ].	^false! !!MaHashIndexRecord methodsFor: 'testing' stamp: 'cmm 11/4/2014 14:48'!hasSlotAvailableAtByteArrayIndex: anInteger 	^ (self controlAtByteArrayIndex: anInteger) maIsBitClear: SlotFilledControlBit! !!MaHashIndexRecord methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:03'!independentCopy	^ self copy postIndependentCopy! !!MaHashIndexRecord methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:03'!postIndependentCopy	byteArray := byteArray copy! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaHashIndexRecord class	instanceVariableNames: ''!!MaHashIndexRecord class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!keySize: keyBits valueSize: valueBits numberOfSlots: entrySizeInteger	^ self new		keySize: keyBits		valueSize: valueBits		numberOfSlots: entrySizeInteger ;		postInitialize ;		yourself! !SharedPool subclass: #MaHashIndexRecordConstants	instanceVariableNames: ''	classVariableNames: 'ControlEntryOffset SizeOfControlFieldInBits SizeOfControlFieldInBytes SizeOfRecordNumberInBits SizeOfRecordNumberInBytes SlotFilledControlBit ValueEntryOffset'	poolDictionaries: ''	category: 'Ma-Collections-private'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaHashIndexRecordConstants class	instanceVariableNames: ''!!MaHashIndexRecordConstants class methodsFor: 'as yet unclassified' stamp: 'cmm 11/4/2014 14:44'!initialize	ControlEntryOffset := 0.	SizeOfControlFieldInBits := 8.	SizeOfControlFieldInBytes := SizeOfControlFieldInBits / 8.	SizeOfRecordNumberInBits := 32.	SizeOfRecordNumberInBytes := SizeOfRecordNumberInBits / 8.	SlotFilledControlBit := 1.	ValueEntryOffset := ControlEntryOffset + SizeOfControlFieldInBytes! !MaObject subclass: #MaHashIndexRecordFactory	instanceVariableNames: 'index recordNumbersPath entryIndexPath byteArrayIndexPath recordPath preMadeNewRecord'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-private'!!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 7/1/2005 17:15'!createPreMadeNewRecord	preMadeNewRecord :=		MaHashIndexRecord			keySize: index keySize			valueSize: index valueSize			numberOfSlots: index hashRecordSize! !!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 7/1/2005 17:15'!initializeRecordPathRecords	1		to: self maxDepth		do:			[ :x |			recordPath				at: x				put: (					MaHashIndexRecord						keySize: index keySize						valueSize: index valueSize						numberOfSlots: index hashRecordSize) ]! !!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 12/4/2002 23:35'!postInitialize	recordNumbersPath := OrderedCollection new: self maxDepth.	entryIndexPath := OrderedCollection new: self maxDepth.	byteArrayIndexPath := OrderedCollection new: self maxDepth.	recordPath := Array new: self maxDepth.	self		createPreMadeNewRecord;		initializeRecordPathRecords! !!MaHashIndexRecordFactory methodsFor: 'accessing'!entryIndexAtLevel: anInteger	^entryIndexPath at: anInteger! !!MaHashIndexRecordFactory methodsFor: 'accessing'!preMadeNewRecord	^preMadeNewRecord! !!MaHashIndexRecordFactory methodsFor: 'accessing' stamp: 'cmm 11/29/2002 22:47'!recordAtLevel: levelInteger	^levelInteger > recordPath size		ifTrue:			[ recordPath first independentCopy ]		ifFalse:			[ recordPath at: levelInteger ]! !!MaHashIndexRecordFactory methodsFor: 'accessing'!recordNumberAtLevel: anInteger	^recordNumbersPath at: anInteger! !!MaHashIndexRecordFactory methodsFor: 'private' stamp: 'cmm 12/4/2002 23:35'!index: aMaHashIndex	index := aMaHashIndex! !!MaHashIndexRecordFactory methodsFor: 'private' stamp: 'cmm 4/2/2007 18:51'!maxDepth	"A shortcut way of saying, index highestPossibleKey log: index numberOfSlots."	^ (index keySize / (index numberOfSlots log: 2)) asInteger! !!MaHashIndexRecordFactory methodsFor: 'building' stamp: 'cmm 7/1/2005 17:00'!put: aMaHashIndexRecord atLevel: levelInteger byteArrayIndex: indexInteger	levelInteger > recordNumbersPath size		ifTrue:			[ recordNumbersPath add: aMaHashIndexRecord recordNumber.			byteArrayIndexPath add: indexInteger.			entryIndexPath add: (aMaHashIndexRecord slotIndexForBax: indexInteger) ]		ifFalse:			[ recordNumbersPath				at: levelInteger				put: aMaHashIndexRecord recordNumber.			byteArrayIndexPath				at: levelInteger				put: indexInteger.			entryIndexPath				at: levelInteger				put: (aMaHashIndexRecord slotIndexForBax: indexInteger) ].	levelInteger > recordPath size		ifFalse:			[ (recordPath at: levelInteger) populateFrom: aMaHashIndexRecord ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaHashIndexRecordFactory class	instanceVariableNames: ''!!MaHashIndexRecordFactory class methodsFor: 'creation' stamp: 'cmm 12/4/2002 23:31'!index: aMaHashIndex	^self new		index: aMaHashIndex;		postInitialize;		yourself! !MaHashIndexRecordConstants initialize!