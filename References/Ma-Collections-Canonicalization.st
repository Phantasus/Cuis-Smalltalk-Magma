MaObject subclass: #MaSharedObjectsBroker	instanceVariableNames: 'dates literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Canonicalization'!!MaSharedObjectsBroker commentStamp: 'cmm 10/9/2011 16:58' prior: 0!A MaxSharedObjectsBroker is used to canonicalize Dates, or other flyweight domain objects.  There is no reason to have multiple copies of the same date across all Securities to consume extra space redundantly in the repository, as well as in client memories.!!MaSharedObjectsBroker methodsFor: 'access' stamp: 'cmm 1/30/2015 14:43'!date: aDate 	"Answer the exact shared date instance for aDate."	^ aDate ifNotNil:		[ aDate maOriginalClass = Date ifFalse: [ MaSoftwareError signal: 'The ''dates'' collection is intended to hold only instances of Date.' ].		aDate start offset isZero ifFalse: [ MaWarning signal: 'Are you sure you want to canonicalize a non-globalalized Date?' ].		(dates includesKey: aDate realObjectIfMutatingProxy)			ifTrue: [ dates at: aDate realObjectIfMutatingProxy ]			ifFalse:				[ | dateToPut |				"Put only a copy to ensure it is a unique instance to this broker and not belonging in another db."				dateToPut := aDate veryDeepCopy.				dates					at: dateToPut					ifAbsentPut: [ dateToPut ] ] ]! !!MaSharedObjectsBroker methodsFor: 'access' stamp: 'cmm 12/13/2016 20:45'!literal: anObject 	"Answer the shared version of anObject, a literal String or Array."	anObject == nil ifTrue: [ ^ anObject ].	anObject == true ifTrue: [ ^ anObject ].	anObject == false ifTrue: [ ^ anObject ].	anObject isSymbol ifTrue: [ ^ anObject ].	(anObject isInteger and: [ anObject <= 1073741823 ]) ifTrue: [ ^ anObject ].	(self shouldCacheAsLiteral: anObject) ifFalse: [ ^ anObject ].	^ self literals		at: anObject		ifAbsentPut:			[ anObject yourself isArray				ifTrue:					[ anObject veryDeepCopy collect:						[ : each | self literal: each ] ]				ifFalse:					[ anObject isVariableBinding						ifTrue:							[ anObject veryDeepCopy								key: (self literal: anObject key)								value: (self literal: anObject value) ]						ifFalse:							[ | master masterInArray |							master := anObject veryDeepCopy.							masterInArray := Array with: master.							self literals								at: masterInArray								ifAbsentPut: [ masterInArray ].							master as32BitFloatIfFloat ] ] ]! !!MaSharedObjectsBroker methodsFor: 'private' stamp: 'cmm 10/2/2012 13:33'!dates	"Invariably, a commit-conflict will occur on this collection.  This accessor allows applications to check the contents of the conflict and retry if this is the only conflict.  Otherwise, only #date: should be used."	^ dates! !!MaSharedObjectsBroker methodsFor: 'private' stamp: 'cmm 4/28/2013 15:47'!literals	^ literals ifNil: [ literals := Dictionary new ]! !!MaSharedObjectsBroker methodsFor: 'private' stamp: 'cmm 2/22/2014 16:11'!shouldCacheAsLiteral: anObject 	"Allow Associations too if both their key and value are literals."	^ anObject yourself isLiteral or:		[ anObject isVariableBinding and:			[ (self shouldCacheAsLiteral: anObject key) and: [ self shouldCacheAsLiteral: anObject value ] ] ]! !!MaSharedObjectsBroker methodsFor: 'initialize-release' stamp: 'cmm 2/21/2014 17:19'!initialize	super initialize.	dates := Dictionary new: 500.	literals := Dictionary new: 500! !