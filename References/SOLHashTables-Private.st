Object subclass: #SOLHashFrame	instanceVariableNames: 'prev curr next'	classVariableNames: ''	poolDictionaries: ''	category: 'SOLHashTables-Private'!!SOLHashFrame commentStamp: 'tbr 4/4/2010 17:17' prior: 0!I contain pointers to a contiguous segment of a linked list, to be used as a work area for traversing the list, and for performing insertion and deletion operations.  I am probably overkill for single-threaded code :), but have been left in place as a remnant of the lock-free multi-threaded list algorithm of Michaels as it is used in the SOL Hash Table of Shalev and Shavit.In a multi-thread environment, a frame would be thread local storage, and so would probably be allocated outside of the SOLHashTable, and passed in to the various SOLHashTable operations.  That kind of interface would be very different from the more usual Squeak collections interface, so this implementation just allocates one when needed.Tom Rushworth <tbr@acm.org>LICENSE--------Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.!!SOLHashFrame methodsFor: 'private' stamp: 'cmm 4/9/2011 17:15'!advance	prev := curr.	curr := next.	next := next ifNotNil: [ next next ]! !!SOLHashFrame methodsFor: 'private' stamp: 'cmm 4/13/2011 18:16'!detach	"Delete the node at curr from the list, and return the extracted node."	| detached |	prev next: next.	detached := curr.	curr := next.	next := curr ifNotNil: [ curr next ].	^ detached! !!SOLHashFrame methodsFor: 'private' stamp: 'tbr 4/3/2010 18:45'!insert: newNode	"Insert newNode between prev and curr and return the inserted node"	"Make a sanity check to see we don't ever insert a double dummy."	"	(newNode dummy) ifTrue:	    [((prev key) = (newNode key)) ifTrue: [self halt].		((nil ~= curr) and: [(curr key) = (newNode key)]) ifTrue: [self halt]].	"	newNode next: curr.	prev next: newNode.	^newNode! !!SOLHashFrame methodsFor: 'private' stamp: 'cmm 4/11/2011 15:30'!locate: startKey in: aNode	"search down linked list of SOLHashNodes starting with (aNode next) for a node that matches srchKey and srchVal.	 Return true if found and set  prev,curr,next to point to the 3 nodes in sequence in the list with curr being the found node.	 Return false if not found and set prev,curr to point to the 2 nodes in sequence in the list between which the <srchKey,srchVal>	 would have been if they were present (i.e. the insertion point if the search values are to be inserted).		 This method needs to be fairly efficient, as it is called for *every* operation on the hash table."	| currKey |	self set: aNode.	[nil = curr] whileFalse:	    ["examine the current node"		currKey := curr key.		(currKey = startKey) 			ifTrue: [^true]			ifFalse:			    [ "unequal keys, quit searching if we're past the insertion point"				currKey > startKey ifTrue: [^false]].		"not found yet, move the frame down the list."		self advance].	^false! !!SOLHashFrame methodsFor: 'private' stamp: 'cmm 4/9/2011 15:31'!set: aSOLHashNode	prev := aSOLHashNode.	curr := prev next.	next := curr ifNotNil: [ curr next ]! !!SOLHashFrame methodsFor: 'accessing' stamp: 'tbr 4/1/2010 09:14'!curr	^curr! !!SOLHashFrame methodsFor: 'accessing' stamp: 'cmm 4/9/2011 17:11'!do: aBlock until: untilBlock 	[ curr isNil or: [ (untilBlock value: curr) ] ] whileFalse:		[ aBlock value: curr.		self advance ]! !!SOLHashFrame methodsFor: 'operations' stamp: 'cmm 4/7/2011 17:00'!find: srchKey in: aNode 	(self		locate: srchKey		in: aNode) ifTrue: [ ^ curr value ].	^ nil! !!SOLHashFrame methodsFor: 'operations' stamp: 'cmm 4/9/2011 17:06'!insert: anObject at: hashKey in: aNode 	"Return an old value that compares: equal to anObject if one is present,	 otherwise return nil to indicate a successful insertion."	self		locate: hashKey		in: aNode ;		 insert:			(SOLHashNode				key: hashKey				value: anObject).	^ anObject! !!SOLHashFrame methodsFor: 'operations' stamp: 'cmm 3/23/2011 15:18'!insertDummy: srchKey in: aNode	| newNode |	((nil ~= aNode) and: [self locate: srchKey in: aNode]) ifTrue: [^curr].	newNode := SOLHashNode key: srchKey value: nil.	(nil ~= aNode) ifTrue: [newNode := self insert: newNode].	^newNode! !!SOLHashFrame methodsFor: '*magma-client' stamp: 'cmm 4/11/2011 13:33'!at: srchKey ifAbsentPut: aBlock from: aNode 	"Return an old value that compares: equal to srchVal if one is present, otherwise return nil to indicate a successful insertion."	(self		locate: srchKey		in: aNode) ifTrue: [ ^ curr value ].	self insert:		(SOLHashNode			key: srchKey			value: aBlock value).	^ nil! !Association subclass: #SOLHashNode	instanceVariableNames: 'next'	classVariableNames: ''	poolDictionaries: ''	category: 'SOLHashTables-Private'!!SOLHashNode commentStamp: 'tbr 4/4/2010 14:50' prior: 0!I represent a list node in a Split-Order list.  Each item in the list has a corresponding key, and the list is kept in key order.  The key values are actually bit-reversed, to make it possible to divide the list into logical buckets, and to divide the list buckets into smaller buckets without having to re-sort the list.  It is this property that allows the SOLHashTable to expand gracefully, without ever having to rehash or rebucket the values.There are probably many other "list" objects that would serve here, but this class is present to keep the SOLHashTable self-contained, and to make it easy to add all the bells and whistles needed for safe multi-threaded operation at some point in the future when the Squeak VM provides true independent process threads.Tom Rushworth <tbr@acm.org>LICENSE---------Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.!!SOLHashNode methodsFor: 'accessing' stamp: 'tbr 4/2/2010 16:21'!dummy	"Return true if receiver is a dummy node."	^0 = ((self key) bitAnd: 1)! !!SOLHashNode methodsFor: 'accessing' stamp: 'tbr 4/1/2010 08:23'!next	^next! !!SOLHashNode methodsFor: 'accessing' stamp: 'tbr 4/1/2010 08:23'!next: aNode	next := aNode! !!SOLHashNode methodsFor: 'private' stamp: 'tbr 4/1/2010 13:52'!initialize: nextNode	"See the class methods for proper creation and initialization."	next := nextNode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SOLHashNode class	instanceVariableNames: ''!!SOLHashNode class methodsFor: 'instance creation' stamp: 'tbr 4/1/2010 13:49'!key: anInteger	^(super key: anInteger value: nil) initialize: nil! !!SOLHashNode class methodsFor: 'instance creation' stamp: 'tbr 3/25/2010 14:38'!key: anInteger value: anObject	^(super key: anInteger value: anObject) initialize: nil! !Object subclass: #SOLHashSegment	instanceVariableNames: 'depth owner pointers'	classVariableNames: ''	poolDictionaries: ''	category: 'SOLHashTables-Private'!!SOLHashSegment commentStamp: 'tbr 4/4/2010 14:50' prior: 0!I represent a "segment" of a hash table containing an array of HashSegmentNumPtrs pointers to SOLHashListNodes or other segments.  The entire hash table is represented as a tree of segments of uniform depth, where the bottommost or "leaf" layer points into the list of nodes, and all higher layers point at lower segments.depth - an int indicating position in the tree, depth == 0 implies this is a leaf segment and the pointers are to SOLHashListNodes.  This is never changed once set.owner - the containing SOLHashTable.  Never changed once set.pointers - an array of (owner segPtrs) pointers, which may be nil, or when depth == 0 may point to SOLHashListNodes, and which otherwise point to the next lower depth SOLHashTableSegments.Tom Rushworth <tbr@acm.org>LICENSE--------Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.!!SOLHashSegment methodsFor: 'accessing' stamp: 'cmm 4/11/2011 15:59'!bucketAt: bucketNum 	"Return whatever (SOLHashSegment, SOLHashNode, or nil) is in pointers at the index corresponding to bucketNum."	^ pointers		at: 1 + (bucketNum bitAnd: owner segMask)		ifAbsent: [ nil ]! !!SOLHashSegment methodsFor: 'accessing' stamp: 'cmm 4/8/2014 22:27'!bucketAt: bucketNum put: anObject	"Set the pointer array at the index corresponding to bucktNum to anObject and return anObject."	| index |	index := 1+(bucketNum bitAnd: (owner segMask)).	[ pointers size < index ] whileTrue: [ pointers add: nil ].	pointers at: index put: anObject.	^anObject! !!SOLHashSegment methodsFor: 'accessing' stamp: 'tbr 4/1/2010 10:29'!depth	^depth! !!SOLHashSegment methodsFor: 'initialize-release' stamp: 'cmm 4/8/2014 22:26'!initializeAtDepth: newDepth owner: anSOLHashTable	"Set up a segment with an empty array of pointers in a tree of segments.	 Depth is measured from the leaves of the tree, starting at 0.	 Pointers in segments at depth 0 point to SOLHashNodes, at other depths the pointers point to segments of depth-1"	depth := newDepth.	owner := anSOLHashTable.	pointers := owner newPointersCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SOLHashSegment class	instanceVariableNames: ''!!SOLHashSegment class methodsFor: 'create' stamp: 'cmm 4/23/2011 18:32'!depth: anInteger owner: aSOLHashTable 	^ self new		initializeAtDepth: anInteger		owner: aSOLHashTable! !