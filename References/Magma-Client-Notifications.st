MaClientServerNotification subclass: #MagmaNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!MagmaNotification subclass: #MagmaLinkChange	instanceVariableNames: 'oldLink newLink'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!!MagmaLinkChange commentStamp: 'cmm 12/9/2012 11:52' prior: 0!This is a private notification to assist with HA processing.  When an HA event occurs, temp vars up on the stack can still be pointing to the server that went down, this notification informs them to update a particular 'oldLink' to a 'newLink' to the new server.!!MagmaLinkChange methodsFor: 'accessing' stamp: 'cmm 12/8/2012 14:01'!linkToReplace: aMaNetworkServerLink 	^ oldLink = aMaNetworkServerLink		ifTrue: [ newLink ]		ifFalse: [ oldLink ]! !!MagmaLinkChange methodsFor: 'initializing' stamp: 'cmm 12/8/2012 14:00'!setOldLink: theOldLink newLink: theNewLink 	oldLink := theOldLink.	newLink := theNewLink! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaLinkChange class	instanceVariableNames: ''!!MagmaLinkChange class methodsFor: 'as yet unclassified' stamp: 'cmm 12/8/2012 14:03'!oldLink: oldLink newLink: newLink 	^ self new				setOldLink: oldLink		newLink: newLink ;		 yourself! !MagmaNotification subclass: #MagmaNodeUpdate	instanceVariableNames: 'add remove setPrimary'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!!MagmaNodeUpdate methodsFor: 'initialize-release' stamp: 'cmm 10/31/2008 11:34'!add: aMagmaRemoteLocation 	add := aMagmaRemoteLocation! !!MagmaNodeUpdate methodsFor: 'initialize-release' stamp: 'cmm 10/31/2008 11:34'!remove: aMagmaRemoteLocation 	remove := aMagmaRemoteLocation! !!MagmaNodeUpdate methodsFor: 'initialize-release' stamp: 'cmm 11/15/2008 14:48'!setPrimary: aMagmaRemoteLocation 	setPrimary := aMagmaRemoteLocation! !!MagmaNodeUpdate methodsFor: 'accessing' stamp: 'cmm 11/15/2008 14:50'!applyTo: aMagmaNode 	"Make updates to the aMagmaNode."	remove ifNotNil: 		[ aMagmaNode removeLocation: remove		"Check node is production-capable (i.e., at least two locations in the node)." ].	add ifNotNil: [ aMagmaNode addLocation: add ].	setPrimary ifNotNil: [ aMagmaNode primaryLocation: setPrimary ]! !!MagmaNodeUpdate methodsFor: 'accessing' stamp: 'cmm 11/24/2009 15:48'!processUsing: aMagmaServerConsole 	"Apply my updates to the node in a transaction.  Then ensure a correct node configuration."	| session node oldBranchCode canSkipReconfigure |	session := aMagmaServerConsole serverSession.	node := aMagmaServerConsole node.	canSkipReconfigure := self isOnlyRemoving and: [ node includesSecondary: remove ].		[ 	[ self wantsNewPrimary ifTrue: 		[ "Can't do a commit if you're not the primary, gotta bite the bullet."		oldBranchCode := aMagmaServerConsole controller branchCode.		aMagmaServerConsole controller commitRestore ].	session commit: [ self applyTo: node ] ] 		on: MagmaCommitError		do: 			[ : err | 			session abort.			oldBranchCode ifNotNil: 				[ "Ahhhh, go back!!  We didn't actually commit anything so it should be safe."				aMagmaServerConsole controller					branchCode: oldBranchCode ;					beginRestore ] ] ] ensure: 		[ "This is needed whether commit-error occurs or not"		"But, if only removing a secondary, we don't need to "		canSkipReconfigure ifFalse: [ aMagmaServerConsole ensureCorrectNodeConfiguration ] ]! !!MagmaNodeUpdate methodsFor: 'testing' stamp: 'cmm 11/24/2009 15:44'!isOnlyRemoving	^ add isNil and: [ self wantsNewPrimary not and: [ remove notNil ] ]! !!MagmaNodeUpdate methodsFor: 'testing' stamp: 'cmm 11/15/2008 16:30'!wantsNewPrimary	^ setPrimary notNil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaNodeUpdate class	instanceVariableNames: ''!!MagmaNodeUpdate class methodsFor: 'signaling' stamp: 'cmm 10/31/2008 11:33'!signalAdd: aMagmaRemoteLocation 	^ self new		add: aMagmaRemoteLocation ;		signal! !!MagmaNodeUpdate class methodsFor: 'signaling' stamp: 'cmm 10/31/2008 11:33'!signalRemove: aMagmaRemoteLocation 	^ self new		remove: aMagmaRemoteLocation ;		signal! !MagmaNotification subclass: #MagmaProxyMaterialization	instanceVariableNames: 'materializedObject'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!!MagmaProxyMaterialization commentStamp: 'cmm 1/13/2005 23:05' prior: 0!I am signaled when a mutating proxy is materialized.  The materializedObject is available as an argument.To use:	[ ... do your stuff ... ]		on: MagmaProxyMaterialization 		do:			[ : theNotification |			doSomethingWith: theNotification.			theNotification resume "<-- very important!!" ]!!MagmaProxyMaterialization methodsFor: 'as yet unclassified' stamp: 'cmm 4/27/2003 20:14'!materializedObject	^materializedObject! !!MagmaProxyMaterialization methodsFor: 'as yet unclassified' stamp: 'cmm 5/2/2003 17:23'!materializedObject: anObject	materializedObject := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaProxyMaterialization class	instanceVariableNames: ''!!MagmaProxyMaterialization class methodsFor: 'signaling' stamp: 'cmm 4/10/2005 18:00'!signalMaterializedObject: anObject 	(self new)		messageText: 'materializing a ' , anObject maOriginalClass printString;		materializedObject: anObject;		signal! !MagmaNotification subclass: #MagmaRepairNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!MagmaNotification subclass: #MagmaServerLowOnMemoryNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!MagmaNotification subclass: #MagmaUserRequirementNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!!MagmaUserRequirementNotification commentStamp: 'cmm 3/11/2005 14:13' prior: 0!I am used when Magma discovers it is missing an object and must get it from the user.  For example, when the user invokes a forwarding-proxy to another repository, connection credentials for that repository must be supplied.  Magma does not keep these for you, but it requires them.!MagmaUserRequirementNotification subclass: #MagmaUserRequiredNotification	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Client-Notifications'!!MagmaUserRequiredNotification methodsFor: 'as yet unclassified' stamp: 'cmm 11/13/2013 20:40'!defaultAction	"The user did not listen for this notification.  For now, bail them out by offering them an opportunity to create one on the fly."	self resume: (session user ifNil: 			[ Smalltalk isHeadless 				ifTrue: [ 'unnamed' ]				ifFalse: 					[ MagmaUser id: (UIManager default request: 'Enter a name to connect under.') ] ])! !!MagmaUserRequiredNotification methodsFor: 'as yet unclassified' stamp: 'cmm 3/13/2005 18:07'!session: aMagmaSession	session := aMagmaSession! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaUserRequiredNotification class	instanceVariableNames: ''!!MagmaUserRequiredNotification class methodsFor: 'private' stamp: 'cmm 3/13/2005 18:08'!requestUserFor: aMagmaSession	^ (self session: aMagmaSession)		messageText: 'Supply a userId for ', aMagmaSession linkInformation ;		signal! !!MagmaUserRequiredNotification class methodsFor: 'as yet unclassified' stamp: 'cmm 3/13/2005 18:07'!session: aMagmaSession	^ self new		session: aMagmaSession ;		yourself! !