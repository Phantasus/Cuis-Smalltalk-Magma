MaObject subclass: #MagmaRepositoryController	instanceVariableNames: 'repository session serverSerializer requestInterruptGuard localLocation preferences serverStatistics backupProcess'	classVariableNames: 'ControllersGuard OpenControllers'	poolDictionaries: ''	category: 'Magma-Server-API'!!MagmaRepositoryController commentStamp: 'cmm 7/29/2007 17:46' prior: 0!A MagmaRepositoryController is the main user interface to a Magma repository.  With this class you create, open and delete repositories.  Instance Variables	localLocation:  a MagmaLocalLocation specifying where the repository is opened on.	preferences:  A MagmaServerPreferences specifying various server-level options.	repository:  The center of the Magma server universe, manages server operations.  Private from general public use.	requestInterruptGuard:  Monitor to allow only one request at a time to execute.	serverSerializer:  The serializer used to send certain whole graph-buffers back to the client.  (My sessions serializer cannot be used because it is optimized for a MagmaSession; i.e., only serializing each object one level deep, etc.).	session:  My standard session used to perform standard operations on the model, mostly for LargeCollection support.!!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 8/1/2007 22:16'!archiveCommitLog	repository archiveCommitLog! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 3/4/2009 15:00'!backupProcess	^ backupProcess! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 7/1/2007 11:23'!commitLogDirectory	^ self localLocation commitLogDirectory! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 8/3/2007 11:02'!deleteUnnecessaryCommitLogs	"Delete all commit log files from my 'commits' subdirectory that have already been written to my repository files and, therefore, are no longer needed by this repository.  This is not performed automatically because the files might be needed for one or more warm backups."	repository deleteUnnecessaryCommitLogs! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 3/29/2010 21:27'!fullBackup	"Backup the repository to the defaultBackupDirectory while the repository is open.  If there is a Magma repository at pathString, an environment error is signaled."	| dir |	dir := self defaultBackupDirectory.	[ self fullBackupTo: dir ] 		on: MagmaDeleteWarning		do: 			[ : warn | 			MagmaEnvironmentError signal: 'Did not expect backup-dir to already exist.  No action taken.' ].	^ 'A new backup is being created at ' , dir fullName! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 12/7/2015 13:31'!fullBackupTo: aFileDirectory 	"Backup the repository to aFileDirectory while the repository is open.  Files in the aFileDirectory will be overwritten."	self isFullBackupRunning ifTrue: [ MagmaUserError signal: 'Model backup is already running.' ].	aFileDirectory fullName = self directory fullName ifTrue: [ MagmaUserError signal: 'Must not back up to running server''s directory!!' ].	aFileDirectory exists ifTrue: [ MagmaEnvironmentError signal: aFileDirectory fullName , ' already exists??!!' ].	aFileDirectory assureExistence.	self requestCritical:		[ "start new commit log that begins with the very next transaction after this backup."		self archiveCommitLog; copyMostRecentCommitLogFileTo: aFileDirectory / MaRecoveryManager commitLogDirectoryName.		backupProcess := MaClientProcess doBlock:			[ | filenames filesNotToCopy | [ repository flushCritical:				[ "Flush now so we minimize the amount kept in RAM, and to ensure the backup is at the most current state."				repository flushCache.				filenames := self filenames.				filesNotToCopy := 					{MaRecoveryManager applyFilename. 					self class openIndicatorFilename. 					repository recoveryManager activeCommitLogFilename}.				backupProcess					 taskSize: filenames size - filesNotToCopy size ;					 unitsVerbPhrase: 'files copied'.				backupProcess advance.				filenames do:					[ : each | (filesNotToCopy includes: each) ifFalse:						[ backupProcess shouldStop ifFalse:							[ backupProcess description: 'Copying ' , each.							[repository directory								maCopyFileNamed: each								toDirectory: aFileDirectory] on: FileExistsException do: [ : exc | backupProcess description: 'Backup FAILED!!'.  MagmaSoftwareError signal: 'File should not possibly exist at this point.  Aborted.' ].							backupProcess advance ] ] ].				aFileDirectory fileNamed: 'about.txt' do: [ : stream | stream setToEnd; ascii; lf; maPrint: aFileDirectory localName; space; maPrint: DateAndTime now ] ].			backupProcess shouldStop not ifTrue:				[ (MaObjectFiler open: aFileDirectory)					 restoreMode: true ;					 close.				backupProcess advance ] ] ensure:				[ backupProcess stopped ifFalse: [ backupProcess description: 'Backup complete.' ] ] ].		backupProcess			 name: 'backing up to ' , aFileDirectory fullName ;			 start ]! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 3/7/2009 14:22'!fullBackupToServerPath: pathString 	"Backup the repository to the directory identified by pathString while the repository is open.  If there is a Magma repository at pathString, all files will be deleted ahead of time, otherwise none will."	| didDelete |	didDelete := false.	[ self fullBackupTo: (MagmaLocalLocation path: pathString) directory ] 		on: MagmaDeleteWarning		do: 			[ : warn | 			didDelete := true.			warn resume ].	^ didDelete 		ifTrue: [ 'Backup at ' , pathString , ' is being replaced with a new backup.' ]		ifFalse: [ 'A new backup is being created at ' , pathString ]! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 9/10/2010 13:51'!isFullBackupRunning	^ self requestCritical: 		[ backupProcess notNil and: [ backupProcess everStarted not or: [ backupProcess isRunning ] ] ]! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 8/2/2007 00:16'!logArchiveFrequency	"Answer the frequency which commit.log files are closed and a new one started.  Commit log files are used to apply to a backup to bring it up to date."	^ repository logArchiveFrequency! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 8/2/2007 00:16'!logArchiveFrequency: aDuration 	"Override the default frequency which commit.log files are closed and a new one started.  Commit log files are used to apply to a backup to bring it up to date.	Example:  myRepositoryController logArchiveFrequency: 15 minutes."	repository logArchiveFrequency: aDuration! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 3/2/2009 15:49'!replayCommitLogs	"Search my 'commits' subdirectory for the proper commit log file to begin replaying from.  Replay it and any subsequent commit log files as far forward possible."	repository rollforwardIfPossible! !!MagmaRepositoryController methodsFor: 'backup / restore' stamp: 'cmm 10/22/2008 15:29'!restoreMode	"Answer whether the receiver is operating in restoreMode.  Warm backups operate in restoreMode, taking commits broadcasted to them from the 'primary' and applying them."	^ repository restoreMode! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 6/6/2005 13:35'!beReadOnly	self requestCritical: [ preferences beReadOnly ]! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 6/6/2005 13:35'!beReadWrite	self requestCritical: [ preferences beReadWrite ]! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 6/23/2002 10:48'!connections	"Used for monitoring server status via some console gui."	self maMarked: 'dev'.! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 5/2/2004 20:40'!maximumNumberOfChallengers: anInteger 	self session 		commit: [ self definition maximumNumberOfChallengers: anInteger ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 11/18/2008 12:54'!branchCode	"The branchCode is a randomly-generated number used to prevent accidentally applying the wrong commit-logs to a repository.  When performing a forward recovery, each CommitLogRecord's #branchCode must match mine.  Every time a commitRestore is performed, this branchCode is updated to a new number."	^ repository branchCode! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 6/2/2008 22:08'!close	"requestCritical: in case an extractProcess managed to queue one last request in at the last second.."	self requestCritical: 		[ self class controllersGuard: 			[ OpenControllers 				remove: self				ifAbsent: 					[ "do nothing"					 ] ].		self primClose ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:52'!commitNumber	"Answer the number of commits ever applied to this repository.  This is useful for determining which commit.n.log files are no longer needed (all which are lower than this number are no longer needed)."	^ repository commitNumber! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 3/29/2010 21:20'!defaultBackupDirectory	"Answer the default backup directory, which is a sibling directory to mine, but named with an extension of my commitNumber."	| myDir parentDir newDirName |	myDir := self directory.	parentDir := myDir containingDirectory.	newDirName := myDir pathParts last , '.' , self commitNumber asString.	^ parentDir / newDirName! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 9/25/2009 11:31'!definition	"Answers a MagmaRepositoryDefinition"	^ session ifNotNil: [ session definition ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 5/11/2007 12:37'!directory	"Answer the directory in which my files reside."	"Note, this is the same FileDirectory that MaObjectFiler has.  It was necessary to duplicate this here to support the auto-reopen feature upon image restart."	^ localLocation directory! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'kph 4/27/2007 02:53'!filenames	^ localLocation fileNames! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'kph 4/27/2007 02:56'!localLocation	"Answer the localLocation where my files reside."	 	^ localLocation! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 8/30/2008 10:14'!magmaId	^ self definition ifNotNilDo: [ : definition | definition magmaId ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 5/11/2007 12:36'!pathName	^ localLocation pathName! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 5/7/2008 17:23'!serverStatistics	^ serverStatistics! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 4/3/2003 22:59'!sessionId	^session id! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/25/2008 15:05'!branchCode: anInteger 	"Private - Do not update the branchCode from outside!!"	repository branchCode: anInteger! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/26/2004 21:54'!codeBaseByteArray	^Array		with: repository classDefinitionsByteArray		with: (serverSerializer serializeGraph: self definition codeBase) trimmedByteArray! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/7/2015 13:38'!copyMostRecentCommitLogFileTo: commitLogOfBackup	commitLogOfBackup assureExistence.	(self commitLogDirectory entries detectMax: [ : each | each modificationTime ]) ifNotNil: [ : entry | entry copyTo: commitLogOfBackup ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 9/16/2008 22:21'!createRepositoryAt: aMagmaLocalLocation 	| anchor |	self initializeSession.	self session initializeDefinition.	self session definition addMinimumClassesForOdbmsUsing: self serverSerializer.	localLocation := aMagmaLocalLocation.	self		repository: (MaObjectRepository 				create: localLocation directory				controller: self) ;		connect ;		forceWrite: (anchor := MaRootAnchor new				definition: self definition ;				yourself).	repository filer		anchorOid: (self session oidFor: anchor) ;		classDefinitionsOid: (self session oidFor: self definition classDefinitions) ;		definitionOid: (self session oidFor: self definition).	self close! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 2/20/2005 16:31'!ensureOpen	self isOpen ifFalse: [ self open ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 3/5/2009 23:39'!executeSwapWith: aMagmaRemoteLocation commitNumber: commitNumber branchCode: branchCode 	"I am the primary.  aMagmaRemoteLocation wants to be the primary now."	| commitLogRecords currentCommitNumber |	self branchCode = branchCode ifFalse: [ MagmaDifferentBranch signal: 'Branch codes don''t match?!!' ].	currentCommitNumber := self commitNumber.	commitLogRecords := repository commitRecordsFrom: commitNumber.	commitLogRecords notEmpty and: 		[ commitLogRecords last commitNumber = currentCommitNumber ifFalse: 			[ MagmaEnvironmentError signal: 'Warm backup is too far behind at this time!!' ] ].	"We will just manually update the node rather than use MagmaNodeUpdate so its simpler and more explicit.  Using MagmaNodeUpdate *may* work, I'm not sure.."	self session commit: [ self node swapWithPrimary: aMagmaRemoteLocation ].	repository beginRestore.	"Now, capture that last commit!!"	commitLogRecords := commitLogRecords , (repository commitRecordsFrom: currentCommitNumber + 1).	^ commitLogRecords! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 2/10/2009 14:04'!forceWrite: anObject 	"This is somewhat of a hacking method to enable us to write objects needed	for the repository to operate (i.e., commit transactions) during initial creation."	| commitPackage answer |	commitPackage := MaCommitPackage new.	anObject maIsLargeCollection ifTrue: [ commitPackage addLargeCollectionChanges: anObject changes ].	session serializer 		serializeGraph: anObject		do: [ : eachObject | commitPackage addObject: eachObject ].	"Prime the serializer."	session begin.	commitPackage copy serializeObjectsUsing: session.	commitPackage serializeObjectsUsing: session.	answer := self forceWritePackage: commitPackage.	session 		refreshViewUsing: answer		includingLocal: false.	^ answer! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 2/10/2009 14:04'!forceWritePackage: aMaCommitPackage 	"This is somewhat of a hacking method to enable us to write objects needed	for the repository to operate (i.e., commit transactions) during initial creation."	^ 	[ repository 		submitAll: aMaCommitPackage		for: session id		beginAnother: false ] ensure: [ session decrementTransactionLevel ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 9/1/2003 19:40'!initializeSystemReadStrategy	repository initializeSystemReadStrategyUsing: self serverSerializer classIdManager! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/10/2005 10:59'!materializeClassDefinitions	"This is needed because, when opening the repository, the default classes do not include MagmaRepositoryDefinition, which is delivered as part of any session-connection.  When the system-session attempts to connect, it tries to read the repository-definition but can't because it can't get a proper read-strategy for it."	[ session loadClassDefinitionsFrom: repository classDefinitionsByteArray ]		on: Error		do:			[ : err | MagmaCorruptionError signal: err messageText ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 11/7/2008 14:32'!newSessionFor: aMaRepositoryConnectionRequest sessionId: aUuid 	^ self repository 		newSessionFor: aMaRepositoryConnectionRequest userId		sessionId: aUuid		numberOfChallengers: MagmaRepositoryDefinition defaultMaximumNumberOfChallengers		clientConnection: aMaRepositoryConnectionRequest clientConnection! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/22/2008 16:53'!newTransactionFor: sessionId 	preferences isReadOnly ifTrue: 		[ MagmaUserError signal: 'This repository is set to read-only, commits are prohibited.' ].	self restoreMode ifTrue: 		[ MagmaUserError signal: 'Transactions are prohibited because this repository is in restore mode.' ].	^ repository newTransactionFor: sessionId! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/24/2015 14:05'!open	"This is called when restarting controllers during image restart."	| tried |	tried := false.	localLocation isPotentiallyOpen ifTrue: [ MagmaPotentiallyOpenError signal: 'found ' , self class openIndicatorFilename , ' file, indicating this repository may currently be open.  If it is not, you may proceed.' ].	(FileDirectory on: self pathName) exists ifFalse: [ MagmaUserError signal: self pathName , ' not found.' ].	[ self privateOpen: localLocation ]		on: MagmaCorruptionError		do:			[ : err | 			tried				ifTrue: [ err pass ]				ifFalse:					[ MagmaRollbackRecoveryNeeded signal: 'Outage occurred while writing system-definitions!!  Will now attempt to repair.'.					repository primitiveRecover.					self close.					tried := true.					err retry ] ].	"Do NOT cascade the following messages.  rollbackIfNecessary may replace my repository with a new one."	repository rollbackIfNecessary.	repository rollforwardIfPossible! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 11/18/2009 14:05'!open: aMagmaLocalLocation 	localLocation := aMagmaLocalLocation.	self class controllersGuard: [ self open ].	self updatePrimaryLocation: aMagmaLocalLocation! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 1/2/2014 17:57'!postOpenInitialize	self		initializeSystemReadStrategy ;		materializeClassDefinitions ;		connect ;		refreshView "so more classes will be pulled from unusedDepths of the SystemReadStrategy".	repository initializeMagmaStatClassIds.	OpenControllers add: self! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 5/25/2010 14:10'!primClose	self requestCritical:		[ session ifNotNil:			[ session disconnect.			session linksDo:				[ : each | each localRequestServer shutdown ] ].		self serverStatistics release.		repository close.		self removeOpenIndicator ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 8/10/2010 21:48'!privateOpen: aMagmaLocalLocation 	self isOpen ifTrue: 		[ MagmaUserError signal: 'Repository ' , aMagmaLocalLocation asString , ' is already open.' ].	MagmaNotification signal: 'opening Magma repository ' , self pathName.	self		initializeSession ;		repository: 			(MaObjectRepository 				open: aMagmaLocalLocation directory				controller: self).	self restoreMode ifFalse: [ self ensurePotentiallyOpenIndicator ].	self postOpenInitialize! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/19/2008 14:02'!refreshView	self session refresh.	repository systemReadStrategy makeReadyForUseUsing: self session serializer classIdManager! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 5/25/2010 18:34'!removeOpenIndicator	self directory deleteFileNamed: self class openIndicatorFilename! !!MagmaRepositoryController methodsFor: 'private'!repository	^repository! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/31/2002 12:54'!repository: aMaObjectRepository	repository := aMaObjectRepository.	aMaObjectRepository repositoryController: self! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/27/2002 15:55'!requestCritical: aBlock	"Coordinate access to all server elements."	^requestInterruptGuard critical: aBlock! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 7/14/2008 16:21'!serverReadStrategy	"Make sure the indexes stays a proxy because the server will not necessarily have the full MagmaCollectionIndex hierarchy."	^ (MaReadStrategy minimumDepth: 1)		forVariableNamed: 'changes'			onAny: MagmaCollection			readToDepth: 99999 ;		forVariableNamed: 'indexes'			onAny: MagmaCollection			readToDepth: -1 ;		forVariableNamed: 'descriptions'			onAny: MagmaCollection			readToDepth: 99999 ;		"For MagmaIdRequest"		onAny: MagmaId			readToDepth: 99999 ;		yourself! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/21/2008 15:37'!serverSave: saveOption andExit: exitOption 	"Wait one second to give time for the response to be sent out so the client doesn't get a NetworkError."	[ (Delay forSeconds: 1) wait.	SmalltalkImage current 		snapshot: saveOption		andQuit: exitOption ] fork! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 11/7/2008 14:23'!serverSaveAndExit	"Wait one second to give time for the response to be sent out so the client doesn't get a NetworkError."		[ (Delay forSeconds: 1) wait.	SmalltalkImage current 		snapshot: true		andQuit: true ] fork! !!MagmaRepositoryController methodsFor: 'private'!serverSerializer	"The serverSerializer is used for processing client requests.  It is also	used during administration and possibly needed during initial creation of a	repository."	^serverSerializer! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/30/2008 16:53'!session	^ session! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/1/2010 16:09'!softBranch	"A softBranch is one in which only the branchCode changes, not the MagmaId.   A a soft-branch is automatically performed when the user opens locally for safety from hurting themself by otherwise accidently branching a Magma repository without detection, if they did the following steps:	- Bring primary off-line.	- Make a file-system copy of the primary.	- Start original primary back up, further commits are made.	- Open copied primary up locally, do some commits.	- Replace primary with copied primary!!  It would send further commits to secondary that never got those other local-commits, but such branch in this case is not detected!!Solution:	- Opening a repository locally forces a 'soft-branch'.  You will still be able to reattach the original warm-backup as long as its branchCode of its last commitRecord matches the commitNumber of that same record in the primary."	repository initializeBranchCode! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/4/2009 11:50'!updatePrimaryLocation: aMagmaLocalLocation 	"When a repository is opened locally, if it's location has never been set or was a different *local* location, then update it to the new aMagmaLocalLocation.  If it was formerly a hosted server, do not update since we could be here simply just for re-opening that repository.  So, to go from a remote repository to a local one, you have to manually update the node's primaryLocation."	| priorLoc |	priorLoc := self definition node primaryLocation.	(priorLoc isNil or: 		[ priorLoc isLocal and: [ priorLoc ~= aMagmaLocalLocation and: [ self restoreMode not ] ] ]) ifTrue: 		[ self session commit: [ self definition node primaryLocation: aMagmaLocalLocation ] ]! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 7/5/2005 20:16'!cacheFlushFrequency	^ preferences cacheFlushFrequency! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 9/12/2007 21:52'!cacheFlushFrequency: numberOfSeconds 	^ self requestCritical: [ preferences cacheFlushFrequency: numberOfSeconds ]! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 10/22/2006 21:38'!filePoolSize: anInteger 	"Set the maximum number of simultaneously-open files that Magma will have."	repository filePoolSize: anInteger! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 6/6/2005 13:38'!isReadOnly	^ preferences isReadOnly! !!MagmaRepositoryController methodsFor: 'high-availability' stamp: 'cmm 10/23/2008 10:50'!catch: thisLocation upTo: aMagmaRemoteLocation 	"I am open on a full-backup of the repository at aMagmaRemoteLocation.  Download commit-log records until I am caught up and then I will begin receiving real-time updates from the server at aMagmaRemoteLocation."	repository 		catch: thisLocation		upTo: aMagmaRemoteLocation! !!MagmaRepositoryController methodsFor: 'high-availability' stamp: 'cmm 7/9/2007 09:27'!commitRestore	"Bring the repository out of restore mode and update my branchCode.  No more commit logs with the old branchCode may be applied."	repository commitRestore! !!MagmaRepositoryController methodsFor: 'high-availability' stamp: 'cmm 11/18/2008 12:44'!ensureInRestoreMode	repository restoreMode ifFalse: [ repository beginRestore ].	^ nil! !!MagmaRepositoryController methodsFor: 'high-availability' stamp: 'cmm 10/30/2008 16:33'!node	^ self definition node! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 1/16/2005 21:54'!connect	session connect: (MagmaUser id: self class systemSessionUserId).	repository initializeSpecialOidsList! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 12/17/2008 17:14'!initialize	super initialize.	requestInterruptGuard := Mutex new.	preferences := MagmaServerPreferences new.	self serverStatistics: MagmaServerStatistics new! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 3/27/2002 22:00'!initializeServerSerializer	"Why is this separate, 'serverSerializer' needed?  Because the session serializer requires a different traversalStrategy.  The serverSerializer needs to be able to fully serialize, to the ends of the graphs, the 'response' objects of various requests."	serverSerializer := self session serializer copyWithNewBuffer initializeTraversalStrategy! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 2/25/2013 20:42'!initializeSession	session := (MagmaSession repositoryController: self)		 allowWriteBarrier: false ;		 readStrategy: self serverReadStrategy ;		 yourself.	self initializeServerSerializer! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 9/29/2008 23:09'!serverStatistics: aMagmaServerStatistics 	serverStatistics := aMagmaServerStatistics! !!MagmaRepositoryController methodsFor: 'testing' stamp: 'cmm 6/24/2015 14:06'!ensurePotentiallyOpenIndicator	localLocation isPotentiallyOpen ifFalse:		[ self directory			maFileNamed: self class openIndicatorFilename			do:				[ : stream | "nothing, just create it" ] ]! !!MagmaRepositoryController methodsFor: 'testing' stamp: 'cmm 10/26/2006 14:55'!isClassIdForLargeCollection: anInteger 	session serializer classIdManager largeCollectionIdsDo: [ : each | each = anInteger ifTrue: [ ^ true ] ].	^ false! !!MagmaRepositoryController methodsFor: 'testing' stamp: 'cmm 6/2/2008 13:31'!isOpen	^ repository notNil and: [ repository isOpen ]! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 3/24/2013 15:17'!numberOfConnectedClientsself maMarked: 'delete'.	^repository sessions size - 1! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 12/22/2008 13:16'!oidCount	"The number of oids allocated by this repository.  The total number of objects ever committed, even if some have since been garbage-collected."	^ repository oidCount! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 2/22/2011 13:26'!spaceTally	"Warning!!  Use of this message could cause a pause in server operations."	SpaceTally new printSpaceAnalysis! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 4/21/2003 16:02'!version	^repository version! !!MagmaRepositoryController methodsFor: 'client/server required methods' stamp: 'cmm 1/7/2014 17:09'!processRequest: aMagmaRepositoryRequest 	aMagmaRepositoryRequest repositoryController: self.	^ [ self requestCritical:		[ | result |		result := aMagmaRepositoryRequest process.		repository freeSomeSpaceIfNecessary: aMagmaRepositoryRequest sessionId.		result ] ]		on: Error		do:			[ : anError | self maMarked: 'dev'.			"This error routine must be improved.  It needs to log and notify for unhandled errors!!"			(MagmaPreferences debug and:				[ ({MagmaCommitConflictError. 				MagmaSessionLost. 				MagmaWrongCommitNumber. 				MagmaWrongServerError. 				MagmaAlreadyInTransaction} includes: anError maOriginalClass) not and:					[ anError isMaUserError not and: [ Smalltalk isHeadless not ] ] ]) ifTrue: [ anError pass ].			anError ]! !!MagmaRepositoryController methodsFor: 'client/server required methods' stamp: 'cmm 9/19/2004 22:08'!value: aMagmaRepositoryRequest	^ self processRequest: aMagmaRepositoryRequest! !!MagmaRepositoryController methodsFor: '*magma-tester' stamp: 'cmm 9/6/2007 21:44'!getNextSequenceNumber	^ self session commit: 		[ (self session cacheAt: #testSequenceNumberGenerator)			increment ;			value ]! !!MagmaRepositoryController methodsFor: '*magma-tester' stamp: 'cmm 9/9/2007 21:30'!initializeSequenceNumberGenerator	"Have my session cache the MagmaCounter that will be accessed many hundreds of times (in a real-world app, that is) so performance is maximized."	| sess counter |	sess := self session.	counter := MagmaCounter new.	sess		cacheAt: #testSequenceNumberGenerator			put: counter ;		commit: 			[ sess root 				at: #testSequenceNumberGenerator				put: counter ].	^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaRepositoryController class	instanceVariableNames: ''!!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 9/17/2011 22:35'!commitRestore: pathOrMagmaLocalLocation 	| rep |	rep := self open: pathOrMagmaLocalLocation asMagmaLocalLocation.	[ rep commitRestore ] ensure: [ rep close ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 1/18/2007 21:29'!compress: sourceLocation to: targetLocation	"sourceLocation and targetLocation may be either a String (relative or fully-qualified path) or a MagmaLocalLocation."	(MagmaCompressor source: sourceLocation) compressTo: targetLocation! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 3/10/2009 20:12'!create: pathStringOrMagmaLocalLocation 	"Creates a repository with an initial root of nil.  I #assureExistence of the location."	| location |	location := pathStringOrMagmaLocalLocation asMagmaLocalLocation.	self validateCanCreateIn: location.	self new createRepositoryAt: location.	(self openedOn: location) in: 		[ : rp | 				[ rp fullBackupTo: location seedDirectory.		[ rp isFullBackupRunning ] whileTrue: [ (Delay forSeconds: 1) wait ] ] ensure: [ rp close ] ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 1/18/2007 21:21'!create: pathStringOrMagmaLocalLocation root: anObject	| session location |	location := pathStringOrMagmaLocalLocation asMagmaLocalLocation.	self create: location.	session := MagmaSession openLocal: location.	session		connect: (MagmaUser id: 'system create:root:') ;		commit: [ session root: anObject ] ;		disconnect ;		closeRepository! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 7/1/2007 12:32'!delete: pathStringOrMagmaLocalLocation 	"Delete the just the files in fullyQualifiedPathString that are part of the Magma repository that resides there."	pathStringOrMagmaLocalLocation asMagmaLocalLocation delete! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:27'!controllerOpenedOn: aMagmaLocalLocation 	"Answer the RepositoryController already opened on aMagmaLocalLocation.  If no existing controller is already open, answer nil."	^ self controllersGuard: 		[ OpenControllers 			maDetect: [ : each | each localLocation = aMagmaLocalLocation ]			ifFound: [ : foundController | foundController ensureOpen ]			ifNone: [ nil ] ]! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'cmm 6/25/2008 10:57'!openControllers	"The collection of repository's that are opened by this image, not necessarily serving, however."	^ OpenControllers! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'cmm 7/15/2008 14:25'!openedOn: aMagmaLocalLocation 	"Answer the RepositoryController already opened on aMagmaLocalLocation.  If no existing controller is already open, open a new one and answer it."	| existingController |	^ self controllersGuard: 		[ (existingController := self controllerOpenedOn: aMagmaLocalLocation) 			ifNil: [ self open: aMagmaLocalLocation ]			ifNotNil: [ existingController ] ]! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 8/8/2007 23:58'!controllersGuard: aBlock 	^ (ControllersGuard ifNil: [ self initializeControllersGuard ]) critical: aBlock! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 3/5/2009 10:05'!open: aMagmaLocalLocation	^ self new open: aMagmaLocalLocation asMagmaLocalLocation! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 5/25/2010 18:35'!openIndicatorFilename	^ '_open'! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 5/1/2003 00:24'!systemSessionUserId	^'__system'! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 3/12/2009 22:22'!initialize	OpenControllers ifNotNil: [ OpenControllers do: [ : each | each close ] ].	OpenControllers := Set new.	self initializeControllersGuard.	Smalltalk		addToStartUpList: self ;		addToShutDownList: self.	Smalltalk 		addToStartUpList: MaServerSocket		after: self! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 9/23/2008 14:26'!initializeControllersGuard	^ ControllersGuard := Mutex new! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 12/27/2004 23:16'!shutDown: aboutToQuit	super shutDown: aboutToQuit.	MagmaSession shutDown: aboutToQuit.	OpenControllers		do:			[ :each | 			[ MagmaNotification signal: 'closing Magma repository ', each pathName asString, '.  Will reopen on next startup.' ]				on: MagmaNotification				do: [ : noti | Transcript cr; show: noti messageText. noti pass ].			each primClose ]! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 9/2/2010 19:36'!startUp: amResuming 	OpenControllers copy do: 		[ : each | 				[ [ each ensureOpen ] 			on: MagmaNotification			do: 				[ : noti | 				Transcript					cr ;					show: noti messageText.				noti resume ] ] 			on: MagmaEnvironmentError			do: 				[ : error | 				"not present anymore, remove from OpenControllers and resignal."				each close.				error pass ] ].	"Now that we're open, ensure any server-sockets that may need to restart can be."	MaServerSocket startUp: amResuming! !!MagmaRepositoryController class methodsFor: 'validation' stamp: 'cmm 7/3/2012 20:16'!validateCanCreateIn: aMagmaLocalLocation	"Magma databases do not share the same directory.  Not only would it be hard to identify which files go with which repository, some of the filenames are based on oids, which would not always be unique across repositories."	(aMagmaLocalLocation isMagmaRepository)		ifTrue:			[ MagmaUserError signal: aMagmaLocalLocation pathName, ' is already a Magma repository.' ]! !MaRequestServerConsole subclass: #MagmaServerConsole	instanceVariableNames: 'server controller'	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-API'!!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 10/14/2010 11:33'!beWarmBackup	self beWarmBackupFor: self node primaryLocation! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 12/21/2012 15:00'!beWarmBackupFor: primaryLocation 	"If I am currently started on backup files created from my primary having had sent #fullBackupTo:, which means I should be in restoreMode, then establish a session to primaryLocation and bring my copy of the repository up to date.  Once up to date, the primary server will then broadcast further updates to me in real-time, and instruct clients that I am a warm backup for that primary.  If they detect the primary server is down they will start sending requests to me, at which point I will verify the server availability myself and will, if the connection is refused, #takeOverAsPrimary."	self isRunning ifFalse: [ MagmaUserError signal: 'Must be running to be a warm backup.' ].	primaryLocation = self thisLocation ifTrue: [ MagmaUserError signal: 'Please don''t try to be a warm-backup of myself!!' ].	[ | primarySession | [ primarySession := primaryLocation newAdminSession.	primarySession connectAs: '_beWarmBackupFor'.	primarySession remoteMagmaId = controller magmaId ifFalse: [ MagmaUserError signal: 'Cannot be a warm backup of ' , primaryLocation printString , ' because I am a totally different repository!!' ].	primarySession inRestoreMode ifTrue: [ MagmaUserError signal: 'Don''t want to be a warm backup of another warm backup.' ].	primarySession remoteCommitNumber < controller commitNumber ifTrue: [ MagmaUserError signal: 'Cannot be a warm backup of ' , primaryLocation printString , ' because it is behind this repository!!' ].	controller ensureInRestoreMode.	controller		catch: self thisLocation		upTo: primaryLocation.	primarySession node addLocation: self thisLocation ] ensure:		[ primarySession ifNotNil: [ primarySession disconnect ] ] ]		on: NetworkError		do:			[ : err | "Don't do anything.  This server couldn't connect to the primary, but it will sit and wait patiently for the primary to come up.  When it does, it will seek out this server and link up.  If, before then, a client requests this to be the primary, I will become so."			err ]! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 3/16/2009 12:47'!isPrimary	^ self node primaryLocation 		ifNil: [ false ]		ifNotNilDo: [ : loc | loc = self thisLocation ]! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 12/4/2015 16:53'!isSecondary	^ self restoreMode "and: 		[ self node notNil and: [ self node secondaryLocations includes: self thisLocation ] ]"! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 3/4/2009 15:45'!removeSecondaryLocation: aMagmaRemoteLocation 	MagmaNodeUpdate new		remove: aMagmaRemoteLocation ;		processUsing: self! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 10/27/2008 09:52'!restoreMode	"Answer whether I am running in restoreMode.  restoreMode only allows commits from a primary to be applied in sequence."	^ controller restoreMode! !!MagmaServerConsole methodsFor: 'high-availability' stamp: 'cmm 7/24/2018 15:40'!thisLocation	"Answer the MagmaRemoteLocation in the node that represents this running server."	^ MagmaRemoteLocation 		host: NetNameResolver maLocalHostName		port: self port! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 9/5/2009 11:25'!compressThreshold	"Compressing large responses can make a significant performance improvement on slow networks.  Compression makes things worse with small responses or on really fast networks.  Answer the number of bytes a response needs for compression to occur."	^ server ifNotNil: [ server compressThreshold ]! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 7/15/2008 22:14'!compressThreshold: anInteger	"Compressing large responses can make a significant performance improvement on slow networks.  Compression makes things worse with small responses or on really fast networks.  Answer the number of bytes a response needs for compression to occur."	server compressThreshold: anInteger! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 12/18/2002 21:52'!controller	^controller! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 9/25/2009 11:31'!definition	^ controller ifNotNil: [ controller definition ]! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 7/24/2018 15:40'!hostname	^ NetNameResolver maLocalHostName ! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 10/30/2008 13:55'!node	^ self definition ifNotNilDo: [ : def | def node ]! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 10/14/2008 14:31'!port	^ server ifNotNil: [ server port ]! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 3/3/2005 10:10'!server	^ server! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 11/15/2008 16:03'!serverSession	^ controller session ! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 8/18/2009 14:30'!useCompression: aBoolean 	self compressThreshold: 		(aBoolean 			ifTrue: [ MaClientSocket mtuSize ]			ifFalse: [ MaSerializedGraphBuffer unreasonablePhysicalSize * 2 ])! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 5/15/2011 20:33'!ensureCorrectNodeConfiguration	"Ensure I am performing the duty my MagmaNode says I should be performing, either as the primary or one of the warmBackups.  I am read-only on the node, I do not modify it.  The intended usage of this method is, you update the node to what you want it to be, then I 'make it so'."	self isPrimary 		ifTrue: 			[ "To be extra conservative, configure all other nodes to restoreMode (before coming out of restoreMode myself)."			self sessionsForOtherLocationsDo: 				[ : each | 				"Warning:  this is a sync request, no secondary should cause this method to be called on the primary.  Perhaps it should be async?"				[each ensureInRestoreMode] on: NetworkError do: [ : err | "oh well" ] ].			self restoreMode ifTrue: 				[ "I need to become the primary, make it so."				controller commitRestore ].	"Now the others can become warm backups."			self sessionsForOtherLocationsDo: [ : each | [each ensureCorrectNodeConfiguration] on: NetworkError do: [ : err | ] ] ]		ifFalse: 			[ self node primaryLocation ifNotNilDo: [ : pl | pl isLocal ifFalse: [ self beWarmBackupFor: pl ] ] ]! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 1/1/2013 22:35'!findCorrectNodeConfiguration	"I'm just starting up, interrogate the other servers in my node to see what the current state of the party is:  who is the primary now?"	| nodes |	nodes := Array streamContents:		[ : stream | self sessionsForOtherLocationsDo:			[ : each | [ each ensureConnected.			stream nextPut: each node ]				on: NetworkError				do:					[ : err | "That server not up or not reachable."					err ] ] ].	"Do all the other nodes agree about who is primary?"	(nodes size <= 1 or:		[ (nodes collect:			[ : each | each primaryLocation ]) asSet size = 1 ]) ifTrue:		[ | primaryLoc |		primaryLoc := nodes isEmpty ifFalse: [ nodes anyOne primaryLocation ].		"Is the agreed-upon primary thisLocation?"		(primaryLoc notNil and: [ primaryLoc = self thisLocation ])			ifTrue: [ self ensureCorrectNodeConfiguration ]			ifFalse:				[ primaryLoc ifNotNil: [ self beWarmBackupFor: primaryLoc ] ] ]! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 12/21/2012 13:01'!postIgnitionSequence	self findCorrectNodeConfiguration! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 12/21/2012 15:56'!preIgnitionSequence: portInteger 	self updatePrimaryLocation: portInteger.	self statistics transition! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 11/13/2008 20:57'!sessionsForOtherLocationsDo: oneArgBlock 	"For the other locations in the Node other than thisLocation, value oneArgBlock."	self node locationsDo: 		[ : each | 		each = self thisLocation ifFalse: [ oneArgBlock value: (self node sessionFor: each) ] ]! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 8/7/2018 20:33'!updatePrimaryLocation: portInteger 	"When I'm started up, update the primaryLocation to this location, if it has changed."	self restoreMode ifFalse:		[ | primaryLoc thisLoc |		"We can't simply use #thisLocation because we aren't running yet (so no port)!!"		"Not sure why some Linux installations report 0.0.0.0 as their maLocalHostName, but if it happens, use a back up method."		thisLoc := MagmaRemoteLocation			host: NetNameResolver maLocalHostName			port: portInteger.		primaryLoc := self node primaryLocation.		(primaryLoc isNil or:			[ primaryLoc isLocal or:				[ primaryLoc isLocalHost not or: [ primaryLoc ~= thisLoc ] ] ]) ifTrue: [ controller session commit: [ self node primaryLocation: thisLoc ] ] ]! !!MagmaServerConsole methodsFor: 'private' stamp: 'cmm 11/13/2013 20:40'!value: aMagmaRepositoryRequest 	"Make the console available too for network-serving repositories."	^ 	[ aMagmaRepositoryRequest		console: self ;		nodeCheck.	controller value: aMagmaRepositoryRequest ] 		on: Error		do: 			[ : anError | 			self maMarked: 'dev'.	"This error routine must be improved.  It needs to log and notify for unhandled errors!!"			(MagmaPreferences debug and: 				[ ({ 					MagmaCommitConflictError.					MagmaSessionLost.					MagmaWrongServerError.					MagmaWrongCommitNumber				 } includes: anError maOriginalClass) not and: 					[ anError isMaUserError not and: [ Smalltalk isHeadless not ] ] ]) ifTrue: [ self halt: anError messageText ].			anError ]! !!MagmaServerConsole methodsFor: 'initialize-release' stamp: 'cmm 9/29/2008 16:11'!initializeStatistics	statistics := MagmaServerStatistics new! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 7/16/2008 10:20'!isRunning	^ server notNil and: [ server isRunning ]! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 9/29/2008 23:12'!open: pathOrMagmaLocalLocation 	"As indicated, pathOrMagmaLocalLocation may be either the String path (relative or fully-qualified) or a MagmaLocalLocation."	controller 		ifNil: 			[ controller := (MagmaRepositoryController open: pathOrMagmaLocalLocation asMagmaLocalLocation)				serverStatistics: statistics ;				yourself ]		ifNotNil: 			[ "Reopen existing controller rather than replacing it with a new construction so prior preferences and statistics are preserved."			controller open: pathOrMagmaLocalLocation asMagmaLocalLocation ]! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 1/1/2009 17:22'!processOn: portInteger 	"Start the Magma server listening on port portInteger."	(controller isNil or: [ controller isOpen not ]) ifTrue: 		[ MagmaUserError signal: 'The repository must be opened before the server can be started.' ].	server := (MaNetworkRequestServer protocol: MagmaSession protocol) console: self.	server 		processOn: portInteger		using: self! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 12/4/2009 14:45'!shutdown	controller ifNotNil: 		[ controller requestCritical: 			[ self isSecondary ifTrue: 				[ self node primarySession ifNotNilDo: 					[ : sess | 					[ sess removeWarmBackup: self thisLocation ] 						on: NetworkError						do: 							[ : err | 							"don't worry about it"							 ] ] ].			server ifNotNil: [ server shutdown ].			self node ifNotNilDo: [ : node | node sessions do: [ : each | each disconnect ] ].			self statistics ifNotNilDo: [ : stat | stat release ] ] ]! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 12/17/2008 17:35'!noteAboutToStart	super noteAboutToStart.	self preIgnitionSequence: self port! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 12/17/2008 17:35'!noteJustStarted	super noteJustStarted.	self postIgnitionSequence ! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/27/2014 17:27'!noteResponseSerializationError: anException lifecycle: aMaServerRequestLifecycle 	(anException isKindOf: OutOfMemory) ifTrue: [ MaObjectRepository freeSomeSpace ].	^ super noteResponseSerializationError: anException lifecycle: aMaServerRequestLifecycle! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 9/29/2008 16:17'!noteServerShutdown	super noteServerShutdown.	controller close.	self note: controller printString , ' closed.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MagmaServerConsole class	instanceVariableNames: ''!!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 7/30/2015 11:24'!configdbservice	"One time setup for a particular DB as a daemontools service.  If this is the first Magma service to run on this server, then configsys should be run first."	^ '#!!/bin/bashecho ensure group magma access to model/commits directorymkdir -p model/commitssudo chgrp magma model/commitssudo setuidgid magma chmod 770 model/commitsAPPNAME="`basename $PWD`"echo creating log/main directorymkdir -p log/mainchmod o-rwx log/mainsudo chgrp magma log/mainecho installing daemon, it will startsudo ln -s $PWD /etc/service/$APPNAME' ->		[]! !!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 7/30/2015 14:52'!configsys	"Part of initial set up of a new server to handle Magma."	^ super configsys key ,	'# magma servers run under user magma which only has access to its own files.echo creating magma usersudo adduser --disabled-login --gecos "" magma# but primary user (ubuntu) must have access to magma filesecho granting the primary user access to magma filessudo usermod -aG magma `whoami`echo ensure no public access to anything in worksudo chmod o-rwx ~/work ~/work/magmasudo chgrp magma ~/work ~/work/magmaecho installing daemontools...sudo apt-get -qqy install daemontools daemontools-runsudo mkdir -p /etc/servicesudo ln -s /etc/service /service'		-> [ ]! !!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 7/28/2015 17:07'!detach	^ 'sudo setuidgid magma spur -vm display=none server-spur.image detach.st'		-> [Smalltalk runAndQuit: ['model' asMagmaLocalLocation detachFromNode]]! !!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 8/16/2016 21:49'!run	"deamontools run script.  put this in /mnt/work/magma/dbdir"	^ '#!!/bin/bashexec 2>&1# ensure _open file not present, otherwise DB will not open# -- this bypasses Magma internal safety check.# -- Should be fine, as long as starting and stopping# -- is done ONLY through daemontools (e.g., svc -u and svc -d).sudo setuidgid magma rm -f ./model/' , MagmaRepositoryController openIndicatorFilename ,'echo ensure model/commits dir owned by magma:magmasetuidgid magma mkdir -p model/commitschgrp magma model/commits# permission for root to run the HT version of the vm (thanks Levente Uzonyi)ulimit -r 2exec setuidgid magma spur -vm display=none server-spur.image run.st `cat port`' ->		[ Smalltalk run:			[ : portString |			Smalltalk mitigateIfHeadless.			(MagmaServerConsole new				 open: 'model' ;				 processOn: portString asInteger ;				 yourself) explore ] ]! !!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 8/3/2015 13:07'!status	"Report the pid, svstat, commitNumber and last access of this repository."	^ '#!!/bin/bashAPPNAME=`basename $PWD`echo Status of $APPNAMEecho ---------------ps -ef | grep $APPNAMEsudo svstat /service/$APPNAMEsudo setuidgid magma spur -vm display=none server-spur.image status.st' ->		[ Smalltalk runAndQuit:			[ : host : portString | (MagmaLocalLocation				host: host				port: portString asInteger) printStatusOn: FileStream stdout ] ]! !!MagmaServerConsole class methodsFor: 'linux-scripts' stamp: 'cmm 7/30/2015 23:03'!view	"View the contents of Squeak's internal RFB server."	^ 'xtightvncviewer ::"$[`cat port`+5900]"'		-> [ ]! !!MagmaServerConsole class methodsFor: 'private' stamp: 'cmm 7/2/2015 16:10'!magmaDir	^ '/mnt/work/magma'! !!MagmaServerConsole class methodsFor: 'private' stamp: 'cmm 7/31/2015 14:08'!retrieveCommitLogFiles	"Script which (employs Banyan to?) copy files from one (remote? ssh?) directory to another.  A roll-forward script could then be used to simply #open: the Repository (which will invoke an automatic roll-foward) and then immediately #close (without ever processing on a port, so no attempt to hook up an HA connection)."! !MagmaRepositoryController initialize!