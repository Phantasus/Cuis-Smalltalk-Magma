MaRecoveryRecord subclass: #MaApplyRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaApplyRecord commentStamp: 'cmm 7/15/2009 15:38' prior: 0!I am an abstract class for the types of records that, on recovery, require rollback of some particular file.  My fileId identifies which file it is.	... see superclass ...	5 - groupId (3 bytes), a number identifying a group of writes	... subclasses may add more fields ...!!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 7/15/2009 15:37'!bufferPositionOfGroupId	"this fields is 3-bytes."	^ 5! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 14:59'!groupId	^ byteArray maUnsigned24At: self bufferPositionOfGroupId+1! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 5/27/2007 20:14'!groupId: anInteger 	byteArray 		maUint: 24		at: self bufferPositionOfGroupId		put: anInteger! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 7/15/2009 15:39'!headerSize	"super headerSize + size of groupId field"	^ 8! !!MaApplyRecord methodsFor: 'printing' stamp: 'cmm 5/27/2007 20:32'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(groupId)		on: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaApplyRecord class	instanceVariableNames: ''!!MaApplyRecord class methodsFor: 'as yet unclassified' stamp: 'cmm 6/3/2005 17:16'!filePositionsFileId	^ 2! !!MaApplyRecord class methodsFor: 'as yet unclassified' stamp: 'cmm 6/3/2005 17:16'!objectsFileId	^ 1! !MaApplyRecord subclass: #MaApplyToFileRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaApplyToFileRecord commentStamp: 'cmm 7/15/2009 15:38' prior: 0!I am an abstract class for the types of records that, on recovery, require rollback of some particular file.  My fileId identifies which file it is.	... see superclass ...	8 - file-id (8-bytes), identifies which file this record describes	... subclasses may add more fields ...!!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 7/15/2009 15:38'!bufferPositionOfFileId	"This field is 8-bytes to make it easy for Magma.  6-bytes for the oid, 2-bytes for the index #."	^ 8! !!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 8/10/2007 00:23'!collectionOid	"for Magma, the fileId is stored in two parts, the high-order 6 bytes represent the oid of the collection.  The low-order 2 bytes represent the index # for that collection or 0 if it is the memberIndex.  This method answers the oid."	^ self fileId bitShift: -16! !!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:00'!fileId	^ byteArray maUnsigned64At: self bufferPositionOfFileId+1! !!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 5/27/2007 20:23'!fileId: anInteger	byteArray		maUint: 64		at: self bufferPositionOfFileId 		put: anInteger! !!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 7/15/2009 15:39'!headerSize	"super headerSize + size of fileId field"	^ 16! !!MaApplyToFileRecord methodsFor: 'accessing' stamp: 'cmm 8/14/2007 22:31'!unapplySelf: aStandardFileStream 	self subclassResponsibility! !!MaApplyToFileRecord methodsFor: 'testing' stamp: 'cmm 5/27/2007 20:54'!isApplyToFile	^ true! !!MaApplyToFileRecord methodsFor: 'testing' stamp: 'cmm 3/7/2011 18:27'!isContentRelated	"Answer whether this type of application changes the contents of a file.  MaNewFileRecord answers false, because it only creates a file, does not affect its content."	^ true! !!MaApplyToFileRecord methodsFor: 'testing' stamp: 'cmm 8/10/2007 00:23'!isForFilePositionsFile	^ self fileId = self class filePositionsFileId! !!MaApplyToFileRecord methodsFor: 'testing' stamp: 'cmm 8/10/2007 00:23'!isForObjectsFile	^ self fileId = self class objectsFileId! !!MaApplyToFileRecord methodsFor: 'printing' stamp: 'cmm 5/27/2007 20:32'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(fileId)		on: aStream! !MaApplyToFileRecord subclass: #MaBeforeImageRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaBeforeImageRecord commentStamp: 'cmm 7/15/2009 15:39' prior: 0!This type of RecoveryRecord is used to restore any bytes in any file to their state prior to the beginning of the interrupted commit.My #fileId identifies the file that was updated.My #location provides information necessary to know *where* in the file I came from.	... see superclass ...	16 - file-position	22 - the record	... see superclass ...I should not be created for updates to new files or for writes beyond the end of the file.!!MaBeforeImageRecord methodsFor: 'debugging' stamp: 'cmm 6/2/2005 13:05'!asMaObjectBuffer	self fileId = 1 ifFalse: [ self error: 'not a before-image of a MaObjectBuffer.' ].	^ (MaObjectBuffer		byteArray: (ByteArray new: MaObjectBuffer oidSize/8), self record		startPos: 0) asSentientBuffer! !!MaBeforeImageRecord methodsFor: 'initializing' stamp: 'cmm 6/3/2005 16:18'!bodySize	^ 1000  "variable length"! !!MaBeforeImageRecord methodsFor: 'initializing' stamp: 'cmm 6/1/2005 13:18'!location: anInteger	byteArray		maUint: 48		at: self bufferPositionOfLocation		put: anInteger! !!MaBeforeImageRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:39'!bufferPositionOfLocation	"this field is 6 bytes"	^ 16! !!MaBeforeImageRecord methodsFor: 'private' stamp: 'cmm 7/15/2009 15:39'!headerSize	"super headerSize + size of location field."	^ 22! !!MaBeforeImageRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 15:53'!isFixed	^ false! !!MaBeforeImageRecord methodsFor: 'accessing' stamp: 'cmm 9/8/2015 15:00'!location	^ byteArray maUnsigned48At: self bufferPositionOfLocation + 1! !!MaBeforeImageRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:09'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(location recordSize)		on: aStream! !!MaBeforeImageRecord methodsFor: 'recovery' stamp: 'cmm 4/10/2007 22:36'!unapplySelf: aMaTransactionalFileStream 	aMaTransactionalFileStream		maWrite: self recordSize			bytesFromPosition: 1			of: self record			atFilePosition: self location ;		maCommit! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaBeforeImageRecord class	instanceVariableNames: ''!!MaBeforeImageRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:38'!assignedRecordType	^ 2! !MaApplyRecord subclass: #MaBeginApplyRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaBeginApplyRecord commentStamp: 'cmm 6/3/2005 15:15' prior: 0!I am the first record of a group of RecoveryRecords for the same transactionId.  If a disaster happens in the middle of a commit and, during recovery, a valid BeginApply record is found in the apply file *without* a valid EndApply record, then we know the commit did not finish and all of the records must be unapplied.!!MaBeginApplyRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isBeginApply	^ true! !!MaBeginApplyRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(isBeginApply)		on: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaBeginApplyRecord class	instanceVariableNames: ''!!MaBeginApplyRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 1! !MaApplyRecord subclass: #MaEndApplyRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaEndApplyRecord commentStamp: 'cmm 3/25/2007 12:36' prior: 0!I am the last record of a group of RecoveryRecords for the same transactionId.  If a disaster happens then, during recovery, I am looked for in the applyFile with the same transactionId as my BeginApply counterpart.  If I'm found, then no were no commits happening at the time of the failure and, thus, no backward recovery is necessary.!!MaEndApplyRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isEndApply	^ true! !!MaEndApplyRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(isEndApply)		on: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaEndApplyRecord class	instanceVariableNames: ''!!MaEndApplyRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 5! !MaApplyToFileRecord subclass: #MaFileGrowthRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaFileGrowthRecord commentStamp: 'cmm 7/15/2009 15:41' prior: 0!I am used to track files that grow in size while applying a commit.  I record the #originalSize such that, during recovery, the file can be truncated: back to its original size.I should not be created for new files.	... see superclass ...	16 - originalSize (6 bytes)	... see superclass ...!!MaFileGrowthRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 16:00'!bodySize  "in bytes"	^ self sizeOfOriginalSizeField / 8! !!MaFileGrowthRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 15:59'!sizeOfOriginalSizeField	^ 48 "bits"! !!MaFileGrowthRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:09'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(originalSize)		on: aStream! !!MaFileGrowthRecord methodsFor: 'access' stamp: 'cmm 9/8/2015 15:09'!originalSize	^ byteArray maUnsigned48At: self headerSize + 1! !!MaFileGrowthRecord methodsFor: 'access' stamp: 'cmm 6/3/2005 16:01'!originalSize: anInteger	^ byteArray		maUint: self sizeOfOriginalSizeField 		at: self headerSize		put: anInteger! !!MaFileGrowthRecord methodsFor: 'recovery' stamp: 'cmm 4/28/2007 14:30'!unapplySelf: aMaTransactionalFileStream 	aMaTransactionalFileStream truncate: self originalSize! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaFileGrowthRecord class	instanceVariableNames: ''!!MaFileGrowthRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 3! !MaApplyToFileRecord subclass: #MaNewFileRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaNewFileRecord commentStamp: 'cmm 7/15/2009 15:41' prior: 0!Sometimes new files are created during a commit.  If a disaster happens before that commit finishes then, upon recovery, those files should be deleted.I record the #filename of the file that should be deleted.	... see superclass ...	16 - filename (variable length)	... see superclass ...!!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 16:18'!bodySize	^ 300  "variable length"! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!filename	^ (byteArray		copyFrom: self headerSize+1		to: self checkSumPosition-1) asString! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 7/4/2005 22:54'!filename: aString	self record: aString! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 15:53'!isFixed	^ false! !!MaNewFileRecord methodsFor: 'testing' stamp: 'cmm 3/7/2011 18:27'!isContentRelated	"Answer whether this type of application changes the contents of a file.  MaNewFileRecord answers false, because it only creates a file, does not affect its content."	^ false! !!MaNewFileRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(filename)		on: aStream! !!MaNewFileRecord methodsFor: 'recovery' stamp: 'cmm 6/4/2007 08:51'!unapplySelf: anUndefinedObject 	(MaAtomicFileStream fileNamed: self filename) deletePhysicalFiles! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaNewFileRecord class	instanceVariableNames: ''!!MaNewFileRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 4! !MaObject subclass: #MaRecoveryManager	instanceVariableNames: 'applyFile serializer preMadeRecords groupId commitNumber filesToDelete commitLogFile targetRecoveryTime logStartTime branchCode location repository logArchiveFrequency'	classVariableNames: 'DefaultRecordSize'	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MaRecoveryManager commentStamp: 'cmm 6/11/2007 22:40' prior: 0!I am responsible for recovery behaviors.Commit-packages received into the server are prepared, serialized and flushed, wrapped in MaRecoveryRecord, to a commits file.  A separate process runs repeatedly, Delaying five seconds and then forking an atomic write of the extents.The atomic write enumerates all of the MaTransactionalFileWriters and captures before-images of the portions of the files about to be overwritten, flushes them to the before-images file.  Then flushes all of the MaTransactionalFileWriters to their respective files.  Finally, an endApply record is flushed to the before-images file.Reads can be interleaved with the atomic write but not commits because the atomic write does not represent a change in the state of the repository.RecoveryIf an outage occurs, we have, in the worst case:	1) some data partially applied	2) some data written to commitPackages, but not yet appliedRecovery addresses these in order.Read the apply-file and look for an incomplete group, a set of RecoveryRecords that have no EndApplyRecord.  If this condition is discovered, the server was in the middle of an atomic-apply when failure occurred.  A partial apply occurred and we must write all of the before-images back to the various files.  Do that.Now we know we do not have corrupt files, however we next need to apply all of the commitPackages that were written to the commit.log file but not yet applied.We just apply the commitPackages whose commitNumber is greater than the commitNumber of the Filer.!!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/13/2007 20:53'!activeCommitLogFilename	^ 'commits.log'! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/1/2007 22:16'!archiveCommitLog	repository commitCritical: 		[ commitLogFile ifNotNil: 			[ commitLogFile close.			commitLogFile := nil.			self renameActiveCommitLog ] ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/13/2007 20:55'!archiveCommitLogFilename	"Answer the proper name for the archive commits file to become a recovery file.  The filename is commits.123.log, where 123 is commitNumber of the last CommitRecord in the file."	^ String streamContents: 		[ : stream | 		stream			maPrint: self class commitLogFilename ;			maPrint: $. ;			maPrint: commitNumber ;			maPrint: $. ;			maPrint: self class commitLogExtension ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/3/2007 12:56'!close	applyFile close.	applyFile := nil.	self archiveCommitLog! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/8/2009 15:19'!commitLogRecordsFrom: startCommitNumber do: aBlock until: untilBlock 	"Enumerate my MaCommitLogRecords beyond my commitNumber.  Value aBlock with the first-class instance of MaCommitLogRecord."	| untilReached |	untilReached := false.	repository flushCritical: 		[ self 			commitLogFileStreamsFrom: startCommitNumber			do: 				[ : eachStream | 				untilReached ifFalse: 					[ untilReached := untilReached or: 						[ self 							commitLogRecordsFrom: startCommitNumber							in: eachStream							do: aBlock							until: untilBlock ] ] ]			unless: [ untilReached ] ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 5/23/2007 23:27'!defaultRecordSize	^ DefaultRecordSize! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/1/2007 14:16'!deleteFilesQueuedForDelete	filesToDelete do: 		[ : eachAtomicFileStream | 		| fd |		eachAtomicFileStream deletePhysicalFiles ].	self initializeFilesToDelete! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/2/2007 22:14'!deleteUnnecessaryCommitLogFiles	"Value oneArgBlock for each commit-log file in my commitsDirectory that is no longer needed for recovery of my repository."	self unnecessaryCommitLogFileNamesDo: 		[ : each | 		self commitLogDirectory deleteFileNamed: each ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 5/31/2005 17:36'!ensureByteArray: aByteArray canHold: anInteger	| newAnswer |	^aByteArray size < anInteger		ifTrue:			[ newAnswer := ByteArray new: anInteger.			newAnswer				replaceFrom: 1				to: aByteArray size				with: aByteArray				startingAt: 1.			newAnswer ]		ifFalse: [ aByteArray ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/7/2005 22:58'!flush	applyFile flush! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/1/2007 13:48'!open: aMagmaLocalLocation 	location := aMagmaLocalLocation.	self openApplyFile.	self commitLogDirectory assureExistence! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/3/2007 13:07'!openApplyFile	applyFile ifNil: [ applyFile := self directory fileNamed: self class applyFilename ].	applyFile		binary ;		position: 0! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 12/19/2008 14:12'!openCommitLog	logStartTime := Time millisecondClockValue.	^ commitLogFile := (self directory fileNamed: self activeCommitLogFilename)		binary ;		setToEnd ;		yourself	"just to be safe"! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/1/2007 14:13'!queueForDelete: aMaAtomicFileStream 	filesToDelete add: aMaAtomicFileStream! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 9/21/2014 18:14'!readRecoveryFile: aStandardFileStream at: filePosition 	| messagePrefix bytesRead inputRecord |	messagePrefix := 'Ungraceful end of commit-group:  '.	inputRecord := MaRecoveryRecord new: self defaultRecordSize.	bytesRead := aStandardFileStream 		maRead: inputRecord bufferSize		bytesFromPosition: 1		of: inputRecord byteArray		atFilePosition: filePosition.	(bytesRead 		between: 1		and: MaRecoveryRecord sizeOfPhysicalSizeField) ifTrue: 		[ MaUnreadableRecoveryRecord signal: messagePrefix , 'no forward-recovery records found' ].	inputRecord physicalSize = 0 ifTrue: [ MaUnreadableRecoveryRecord signal: 'End of recovery group' ].	inputRecord physicalSize > MaSerializedGraphBuffer unreasonablePhysicalSize ifTrue: 		[ MaUnreadableRecoveryRecord signal: messagePrefix , 'unreasonable physicalSize found' ].	"check physicalSize to see if we've read enough."	inputRecord physicalSize > bytesRead ifTrue: 		[ "We haven't read enough, read the rest, ensuring we get as much as we should."		inputRecord byteArray: (self 				ensureByteArray: inputRecord byteArray				canHold: inputRecord physicalSize).		bytesRead := aStandardFileStream 			maRead: inputRecord physicalSize - bytesRead			bytesFromPosition: bytesRead + 1			of: inputRecord byteArray			atFilePosition: filePosition + bytesRead.		bytesRead = (inputRecord physicalSize - self defaultRecordSize) ifFalse: [ MaUnreadableRecoveryRecord signal: messagePrefix , 'end of file' ] ].	self validateRecord: inputRecord.	^ self selectPreMadeRecord: inputRecord! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/2/2007 00:33'!renameActiveCommitLog	"To support one or more warm backups, a staging directory should be used in conjunction with Banyan (or any external copy script) to copy the files to the remote directories.  To make this easier, the current file is written in the repository directory and, when later closed, moved to the separate staging directory (commits) when it is safe to be copied to the warm backup's commitLogs.	If the image crashes, the active commit.log file is still in the repository directory."	commitLogFile ifNotNil: 		[ MagmaSoftwareError signal: 'expected the active-commits file to be closed.' ].	self hasActiveCommitLog ifTrue: 		[ self directory 			rename: self activeCommitLogFilename			toBe: (self commitLogDirectory fullNameFor: self archiveCommitLogFilename) ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 8/6/2007 21:29'!resetApplyFile	"Done with a recovery, now we should truncate the applyFile so future sessions have no chance to encounter the data think recovery operations are needed."	applyFile		truncate ;		close ;		open! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/10/2007 20:46'!selectPreMadeRecord: aMaRecoveryRecord 	^ (preMadeRecords 		at: aMaRecoveryRecord recordType		ifAbsent: 			[ MaUnreadableRecoveryRecord signal: 'Ungraceful end of commit-group:  invalid recordType found (' , aMaRecoveryRecord recordType printString , ').' ])		byteArray: aMaRecoveryRecord byteArray ;		yourself! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 2/24/2013 19:22'!unnecessaryCommitLogFileNamesDo: oneArgBlock 	"Value oneArgBlock for each commit-log file in my commitsDirectory that is no longer needed for recovery of my repository."	self commitLogDirectory in:		[ : dir | dir exists ifTrue:			[ dir entries do:				[ : each | | nameParts |				nameParts := dir splitNameVersionExtensionFor: each name.				(nameParts at: 2) <= commitNumber ifTrue: [ oneArgBlock value: (self commitLogDirectory fullNameFor: each name) ] ] ] ]! !!MaRecoveryManager methodsFor: 'debugging' stamp: 'cmm 7/16/2005 17:58'!applyRecords	| answer |	answer := OrderedCollection new.	[ self applyRecordsDo:		[ : each |		answer add: each independentCopy ] ]		on: MaUnreadableRecoveryRecord		do: [ : err | answer add: err messageText ].	^ answer! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!applyRecordsDo: aBlock	"Enumerate the block of RecoveryRecords for a single groupId in my applyFile."	| currentPosition selectedRecord |	currentPosition := 0.	[ selectedRecord := 		self 			readRecoveryFile: applyFile			at: currentPosition.	selectedRecord isBeginApply		ifTrue: [ groupId := selectedRecord groupId ]		ifFalse: 			[ selectedRecord groupId = groupId				ifFalse:					[ MaUnreadableRecoveryRecord signal: 'expected groupId ', groupId printString, ' but encountered record with ', selectedRecord groupId printString. ] ].	aBlock value: selectedRecord.	selectedRecord isEndApply ]		whileFalse:			[ currentPosition := currentPosition + selectedRecord physicalSize ]! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/8/2009 14:16'!hasActiveCommitLog	^ commitLogFile notNil or: [ self directory fileExists: self activeCommitLogFilename ]! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!isRollbackNeeded	| hasRecords hasValidEndApplyIndicator |	hasRecords := false.	hasValidEndApplyIndicator := false.	[ self applyRecordsDo:		[ : each |		each isBeginApply ifTrue: [ hasRecords := true ].		each isEndApply			ifTrue:				[ hasValidEndApplyIndicator := true ] ] ]		on: MaUnreadableRecoveryRecord		do: 			[ : error |			"An incomplete set of records for a single transactionId was found."			MagmaNotification signal: error messageText.			error return ].	^ hasRecords and: [ hasValidEndApplyIndicator not ]! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 10/28/2008 11:26'!materializeCommitLogEntryIn: aMaCommitLogRecord 	^ serializer resetOidManager materializeGraph: aMaCommitLogRecord record! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 6/11/2007 22:19'!primitiveRecoverUsing: aMaObjectRepository 	"This recovery only happens if there was an outage exactly at the moment where the system was writing its own definition.  In that case, it would not even be able to open properly to perform a normal recovery; therefore we do this initial recovyer which should then *allow* it to materialize its definition so that it can then perform a normal recovery which will get the large-collections.  Whew!!"	MagmaRecoveryNotification signal: 'System recovery needed!!'.	[ self applyRecordsDo: 		[ : eachRecoveryRecord | 		(eachRecoveryRecord isApplyToFile and: 			[ eachRecoveryRecord isForObjectsFile or: [ eachRecoveryRecord isForFilePositionsFile ] ]) ifTrue: [ aMaObjectRepository unapply: eachRecoveryRecord ] ] ] 		on: MaUnreadableRecoveryRecord		do: 			[ : error | 			MagmaRecoveryNotification signal: error messageText , '.  System recovery complete.' ].	^ true! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 6/20/2016 15:07'!reapplyCommitPackagesUsing: aMaObjectRepository 	| count continue onTrack applyCommitRecord |	count := 0.	continue := true.	onTrack := false.	applyCommitRecord := [ : recoveryRecord | | eachCommitLogEntry |	count := count + 1.	eachCommitLogEntry := self materializeCommitLogEntryIn: recoveryRecord.	aMaObjectRepository commitCritical:		[ aMaObjectRepository			write: eachCommitLogEntry			logged: false			commitLogRecord: recoveryRecord.		repository session advanceWith: eachCommitLogEntry ] ].	"Branch code is allowed to change as long as we establish that we are 'onTrack' first.  branchCode can change when a backup is moved somewhere else and used as a primary."	[ self		commitLogRecordsFrom: commitNumber		do:			[ : each | continue = true ifTrue:				[ "Apply ONLY if we have the exact next commit."				(branchCode = each branchCode and: [ each commitNumber = (commitNumber + 1) ])					ifTrue:						[ count = 0 ifTrue:							[ continue := MagmaForwardRecoveryNeeded signal: 'A forward recovery from ' , each timestamp printString , ' is necessary.  If you wish to recover to a point-in-time, press Debug and save the desired target DateAndTime in my ''targetRecoveryTime''.'.							self validateTargetRecoveryTime ].						applyCommitRecord value: each ]					ifFalse:						[ each branchCode = branchCode							ifTrue:								[ each commitNumber > (commitNumber + 1)									ifTrue:										[ MagmaMissingCommitLogWarning signal: 'Looking for commit record ' , (commitNumber + 1) asString , ' but the oldest commit record found was ' , each commitNumber printString.										^ self ]									ifFalse:										[ onTrack := each commitNumber = commitNumber and: [ "{ branchCode. repository previousBranchCode} includes: each branchCode"											true ] ] ]							ifFalse:								[ each commitNumber = (commitNumber + 1) ifTrue:									[ onTrack										ifTrue:											[ repository branchCode: each branchCode.											applyCommitRecord value: each ]										ifFalse: [ MagmaDifferentBranch signal ] ] ] ] ] ]		until: [ : each | continue = false or: [ targetRecoveryTime notNil and: [ each timestamp >= targetRecoveryTime ] ] ] ]		on: MaUnreadableRecoveryRecord		do:			[ : error | MagmaWarning signal: count printString , ' reapply''s completed before encountering an error in the commit-log:  ' , error messageText , '.  ' ]! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 8/6/2007 21:08'!rollbackUsing: aMaObjectRepository 	"If a beginApply record with a valid checkSum is found, then we must find a corresponding endApply record also with a valid checkSum.  If we don't, then we must reverse the entire transaction by starting back at the beginning and applying all of the beforeImage records with valid checkSums back to their files."	MagmaServerPreferences debugRecovery ifTrue: [ self halt: 'about to rollback' ].	[ self applyRecordsDo: 		[ : each | 		each isApplyToFile ifTrue: [ aMaObjectRepository unapply: each ] ] ] 		on: MaUnreadableRecoveryRecord		do: 			[ : error | 			MagmaRecoveryNotification signal: error messageText , '.  Rollback complete.' ].	aMaObjectRepository repositoryController close.	"because class-definitions or largeCollections may have even needed rolled-back; refreshView will not refresh them."	self deleteApplyFile.	"so we don't try to recover again on the next open.."	aMaObjectRepository repositoryController open! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/12/2005 14:28'!beginApply	self preMadeBeginApplyRecord		groupId: self getNextGroupId ;		writeTo: applyFile  "no need to flush until the first ApplyRecord is written."! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 5/15/2007 00:12'!endApply	self preMadeEndApplyRecord		groupId: groupId ;		writeTo: applyFile.	applyFile flush.	self deleteFilesQueuedForDelete.	"Ok, this group is a wrap.  We can now start back at the beginning."	applyFile position: 0.	serializer resetOidManager! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 6/5/2005 21:40'!getNextGroupId 	^ groupId := groupId + 1! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 8/13/2007 22:23'!writeBeforeImageRecordsFrom: aMaAtomicFileStream fileId: fileId 	| hasWrittenFileGrowth |	hasWrittenFileGrowth := false.	aMaAtomicFileStream writersDo: 		[ : each | 		each willCauseGrowth 			ifTrue: 				[ "Only need to write one of these."				hasWrittenFileGrowth ifFalse: 					[ self preMadeFileGrowthRecord						originalSize: aMaAtomicFileStream committedSize ;						fileId: fileId ;						groupId: groupId ;						writeTo: applyFile.					hasWrittenFileGrowth := true ] ]			ifFalse: 				[ self preMadeBeforeImageRecord					location: each filePos ;					record: each currentRecord ;					fileId: fileId ;					groupId: groupId ;					writeTo: applyFile ] ]! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 5/24/2006 22:21'!writeNewFileRecordFrom: aMaTransactionalFileStream fileId: fileId	self preMadeNewFileRecord		filename: aMaTransactionalFileStream filename ;		fileId: fileId ;		groupId: groupId ;		writeTo: applyFile! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 8/13/2007 22:23'!writeRollbackRecordsFor: aMaAtomicFileStream fileId: fileId 	aMaAtomicFileStream isNew 		ifTrue: 			[ self 				writeNewFileRecordFrom: aMaAtomicFileStream				fileId: fileId ]		ifFalse: 			[ self 				writeBeforeImageRecordsFrom: aMaAtomicFileStream				fileId: fileId ]! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 6/19/2007 23:21'!branchCode	^branchCode! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 6/19/2007 23:21'!branchCode: anInteger	branchCode := anInteger! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 7/1/2007 11:47'!commitLogDirectory	^ location commitLogDirectory! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 6/11/2007 22:29'!commitLogFile	^ commitLogFile ifNil: [ self openCommitLog ]! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 5/24/2007 22:37'!commitNumber	^ commitNumber! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 7/1/2007 14:00'!directory	^location directory ! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 12/19/2008 14:11'!logArchiveFrequency	^ logArchiveFrequency ifNil: [ logArchiveFrequency := 5 minutes asMilliSeconds ]! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 12/19/2008 14:42'!logArchiveFrequency: aDuration 	"Set the frequency Magma should create new commit.n.log files.  "	logArchiveFrequency := aDuration asMilliSeconds! !!MaRecoveryManager methodsFor: 'accessing' stamp: 'cmm 8/15/2008 14:43'!serializer	^ serializer! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 2/24/2013 19:19'!commitLogFileNamesFrom: startNumber do: oneArgBlock 	"Create a SortedCollection of the entries by the commitLogNumber.  Attach the original names so we don't have to reconstruct them after the sort."	| selectedEntries sortedEntries dir |	selectedEntries := OrderedCollection new.	dir := self commitLogDirectory.	dir exists ifFalse: [ ^ Array empty ].	dir entries do:		[ : each | | nameParts |		nameParts := dir splitNameVersionExtensionFor: each name.		(nameParts at: 2) >= startNumber ifTrue: [ selectedEntries add: {each name. nameParts} ] ].	sortedEntries := selectedEntries asSortedCollection:		[ : a : b | a second second < b second second ].	sortedEntries do:		[ : each | oneArgBlock value: (self commitLogDirectory fullNameFor: each first) ]! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 7/8/2009 15:19'!commitLogFileStreamsFrom: startCommitNumber do: aBlock unless: dontDoItBlock 	"Value aBlock with each appropriate StandardFileStream instance for reading a chunk of records from startCommitNumber."	self 		commitLogFileNamesFrom: startCommitNumber		do: 			[ : eachFilename | 			dontDoItBlock value ifFalse: 				[ (FileStream readOnlyFileNamed: eachFilename) in: [ : stream | [ aBlock value: stream ] ensure: [ stream close ] ] ] ].	dontDoItBlock value ifFalse: 		[ self hasActiveCommitLog ifTrue: 			[ self commitLogFile reset.			aBlock value: self commitLogFile ] ]! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 7/8/2009 15:08'!commitLogRecordsFrom: anInteger in: aStandardFileStream do: oneArgBlock until: untilBlock 	| currentPosition selectedRecord untilReached |	untilReached := false.	currentPosition := 0.	[ aStandardFileStream atEnd or: [ untilReached ] ] whileFalse: 		[ selectedRecord := self 			readRecoveryFile: aStandardFileStream			at: currentPosition.		(selectedRecord commitNumber >= anInteger and: [ (untilReached := untilBlock value: selectedRecord) not ]) ifTrue: [ oneArgBlock value: selectedRecord ].		currentPosition := currentPosition + selectedRecord physicalSize ].	^ untilReached! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 8/6/2007 21:19'!deleteApplyFile	applyFile ifNotNil: [ applyFile close ].	self directory deleteFileNamed: self class applyFilename! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 7/16/2008 20:04'!validateRecord: inputRecord 	inputRecord hasValidCheckSum ifFalse: 		[ MaUnreadableRecoveryRecord signal: 'record could not validate its checkSum.' ]! !!MaRecoveryManager methodsFor: 'private' stamp: 'cmm 6/11/2007 21:22'!validateTargetRecoveryTime	targetRecoveryTime ifNotNil: 		[ targetRecoveryTime class name = DateAndTime ifFalse: 			[ MagmaUserError signal: 'targetRecoveryTime should be a kind of DateAndTime.' ] ]! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 5/24/2007 22:36'!commitNumber: anInteger	commitNumber := anInteger! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 7/8/2007 17:41'!initialize	super initialize.	groupId := 0.	self 		initializePreMadeRecords ;		initializeFilesToDelete ;		initializeSerializer! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 6/6/2005 12:37'!initializeFilesToDelete	filesToDelete := OrderedCollection new! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 6/11/2007 19:54'!initializePreMadeRecords	preMadeRecords := { 		(MaBeginApplyRecord new).		(MaBeforeImageRecord new).		(MaFileGrowthRecord new).		(MaNewFileRecord new).		(MaEndApplyRecord new).		(MaCommitLogRecord new)	 }! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 8/15/2008 12:20'!initializeSerializer	serializer := MagmaSession newCommitLogSerializer! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 7/8/2007 17:34'!setRepository: aMaObjectRepository	repository := aMaObjectRepository! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 4/8/2015 20:05'!log: aMaCommitLogRecord 	"In case a MaCommitLogRecordRequest had come in and repositioned the file-pointer of the commitLogFile, just ensure it is setToEnd before appending the next commit.  This does *not* belong in #writeTo: because that would cause the applied.images file to grow endlessly."	self commitLogFile setToEnd.	aMaCommitLogRecord writeTo: self commitLogFile.	self commitLogFile flush.	self timeToStartNewCommitLog ifTrue: [ self archiveCommitLog ]! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 12/26/2009 15:21'!log: aMaCommitLogRecord flush: aBoolean 	"In case a MaCommitLogRecordRequest had come in and repositioned the file-pointer of the commitLogFile, just ensure it is setToEnd before appending the next commit.  This does *not* belong in #writeTo: because that would cause the applied.images file to grow endlessly."	self commitLogFile setToEnd.	aMaCommitLogRecord writeTo: self commitLogFile.	aBoolean ifTrue: [ self commitLogFile flush ].	self timeToStartNewCommitLog ifTrue: [ self archiveCommitLog ]! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 7/14/2009 19:36'!newCommitLogRecordFor: aMaCommitLogEntry 	| commitPackageRecord |	commitPackageRecord := self preMadeCommitPackageRecord.	commitPackageRecord		record: (serializer resetOidManager serializeGraph: aMaCommitLogEntry) trimmedByteArray ;		commitNumber: commitNumber ;		timestamp: DateAndTime now ;		branchCode: branchCode.	^ commitPackageRecord independentCopy! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 5/23/2007 22:40'!nextCommitNumber	^ commitNumber := commitNumber + 1! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 12/19/2008 14:12'!timeToStartNewCommitLog	^ (Time millisecondsSince: logStartTime) > self logArchiveFrequency! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:40'!preMadeBeforeImageRecord	^ preMadeRecords at: MaBeforeImageRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeBeginApplyRecord 	^ preMadeRecords at: MaBeginApplyRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/11/2007 19:55'!preMadeCommitPackageRecord 	^ preMadeRecords at: MaCommitLogRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeEndApplyRecord 	^ preMadeRecords at: MaEndApplyRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeFileGrowthRecord	^ preMadeRecords at: MaFileGrowthRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeNewFileRecord	^ preMadeRecords at: MaNewFileRecord assignedRecordType! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaRecoveryManager class	instanceVariableNames: ''!!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 6/9/2005 15:55'!applyFilename	^ 'applied.images'! !!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 7/1/2007 13:52'!commitLogDirectoryName	^ 'commits'! !!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 6/6/2007 23:22'!commitLogExtension	^ 'log'! !!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 6/6/2007 23:22'!commitLogFilename	^ 'commits'! !!MaRecoveryManager class methodsFor: 'class initialization' stamp: 'cmm 5/23/2007 23:27'!defaultRecordSize: anInteger 	DefaultRecordSize := anInteger! !!MaRecoveryManager class methodsFor: 'class initialization' stamp: 'cmm 5/23/2007 23:27'!initialize	super initialize.	self defaultRecordSize: 300! !!MaRecoveryManager class methodsFor: 'create' stamp: 'cmm 7/8/2007 17:33'!repository: aMaObjectRepository 	^ self new		setRepository: aMaObjectRepository ;		yourself! !MagmaWarning subclass: #MagmaForwardRecoveryNeeded	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!!MagmaForwardRecoveryNeeded methodsFor: 'as yet unclassified' stamp: 'cmm 3/2/2009 19:53'!defaultAction	^ self resume: true! !MagmaNotification subclass: #MagmaRecoveryNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!MagmaWarning subclass: #MagmaRollbackRecoveryNeeded	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magma-Server-Recovery'!MaRecoveryManager initialize!