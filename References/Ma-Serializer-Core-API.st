Object subclass: #MaObjectGraphTraversalStrategy	instanceVariableNames: 'valueWhenBlock traverseWhenBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-API'!!MaObjectGraphTraversalStrategy methodsFor: 'private' stamp: 'cmm 5/2/2005 22:13'!initialize	super initialize.	valueWhenBlock := [:path :parent :instVarIndex | true].	traverseWhenBlock := [:path :parent :instVarIndex | true]! !!MaObjectGraphTraversalStrategy methodsFor: 'testing'!shouldTraverseIntoLastOf: path from: parent index: anInteger	^traverseWhenBlock		value: path		value: parent		value: anInteger! !!MaObjectGraphTraversalStrategy methodsFor: 'testing'!shouldValueLastOf: anOrderedCollection from: parentObject index: anInteger	^valueWhenBlock		value: anOrderedCollection		value: parentObject		value: anInteger! !!MaObjectGraphTraversalStrategy methodsFor: 'building'!traverseWhen: threeArgBlock	"The default traversal behavior is to traverse everything.  threeArgBlock	may be specified to restrict the default traversal (stepping into an objects	instance variables).  The first argument is an OrderedCollection of the	path of objects that lead to the current node, the second is the parent	of the current node (and second to last in the path), the last is the integer	index of the instVar of the current node."	traverseWhenBlock := threeArgBlock! !!MaObjectGraphTraversalStrategy methodsFor: 'building'!valueWhen: threeArgBlock	"The default behavior is to value every node once (the framework automatically	keeps track of where it has already been).   threeArgBlock takes the same arguments	as the other parameters of this class."	valueWhenBlock := threeArgBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectGraphTraversalStrategy class	instanceVariableNames: ''!!MaObjectGraphTraversalStrategy class methodsFor: 'create' stamp: 'cmm 2/16/2014 18:01'!newTraverseForSerialization	^ self new traverseWhen:		[ : path : parent : indexInteger | path last			maShouldTraverseWithPath: path			parent: parent			index: indexInteger ]! !!MaObjectGraphTraversalStrategy class methodsFor: 'create' stamp: 'cmm 2/16/2014 17:48'!newTraverseNoBytes	"Make a new traversal strategy that does not traverse into individual bytes or words of those class-types, only named and index pointers."	^ self new traverseWhen:		[ : path : parent : index | | obj cl |		obj := path last.		cl := self class.		cl = CompiledMethod ifTrue: [ ^ true ].		cl isBytes ifTrue: [ ^ false ].		cl isPointers ifFalse: [ ^ false ].		^ true ]! !!MaObjectGraphTraversalStrategy class methodsFor: 'create' stamp: 'cmm 2/16/2014 17:53'!newTraverseNoBytesNoGlobals	"Make a new traversal strategy that does not traverse into individual bytes or words of those class-types, only named and index pointers."	^ self new traverseWhen:		[ : path : parent : index | | obj |		obj := path last.		(self shouldTraverseNoBytes: obj) and: [ self shouldTraverseNoGlobals: obj ] ]! !!MaObjectGraphTraversalStrategy class methodsFor: 'private' stamp: 'cmm 2/16/2014 17:51'!shouldTraverseNoBytes: anObject 	| cl |	cl := anObject class.	cl = CompiledMethod ifTrue: [ ^ true ].	cl isBytes ifTrue: [ ^ false ].	cl isPointers ifFalse: [ ^ false ].	^ true! !!MaObjectGraphTraversalStrategy class methodsFor: 'private' stamp: 'cmm 5/28/2014 14:14'!shouldTraverseNoGlobals: anObject 	anObject == Smalltalk ifTrue: [ ^ false ].	anObject == Processor ifTrue: [ ^ false ].	anObject == Display ifTrue: [ ^ false ].	anObject == ActiveHand ifTrue: [ ^ false ].	anObject == ActiveWorld ifTrue: [ ^ false ].	anObject == Sensor ifTrue: [ ^ false ].	anObject == SourceFiles ifTrue: [ ^ false ].	anObject == SystemOrganization ifTrue: [ ^ false ].	anObject == TextConstants ifTrue: [ ^ false ].	anObject == World ifTrue: [ ^ false ].	anObject isBehavior ifTrue: [ ^ false ].	anObject maIsEnvironment ifTrue: [ ^ false ].	^ true! !MaObject subclass: #MaObjectSerializer	instanceVariableNames: 'oidManager classIdManager preMadeObjectBuffers graphBuffer createProxyBlock traversalStrategy amBusy preferences bpMapIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-API'!!MaObjectSerializer commentStamp: 'cmm 8/3/2011 17:46' prior: 0!A MaObjectSerializer serializes any object into a bytes and back.  Transforming an object into bytes is useful for storing it on disk or sending it over the network.A primary feature of this serializer is that it stores in a first-class buffer format.  There is a hierarchy of buffers for storing the various kinds of objects:  named inst-vars, indexed-vars, named + indexed, bytes, words, and a special one for CompiledMethods and MethodContexts.First-class buffers allows object graphs to be "walked" similarly to the way the standard Smalltalk object-model is walked.!!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 10/13/2012 17:13'!afterMaterializingAny: className do: oneArgValuator 	"Set up preference for materializing instances of the class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	preferences		afterMaterializingAny: className		do: oneArgValuator! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 10/13/2012 17:13'!afterSerializingAny: className do: oneArgValuator 	"Set up preference for serializing instances of class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	preferences		afterSerializingAny: className		do: oneArgValuator! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 10/13/2012 17:12'!beforeSerializingAny: className do: oneArgValuator 	"Set up preference for serializing instances of Class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	preferences		beforeSerializingAny: className		do: oneArgValuator! !!MaObjectSerializer methodsFor: 'building'!graphBuffer: aMaSerializedGraphBuffer	graphBuffer := aMaSerializedGraphBuffer! !!MaObjectSerializer methodsFor: 'building'!oidManager: aMaOidManager	oidManager := aMaOidManager! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 12/29/2002 16:49'!optimumByteArraySize: anInteger	self byteArray: (ByteArray new: anInteger).	self resetByteArray! !!MaObjectSerializer methodsFor: 'building'!toCreateProxies: oneArgBlock	createProxyBlock := oneArgBlock! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 8/29/2011 10:01'!append: anObject	"Append only anObject to the receiver.  However, in the case where anObject is stored via a storage-object (see #maAsStorageObject), the entire graph of the storage object must be stored."	| storageObject |	storageObject := anObject maAsStorageObject.	anObject maWantsPreSerialization ifTrue: [ self preSerialize: storageObject ].	storageObject ~~ anObject		ifTrue:			[ "This is a storage object, so traverse it deeply into an inner serialized graph ByteArray."			storageObject := (self copyForStorageObject serializeGraph: storageObject) trimmedByteArray ].	self graphBuffer increaseBufferSizeBy:		(self			bufferFor: anObject			storageObject: storageObject			startingAt: self graphBuffer bufferSize)				physicalSize.	"Since the need is so scarce anyway, if you order pre-serialization, you get post too."	anObject maWantsPreSerialization ifTrue: [ self postSerialize: storageObject ]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/22/2013 18:48'!appendGraph: anObject do: oneArgBlock 	"Answer a MaSerializedObjectBuffer containing anObject and all objects it can reach, serialized into aByteArray."	self beBusy.	anObject		maGraphDo:			[ : path : parent : index | (path last				maShouldAppendWithPath: path				parent: parent				index: index) ifTrue:				[ self append: path last.				oneArgBlock value: path last ] ]		using: self traversalStrategy.	self beBored.	^ self graphBuffer trimByteArray! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/29/2002 23:22'!beBored	amBusy := false! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/29/2002 23:33'!beBusy	amBusy := true! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 8/27/2008 14:47'!bpMap	^ MaObjectBuffer bpMapsAt: bpMapIndex + 1! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/23/2013 09:50'!bufferFor: anObject storageObject: storageObject startingAt: anInteger 	| buffer |	buffer := anObject == storageObject 		ifTrue: [ storageObject realObjectIfMutatingProxy maSelectPreMadeObjectBufferFrom: self ]		ifFalse: [ self preMadeStorageObjectBuffer ].	buffer		startPos: anInteger ;		ensureSpaceFor: storageObject realObjectIfMutatingProxy			using: self bpMap.	buffer byteArray == self byteArray ifFalse: 		[ "aByteArray must not have been big enough.."		self byteArray: buffer byteArray ].	buffer 		populateHeaderFor: anObject		using: self.	buffer 		populateBodyFor: storageObject realObjectIfMutatingProxy		using: self.	^ buffer! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/10/2005 18:56'!classFor: anObject 	^ anObject maSerializationClass! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 9/20/2014 16:02'!materializeGraphDo: twoArgBlock 	"Materialize as much as the object in the receivers byteArray as possible.  For each object *materialized*, value twoArgBlock [ : eachObject : eachBuffer | ].  twoArgBlock is not valued for objects encountered in the materialized graph if they were already present in the receivers oidManager, that way we know when objects are exactly materialized."	| skeletons rootObject |	skeletons := OrderedCollection new: 48.	rootObject := nil.	self beBusy.	[ self graphBuffer buffersDo:		[ : each | | object |		object := self			objectWithOid: each oid			ifFound:				[ : foundObj | (foundObj maIsMutatingProxy and: [ foundObj maRealObjectIsReified not ]) ifTrue:					[ skeletons add:						(Association							key:								(self									newSkeletonFor: each									fromProxy: foundObj)							value: each copyWithSameBuffer) ].				foundObj ]			ifAbsent:				[ | newObject |				skeletons add:					(Association						key:							(newObject := self								newSkeletonFor: each								fromProxy: nil)						value: each copyWithSameBuffer).				newObject ].		rootObject ifNil: [ rootObject := object ] ] ] ensure:		[ | hashedCollections |		hashedCollections := OrderedCollection new.		skeletons do:			[ : eachAssociation | | eachObject eachBuffer |			eachObject := eachAssociation key.			eachBuffer := eachAssociation value.			eachObject realObjectIfMutatingProxy maIsHashedCollection ifTrue: [ hashedCollections add: eachAssociation ].			eachBuffer				establishReferencesFrom: eachObject realObjectIfMutatingProxy				using: self ].		hashedCollections do:			[ : eachAssociation | eachAssociation key realObjectIfMutatingProxy rehash ] ].	skeletons do:		[ : eachAssociation | | eachFullyFormedObject eachBuffer |		eachFullyFormedObject := eachAssociation key.		eachBuffer := eachAssociation value.		eachFullyFormedObject maWantsPostMaterialization ifTrue: [ self postMaterialize: eachFullyFormedObject ].		twoArgBlock			value: eachFullyFormedObject			value: eachBuffer ].	self beBored.	^ rootObject! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/6/2013 14:43'!newSkeletonFor: aMaObjectBuffer fromProxy: aMaMutatingProxy 	| skel |	skel := aMaObjectBuffer createObjectUsing: self.	aMaMutatingProxy ifNotNil:		[ aMaMutatingProxy setRealObjectTo: skel.		skel := aMaMutatingProxy ].	self		oidOf: skel		is: aMaObjectBuffer oid.	^ skel! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 10/30/2006 00:09'!objectsDo: oneArgBlock 	self oidsAndObjectsDo: [ : eachOid : eachObject | oneArgBlock value: eachObject ]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 6/23/2004 17:41'!oidOf: anObject is: anInteger	oidManager		oidOf: anObject		is: anInteger! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 10/30/2006 00:09'!oidsAndObjectsDo: twoArgBlock	oidManager oidsAndObjectsDo: twoArgBlock! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 3/24/2005 14:20'!postCopyWithNewBuffer	graphBuffer := MaSerializedGraphBuffer new: 1000.	self		initializePreMadeObjectBuffers;		resetByteArray;		beBored! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/7/2008 16:28'!postCopyWithNewOidSpace	self oidManager: 		(oidManager species new			useStatisticsFrom: oidManager ;			yourself)! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 3/23/2013 17:10'!postIndependentCopy	"Answer a completely independent copy of the receiver.  This will probably mostly be used during debugging."self maMarked: 'delete'.	self 		oidManager: oidManager independentCopy;		classIdManager: self classIdManager independentCopy;		resetByteArray.	graphBuffer := graphBuffer copy.	traversalStrategy := traversalStrategy copy! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 10/28/2011 15:38'!postMaterialize: anObject 	"maPostMaterialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPostMaterialize) 		ifTrue: [anObject maPostMaterialize].	anObject maOriginalClass withAllSuperclassesDo: 			[:eachClass | 			preferences postMaterializers 				at: eachClass name				ifPresent: 					[:valuators | 					valuators do: [:each | each valueWithArguments: { 										anObject}]]				ifAbsent: 					["do nothing"					]]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 10/28/2011 15:39'!postSerialize: anObject 	"maPostSerialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPostSerialize) ifTrue: [anObject maPostSerialize].	anObject maOriginalClass withAllSuperclassesDo: 			[:eachClass | 			preferences postSerializers 				at: eachClass name				ifPresent: [:valuators | valuators do: [:each | each value: anObject]]				ifAbsent: 					["do nothing"					]]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:42'!preMadeByteObjectBuffer	^ self preMadeObjectBufferAt: 1! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 7/30/2011 12:08'!preMadeCompiledMethodBuffer	^ self preMadeObjectBufferAt: 6! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:43'!preMadeFixedObjectBuffer	^ self preMadeObjectBufferAt: 3! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 7/30/2011 12:08'!preMadeMethodContextBuffer	^ self preMadeObjectBufferAt: 7! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:42'!preMadeObjectBufferAt: bufferTypeInteger	^ preMadeObjectBuffers at: bufferTypeInteger! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 21:42'!preMadeStorageObjectBuffer	^ self preMadeObjectBufferAt: 5! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:43'!preMadeVariableObjectBuffer	^ self preMadeObjectBufferAt: 2! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 22:14'!preMadeVariableWordBuffer	^ self preMadeObjectBufferAt: 4! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 10/28/2011 15:39'!preSerialize: anObject 	"maPreserialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPreSerialize) ifTrue: [ anObject maPreSerialize ].	anObject maOriginalClass withAllSuperclassesDo: 		[ : eachClass | 		preferences preSerializers 			at: eachClass name			ifPresent: 				[ : valuators | 				valuators do: [ : each | each valueWithArguments: {  anObject  } ] ]			ifAbsent: 				[ "do nothing"				 ] ]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/6/2013 15:01'!proxyFor: oid 	| proxy |	self		oidOf: (proxy := createProxyBlock value: oid)		is: oid.	^ proxy! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 8/27/2008 10:14'!bpMapIndex	"The index into the MaObjectBuffer's 'BufferPositionMaps' Array referring to the MaBufferPositionMap, which identifies the attribute offsets."	^ bpMapIndex! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 8/27/2008 20:47'!bpMapIndex: anInteger 	"Set the 0-based index of the MaBufferPositionMap to be used by this serializer."	bpMapIndex := anInteger! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 6/3/2004 14:07'!classDefinitions: aDictionary	"aDictionary keys are the classId (an Integer), values are a collection of known MaClassDefinitions, representing different versions of that class."	self classIdManager classDefinitionsById: aDictionary! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 6/8/2004 22:09'!classDefinitionsByteArray: aByteArray	"Initialize the receiver with aByteArray that materializes to my classDefinitions.  These are the classDefinitions used to work with objects that were being used when the user saved off the byteArray by calling the getter, #classDefinitionsByteArray."	self classDefinitions: (self materializeGraph: aByteArray)! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 5/2/2005 15:03'!classIdManager: aMaClassIdManager	classIdManager := aMaClassIdManager.	self setUpClassDefinitionProcessing! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 8/21/2012 21:15'!initialize	super initialize.	bpMapIndex := 0. "0-based index"	preferences := MaObjectSerializerPreferences new.	self		 oidManager: MaOidManager new ;		 classIdManager: MaClassIdManager new ;		 initializeTraversalStrategy ;		 toCreateProxies:			[ : oid | MaObjectSerializationUserError signal: 'No createProxyBlock specified.  See MaObjectSerializer>>toCreateProxies:' ]; 		graphBuffer: (MaSerializedGraphBuffer new: 50) ;		 initializePreMadeObjectBuffers ;		 beBored ;		 setUpPreAndPostProcessing! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 10/21/2004 12:53'!initializePreMadeObjectBuffers	preMadeObjectBuffers := MaObjectBuffer bufferClasses collect:		[ :each |		each			byteArray: self byteArray			startPos: 0 ]! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 2/16/2014 18:02'!initializeTraversalStrategy	traversalStrategy := MaObjectGraphTraversalStrategy newTraverseForSerialization! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 3/16/2009 20:38'!protocol	"The protocol established (directly or indirectly) for this serializer."	^ classIdManager protocol! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 1/26/2009 13:57'!protocol: aCollection 	"This is only called once per instance, don't try to reset the protocol because this implementation doesn't remove any old protocol.  Create a new serializer if you have to."	| sc |	sc := aCollection asSortedCollection: [ : a : b | a name < b name ].	sc do: [ : each | classIdManager addNewClass: each ].	self classIdManager beImmutable! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 9/21/2013 18:01'!setUpClassDefinitionProcessing	preferences				beforeSerializingAny: #MaClassReference		do:			[ : aMaClassReference | | id defs |			id := classIdManager				idForClass: aMaClassReference classObject				ifAbsent: [ (classIdManager addNewClass: aMaClassReference classObject theNonMetaClass) id ].			defs := classIdManager				classDefinitionsForId: id				ifAbsent: [ Array empty ].			aMaClassReference isDefinition ifTrue:				[ (defs noneSatisfy:					[ : each | each isKnownAs: aMaClassReference name ]) ifTrue: [ MaObjectSerializationUserError signal: 'MaClassDefinitions are private to serializers, you must not serialize MaClassDefinitions from other serializers.' ] ].			aMaClassReference id: id ] ;				afterMaterializingAny: #MaClassDefinition		do:			(MessageSend				receiver: classIdManager				selector: #addClassDefinition:)! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 4/16/2018 20:11'!setUpPreAndPostProcessing	"Initiailize the pre and post-materializers for classes that come with standard Squeak.  Base Squeak uses one of two methods for serializing objects; ReferenceStream and ImageSegments.  MaObjectSerialization more-closely resembles ReferenceStream.  While the setup for these processors is based on the behavior in those other two frameworks, there are bound to be some minor differences."	self setUpClassDefinitionProcessing.	preferences		afterMaterializingAny: #Form		do: [ : aForm | aForm maCheckBits ].	"preferences	beforeSerializingAny: #Form	do: [ : aForm | aForm hibernate ].preferences	afterSerializingAny: #Form	do: [ : aForm | aForm unhibernate ]."	"preferences	beforeSerializingAny: #ColorForm	do: [ : aColorForm | aColorForm clearColormapCache ]."	preferences 		beforeSerializingAny: #Morph		do: 			[ : aPasteUpMorph | 			aPasteUpMorph prepareToBeSaved.	"Amen"			thisContext home removeSelf ].	"preferences	afterSerializingAny: #ScriptEditorMorph	do: [ : aScriptEditorMorph | aScriptEditorMorph class = BooleanScriptEditor ifFalse: [ aScriptEditorMorph unhibernate ] ].preferences	afterMaterializingAny: #ScriptEditorMorph	do: [ : aScriptEditorMorph | aScriptEditorMorph class = BooleanScriptEditor ifFalse: [ aScriptEditorMorph unhibernate ] ]."	preferences 		beforeSerializingAny: #TTCFont		do: 			[ : aTTCFont | 			aTTCFont flushCache.			thisContext home removeSelf ].	"preferences		beforeSerializingAny: #Wonderland		do: [ : aWonderland | aWonderland prepareToBeSaved ].preferences	beforeSerializingAny: #ViewerFlapTab	do: [ : aViewFlapTab | aViewFlapTab hibernate ]."	self maMarked: 'dev'.	"You've got this commented out because it changes the shape of the object while you're serializing it, which ends up causing the graphBuffer to not be #isWhole (which causes problems on materialization).Do we need this?  It appears that Project>>exportSegmentWithChangeSet:  fileName:  directory: calls it at the end.  Also, Project>>exportSegmentWithCatagories: classes: fileName: directory:"	"preferences	afterSerializingAny: #ViewerFlapTab	do: [ : aViewerFlapTab | aViewerFlapTab unhibernate ].preferences	afterMaterializingAny: #ViewerFlapTab	do: [ : aViewerFlapTab | aViewerFlapTab unhibernate ]."	preferences		beforeSerializingAny: #CompiledMethod			do: [ : aCompiledMethod | aCompiledMethod fixForWriteBarrier ] ;		beforeSerializingAny: #Context			do:				[ : aContext | aContext removeSelf.				1 to: aContext numArgs do: [ : n | aContext tempAt: n put: nil ] ] ;		afterMaterializingAny: #Context			do: [ : aContext | aContext privRefresh ].	(Smalltalk hasClassNamed: #Project) ifTrue: 		[ preferences 			beforeSerializingAny: #Project			do: 				[ : aProject | 				| world |				world := aProject world.				aProject world 					setProperty: #optimumExtentFromAuthor					toValue: aProject world extent.	"As suggested by Project>>#storeOnServerAssumingNameValid"				(Smalltalk classNamed: #Utilities) ifNotNilDo: 					[ : utilities | 					"The following is from Project>>#exportSegmentWithChangeSet:fileName:directory:"					utilities emptyScrapsBook ].				world currentHand pasteBuffer: nil.	"don't write the paste buffer."				world currentHand mouseOverHandler initialize.	"forget about any references here"				"Display checkCurrentHandForObjectToPaste."				(Smalltalk classNamed: #Command) ifNotNilDo: [ : command | command initialize ].				world clearCommandHistory.				world					fullReleaseCachedState ;					releaseViewers.				world cleanseStepList.				world releaseSqueakPages.				(Smalltalk classNamed: #ScriptEditorMorph) ifNotNilDo: 					[ : sem | 					sem writingUniversalTiles: (aProject 							projectParameterAt: #universalTiles							ifAbsent: [ false ]) ].				thisContext home removeSelf ].		preferences 			afterMaterializingAny: #Project			do: 				[ : aProject | 				aProject setParent: (Smalltalk classNamed: #Project) current.				aProject world beWorldForProject: aProject.	"sets aProject's worldState"				"This behavior suggested by ImageSegment>>#comeFullyUpOnReload:"				aProject ensureChangeSetNameUnique.				(Smalltalk classNamed: #Project) addingProject: aProject.				aProject restoreReferences.				self maMarked: 'dev'.	"need to restore dependents??"				(Smalltalk classNamed: #ScriptEditorMorph) ifNotNilDo: 					[ : sem | 					sem writingUniversalTiles: ((aProject projectPreferenceAt: #universalTiles) ifNil: [ false ]) ].				thisContext home removeSelf ]		"preferences	afterMaterializingAny: #WorldState	do:		[ : aWorldState |		aWorldState			convertStepList ;			convertAlarms ]." ]! !!MaObjectSerializer methodsFor: 'accessing'!byteArray	^self graphBuffer byteArray! !!MaObjectSerializer methodsFor: 'accessing'!byteArray: aByteArray	self graphBuffer byteArray: aByteArray.	preMadeObjectBuffers do: [ :each | each byteArray: aByteArray ]! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 11/25/2011 16:38'!classDefinitionsById	^ classIdManager classDefinitionsById! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 6/8/2004 21:14'!classDefinitionsByteArray	"Answer a ByteArray that can be used to reinitialize a new instance of the receiver so that it can materialize the objects it has serialized."	^ (self copyWithNewBuffer serializeGraph: self classIdManager classDefinitionsById) trimmedByteArray! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 5/23/2004 22:18'!classDefinitionsOid	^self oidFor: self classIdManager classDefinitionsById! !!MaObjectSerializer methodsFor: 'accessing'!classIdManager	^classIdManager! !!MaObjectSerializer methodsFor: 'accessing'!graphBuffer	^graphBuffer! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/27/2006 16:45'!objectWithOid: anInteger	^ oidManager		objectWithOid: anInteger		ifAbsent: [ self proxyFor: anInteger ]! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:55'!objectWithOid: anInteger ifAbsent: aBlock	^oidManager		objectWithOid: anInteger		ifAbsent: aBlock! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:54'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^oidManager		objectWithOid: anInteger		ifFound: oneArgBlock		ifAbsent: aBlock! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 4/20/2003 22:18'!oidCount	"Answers the number of objects that have oids."	^oidManager oidCount! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:54'!oidFor: anObject	^oidManager oidFor: anObject! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 7/10/2009 17:19'!oidFor: anObject ifAbsent: aBlock 	^ oidManager 		oidFor: anObject		ifAbsent: aBlock! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 11/26/2004 09:46'!preferences	^ preferences! !!MaObjectSerializer methodsFor: 'accessing'!traversalStrategy	^traversalStrategy! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 8/29/2011 19:47'!copyForStorageObject	^ self copyWithNewOidSpace		 initializeTraversalStrategy ;		 yourself! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:59'!copyWithNewBuffer	^ self copy		postCopyWithNewBuffer ;		yourself! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:58'!copyWithNewOidSpace	"Answer a new instance of the me that shares my class-ids, but not the oids."		^ self copyWithNewBuffer		postCopyWithNewOidSpace ;		yourself! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/23/2013 17:09'!independentCopy	"Answer a completely independent copy of the receiver.  This will probably mostly be used during debugging."self maMarked: 'delete'.	^ self copy postIndependentCopy! !!MaObjectSerializer methodsFor: 'serializing' stamp: 'HB 3/30/2017 23:26'!fileOut: anObject toFileNamed: fileName in: aFileDirectory 	"Write anObject to a file named fileName in aFileDirectory."	^ aFileDirectory asFileDirectory		maFileNamed: fileName		do: 			[ : stream | 			stream				binary ;				position: 0.			self 				object: anObject				toStream: stream ]! !!MaObjectSerializer methodsFor: 'serializing' stamp: 'cmm 11/22/2016 14:42'!object: anObject toStream: aWriteStream 	"Serialize anObject onto aWriteStream, taking care to ensure any Proxies are reified first, so that the entire graph is serialized.  Answer the final MaSerializedGraphBuffer."	| objectGb anyProxyEncountered |	[ anyProxyEncountered := nil.	objectGb := [ self serializeGraph: anObject ]		on: MaTraverseProxyNotification		do:			[ : noti | anyProxyEncountered := noti proxy.			anyProxyEncountered realObjectIfMutatingProxy.			noti resume ].	anyProxyEncountered yourself. "one force bulkBecome"	anyProxyEncountered notNil ] whileTrue.	objectGb buffersMissingFromWhole ifNotEmpty:		[ : missing | MaSoftwareError signal: 'Incomplete graph, check serializer configuration.' ].	"serialize protocol and object in succession."	aWriteStream		 nextPutAll: self classDefinitionsByteArray ;		 nextPutAll: objectGb byteArray.	^ objectGb! !!MaObjectSerializer methodsFor: 'serializing' stamp: 'cmm 3/16/2009 20:12'!serializeGraph: anObject	"Serialize anObject and answer it as a MaSerializedGraphBuffer."	^self		serializeGraph: anObject		do: [ :each | nil ]! !!MaObjectSerializer methodsFor: 'serializing' stamp: 'cmm 8/9/2010 19:33'!serializeGraph: anObject do: oneArgBlock	"Serialize anObject and answer it as a MaSerializedGraphBuffer.  For each object traversed in the serialization, value oneArgBlock."	^ self copyWithNewBuffer		appendGraph: anObject		do: oneArgBlock! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 1/20/2003 22:26'!finalizeOids	oidManager finalizeOids! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 12/29/2004 17:30'!rehashOids	oidManager rehashOids! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 7/30/2011 12:06'!resetByteArray	"Ensure my preMade buffers share the same byteArray as my graphBuffer (a performance optimization) and set my size to 0 objects."	preMadeObjectBuffers first byteArray ~~ self byteArray ifTrue:		[ | ba |		ba := self byteArray.		preMadeObjectBuffers do:			[ : each | each byteArray: ba ] ].	self graphBuffer resetBufferSize! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 6/8/2006 15:45'!resetOidManager	"If receiving a byteArray from another serializer, this method should be invoked prior to materializing here so cached oids in the oidManager that may not match the objects that were serialized by the other serializer."	oidManager reset! !!MaObjectSerializer methodsFor: 'event handling' stamp: 'cmm 12/12/2004 18:54'!handleClassModification: aModifiedClassDefinitionEvent	aModifiedClassDefinitionEvent isModified ifFalse: [ ^ self ].	aModifiedClassDefinitionEvent item isMeta ifTrue: [ ^ self ].	oidManager		handleClassModification: aModifiedClassDefinitionEvent item		using: self.	classIdManager		handleClassModification: aModifiedClassDefinitionEvent item		using: self! !!MaObjectSerializer methodsFor: 'testing' stamp: 'cmm 7/17/2002 22:49'!hasOidFor: anObject	^oidManager hasOidFor: anObject! !!MaObjectSerializer methodsFor: 'testing' stamp: 'cmm 3/16/2009 20:24'!protocolEstablished	^ classIdManager isMutable not! !!MaObjectSerializer methodsFor: 'materializing' stamp: 'cmm 10/9/2004 23:58'!materializeGraph: aByteArray	^self		materializeGraph: aByteArray		do: [ : eachObject : eachBuffer | "do nothing" ]! !!MaObjectSerializer methodsFor: 'materializing' stamp: 'cmm 1/30/2005 20:47'!materializeGraph: aByteArray do: twoArgBlock	"Answer a fully-formed object from aByteArray of aMaSerializedGraphBuffer.  If buffers are missing to complete the full-graph, I will substitute with proxy's based on the block specified by toCreateProxies:."	"Guard against stepping on my own buffers if I'm busy serializing or materializing already."	^ amBusy		ifTrue:			[ self copyWithNewBuffer				byteArray: aByteArray;				materializeGraphDo: twoArgBlock ]		ifFalse:			[ self				byteArray: aByteArray;				materializeGraphDo: twoArgBlock ]! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 5/8/2003 13:50'!cachedObjectCountByClass	^oidManager objectCountByClass! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 11/13/2011 18:20'!cachedObjectsDo: aBlock	"Enumerate all objects which are materialized in memory."	oidManager objectsDo: aBlock! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 9/2/2012 21:46'!cleanObject: anObject	oidManager cleanObject: anObject! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 11/13/2011 20:11'!initializeImmutabilityStrategy: aMaImmutabilityStrategy using: aMaTransaction 	"Populate aMaImmutabilityStrategy's immutables as best we can from existing cached objects."	aMaImmutabilityStrategy resetImmutables.	self cachedObjectsDo:		[ : each | aMaImmutabilityStrategy			rememberImmutableReferencesFrom: each			for: aMaTransaction ]! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 4/20/2005 17:27'!resetNewObjects	oidManager resetNewObjects! !!MaObjectSerializer methodsFor: '*magma-client' stamp: 'cmm 8/3/2009 20:43'!validateNextOid	oidManager validateNextOid! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectSerializer class	instanceVariableNames: ''!!MaObjectSerializer class methodsFor: 'debugging' stamp: 'cmm 4/19/2009 20:52'!fileIn: aDirectoryEntryFile 	^ aDirectoryEntryFile containingDirectory 		maFileNamed: aDirectoryEntryFile name		do: 			[ : stream | 			stream binary.			self objectFromStream: stream ]! !!MaObjectSerializer class methodsFor: 'debugging' stamp: 'cmm 11/9/2010 23:00'!objectFromStream: stream 	| serializer buffers |	stream binary.	buffers := OrderedCollection new.	stream maBuffersDo:		[ : each | buffers add: each ].	serializer := MaObjectSerializer new.	^ buffers size > 1		ifTrue:			[ serializer classDefinitionsByteArray: buffers first.			serializer materializeGraph: buffers second ]		ifFalse: [ serializer materializeGraph: buffers first ]! !!MaObjectSerializer class methodsFor: 'debugging' stamp: 'cmm 8/23/2005 18:56'!testMaterialize: anObject	| s1 graphBuffer |	s1 := self new.	graphBuffer := s1 serializeGraph: anObject.	^ self new		classDefinitionsByteArray: s1 classDefinitionsByteArray ;		materializeGraph: graphBuffer byteArray copy! !!MaObjectSerializer class methodsFor: 'creation' stamp: 'cmm 10/15/2002 22:15'!new	^self new: 1000! !!MaObjectSerializer class methodsFor: 'creation'!new: anInteger	^super new optimumByteArraySize: anInteger! !!MaObjectSerializer class methodsFor: 'creation' stamp: 'cmm 10/25/2005 22:00'!protocol: aCollection	^ self new		protocol: aCollection ;		yourself! !MaObject subclass: #MaObjectSerializerPreferences	instanceVariableNames: 'preSerializers postSerializers postMaterializers'	classVariableNames: 'WeakIdentityKeyDictionaryClass WeakValueDictionaryClass'	poolDictionaries: ''	category: 'Ma-Serializer-Core-API'!!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!afterMaterializingAny: className do: oneArgValuator	"Set up preference for materializing instances of the class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	| valuators |	self		validate: className		has: #maWantsPostMaterialization.	valuators := 		(postMaterializers			at: className			ifAbsentPut: [ OrderedCollection new ]).	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!afterSerializingAny: className do: oneArgValuator	"Set up preference for serializing instances of class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	| valuators |	self		validate: className		has: #maWantsPreSerialization.	valuators := postSerializers		at: className		ifAbsentPut: [ OrderedCollection new ].	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!beforeSerializingAny: className do: oneArgValuator	"Set up preference for serializing instances of aClass by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization.	Note, only do this if aClass is present."	| valuators |	self		validate: className		has: #maWantsPreSerialization.	valuators := 		preSerializers			at: className			ifAbsentPut: [ OrderedCollection new ].	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/26/2004 10:17'!postMaterializers	^ postMaterializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/28/2004 17:12'!postSerializers	^ postSerializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/26/2004 10:17'!preSerializers	^ preSerializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:54'!releasePostMaterializationFor: className	"Remove all post-materialization behaviors for the class named className."	postMaterializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:55'!releasePostSerializationFor: className	"Remove all post-materialization behaviors for the class named className."	postSerializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:51'!releasePreserializationFor: className	"Remove all preserialization behaviors for the Class named className."	preSerializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'initializing' stamp: 'cmm 11/28/2004 19:22'!initialize	super initialize.	preSerializers := Dictionary new.	postSerializers := Dictionary new.	postMaterializers := Dictionary new! !!MaObjectSerializerPreferences methodsFor: 'validate' stamp: 'cmm 9/13/2013 14:09'!validate: className has: selector 	| inst cls |	className isSymbol ifFalse: [ MaObjectSerializationUserError signal: 'Specify the class *name*, not the class itself.' ].	(Smalltalk hasClassNamed: className) ifFalse: [ "No validation needed"		^ self ].	"MagmaForwardingProxy cannot understand #perform:, so we special check it by type name."	className = #MagmaForwardingProxy ifTrue: [ ^ self ].	inst := (cls:=Smalltalk at: className) someInstance		ifNil: [ cls basicNew ].	(inst perform: selector) ifFalse: [ MaObjectSerializationUserError signal: 'Need to implement ' , selector , ' on ' , className ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaObjectSerializerPreferences class	instanceVariableNames: ''!!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 11/22/2010 10:13'!defaultWeakIdentityKeyDictionaryClass	^ "MaAutoWeakDictionary supportsAutoCleaning		ifTrue: [ MaAutoWeakIdentityKeyDictionary ]		ifFalse: [ MaWeakIdentityKeyDictionary ]""Do not use AutoDictionary's for now, my initial tests show they do not collect properly..?"MaWeakIdentityKeyDictionary! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 6/14/2010 22:25'!defaultWeakValueDictionaryClass	^ MaAutoWeakDictionary supportsAutoCleaning		ifTrue: [ MaAutoIdentityKeyWeakValueDictionary ]		ifFalse: [ MaWeakValueDictionary ]! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 4/23/2011 16:56'!newWeakIdentityKeyDictionary	| dict |	dict := self weakIdentityKeyDictionaryClass new.	"There is a precendent for using a standard (strong) IdentityKeyDictionary, therefore check that it can #finalizeValues.""Don't register with WeakArray.  It might be possible for the finalization process to be finalizing at the same time access is occurring (although, since that runs at a higher-priority, it shouldn't).	However, it seems really don't need this since we clean-up from MagmaSession>>#refreshViewUsing:includingLocal: anyway.""	(dict respondsTo: #finalizeValues) ifTrue: [ WeakArray addWeakDependent: dict ]."	^ dict! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 21:13'!newWeakValueDictionary	^ self weakValueDictionaryClass new! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 6/14/2010 22:20'!weakIdentityKeyDictionaryClass	^ WeakIdentityKeyDictionaryClass		ifNil: [ self defaultWeakIdentityKeyDictionaryClass ]		ifNotNil:			[ WeakIdentityKeyDictionaryClass isAutoCleaning				ifTrue: [ self defaultWeakIdentityKeyDictionaryClass ]				ifFalse: [ WeakIdentityKeyDictionaryClass ] ]! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 20:44'!weakIdentityKeyDictionaryClass: aClass	WeakIdentityKeyDictionaryClass := aClass! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 6/14/2010 22:20'!weakValueDictionaryClass	^ WeakValueDictionaryClass		ifNil: [ self defaultWeakValueDictionaryClass ]		ifNotNil:			[ WeakValueDictionaryClass isAutoCleaning				ifTrue: [ self defaultWeakValueDictionaryClass ]				ifFalse: [ WeakValueDictionaryClass ] ]! !!MaObjectSerializerPreferences class methodsFor: 'special collections' stamp: 'cmm 4/25/2010 20:44'!weakValueDictionaryClass: aClass 	WeakValueDictionaryClass := aClass! !MaStatCollection subclass: #MaSerializationStat	instanceVariableNames: 'timeToSerializeHistory timeToMaterializeHistory houseCleaningTimeHistory'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-API'!!MaSerializationStat methodsFor: 'enumerate' stamp: 'cmm 5/7/2008 15:20'!historysDo: aBlock 	{ 		houseCleaningTimeHistory.		timeToMaterializeHistory.		timeToSerializeHistory	 } do: aBlock! !!MaSerializationStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:04'!houseCleaningTimeHistory	"MaObjectSerializers must do house-cleaning to maintain good performance but this, itself, consumes a bit of time, which is tracked by this stat."	^houseCleaningTimeHistory! !!MaSerializationStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:03'!timeToMaterializeHistory	"The time spent materializing objects.  In a client-server application, this means materializing requests on the server or responses on the client."	^timeToMaterializeHistory! !!MaSerializationStat methodsFor: 'historys' stamp: 'cmm 5/9/2008 17:03'!timeToSerializeHistory	"The time spent serializing objects.  In a client-server application, this means serializing requests on the client or responses on the server."	^timeToSerializeHistory! !!MaSerializationStat methodsFor: 'initialize-release' stamp: 'cmm 5/7/2008 17:38'!initialize	super initialize.	houseCleaningTimeHistory := MaStatHistory name: 'House Cleaning Times'.	timeToMaterializeHistory := MaStatHistory name: 'Time Spent Materializing'.	timeToSerializeHistory := MaStatHistory name: 'Time Spent Serializing'! !!MaSerializationStat methodsFor: 'ui-support' stamp: 'cmm 4/27/2009 20:50'!serializationStats	"Statistics related to local serialization and materialization of objects."	^ { 		timeToSerializeHistory.		timeToMaterializeHistory.		houseCleaningTimeHistory	 }! !