'From Squeak5.2 of 13 December 2018 [latest update: #18225] on 5 May 2021 at 9:43:48 pm'!!Object methodsFor: '*magma-client' stamp: 'cmm 12/1/2011 20:44'!addSelfToWriteBarrier: aMaxTransaction	aMaxTransaction addNormalObject: self! !!Object methodsFor: '*magma-client' stamp: 'cmm 2/24/2009 16:26'!asMagmaForwardingProxy	^ MagmaForwardingProxy for: self! !!Object methodsFor: '*magma-client' stamp: 'cmm 5/23/2013 10:32'!conflictingObjectCopy	^ self shallowCopy! !!Object methodsFor: '*magma-client' stamp: 'cmm 7/17/2010 11:16'!hash32	"Answer my hash, ensuring not to exceed 32-bits."	^ self hash \\ (1 bitShift: 32)! !!Object methodsFor: '*magma-client' stamp: 'cmm 11/13/2011 16:02'!immutabilityStrategy	^ MaImmutabilityStrategy new		treatAny: String		asImmutableIf: [ : string | true ] ; 		yourself! !!Object methodsFor: '*magma-client' stamp: 'cmm 4/28/2014 10:10'!isDirtyInMagma	"If I was read from a Magma database, and I've changed since being read, answer true.  Otherwise, false."	^ self magmaSession isDirty: self! !!Object methodsFor: '*magma-client' stamp: 'cmm 4/8/2005 12:40'!isImmutableInMagma	"This is used to help determine whether I should be stored in Magma's 'readSet', which is used to track changes.  But changes to some objects, such as Symbols, Blocks, CompiledMethods or logically-referenced globals are not tracked.  Therefore, there is no reason to bloat the readSet (not to mention when refreshPersistentObjectsEvenWhenChangedOnlyByMe is true, it won't try to refresh the unrefreshable."	^ self maInstSize = 0! !!Object methodsFor: '*magma-client' stamp: 'cmm 7/6/2009 21:21'!isMagmaId	^ false! !!Object methodsFor: '*magma-client' stamp: 'cmm 1/28/2005 00:16'!isMagmaServerResult	^ false! !!Object methodsFor: '*magma-client' stamp: 'cmm 5/22/2018 22:35'!maAllowsWriteBarrier	"Override in subclasses, if desired."	"Objects *can* change during serialization (such as when the first instance of a new class is added, the classDefinitions will change), so we cannot #suspendWriteBarrierModifiedsWhile: serializing.  However, we don't want to pick up changes due to #maWantsPreSerialization, because that hook does not cause the readSet to expand when not using WriteBarrier, therefore we don't want it to when using the WriteBarrier (we want the behavior to be consistent)."	^ self isImmutableInMagma not and: [ self maWantsPreSerialization not ]! !!Object methodsFor: '*magma-client' stamp: 'apg 4/25/2005 10:06'!maIsAssociation	^ false! !!Object methodsFor: '*magma-client' stamp: 'cmm 11/8/2014 12:25'!maIsChangedFrom: aMaVariableObjectBuffer using: aMaObjectSerializer 	"I am variable."	aMaVariableObjectBuffer isPointers 		ifFalse: 			[MagmaSoftwareError signal: self maOriginalClass name 						, ' should implement maIsChangedFrom:using:.'].	1 to: self maInstSize		do: 			[:index | 			(index > self maOriginalClass instSize 				or: [(self maIsTransient: index) not]) 					ifTrue: 						[(aMaObjectSerializer oidFor: (self slotAt: index)) 							~= (aMaVariableObjectBuffer maInstVarAt: index) ifTrue: [^true]]].	^false! !!Object methodsFor: '*magma-client' stamp: 'cmm 11/10/2014 10:31'!maRefreshTo: aMaVariableBuffer using: aMagmaSession 	"I am variable."	self maOriginalClass isBytes		ifTrue:			[ self				replaceFrom: 1				to: self size				with: aMaVariableBuffer asByteArray				startingAt: 1 ]		ifFalse:			[ "I am pointers or words."			aMaVariableBuffer instVarsDoWithIndex:				[ : eachOid : eachIndex |				self					slotAt: eachIndex					put: (aMagmaSession serializer objectWithOid: eachOid) ] ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/30/2013 17:42'!magmaBuffer	"The database buffer representing this object."	^ self magmaSession ifNotNil:		[ : sess | sess bufferFor: self ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/19/2013 14:05'!magmaCommitLogEntry	^ self magmaSession ifNotNil: [ : sess | sess commitLogEntryAt: self magmaCommitNumber ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/19/2013 14:00'!magmaCommitLogRecord	^ self magmaSession ifNotNil: [ : sess | sess commitLogRecordAt: self magmaCommitNumber ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/19/2013 13:51'!magmaCommitNumber	"The database buffer representing this object."	^ self magmaBuffer ifNotNil: [ : buffer | buffer commitNumber ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/20/2013 18:43'!magmaCommitPackage	"The package of objects which were part of the same commit as this objects last commit."	^ self magmaSession ifNotNil: [ : sess | sess commitPackageAt: self magmaCommitNumber ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/20/2013 18:42'!magmaLastUpdated	"The DateAndTime this object was lastUpdated.  If this information is no longer available in the commit logs, nil."	^ self magmaCommitLogRecord ifNotNil:		[ : rec | rec timestamp ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/20/2013 18:52'!magmaLastUpdaterSessionId	"The sessionId (UUID) of the last session that updated this object.  If this information is no longer available in the commit logs, nil."	^ self magmaCommitLogEntry ifNotNil:		[ : entry | entry connection sessionId ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 6/20/2013 18:52'!magmaLastUpdaterUserId	"The userId of the last session that updated this object.  If this information is no longer available in the commit logs, nil."	^ self magmaCommitLogEntry ifNotNil:		[ : entry | entry connection userId ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 3/23/2009 18:00'!magmaOid	^ self magmaSession ifNotNilDo: [ : sess | sess oidFor: self ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 3/6/2011 20:18'!mcModel	^ self isInMagma ifTrue: [ self magmaSession mcModel ]! !!Object methodsFor: '*magma-client' stamp: 'cmm 12/22/2012 14:06'!mergeConflicting: anObject	^ false! !!Object methodsFor: '*magma-client' stamp: 'cmm 7/10/2014 13:03'!needsRepair	"Generic implementation of a #needsRepair.  If proper convention of signaling a MagmaRepairNotification every time a piece of bad data is found, then no MagmaDataRepair's should need to specify any check block other than 'each needsRepair'."	[ self repair ]		on: MagmaRepairNotification		do:			[ : noti | "Let the repair notification be printed to the log."			MagmaRepairNotification signal: noti messageText.			^ true ].	^ false! !!Object methodsFor: '*magma-client' stamp: 'cmm 1/16/2014 14:10'!postRefreshUsing: aMaObjectBuffer for: aMagmaSession	aMagmaSession transaction		markRead: self		using: aMaObjectBuffer! !