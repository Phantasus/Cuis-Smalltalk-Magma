MaObject subclass: #MaBufferPositionMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaBufferPositionMap commentStamp: 'cmm 8/26/2008 02:36' prior: 0!This is an abstraction for the attributes available on a MaObjectBuffer.  Subclasses may override and extend.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaBufferPositionMap class	instanceVariableNames: ''!!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/1/2011 13:51'!bufferPositionOfByteCodesPlusTrailerSize	^ 22! !!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/10/2010 15:50'!bufferPositionOfClassVersion	"Zero-based position."	^ 16! !!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/1/2011 13:08'!bufferPositionOfMethodHeader	^ 18! !!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/10/2010 15:23'!headerSize	"The standard record has 18 bytes of header."	^ 18! !!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/4/2011 21:32'!headerSizeForCompiledMethodBuffer	^ 26! !!MaBufferPositionMap class methodsFor: 'as yet unclassified' stamp: 'cmm 8/27/2008 20:53'!indexPosition	"Reserve the 0-based particular slot for this attribute map."	^ 0! !MaObject subclass: #MaClassIdManager	instanceVariableNames: 'classesById idsByClass nextClassId classDefinitionsById inImageDefinitions minimumClasses mutable'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaClassIdManager commentStamp: 'cmm 6/11/2004 16:53' prior: 0!classDefinitionsById -- all versions of all classes that I know about inImageDefinitions -- the in-image version of each class I know about.!!MaClassIdManager methodsFor: 'building' stamp: 'cmm 8/24/2011 21:11'!addClassDefinition: aMaClassDefinition 	| definitions answer |	definitions := self ensureClassDefinitionsFor: aMaClassDefinition.	(answer := self		definitionLike: aMaClassDefinition		in: definitions) ifNil:		[ answer := aMaClassDefinition.		aMaClassDefinition version = 0			ifTrue:				[ definitions add: aMaClassDefinition.				aMaClassDefinition version: definitions size ]			ifFalse:				[ [ definitions size < aMaClassDefinition version ] whileTrue: [ definitions add: nil ].				definitions					at: aMaClassDefinition version					put: aMaClassDefinition ] ].	answer isDefined ifTrue:		[ self			idOfClass: answer classObject			is: answer id.		self refreshInImageDefinition: answer classObject.		(answer superclassDefinition isNil and: [ answer classObject superclass ~= nil ]) ifTrue:			[ self addNewClass: answer classObject superclass.			answer initializeSuperclassDefinitionUsing: self ] ].	^ answer! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 11/30/2011 20:48'!addNewClass: aClass 	"Answer the storage definition created for aClass."	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ self addClassDefinition: (self newDefinitionNamed: aClass name)! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 8/23/2007 16:25'!beImmutable	mutable := false! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 12/11/2013 17:08'!idOfClass: aClass is: anInteger 	mutable ifFalse: 		[ (classesById includesKey: anInteger) ifFalse: 			[ MaObjectSerializationSoftwareError signal: '#protocol extension not allowed (' , aClass printString , ').' ] ].	nextClassId := nextClassId max: anInteger.	classesById 		at: anInteger		put: aClass.	^ idsByClass 		at: aClass		put: anInteger! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 6/30/2013 21:13'!refreshInImageDefinition: aClass 	"Whenever the user recompiles a class in the image (e.g., during development)."	({Object. 	ProtoObject} includes: aClass) ifTrue:		[ (self hasClassDefinitionFor: aClass) ifTrue:			[ inImageDefinitions				at: aClass				ifAbsentPut: [ "We should only ever have one definition of Object or ProtoObject."					(self classDefinitionsForClass: aClass) last ].			^ self"performance" ] ].	aClass withAllSubclassesDo:		[ : eachClass | | knownDefinitions | (eachClass = aClass or: [ self includesIdForClass: eachClass ]) ifTrue:			[ knownDefinitions := (self hasClassDefinitionFor: eachClass)				ifTrue: [ self classDefinitionsForClass: eachClass ]				ifFalse: [ Array empty ].			inImageDefinitions				at: eachClass				put:					(knownDefinitions						maDetect: [ : each | each notNil and: [ each hasSameDefinitionAs: eachClass ] ]						ifFound:							[ : foundDef | "In the rare case, where a classdef was materialized but not defined in the image, so it was added to definitions only.  Now we're defining it so we need to be sure we set up its mappings."							self								idOfClass: eachClass								is: foundDef id.							foundDef ]						ifNone: [ self newDefinitionNamed: eachClass name ]) ] ]! !!MaClassIdManager methodsFor: 'accessing'!classDefinitionsById	^classDefinitionsById! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 5/19/2018 17:12'!classDefinitionsById: aDictionary 	classDefinitionsById := aDictionary.	"One day I encountered a class in an external package whose class name was a WideString (with special characters in it).  To be able to use such class, Magma would need WideString in its minimumClasses (as this is the set of classes required to materialize the classDefinitionsById Dictionary, which has MaClassDefinitions as its values).	HOWEVER, some databases already have WideString incidentally from objects in their domain.  If this is the case, we must remove it from the minimumClasses to avoid an ambigous classId assignment!!"	aDictionary		detect:			[ : each | each anyOne className = #WideString ]		ifFound:			[ : defs | defs anyOne id = (minimumClasses indexOf: WideString) ifFalse: [ minimumClasses := minimumClasses copyWithout: WideString ] ]		ifNone: [ "rebuildTransientClassMaps will end up putting it in, 'resulting in a dirty classDefinitionsById only upon opening." ].	self rebuildTransientClassMaps! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/17/2004 22:39'!classDefinitionsForClass: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ self classDefinitionsForId: (self idForClass: aClass)! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 8/22/2005 09:23'!classDefinitionsForId: anInteger	^ self		classDefinitionsForId: anInteger		ifAbsent: [ MaObjectSerializationSoftwareError signal: 'class-definition not found' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/12/2004 22:16'!classDefinitionsForId: anInteger ifAbsent: aBlock	^ anInteger		ifNil: [ aBlock value ]		ifNotNil:			[ classDefinitionsById				at: anInteger				ifAbsent: aBlock ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/8/2004 16:13'!classForId: anInteger	^ self		classForId: anInteger		ifAbsent: [ self error: anInteger printString, ' is not a known class id.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 12:46'!classForId: anInteger ifAbsent: aBlock	^ anInteger <= minimumClasses size		ifTrue:			[ minimumClasses at: anInteger ]		ifFalse:			[ classesById				at: anInteger				ifAbsent: aBlock ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/17/2004 22:39'!currentVersionOfClass: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ (self		inImageDefinition: aClass		ifAbsent: [ ^ 1 ]) version! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 3/23/2005 13:25'!definitionForClassId: classIdInteger version: classVersionInteger	^ classVersionInteger = 0		ifTrue: [ self inImageDefinition: (self classForId: classIdInteger) ]		ifFalse: [ (self classDefinitionsForId: classIdInteger) at: classVersionInteger ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/11/2018 22:16'!ensureClassDefinitionsFor: aMaClassDefinition 	"Look for the collection of versions of the same class that aMaClassDefinition is for.  If none exist create and answer the new collection that will hold aMaClassDefinition and its future versions."	^ (aMaClassDefinition id notNil and: [ classDefinitionsById includesKey: aMaClassDefinition id ])		ifTrue: [ classDefinitionsById at: aMaClassDefinition id ]		ifFalse:			[ classDefinitionsById				detect:					[ : eachDefinitions | eachDefinitions anySatisfy:						[ : each | each notNil and: [ each isKnownAs: aMaClassDefinition className ] ] ]				ifFound:					[ : defs | "If new version of existing in-image class, make sure it's id is set!!"					aMaClassDefinition hasId ifFalse: [ aMaClassDefinition id: defs first id ].					defs ]				ifNone:					[ | id class |					"None found, create one.  First, figure out the id."					id := aMaClassDefinition hasId						ifTrue: [ aMaClassDefinition id ]						ifFalse:							[ "Okay, new class, increment classId and assign it.  Oh, but make sure this is not one of the minimumClasses which get added here during initialization."							class := Smalltalk classNamed: aMaClassDefinition className.							(class notNil and: [ self isMemberOfMinimumClasses: class ])								ifTrue: [ self idForClass: class ]								ifFalse: [ self nextClassId ] ].					aMaClassDefinition id: id.					classDefinitionsById						at: id						put: (OrderedCollection new: 1) ] ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 8/26/2002 22:03'!idForClass: aClass	^self		idForClass: aClass		ifAbsent: [ MaSoftwareError signal: aClass name, ' has no id assigned.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/20/2007 11:52'!idForClass: aClass ifAbsent: aBlock 	| index |	aClass isMeta ifTrue: 		[ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ idsByClass 		at: aClass		ifAbsent: 			[ (index := minimumClasses indexOf: aClass) > 0 				ifTrue: [ index ]				ifFalse: [ aBlock value ] ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/6/2004 19:46'!inImageDefinition: aClass	^ self		inImageDefinition: aClass		ifAbsent: [ self error: aClass name, ' is not part of my inImageDefinitions.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/15/2004 11:58'!inImageDefinition: aClass ifAbsent: aBlock	^ inImageDefinitions		at: (aClass isMeta ifTrue: [ Metaclass ] ifFalse: [ aClass ])		ifAbsent: aBlock! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 12:46'!minimumClasses	^ minimumClasses! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 14:38'!numberOfClasses	^ classDefinitionsById size! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 3/16/2009 20:43'!protocol	"Calculate and answer the protocol based on assigned classId's (which, because superclasses are added, may not match the original protocol set).  This is used for fileingout a single object, the user is not burdened with protocol, it is calculated and stored with the object."	^ ((self classDefinitionsById select: [ : each | each anyOne id > self initialClassId ]) asSortedCollection: [ : a : b | a anyOne id < b anyOne id ]) collect: [ : each | each anyOne classObject ]! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 8/23/2011 21:55'!definitionLike: aMaClassDefinition in: definitionsCollection 	definitionsCollection isEmpty ifTrue: [ ^ nil ].	(definitionsCollection anySatisfy:		[ : each | each className = aMaClassDefinition className ]) ifFalse: [ ^ nil ].	(definitionsCollection includes: aMaClassDefinition) ifTrue: [ ^ aMaClassDefinition ].	^ definitionsCollection		detect:			[ : eachDef | eachDef notNil and: [ eachDef hasSameDefinitionAs: aMaClassDefinition ] ]		ifNone: [ nil ]! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 2/10/2012 15:38'!hasClassDefinitionFor: aClass 	| foundQuickly |	foundQuickly := inImageDefinitions		at: aClass		ifPresent: [ : definition | definition isPartOfClassDefinitions ]		ifAbsent: [ false ].	^ foundQuickly or:		[ classDefinitionsById anySatisfy:			[ : eachDefinitions | (eachDefinitions last isKnownAs: aClass name) and:				[ eachDefinitions anySatisfy:					[ : each | each notNil and: [ each hasSameDefinitionAs: aClass ] ] ] ] ]! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 6/30/2004 00:03'!includesIdForClass: aClass	^ idsByClass includesKey: aClass! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 7/11/2005 12:46'!isMemberOfMinimumClasses: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ minimumClasses includes: aClass! !!MaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/1/2004 15:21'!handleClassModification: aClass using: aMaObjectSerializer	"Optional subclass hook."! !!MaClassIdManager methodsFor: 'copy' stamp: 'cmm 3/23/2013 17:11'!independentCopyself maMarked: 'delete'.	^ self copy postIndependentCopy! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 5/20/2010 14:26'!initialClassId	^ 1000! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 3/16/2009 20:29'!initialize	super initialize.	idsByClass := Dictionary new.	classesById := Dictionary new.	nextClassId := self initialClassId.	inImageDefinitions := Dictionary new.	mutable := true.	self classDefinitionsById: Dictionary new.	self initializeMinimumClasses! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 5/19/2018 17:04'!initializeMinimumClasses	| legacyDefinitions minimumClassDefs |	legacyDefinitions := OrderedCollection new.	"In Squeak 3.9, there were only 14 minimumClasses numbered from (101 to: 114).  115 was the first user class-id, but as-of Squeak 4.1, the hierarchy changed and HashedCollection is extra and would try to occupy 115 when initializing the minimumClasses.  This made me realize minimumClasses could change, and therefore needed some buffer space.  Therefore, I made HashedCollection 90 and set the first user classId up to 1000 so it won't happen again!!"	(Smalltalk classNamed: #HashedCollection)		ifNil: [ Array empty ]		ifNotNilDo: 			[ : cls | 			legacyDefinitions add:				((self newDefinitionNamed: cls name)					id: 90 ;					yourself) ].	minimumClasses := self class minimumClasses.	self legacyClassMap do: 		[ : each | 		legacyDefinitions add:			((self newDefinitionNamed: each value name)				id: each key ;				yourself) ].	"Reserve those legacy id's first."	minimumClassDefs := legacyDefinitions collect: [ : each | self primAddClassDefinition: each ].	nextClassId := 1000.	"Now add them using the normal API so that their superlcass defs will get defined too."	minimumClassDefs do: [ : each | self addClassDefinition: each ].	"Finally, make sure any that were added as minimumClasses since those legacy ones are also included."	minimumClasses do: [ : each | (self hasClassDefinitionFor: each) ifFalse: [ self addNewClass: each ] ]! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 2/25/2008 16:36'!isMutable	^ mutable! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 7/14/2010 14:28'!legacyClassMap	^ { 		(1 -> Metaclass).		(2 -> Class).		(3 -> MaClassReference).		(4 -> MaClassDefinition).		(5 -> Boolean).		(6 -> SmallInteger).		(7 -> Character).		(8 -> Float).		(9 -> UndefinedObject).		(10 -> Array).		(11 -> ByteSymbol).		(12 -> ByteString).		(13 -> ByteArray).		(14 -> Set).		(15 -> OrderedCollection).		(16 -> Dictionary).		(17 -> True).		(18 -> False).		(101 -> ClassDescription).		(102 -> Behavior).		(103 -> Object).		(104 -> ProtoObject).		(105 -> MaGlobalReference).		(106 -> MaObject).		(107 -> Integer).		(108 -> Number).		(109 -> Magnitude).		(110 -> ArrayedCollection).		(111 -> SequenceableCollection).		(112 -> Collection).		(113 -> Symbol).		(114 -> String)	 }! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 11/30/2011 20:46'!newDefinitionNamed: className 	^ MaClassDefinition className: className! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 8/15/2002 23:53'!nextClassId	^nextClassId := nextClassId + 1! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 3/23/2013 17:12'!postIndependentCopyself maMarked: 'delete'.	classesById := classesById copy.	idsByClass := idsByClass copy.	classDefinitionsById := classDefinitionsById copy.	inImageDefinitions := inImageDefinitions copy! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 8/24/2011 21:05'!primAddClassDefinition: aMaClassDefinition 	"Add only aMaClassDefinition without any of its superclasses."	| definitions answer |	definitions := self ensureClassDefinitionsFor: aMaClassDefinition.	(answer := self		definitionLike: aMaClassDefinition		in: definitions) ifNil:		[ answer := aMaClassDefinition.		aMaClassDefinition version = 0			ifTrue:				[ definitions add: aMaClassDefinition.				aMaClassDefinition version: definitions size ]			ifFalse:				[ definitions					at: aMaClassDefinition version					put: aMaClassDefinition ] ].	answer isDefined ifTrue:		[ self			idOfClass: answer classObject			is: answer id.		self refreshInImageDefinition: answer classObject ].	^ answer! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 9/28/2009 11:43'!rebuildTransientClassMaps	| highestId |	idsByClass := idsByClass maOriginalClass new: idsByClass size.	classesById := classesById maOriginalClass new: classesById size.	inImageDefinitions := inImageDefinitions maOriginalClass new: inImageDefinitions size.	highestId := 0.	classDefinitionsById keysAndValuesDo: 		[ : eachId : eachDefinitions | 		| eachClass |		highestId := highestId max: eachId.		eachDefinitions do: 			[ : each | 			each isDefined ifTrue: 				[ eachClass := each classObject.				self 					idOfClass: eachClass					is: eachId.				self refreshInImageDefinition: eachClass ] ] ].	nextClassId := highestId max: nextClassId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClassIdManager class	instanceVariableNames: ''!!MaClassIdManager class methodsFor: 'accessing' stamp: 'cmm 1/21/2018 14:54'!minimumClasses	"These are the classes required to transmit a MaClassDefinition, used to establish protocol between two images."	^ { Metaclass.  Class.  MaClassReference.  MaClassDefinition.	"These atomic types are needed for backward compatibility with version 8."	Boolean. SmallInteger. Character. Float. UndefinedObject.	Array. #size class. '' class. ByteArray. Set.  OrderedCollection. Dictionary.	"Added these at the end for backward compatibility.  Boolean was not the right one, you need the exact classes!!"	True. False.	WideString } ! !MaObject subclass: #MaGlobalReference	instanceVariableNames: 'globalName'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaGlobalReference methodsFor: 'private'!globalName	^globalName! !!MaGlobalReference methodsFor: 'private'!globalName: aSymbol	globalName := aSymbol! !!MaGlobalReference methodsFor: 'accessing' stamp: 'cmm 9/6/2012 18:11'!globalObject	^ Smalltalk classNamed: self globalName! !!MaGlobalReference methodsFor: 'printing' stamp: 'cmm 4/22/2002 22:25'!maPrintAbbreviatedOn: aStream	aStream nextPutAll: self globalName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaGlobalReference class	instanceVariableNames: ''!!MaGlobalReference class methodsFor: 'creation'!globalName: aSymbol	^self new globalName: aSymbol! !MaGlobalReference subclass: #MaClassReference	instanceVariableNames: 'id'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaClassReference methodsFor: 'accessing'!className	^self globalName! !!MaClassReference methodsFor: 'accessing'!classObject	^self globalObject! !!MaClassReference methodsFor: 'accessing' stamp: 'cmm 6/23/2004 00:03'!hasId	^ self id notNil! !!MaClassReference methodsFor: 'accessing'!id	^id! !!MaClassReference methodsFor: 'accessing' stamp: 'cmm 1/1/2003 23:52'!name	"For interface compatibility with Class."	^self className! !!MaClassReference methodsFor: 'building'!className: aSymbol	self globalName: aSymbol! !!MaClassReference methodsFor: 'building' stamp: 'cmm 5/18/2018 18:21'!id: anInteger	(id notNil and: [id~=anInteger]) ifTrue: [ MaObjectSerializationSoftwareError signal ].	id := anInteger! !!MaClassReference methodsFor: 'testing' stamp: 'cmm 2/11/2012 16:51'!isDefinition	^ false! !!MaClassReference methodsFor: 'private' stamp: 'cmm 5/2/2005 15:20'!maWantsPreSerialization	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClassReference class	instanceVariableNames: ''!!MaClassReference class methodsFor: 'creation' stamp: 'cmm 6/28/2004 18:05'!className: aSymbol	^ self globalName: aSymbol! !MaClassReference subclass: #MaClassDefinition	instanceVariableNames: 'instVarNames version superclassDefinition category type comment commentStamp classVarNames poolDictionaryNames classInstVarNames aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 12/19/2002 21:45'!allInstVarNames	^instVarNames! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 9/26/2009 19:08'!allSuperclassDefinitions	^ Array streamContents: 		[ : stream | 		self allSuperclassDefinitionsDo: [ : each | stream nextPut: each ] ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 9/6/2012 18:12'!ensureClassUsing: aMaObjectSerializer 	^ self classObject ifNil: [ self createClassUsing: aMaObjectSerializer ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 9/6/2012 18:16'!globalObject	^ super globalObject ifNil:		[ aliases do:			[ : each | (Smalltalk classNamed: each) ifNotNil:				[ : cls | ^ cls ] ].		nil ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 6/16/2004 22:40'!indexOfInstVarCorrespondingTo: instVarIndex of: anotherMaClassDefinition	"Answer the index of the instVar in me that corresponds to the one at instVarIndex in anotherMaClassDefinition."	self == anotherMaClassDefinition ifTrue: [ ^ instVarIndex ].	"different versions, determine if instVarIndex refers to a named or indexed var"	^ instVarIndex > anotherMaClassDefinition allInstVarNames size		ifTrue:			[ "indexed inst var" 			self allInstVarNames size + (instVarIndex - anotherMaClassDefinition allInstVarNames size) ]		ifFalse:			[ "find the instVar with the same name."			self allInstVarNames				indexOf: (anotherMaClassDefinition allInstVarNames at: instVarIndex) ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 12/19/2002 21:43'!namedInstSize	^self allInstVarNames size! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 6/11/2004 00:55'!superclassDefinition	^ superclassDefinition! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 6/10/2004 23:49'!superclassName	^ superclassDefinition className! !!MaClassDefinition methodsFor: 'accessing'!version	^version! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 1/26/2005 13:06'!allSuperclassDefinitionsDo: oneArgBlock	"Value oneArgBlock with each of my superclass-definitions, in turn."	superclassDefinition ifNotNil: [ superclassDefinition withAllSuperclassDefinitionsDo: oneArgBlock ]! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 3/8/2005 13:51'!createClassUsing: aMaObjectSerializer	| superClass |	superClass := self superclassDefinition ensureClassUsing: aMaObjectSerializer.	^ SystemChangeNotifier uniqueInstance doSilently:		[ ((ClassBuilder new)			name: self className			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category)						ifNotNilDo:				[ : class |				aMaObjectSerializer classIdManager					idOfClass: class					is: self id.				class class instanceVariableNames: self classInstanceVariablesString.				class hasComment					ifTrue: 						[ class 							classComment: comment 							stamp: commentStamp ].				aMaObjectSerializer classIdManager refreshInImageDefinition: class.				class ] ]! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 10/17/2004 15:04'!withAllSuperclassDefinitionsDo: oneArgBlock	"Value oneArgBlock with myself, then each of my superclass-definitions, in turn."	oneArgBlock value: self.	superclassDefinition ifNotNil: [ superclassDefinition withAllSuperclassDefinitionsDo: oneArgBlock ]! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:38'!classInstanceVariablesString	^ self stringForVariables: classInstVarNames! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:37'!classVariablesString	^ self stringForVariables: classVarNames! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 10/13/2004 23:50'!initialize	super initialize.	self version: 0.	aliases := OrderedCollection new! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 6/10/2004 23:43'!initializeFrom: aClass	self globalName: aClass name.	instVarNames := aClass allInstVarNames.	classVarNames := aClass classVarNames.	poolDictionaryNames := aClass poolDictionaryNames.	classInstVarNames := aClass class instVarNames.	category := aClass category.	type := aClass typeOfClass.	comment := aClass organization classComment asString.	commentStamp := aClass organization commentStamp! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 10/13/2004 13:03'!instanceVariablesString	^ self stringForVariables: (instVarNames copyWithoutAll: superclassDefinition allInstVarNames)! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:35'!sharedPoolsString	^ self stringForVariables: poolDictionaryNames! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:34'!stringForVariables: aCollection	^ String streamContents:		[ :stream |		aCollection			do: [ :ea | stream nextPutAll: ea ]			separatedBy: [ stream space ] ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 5/20/2010 15:19'!hasSameDefinitionAs: aClassOrMaClassDefinition 	"Answer whether my definition is the same as aClassOrMaClassDefinition.  However, since Ma serializes only above the Smalltalk meta-layer, don't acknowledge differences in Class or Metaclass."	^ (self name = #Class or: [ self name = #Metaclass ])		or: [ self allInstVarNames maMatchesElementsOf: aClassOrMaClassDefinition allInstVarNames ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 9/6/2012 18:06'!isDefined	^ (Smalltalk hasClassNamed: self className) or:		[ aliases anySatisfy:			[ : each | Smalltalk hasClassNamed: each ] ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 2/11/2012 16:51'!isDefinition	^ true! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 10/13/2004 23:53'!isKnownAs: className	^ self name = className	or: [ aliases includes: className ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 6/7/2004 21:35'!isPartOfClassDefinitions	^ version > 0! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 11/26/2004 15:12'!maWantsPostMaterialization	^ true! !!MaClassDefinition methodsFor: 'building' stamp: 'cmm 8/24/2011 16:42'!initializeSuperclassDefinitionUsing: aMaClassIdManager 	| superclassDefinitions |	superclassDefinitions := aMaClassIdManager classDefinitionsForClass: self classObject superclass.	superclassDefinition := superclassDefinitions		detect:			[ : each | each notNil and: [ each hasSameDefinitionAs: self classObject superclass ] ]		ifNone: [ aMaClassIdManager inImageDefinition: self classObject superclass ]! !!MaClassDefinition methodsFor: 'building' stamp: 'cmm 6/23/2004 13:49'!version: anInteger	version := anInteger! !!MaClassDefinition methodsFor: 'printing' stamp: 'cmm 6/24/2004 14:42'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttribute: #version		on: aStream! !!MaClassDefinition methodsFor: '*magma-client' stamp: 'cmm 9/6/2012 17:55'!beKnownAs: newClassName	self className ifNotNil: [ aliases add: self className ].	self className: newClassName! !!MaClassDefinition methodsFor: '*magma-client' stamp: 'cmm 10/28/2011 15:38'!inheritDeeperDepthsFrom: superMaClassDefinition using: depthsDictionary 	"Look in depthsDictionary for a depthSpec (anInteger or Array of Integers) for superMaClassDefinition.  If has been specified,  answer an enhanced 'spec' that is the deeper between it and the depth-spec for me."	superMaClassDefinition allInstVarNames withIndexDo: 		[ : each : index | 		depthsDictionary 			at: { 					(superMaClassDefinition id).					(superMaClassDefinition version)				 }			ifPresent: 				[ : superSpec | 				| mySpec superDepth |				superDepth := superSpec isInteger 					ifTrue: [ superSpec ]					ifFalse: [ superSpec at: index ].				mySpec := depthsDictionary at: {  id. version  }.				mySpec isInteger 					ifTrue: 						[ depthsDictionary 							at: {  id. version  }							put: (mySpec max: superDepth) ]					ifFalse: 						[ mySpec 							at: index							put: ((mySpec at: index) max: superDepth) ] ]			ifAbsent: 				[ "No spec for this superclass, nothing to inherit."				 ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaClassDefinition class	instanceVariableNames: ''!!MaClassDefinition class methodsFor: 'creation' stamp: 'cmm 6/16/2004 11:26'!className: aSymbol	^(super className: aSymbol)		initializeFrom: (Smalltalk classNamed: aSymbol) ;		yourself! !MaObject subclass: #MaOidCalculator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'MaSerializerConstants'	category: 'Ma-Serializer-Core-private'!!MaOidCalculator commentStamp: 'cmm 12/3/2014 10:48' prior: 0!The oid ranges are as follows:The range from (0 to: SmallInteger maxVal - SmallInteger minVal) are reserved for:  user objects, the non-integral atomics including 65536 characters and space for 4000000 new-object oids (bigger than any transaction should ever be!!).  We should allow a few thousand for future-use as well.SmallInteger minVal actually starts at the oid with the value SmallInteger maxVal + 1.  Thus, SmallInteger maxVal has the oidWe start at the bottom so user-objects are contiguous above    a   n u m b e r   l i n e|<--- SmallInteger range -------------->|< - - - - - -  LargeInteger range - - - - - - - - - ->|atomics | chars | new objects          |    user objects             | Floats | SmallIntegers  |0	nil1	false2	true3	indicate an unused slot in a MaHashIndex4 to: 65539	DB character-set (only SB currently supported)65540 to: 66540	future use?66541 to: 66541 + 4000000  "no more than four-million new objects are allowed in a single commit."	new-object oids4066542 to: 281468533259712 (self oidForSmallestFloat-1)	user objects281468533259713 to: self oidForSmallestOptimizedInteger-1	32-bit IEEE floats281472829227008 to: 281474976710655	SmallIntegers!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaOidCalculator class	instanceVariableNames: ''!!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 4/29/2005 12:20'!firstCharacterOid	^ 4! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 6/1/2005 09:13'!firstUserObjectOid	^ 4066542! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 4/29/2005 12:21'!lastCharacterOid	"^self firstCharacterOid + 65535"   "DBCS"	^ 65539! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 4/21/2005 15:41'!lastUserObjectOid	^ 281468533259712   "self oidForSmallestFloat - 1"! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 9/1/2002 22:54'!newOidMinimum	^66541! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 12/3/2014 10:56'!objectWithOid: anInteger ifNone: aBlock 	anInteger == OidForNil ifTrue: [ ^ nil ].	anInteger == OidForFalse ifTrue: [ ^ false ].	anInteger == OidForTrue ifTrue: [ ^ true ].	(anInteger		between: FirstFloatOid		and: LastFloatOid) ifTrue: [ ^ self floatFromOid: anInteger ].	(anInteger		between: FirstSmallIntegerOid		and: LastSmallIntegerOid) ifTrue: [ ^ self integerFromOid: anInteger ].	(anInteger		between: FirstCharacterOid		and: LastCharacterOid) ifTrue: [ ^ Character value: anInteger - FirstCharacterOid ].	^ aBlock value! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 12/3/2014 10:40'!oidForCharacter: aCharacter 	^ FirstCharacterOid + aCharacter asciiValue! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:41'!oidForFalse	^1! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:37'!oidForNil	^0! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:41'!oidForTrue	^2! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 12/2/2014 22:15'!floatFromOid: anInteger 	^ Float fromIEEE32Bit: anInteger - FirstFloatOid! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 12/2/2014 22:12'!isOidForFloat: oidInteger 	^ oidInteger		between: FirstFloatOid		and: LastFloatOid! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 12/2/2014 22:12'!oidForFloat: aFloat 	^ aFloat asIEEE32BitWord + FirstFloatOid! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 12/2/2014 22:17'!oidForSmallestFloat	^ 281468533259713! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 12/2/2014 22:14'!integerFromOid: oidInteger 	^ oidInteger - OidForZero! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 12/3/2014 10:38'!isOidForOptimizedInteger: oidInteger	^ oidInteger		between: FirstSmallIntegerOid  "self oidForZero + SmallInteger minVal"		and: LastSmallIntegerOid  "self oidForZero + SmallInteger maxVal"! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 12/2/2014 22:22'!oidForInteger: anInteger 	^ anInteger + OidForZero! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 12/2/2014 22:26'!oidForSmallestOptimizedInteger	"Hard-code to avoid potential problems when moving to 64-bit Squeak."	^ self oidForInteger: -1073741824 "SmallInteger minVal"! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 6/1/2005 09:42'!oidForZero	"^16rFFFFFFFFFFFF - SmallInteger maxVal"	^ 281473902968832! !!MaOidCalculator class methodsFor: 'testing' stamp: 'cmm 12/3/2014 10:40'!isOidForOptimizedObject: oidInteger 	"Answer whether oidInteger is an oid for anObject which will never require its own buffer.  These include optimized Integers, nil, true, false, and all Characters."	^ oidInteger <= LastCharacterOid or: [ oidInteger >= FirstFloatOid ]! !!MaOidCalculator class methodsFor: '*magma-client' stamp: 'cmm 12/3/2014 10:46'!indexPositionForOid: anInteger 	^ anInteger - FirstUserObjectOid + 1! !!MaOidCalculator class methodsFor: '*magma-client' stamp: 'cmm 12/2/2014 21:04'!isOidForNewObject: anInteger 	^ anInteger		between: FirstNewObjectOid		and: LastNewObjectOid! !!MaOidCalculator class methodsFor: '*magma-client' stamp: 'cmm 12/3/2014 10:53'!isOidForUserObject: anInteger	"A 'user' object is a persistent object stored in a Magma database that does not have a special oid, such as SmallIntegers, Floats, Booleans, etc. have."	^anInteger		between: FirstUserObjectOid		and: LastUserObjectOid! !!MaOidCalculator class methodsFor: '*magma-client' stamp: 'cmm 12/3/2014 10:49'!oidForFilePositionIndexPosition: anInteger 	^ FirstUserObjectOid + anInteger! !!MaOidCalculator class methodsFor: '*magma-client-debugging' stamp: 'cmm 7/18/2005 10:53'!infoFor: oidInteger	| obj |	obj :=		self			objectWithOid: oidInteger			ifNone:				[ ^(self isOidForNewObject: oidInteger)					ifTrue: [ 'new object' ]					ifFalse: [ 'index position: ', (self indexPositionForOid: oidInteger) printString ] ].	^'(' , obj printString , ')'! !MaObject subclass: #MaOidManager	instanceVariableNames: 'objects oids nextOid'	classVariableNames: ''	poolDictionaries: 'MaSerializerConstants'	category: 'Ma-Serializer-Core-private'!!MaOidManager methodsFor: 'actions' stamp: 'cmm 6/22/2016 20:00'!finalizeOids	objects class isAutoCleaning		ifTrue: [ objects finalizeValues ]		ifFalse: [ objects := objects reject: [ : each | each isNil ] ].	oids finalizeValues: true! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 10/30/2006 00:06'!oidsAndObjectsDo: twoArgBlock	objects keysAndValuesDo: twoArgBlock! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 12/29/2004 17:29'!rehashOids	oids rehash! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 4/27/2010 09:13'!reset	oids := MaObjectSerializerPreferences newWeakIdentityKeyDictionary.	objects := MaObjectSerializerPreferences newWeakValueDictionary.	self resetNextOid! !!MaOidManager methodsFor: 'private' stamp: 'cmm 7/26/2005 13:09'!getNextOid	^ nextOid := nextOid + 1! !!MaOidManager methodsFor: 'private' stamp: 'cmm 12/22/2008 15:47'!initialize	super initialize.	self		reset ;		resetNextOid! !!MaOidManager methodsFor: 'private' stamp: 'cmm 3/23/2013 17:11'!postIndependentCopyself maMarked: 'delete'.	objects := objects copy.	oids := oids copy.	self resetNextOid! !!MaOidManager methodsFor: 'private' stamp: 'cmm 12/2/2014 17:17'!resetNextOid	nextOid := FirstNewObjectOid! !!MaOidManager methodsFor: 'private' stamp: 'cmm 5/7/2008 16:28'!useStatisticsFrom: anotherOidManager	"Do nothing for now, since only MagmaOidManagers have an interest in statistics."! !!MaOidManager methodsFor: 'event handling' stamp: 'cmm 6/24/2004 11:59'!handleClassModification: aClass using: aMaObjectSerializer	"optional subclass responsibility"! !!MaOidManager methodsFor: 'testing' stamp: 'cmm 4/22/2013 15:22'!hasOidFor: anObject 	^ oids includesKey: anObject! !!MaOidManager methodsFor: 'copying' stamp: 'cmm 3/23/2013 17:11'!independentCopyself maMarked: 'delete'.	^ self copy postIndependentCopy! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 3/20/2011 14:11'!objectCountByClass	^ (objects collect: [ : e | e class ]) asBag sortedCounts! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 12/27/2002 16:03'!objectWithOid: anInteger ifAbsent: aBlock	^self		objectWithOid: anInteger		ifFound: [ :foundObj | foundObj ]		ifAbsent: aBlock! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 10/28/2011 15:39'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^MaOidCalculator		objectWithOid: anInteger		ifNone:			[ objects				at: anInteger				ifPresent:					[ :obj |					obj   "oid key marked to be cleaned"						ifNil: [ aBlock value ]						ifNotNil: [ oneArgBlock value: obj ] ]				ifAbsent: [ aBlock value ] ]! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 4/20/2003 22:18'!oidCount	^oids size! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 4/22/2013 15:22'!oidFor: anObject 	^ self		oidFor: anObject		ifAbsent:			[ self				oidOf: anObject				is: self getNextOid ]! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 5/5/2013 21:53'!oidFor: anObject ifAbsent: aBlock 	^ anObject maRequiresOwnBuffer		ifTrue:			[ oids				at: anObject				ifPresent: [ : oid | oid ifNil: aBlock ]				ifAbsent: aBlock ]		ifFalse: [ anObject maOid ]! !!MaOidManager methodsFor: 'building' stamp: 'cmm 12/22/2008 15:58'!oidOf: anObject is: anInteger 	objects 		at: anInteger		put: anObject.	^ oids 		at: anObject		put: anInteger! !!MaOidManager methodsFor: '*magma-client' stamp: 'cmm 9/2/2012 21:46'!cleanObject: anObject 	objects		removeKey:			(oids				removeKey: anObject				ifAbsent: [ ^ self ])		ifAbsent: [  ]! !!MaOidManager methodsFor: '*magma-client' stamp: 'cmm 11/13/2011 18:19'!objectsDo: oneArgBlock 	oids keysDo:		[ : each | (each maIsMutatingProxy not or: [ each maRealObjectIsReified ]) ifTrue: [ oneArgBlock value: each ] ]! !SharedPool subclass: #MaSerializerConstants	instanceVariableNames: ''	classVariableNames: 'FirstCharacterOid FirstFloatOid FirstNewObjectOid FirstSmallIntegerOid FirstUserObjectOid LastCharacterOid LastFloatOid LastNewObjectOid LastSmallIntegerOid LastUserObjectOid OidForFalse OidForNil OidForTrue OidForZero'	poolDictionaries: ''	category: 'Ma-Serializer-Core-private'!!MaSerializerConstants commentStamp: 'cmm 12/2/2014 17:01' prior: 0!Package-level constants.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaSerializerConstants class	instanceVariableNames: ''!!MaSerializerConstants class methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2014 10:57'!initialize	OidForNil := MaOidCalculator oidForNil.	OidForFalse := MaOidCalculator oidForFalse.	OidForTrue := MaOidCalculator oidForTrue.	OidForZero :=  MaOidCalculator oidForZero.	FirstNewObjectOid := MaOidCalculator newOidMinimum.	LastNewObjectOid := MaOidCalculator firstUserObjectOid-1.	FirstUserObjectOid := MaOidCalculator firstUserObjectOid.	LastUserObjectOid := MaOidCalculator lastUserObjectOid.	FirstCharacterOid := MaOidCalculator firstCharacterOid.	LastCharacterOid := MaOidCalculator lastCharacterOid.	FirstFloatOid := MaOidCalculator oidForSmallestFloat.	LastFloatOid := MaOidCalculator oidForSmallestOptimizedInteger - 1.	"Hardcoded values to smooth transition to 64-bit Squeak..??  Although I guess it will still dispatch to the wrong class for serialization/materialization."	FirstSmallIntegerOid :=  281472829227008 "MaOidCalculator oidForInteger: SmallInteger minVal".	LastSmallIntegerOid := 281474976710655 "MaOidCalculator oidForInteger: SmallInteger minVal".! !MaSerializerConstants initialize!