Association subclass: #MaAssociation	instanceVariableNames: 'next'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:32'!do: aBlock	aBlock value: self.	next ifNotNil: [ next do: aBlock ]! !!MaAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:32'!findKeyOrNil: akey	^ key = akey ifTrue: [ self ] ifFalse: [ next ifNotNil: [next findKeyOrNil: akey ] ]! !!MaAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:32'!key: akey value: avalue next: anext	key := akey.	value := avalue.	next := anext! !!MaAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:32'!next	^ next! !!MaAssociation methodsFor: 'accessing' stamp: 'sig 7/20/2007 12:32'!next: aNext	next := aNext! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaAssociation class	instanceVariableNames: ''!!MaAssociation class methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:32'!key: key value: value next: next	^ self basicNew key: key value: value next: next! !Dictionary subclass: #MaDictionary	instanceVariableNames: ''	classVariableNames: 'Primes'	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaDictionary commentStamp: '<historical>' prior: 0!| sd md r | Transcript clear.r := OrderedCollection new.ByteString allInstancesDo: [:each | r add: each ].Smalltalk garbageCollect.sd := Dictionary new.Transcript cr; show: 'time to add all strings to sd: ', 	[ r do: [:each | sd at: each put: each ] ] timeToRun printString.Smalltalk garbageCollect.sd := MaDictionary new.Transcript cr; show: 'time to add all strings to md: ', 	[ r do: [:each | sd at: each put: each ] ] timeToRun printString.r _ (1 to: 15500) collect: [ :e | Object new ].r _ r shuffled.Smalltalk garbageCollect.sd _ WeakIdentityKeyDictionary new.md _ MaWeakIdentityKeyDictionary new.Transcript cr; show: 'time to add to sd: ', ([ r do: [ :each | sd at: each put: each ] ] timeToRun) printString.Transcript cr; show: 'time to add to md: ', ([ r do: [ :each | md at: each put: each ] ] timeToRun) printString.r_r shuffled.Transcript cr; show: 'time to access to sd: ', ([ r do: [ :each | sd at: each ] ] timeToRun) printString.Transcript cr; show: 'time to access to md: ', ([ r do: [ :each | md at: each ] ] timeToRun) printString.r _ r shuffled.Transcript cr; show: 'time to replace to sd: ', ([ r do: [ :each | sd at: each put: each ] ] timeToRun) printString.Transcript cr; show: 'time to replace to md: ', ([ r do: [ :each | md at: each put: each ] ] timeToRun) printString.r _ r shuffled.Transcript cr; show: 'time to remove 300 from sd: ', ([ (r copyFrom: 1 to: 300) do: [ :each | sd removeKey: each ] ] timeToRun) printString.Transcript cr; show: 'time to remove 300 from md: ', ([ (r copyFrom: 1 to: 300) do: [ :each | md removeKey: each ] ] timeToRun) printString.!!MaDictionary methodsFor: 'adding' stamp: 'sig 7/19/2007 22:26'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/20/2007 16:03'!associationAt: key ifAbsent: aBlock 	| bucket |	bucket := array at: (self keyHash:key).	^ bucket ifNil: aBlock		ifNotNil: [ (bucket findKeyOrNil: key) ifNil: aBlock ]! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/20/2007 12:37'!associationClass	^ MaAssociation! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/19/2007 22:26'!atIndex: index insertKey: key value: value	| newb |	newb := self associationClass key: key value: value next: (array at: index).	array at: index put: newb.	tally := tally + 1.	self checkForOverflow.	^ value	! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/19/2007 22:26'!atRandom: aGenerator	"Its ugly slow, not recommended to use."	| ind i |	self emptyCheck.	ind := aGenerator nextInt: array size.	i := 1.	self associationsDo: [:b |  (i=ind) ifTrue: [^b]. i := i +1].	self errorEmptyCollection.! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/19/2007 22:26'!bestArraySizeFor: size	| hb |	hb := size highBit. 	^ (hb <= Primes size) ifTrue: [ Primes at: hb ] ifFalse: [ size ]! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/20/2007 12:25'!checkForOverflow	| sz |	sz := array size.	( sz < self maxBuckets) ifTrue: [		tally >= (sz * 4) ifTrue: [ self rehash: (self bestArraySizeFor: tally * 2). ]	]	! !!MaDictionary methodsFor: 'private' stamp: 'cmm 5/6/2013 10:49'!checkForUnderflow	self checkForUnderflow: false! !!MaDictionary methodsFor: 'private' stamp: 'cmm 5/6/2013 10:46'!checkForUnderflow: forceRehash 	(forceRehash or: [ tally < (array size / 4) ]) ifTrue: [ self rehash: (self bestArraySizeFor: tally * 2 + 1) ]! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/25/2007 17:46'!grow	"do nothing"! !!MaDictionary methodsFor: 'private' stamp: 'cmm 5/5/2013 20:30'!inspectorClass	^ BasicInspector! !!MaDictionary methodsFor: 'private' stamp: 'cmm 10/13/2014 21:22'!keyHash: key	"Expand key's hash into the range of positive SmallIntegers.  See PluggableSet class>>#integerSet."	^ ((key hash \\ 1064164 * 1009) \\ array size) + 1! !!MaDictionary methodsFor: 'private' stamp: 'cmm 10/13/2014 21:24'!keyHash: key size: aSize	^ ((key hash \\ 1064164 * 1009) \\ aSize) + 1! !!MaDictionary methodsFor: 'private' stamp: 'cmm 3/28/2010 11:51'!maxBuckets	^ SmallInteger maxVal! !!MaDictionary methodsFor: 'private' stamp: 'Igor.Stasenko 9/24/2010 17:34'!rehash		"Force rehashing .. (was do nothing)"		self rehash: array size! !!MaDictionary methodsFor: 'private' stamp: 'sig 7/19/2007 22:26'!rehash: newSize	| newArray index |	"rehash"	newArray := Array new: newSize.	array do: [ :b | | next |		next := b.		[ next notNil ] whileTrue: [  | nn |			nn := next next.			index := self keyHash: next key size: newSize.			next next: (newArray at: index).			newArray at: index put: next.			next := nn]	].	array := newArray.! !!MaDictionary methodsFor: 'enumerating' stamp: 'Igor.Stasenko 11/8/2010 00:05'!associationsDo: aBlock	array do: [ :b |		b ifNotNil: [ b do: aBlock ]	].! !!MaDictionary methodsFor: 'enumerating' stamp: 'sig 7/19/2007 22:26'!do: aBlock	self associationsDo: [:assoc | aBlock value: assoc value]! !!MaDictionary methodsFor: 'accessing' stamp: 'sig 7/20/2007 14:22'!at: key ifAbsent: aBlock	| bucket |	bucket := array at: (self keyHash: key).	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [^ bucket value]. bucket := bucket next ].	^ aBlock value.! !!MaDictionary methodsFor: 'accessing' stamp: 'sig 7/20/2007 15:56'!at: key ifAbsentPut: aBlock	| index bucket |	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [^ bucket value]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: aBlock value.! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 10/30/2011 16:49'!at: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock 	^ oneArgBlock value:		(self			at: anObject			ifAbsent: [ ^ zeroArgBlock value ])! !!MaDictionary methodsFor: 'accessing' stamp: 'sig 7/20/2007 15:23'!at: key put: value	| index bucket  |	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [ bucket value: value. ^ value ]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: value.! !!MaDictionary methodsFor: 'accessing' stamp: 'sig 7/19/2007 22:29'!maAllKeysAtValue: anObject	| aCollection |	aCollection := OrderedCollection new.	self keysAndValuesDo: [ :key :value | value = anObject ifTrue: [ aCollection add: key ] ].	^aCollection! !!MaDictionary methodsFor: 'accessing' stamp: 'sig 7/19/2007 22:26'!size	^ tally! !!MaDictionary methodsFor: 'copying' stamp: 'sig 7/25/2007 18:20'!copy	| dict |	dict := self species new: self size.	self associationsDo: [:b | dict at: b key put: b value  ].	^ dict.! !!MaDictionary methodsFor: 'testing' stamp: 'cmm 10/29/2013 16:42'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	self		at: key		ifAbsent: [ ^ false ].	^ true! !!MaDictionary methodsFor: 'testing' stamp: 'sig 7/19/2007 22:30'!maIsHashedCollection	^true! !!MaDictionary methodsFor: 'removing' stamp: 'sig 7/19/2007 22:26'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index bucket next |	index := self keyHash: key.	bucket := array at: index.	bucket ifNil: [ ^ aBlock value ].	bucket key = key ifTrue: [ 		tally := tally -1. 		array at: index put: bucket next. 		self checkForUnderflow.		^ bucket value ].	[(next := bucket next) notNil ] whileTrue: [		next key = key ifTrue: [ 		tally := tally - 1. 		bucket next: next next. 		self checkForUnderflow.		^ next value ].		bucket := next.	].	^ aBlock value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaDictionary class	instanceVariableNames: ''!!MaDictionary class methodsFor: 'as yet unclassified' stamp: 'sig 7/19/2007 22:26'!initialize	"Primes up to 2^27"	Primes := #(		5 5 11 17 37 67 131 257 521 1031 2053 4099 8209 16411 32771 65537 131101 		262147 524309 1048583 2097169 4194319 8388617 16777259 33554467 67108879 134217757).! !!MaDictionary class methodsFor: 'as yet unclassified' stamp: 'sig 7/19/2007 22:26'!primes	^ Primes! !TestCase subclass: #MaDictionarysTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaDictionarysTests commentStamp: '<historical>' prior: 0!before running tests , use:MaDictionaryTest initDictClass: MaWeakValueDictionaryMaDictionaryTest initDictClass: MaWeakValueDictionarytests for WeakKey/WeakIdentityKey dicts will fail (keys must be non nil, and some tests because of identity compatison )!!MaDictionarysTests methodsFor: 'instantiating dict' stamp: 'Igor.Stasenko 5/12/2010 22:10'!newDict	^ MaDictionary new! !!MaDictionarysTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/12/2010 21:39'!testAdd		| dict |	dict := self newDict.	dict add: #a -> 1.	dict add: #b -> 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2! !!MaDictionarysTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/12/2010 21:39'!testAddAll		| dict1 dict2 |	dict1 := self newDict.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := self newDict.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!MaDictionarysTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testComma		| dict1 dict2 dict3 |	dict1 := self newDict.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := self newDict.	dict2 at: #a put: 3 ; at: #c put: 4.	dict3 := dict1, dict2.	self assert: (dict3 at: #a) = 3.	self assert: (dict3 at: #b) = 2.	self assert: (dict3 at: #c) = 4.! !!MaDictionarysTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testPseudo	"(self run: #testPseudo)"	"true and false are valid keys"		| dict1  |	dict1 := self newDict.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!MaDictionarysTests methodsFor: 'association tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testAddAssociation	"self run:#testAddAssociation"	"self debug:#testAddAssociation"		| dict |	dict := self newDict.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2.		dict at: #a put: 10.	dict at: #c put: 2.		self assert: (dict at: #a) = 10.	self assert: (dict at: #b) = 2.	self assert: (dict at: #c) = 2		! !!MaDictionarysTests methodsFor: 'association tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testAssociationsSelect	| answer d |	d := self newDict.	d at: (Array with: #hello with: #world)	  put: #fooBar.	d at: Smalltalk put: #'Smalltalk is the key'.	d at: #Smalltalk put: Smalltalk.	answer := d				associationsSelect: [:assoc | assoc key == #Smalltalk						and: [assoc value == Smalltalk]].	self		should: [answer isKindOf: MaDictionary].	self		should: [answer size == 1].	self		should: [(answer at: #Smalltalk)				== Smalltalk].	answer := d				associationsSelect: [:assoc | assoc key == #NoSuchKey						and: [assoc value == #NoSuchValue]].	self		should: [answer isKindOf: MaDictionary].	self		should: [answer size == 0]! !!MaDictionarysTests methodsFor: 'association tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testIncludesAssociation	"self run:#testIncludesAssociation"		| dict |	dict := self newDict.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict includesAssociation: (#a -> 1)).	self assert: (dict includesAssociation: (#b -> 2)).		! !!MaDictionarysTests methodsFor: 'association tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testIncludesAssociationNoValue	"self run:#testIncludesAssociationNoValue"	"self debug:#testIncludesAssociationNoValue"		| dict a1 a3 |	a1 := Association key: #Italie.	a3 := Association key: #France value: 'Paris'.		self assert: (a1 key = #Italie).	self assert: (a1 value isNil).		dict := self newDict.	dict add: a1.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: #Italie).	self assert: (dict at: #Italie) isNil.	self assert: (dict at: #France) = 'Paris'			! !!MaDictionarysTests methodsFor: 'basic tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testAtError	"self run: #testAtError"		| dict |	dict := self newDict.	dict at: #a put: 666.	self shouldnt: [ dict at: #a ] raise: Error.	self should: [ dict at: #b ] raise: Error.		! !!MaDictionarysTests methodsFor: 'basic tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testAtIfAbsent	"self run: #testAtIfAbsent"		| dict |	dict := self newDict.	dict at: #a put: 666.		self assert: (dict at: #a ifAbsent: [nil]) = 666.		self assert: (dict at: #b ifAbsent: [nil]) isNil.	! !!MaDictionarysTests methodsFor: 'basic tests' stamp: 'cmm 3/19/2013 16:45'!testAtPut	"self run: #testAtPut"	"self debug: #testAtPut"		| adictionary |	adictionary := self newDict.	adictionary at: #a put: 3.	self assert: (adictionary at: #a) = 3.	adictionary at: #a put: 3.	adictionary at: #a put: 4.	self assert: (adictionary at: #a) = 4! !!MaDictionarysTests methodsFor: 'basic tests' stamp: 'cmm 3/19/2013 16:32'!testOccurrencesOf	| dict |	dict := self newDict		at: #a put: 1 ;		at: #b put: 2 ;		at: #c put: 1 ;		at: #d put: 3 ;		at: #z put: nil ;		 yourself.	self 		assert: (dict occurrencesOf: 1) = 2 ;		assert: (dict occurrencesOf: nil) = 1! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 11/8/2010 00:37'!testCopy	"self run:#testKeys "		| dict dict2 | 	dict := self newDict.	dict at: 1 put: 1.	dict at: 2 put: 2.	dict at: 3 put: 3.	dict at: 4 put: 4.	dict2 := dict copy.	dict2 associationsDo: [:each | self assert: (dict at: each key) = each value ].	self assert: dict size= dict2 size.	! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testDictionaryConcatenation	"self run: #testDictionaryConcatenation"			| dict1 dict2 dict3 |	dict1 := self newDict.	dict1 at: #a put: 'Nicolas' ; at: #b put: 'Damien'. 		dict2 := self newDict.	dict2 at: #a put: 'Christophe' ; at: #c put: 'Anthony'.	dict3 := dict1, dict2.		self assert: (dict3 at: #a) = 'Christophe'.	self assert: (dict3 at: #b) = 'Damien'.	self assert: (dict3 at: #c) = 'Anthony'.		! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'cmm 10/13/2014 21:23'!testKeyAtValue	"self run: #testKeyAtValue"	"self debug: #testKeyAtValue"		| dict |	dict := self newDict.	dict at: #a put: 1.	dict at: #b put: 2.	dict at: #c put: 1.		self assert: (dict keyAtValue: 2) = #b.	self assert: (#(c a) includes: (dict keyAtValue: 1)).	"ugly may be a bug, why not having a set #a and #c"		self should: [dict keyAtValue: 0] raise: Error		! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testKeys	"self run:#testKeys "		| a1 a2  dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := self newDict.	dict add: a1.	dict add: a2.	 			self assert: (dict keys size) = 2.		self assert: (dict keys includes: #France)				! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testKeysDo	"self run: #testKeysDo"	"self debug: #testKeysDo"		| dict res |	dict := self newDict.		dict at: #a put: 33.	dict at: #b put: 66.		res := OrderedCollection new.	dict keysDo: [ :each | res add: each].		self assert: res asSet = #(a b) asSet.		! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testRemoveKey		"self run:#testRemoveKey "	| dict | 	dict := self newDict.	dict at: #a put: 1.	dict at: #b put: 2.	 	self assert: (dict keys size) = 2.	dict removeKey: #a.	self assert: dict keys size  = 1.	self should: [dict at: #a] raise: Error.	self assert: (dict at: #b) = 2		! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'cmm 3/19/2013 16:44'!testValues	"self run:#testValues "		| a1 a2 dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := self newDict.	dict add: a1.	dict add: a2.	 	self assert: (dict values size ) = 2.	self assert: (dict values includes: 'Paris').! !!MaDictionarysTests methodsFor: 'keys and value tests' stamp: 'sig 8/21/2007 23:03'!testWeakReject	"self run:#testKeys "		| dict dict2 | 	dict := MaWeakValueDictionary new.	dict at: 1 put: 2.	dict at: 2 put: 3.	dict at: 3 put: nil.	dict at: 4 put: 5.	dict2 := dict reject: [:each | each isNil ].	! !!MaDictionarysTests methodsFor: 'implementation tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testPseudoVariablesAreValidKeys	"(self run: #testPseudoVariablesAreValidKeys)"	"true and false are valid keys"		| dict1  |	dict1 := self newDict.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!MaDictionarysTests methodsFor: 'weak keys' stamp: 'Igor.Stasenko 11/8/2010 00:33'!testWeakIdentityKeys	self weakIdentityKeysTestFor: self weakIdentityKeyClass."	self weakIdentityKeysTestFor: WeakIdentityKeyDictionary."! !!MaDictionarysTests methodsFor: 'weak keys' stamp: 'Igor.Stasenko 11/8/2010 00:29'!testWeakKeys	self weakKeysTestFor: self weakKeyClass"	self weakKeysTestFor: WeakKeyDictionary."! !!MaDictionarysTests methodsFor: 'weak keys' stamp: 'sig 7/26/2007 23:52'!weakIdentityKeysTestFor: aClass	| d k1 k2 |	d := aClass new.	k1 := 'x' copy.	k2 := k1 copy.	d at: k1 put: 1.	d at: k2 put: 2.	self assert:  (d at: k1) == 1 .	self assert:  (d at: k2) == 2 .	d at: k1 put: k2.	k1 := nil.	k2 := nil.	Smalltalk garbageCollect.	self assert:  d size = 2 .	self assert:  (d includesKey: nil) not.	self assert: ( d values includes: 2).	self assert: ( d values includes: 1) not.	d finalizeValues.	self assert: d size = 1 .	Smalltalk garbageCollect.	d finalizeValues.	self assert:  d size = 0 .! !!MaDictionarysTests methodsFor: 'weak keys' stamp: 'Igor.Stasenko 11/8/2010 00:29'!weakKeyClass	^ MaWeakKeyDictionary.! !!MaDictionarysTests methodsFor: 'weak keys' stamp: 'sig 7/26/2007 23:50'!weakKeysTestFor: aClass	| d |	d := aClass new.	d at: 'x' copy put: 'yyy'.	d at: 'y' put: #zzz.	Smalltalk garbageCollect.	self assert:  (d includesKey: 'x') not .	self assert:  (d at: 'y') = #zzz .	self assert:  (d includesKey: nil ) not .	self assert:  d size = 2 .	d finalizeValues.	self assert: d size = 1 .	self assert: (d at: 'y') = #zzz.	self assert:  (d at: nil put: 'kkk') = 'kkk' .	self assert:  (d includesKey: nil ) not .! !!MaDictionarysTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 11/8/2010 00:39'!weakIdentityKeyClass	^ MaWeakIdentityKeyDictionary ! !MaDictionarysTests subclass: #MaDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaDictionaryTest methodsFor: 'basic tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testAtNil	"(self run: #testAtNil)"	"nil is a valid key in squeak. In VW nil is not a valid key"	"Ansi 1.9 p, 168    		5.7.2.5 Message: at: key put: newElement    		Synopsis    			Store newElement at key in the receiver. Answer newElement.    		Definition: <abstractDictionary>    		If lookup succeeds for key, then newElement replaces the element previously stored at key.    		Otherwise, the newElement is stored at the new key. In either case, subsequent successful    		lookups for key will answer newElement.  Answer newElement.    		The result is undefined if the key is nil.		This clearly indicates that different smalltalks where doing different assumptions."				| dict1  |	dict1 := self newDict.	self shouldnt: [ dict1 at: nil put: #none] raise: Error.	self assert: (dict1 at: nil) = #none. 	! !!MaDictionaryTest methodsFor: 'basic tests' stamp: 'Igor.Stasenko 5/12/2010 21:40'!testAtPutNil	"self run: #testAtPut"	"self debug: #testAtPut"		| dict |	dict := self newDict.	dict at: nil put: 1.	self assert: (dict at: nil) = 1.	dict at: #a put: nil.	self assert: (dict at: #a) = nil.	dict at: nil put: nil.	self assert: (dict at: nil) = nil.			! !!MaDictionaryTest methodsFor: 'basic tests' stamp: 'Igor.Stasenko 5/12/2010 21:41'!testIncludesKey	"self run:#testIncludesKey"	"self debug:#testIncludesKey"		| dict a1 a2 a3 |	a1 := Association key: 'Italie'.	a2 := Association new.	a3 := Association key: 'France' value: 'Paris'.		dict := self newDict.	dict add: a1 .	dict add: a2.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: 'France').	self assert: (dict includesKey: #Italie).	self assert: (dict includesKey: nil).				self assert: (dict at: 'France' ) = 'Paris'.! !!MaDictionaryTest methodsFor: 'keys and value tests' stamp: 'Igor.Stasenko 5/12/2010 21:42'!testValues	"self run:#testValues "		| a1 a2 a3 dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := self newDict.	dict add: a1.	dict add: a2.	 	self assert: (dict values size ) = 2.	self assert: (dict values includes: 'Paris').		a3 := Association new.	dict add: a3.	self assert: (dict values size ) = 3.	self assert: (dict values includes: nil).								! !MaDictionary subclass: #MaIdentityDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 13:39'!associationClass	^ MaIdentityKeyAssociation ! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 13:36'!at: key ifAbsent: aBlock	| bucket |	bucket := array at: (self keyHash: key).	[bucket notNil] whileTrue: [ bucket key == key ifTrue: [^ bucket value]. bucket := bucket next ].	^ aBlock value.! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 3/27/2010 22:30'!at: key ifAbsentPut: aBlock	| index bucket |	index := self keyHash: key.	bucket := array at: index.	[bucket ~~ nil] whileTrue: [ bucket key == key ifTrue: [^ bucket value]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: aBlock value.! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 13:35'!at: key put: value	| index bucket  |	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key == key ifTrue: [ bucket value: value. ^ value ]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: value.! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 14:59'!keyHash: key	^ (key identityHash \\ array size) + 1! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 14:59'!keyHash: key size: aSize	^ (key identityHash \\ aSize) + 1! !!MaIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 13:43'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index bucket next |	index := self keyHash: key.	bucket := array at: index.	bucket ifNil: [ ^ aBlock value ].	bucket key == key ifTrue: [ 		tally := tally -1. 		array at: index put: bucket next. 		self checkForUnderflow.		^ bucket value ].	[(next := bucket next) notNil ] whileTrue: [		next key == key ifTrue: [ 		tally := tally - 1. 		bucket next: next next. 		self checkForUnderflow.		^ next value ].		bucket := next.	].	^ aBlock value! !!MaIdentityDictionary methodsFor: 'private' stamp: 'cmm 3/28/2010 11:50'!maxBuckets 	"squeak uses 12 bits for identity hash, using buckets more than 2^12 is pointless"	^ 4096 " 2 raisedTo: 12 "! !MaAssociation subclass: #MaIdentityKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaIdentityKeyAssociation methodsFor: 'as yet unclassified' stamp: 'cmm 6/22/2009 13:39'!findKeyOrNil: akey	^ key == akey ifTrue: [ self ] ifFalse: [ next ifNotNil: [next findKeyOrNil: akey ] ]! !MaAssociation subclass: #MaWeakKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'cmm 11/5/2008 17:05'!do: aBlock 	| k |	k := self key.	k ifNotNil: [ aBlock value: self ].	next ifNotNil: [ next do: aBlock ]! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!findKeyOrNil: akey	^ self key = akey ifTrue: [ self ] ifFalse: [ next ifNotNil: [next findKeyOrNil: akey ] ]! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^self key hashMappedBy: map! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ self key identityHashMappedBy: map! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!key	^key ifNotNil: [key at: 1]! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!key: aKey	key := WeakArray with: aKey! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!key: aKey value: anObject	key := WeakArray with: aKey.	value := anObject.! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!key: aKey value: anObject next: aNext	key := WeakArray with: aKey.	value := anObject.	next := aNext! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!MaWeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:34'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !MaWeakKeyAssociation subclass: #MaWeakIdentityKeyAssociation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakIdentityKeyAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:33'!findKeyOrNil: akey	^ self key == akey ifTrue: [ self ] ifFalse: [ next ifNotNil: [next findKeyOrNil: akey ] ]! !MaDictionary subclass: #MaWeakKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:38'!associationClass	^ MaWeakKeyAssociation 	! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/25/2007 17:54'!at: key ifAbsent: aBlock	| bucket |	"nil keys always absent in weak dictionary"	key ifNil: [ ^ aBlock value ] ifNotNil: [		bucket := array at: (self keyHash: key).		[bucket notNil] whileTrue: [ bucket key = key ifTrue: [^ bucket value]. bucket := bucket next ].		^ aBlock value.	]! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 16:00'!at: key ifAbsentPut: aBlock	| index bucket |	key ifNil: [ ^ aBlock value ].	"nil keys is not allowed"	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [^ bucket value]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: aBlock value.! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 15:54'!at: key put: value	| index bucket  |	"its better to use some Dead unique object for determining dead weaklings,	but since in squeak dead weaklings replaced by nil, we can't allow to add it as key"	key ifNil: [ ^ value ].	"nil keys is not allowed"	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key = key ifTrue: [ bucket value: value. ^ value ]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: value.! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 5/6/2013 10:48'!finalizeValues	self finalizeValues: false! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'cmm 5/6/2013 10:48'!finalizeValues: forceRehash 	"remove all nil keys and rehash the receiver afterwards if forceRehash is true or if it needs resized."	1		to: array size		do:			[ : i | | each next |			each := array at: i.			[ each notNil and: [ each key isNil ] ] whileTrue:				[ tally := tally - 1.				each := each next ].			array				at: i				put: each.			each ifNotNil:				[ next := each next.				[ next notNil ] whileTrue:					[ next key						ifNil:							[ tally := tally - 1.							each next: next next ]						ifNotNil: [ each := next ].					next := next next ] ] ].	self checkForUnderflow: forceRehash! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/27/2007 00:04'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | 		association key ifNotNil:[aBlock value: association key]].! !!MaWeakKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/25/2007 18:02'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index bucket next |	key ifNil: [ ^ aBlock value ].	index := self keyHash: key.	bucket := array at: index.	bucket ifNil: [ ^ aBlock value ].	bucket key = key ifTrue: [ 		tally := tally -1. 		array at: index put: bucket next. 		self checkForUnderflow.		^ bucket value ].	[(next := bucket next) notNil ] whileTrue: [		next key = key ifTrue: [ 		tally := tally - 1. 		bucket next: next next. 		self checkForUnderflow.		^ next value ].		bucket := next.	].	^ aBlock value! !MaWeakKeyDictionary subclass: #MaWeakIdentityKeyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:39'!associationClass	^ MaWeakIdentityKeyAssociation! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/25/2007 17:56'!at: key ifAbsent: aBlock	| bucket |	"nil keys always absent in weak dictionary"	key ifNil: [ ^ aBlock value ] ifNotNil: [		bucket := array at: (self keyHash: key).		[bucket notNil] whileTrue: [ bucket key == key ifTrue: [^ bucket value]. bucket := bucket next ].		^ aBlock value.	]! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 16:09'!at: key ifAbsentPut: aBlock	| index bucket |	key ifNil: [ ^ aBlock value ].	"nil keys is not allowed"	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key == key ifTrue: [^ bucket value]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: aBlock value.! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 16:09'!at: key put: value	| index bucket  |	key ifNil: [ ^ value ].	"nil keys is not allowed"	index := self keyHash: key.	bucket := array at: index.	[bucket notNil] whileTrue: [ bucket key == key ifTrue: [ bucket value: value. ^ value ]. bucket := bucket next ].	^ self atIndex: index insertKey: key value: value.! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/19/2007 22:28'!keyHash: key	^ (key identityHash \\ array size) + 1! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/19/2007 22:28'!keyHash: key size: aSize	^ (key identityHash \\ aSize) + 1! !!MaWeakIdentityKeyDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/25/2007 18:01'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index bucket next |	key ifNil: [ ^ aBlock value ].	index := self keyHash: key.	bucket := array at: index.	bucket ifNil: [ ^ aBlock value ].	bucket key == key ifTrue: [ 		tally := tally -1. 		array at: index put: bucket next. 		self checkForUnderflow.		^ bucket value ].	[(next := bucket next) notNil ] whileTrue: [		next key == key ifTrue: [ 		tally := tally - 1. 		bucket next: next next. 		self checkForUnderflow.		^ next value ].		bucket := next.	].	^ aBlock value! !WeakValueAssociation weakSubclass: #MaWeakValueAssociation	instanceVariableNames: 'next'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:37'!do: aBlock	aBlock value: self.	next ifNotNil: [ next do: aBlock ]! !!MaWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:37'!findKeyOrNil: akey	^ key = akey ifTrue: [ self ] ifFalse: [ next ifNotNil: [next findKeyOrNil: akey ] ]! !!MaWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/25/2007 18:24'!key: aKey value: anObject next: aNext	"Store the arguments as the variables of the receiver."	key := aKey.	self value: anObject.	next := aNext! !!MaWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:37'!next	^ next! !!MaWeakValueAssociation methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:37'!next: aNext	next := aNext! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MaWeakValueAssociation class	instanceVariableNames: ''!!MaWeakValueAssociation class methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:37'!key: key value: value next: next	^ (self basicNew:1) key: key value: value next: next! !MaDictionary subclass: #MaWeakValueDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Dictionarys'!!MaWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'sig 7/20/2007 12:38'!associationClass	^ MaWeakValueAssociation! !!MaWeakValueDictionary methodsFor: 'as yet unclassified' stamp: 'sig 9/3/2007 15:38'!reject: aBlock" dirty hack , uncomment following line	10 seconds asDelay wait. "	^ super reject: aBlock! !MaDictionary initialize!