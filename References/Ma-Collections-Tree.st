MaObject subclass: #MaTree	instanceVariableNames: 'parents children sortBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Tree'!!MaTree methodsFor: 'building'!add: anObject	"Adds anObject as a main parent in the receiver."	self		add: anObject		asChildOf: nil.	^anObject! !!MaTree methodsFor: 'building' stamp: 'cmm 4/13/2007 16:05'!add: anObject asChildOf: aParentObject 	parents 		at: anObject		put: aParentObject.	(children 		at: aParentObject		ifAbsentPut: [ self newChildCollection ]) in: [ : immediateChildren | (immediateChildren includes: anObject) ifFalse: [ immediateChildren add: anObject ] ].	children 		at: anObject		ifAbsentPut: [ self newChildCollection ].	^ anObject! !!MaTree methodsFor: 'building' stamp: 'cmm 2/23/2007 16:00'!addAll: aCollection 	"Adds all in aCollection as main parents in the receiver."	aCollection do: [ : each | self add: each ]! !!MaTree methodsFor: 'building' stamp: 'cmm 2/23/2007 16:11'!mergePath: anOrderedCollection 	"Adds each object in anOrderedCollection as a new path in	the receiver.  The first element in anOrderedCollection is the	main parent, and each subsequent element is a child of the	previous.  Any parts of the path that need created will be."	^ self 		mergePath: anOrderedCollection		to: nil! !!MaTree methodsFor: 'building' stamp: 'cmm 2/23/2007 16:11'!mergePath: anOrderedCollection to: parentObject 	"Adds each object in anOrderedCollection as a new path in the receiver.  The first element in anOrderedCollection is added as a child of parentObject, and each subsequent element is a child of the previous.  Whereever part of the path already exists, it is reused."	parentObject ifNotNil: [ self verifyIncludes: parentObject ].	anOrderedCollection 		inject: parentObject		into: 			[ : parent : each | 			self 				add: each				asChildOf: parent.			each ].	^ anOrderedCollection! !!MaTree methodsFor: 'building' stamp: 'cmm 2/23/2007 16:12'!mergeTree: aMaTree 	^ self 		mergeTree: aMaTree		at: nil! !!MaTree methodsFor: 'building' stamp: 'cmm 2/23/2007 16:12'!mergeTree: aMaTree at: anObject 	self verifyIncludes: anObject.	aMaTree withParentsDo: 		[ : each : eachParent | 		self 			add: each			asChildOf: eachParent ].	^ aMaTree! !!MaTree methodsFor: 'building' stamp: 'cmm 4/11/2007 17:20'!move: anObject to: newParentObject 	^ self 		add: anObject		asChildOf: newParentObject! !!MaTree methodsFor: 'building' stamp: 'cmm 7/25/2002 19:42'!remove: anObject	"Removes anObject and all of its children."	^self		remove: anObject		ifAbsent: [ self error: anObject printString, ' was not found in ', self printString ]! !!MaTree methodsFor: 'building' stamp: 'cmm 4/13/2007 13:51'!remove: anObject ifAbsent: aBlock 	"Answers the tree of removed objects removed after removing anObject after removing it and all of its children."	| tree |	(self includes: anObject) ifFalse: [ ^ aBlock value ].	self removeFromChildren: anObject.	(tree := self treeAt: anObject) asSet do: 		[ : each | 		parents removeKey: each.		children 			removeKey: each			ifAbsent: 				[ "do nothing"				 ] ].	^ tree! !!MaTree methodsFor: 'building' stamp: 'cmm 4/13/2007 16:17'!sortBlock: aBlock 	"Specify a two-argument block, aBlock, which describes how children at each level are sorted."	| newChildren |	sortBlock := aBlock.	newChildren := children class new: children size.	children keysAndValuesDo: 		[ : eachParent : eachChildren | 		newChildren 			at: eachParent			put: (eachChildren asSortedCollection: sortBlock) ].	children := newChildren! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/22/2007 12:25'!anyOne	^ self roots anyOne! !!MaTree methodsFor: 'accessing' stamp: 'cmm 4/11/2007 17:19'!childrenOf: anObject 	^ children at: anObject! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 16:05'!depthOf: anObject 	"Returns the number of parents anObject has."	| depth |	depth := -1.	self 		pathFrom: anObject		to: nil		do: [ : eachInPath | depth := depth + 1 ].	^ depth! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 16:05'!nodesInPathFrom: someChildObject to: someParentObject 	"Returns a collection of nodes between someChildObject	and someParentObject."	| answer |	answer := OrderedCollection new.	self 		pathFrom: someChildObject		to: someParentObject		do: [ : each | answer add: each ].	^ answer! !!MaTree methodsFor: 'accessing' stamp: 'cmm 4/12/2007 13:31'!parentOf: anObject 	^ parents at: anObject! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 15:57'!pathFrom: anObject 	"Returns a collection of the objects that are contained in the path to anObject ordered from an Object to the top of the hierarchy."	^ self 		nodesInPathFrom: anObject		to: nil! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 15:57'!pathTo: anObject 	"Returns a collection of the objects that are contained in the path to anObject, ordered from the the top of the hierarchy to anObject."	^ (self pathFrom: anObject) reverse! !!MaTree methodsFor: 'accessing' stamp: 'cmm 4/29/2007 13:56'!reSort	children do: [ : each | each maIsSortedCollection ifTrue: [ each reSort ] ]! !!MaTree methodsFor: 'accessing' stamp: 'cmm 6/10/2003 23:08'!roots	"Answers a collection of all roots in this tree."	^self childrenOf: nil! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 15:58'!size	^ parents size! !!MaTree methodsFor: 'accessing' stamp: 'cmm 2/23/2007 15:58'!treeAt: anObject 	"Return a new instance of the receiver which has a single main parent anObject."	^ self 		treeAt: anObject		ifAbsent: 			[ self error: anObject printString , ' was not found in ' , self printString ]! !!MaTree methodsFor: 'accessing' stamp: 'cmm 12/21/2007 09:54'!treeAt: anObject ifAbsent: aBlock 	"Return a new instance of the receiver which has a single main parent anObject."	| newTree |	(self includes: anObject) ifFalse: [ ^ aBlock value ].	newTree := self maOriginalClass new.	self 		depthFirstDo: 			[ : path | 			newTree 				add: path last				asChildOf: (path size > 1 ifTrue: [ path at: path size - 1 ]) ]		at: anObject.	^ newTree! !!MaTree methodsFor: 'converting' stamp: 'cmm 5/24/2012 22:17'!asSet	"Answer a Set of all the members of this tree."	^ parents keys asSet! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 4/11/2007 17:37'!breadthFirstDo: oneArgBlock	self 		breadthFirstDo: oneArgBlock		at: nil! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 4/12/2007 10:45'!breadthFirstDo: oneArgBlock at: nodeObject 	self 		breadthFirstDo: oneArgBlock		atAll: {nodeObject}		path: OrderedCollection new! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/21/2007 09:53'!collect: aBlock	"Returns a new tree whose nodes have all been operated on by aBlock."	^self		collect: aBlock		into: self maOriginalClass new! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/21/2007 12:55'!depthFirstDo: oneArgBlock 	"Value oneArgBlock with the path of objects in the receiver from each main parent in the order of depthFirst."	self 		depthFirstDo: oneArgBlock		at: nil! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/21/2007 12:54'!depthFirstDo: oneArgBlock at: anObject 	self 		depthFirstDo: oneArgBlock		at: anObject		path: OrderedCollection new! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:04'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:03'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [ : each | (aBlock value: each) ifTrue: [ ^ each ] ].	^ exceptionBlock value! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/24/2002 16:07'!do: oneArgBlock	parents keysDo: oneArgBlock! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:04'!maDetect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	"foundBlock takes one argument, the found object."	self 		do: [ :element | (aBlock value: element) ifTrue: [ ^foundBlock value: element ] ].	^exceptionBlock value! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:05'!pathFrom: anObject do: aBlock 	"Value aBlock with the objects from anObject to its highest level parent."	self 		pathFrom: anObject		to: nil		do: aBlock! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 4/12/2007 13:31'!pathFrom: someChildObject to: someParentObject do: oneArgBlock 	"For each node in the tree from someChildObject to someParentObject, inclusive, value oneArgBlock.  The highest level parent (nil) will not be used as an argument to value oneArgBlock."	| node |	someParentObject ifNotNil: [ self verifyIncludes: someParentObject ].	node := someChildObject.	[ node isNil or: [ node = someParentObject ] ] whileFalse: 		[ oneArgBlock value: node.		node := self parentOf: node ]! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/21/2007 09:54'!reject: aBlock 	"Answer the Set of my elements which do not satisfy aBlock."	| answer |	answer := self maOriginalClass new.	self do: [ : each | (aBlock value: each) ifFalse: [ answer add: each ] ].	^ answer! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:11'!rejectBranches: aBlock 	"Returns a new Tree without my branches that satisfy aBlock."	| newTree |	newTree := self maOriginalClass new.	self do: [ : each | (aBlock value: each) ifFalse: [ newTree mergePath: (self pathTo: each) ] ].	^ newTree! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 2/23/2007 16:28'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  Answer a new Set, only those elements for which aBlock evaluates to true."	| newCollection |	newCollection := Set new.	self do: [ : each | (aBlock value: each) ifTrue: [ newCollection add: each ] ].	^ newCollection! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/21/2007 09:48'!selectPaths: aBlock 	"Answer a new Tree with just my branches that at least somewhere link nodes that satisfy aBlock.  The argument to aBlock is the path of nodes to the current node."	| newTree |	newTree := self maOriginalClass new.	self depthFirstDo: 		[ : path | 		(aBlock value: path) ifTrue: [ newTree mergePath: path ] ].	^ newTree! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/24/2002 16:09'!withParentsDo: twoArgBlock	parents keysAndValuesDo: twoArgBlock! !!MaTree methodsFor: 'private' stamp: 'cmm 4/12/2007 13:10'!breadthFirstDo: oneArgBlock atAll: nodes path: path 	nodes do: [ : each | 		each ifNotNil: 			[ path addLast: each.			oneArgBlock value: path ] ].	nodes ifNotEmpty: 		[ self 			breadthFirstDo: oneArgBlock			atAll: (nodes 					inject: OrderedCollection new					into: 						[ : coll : each | 						coll							addAll: (self childrenOf: each) ;							yourself ])			path: path ].	path removeLast! !!MaTree methodsFor: 'private' stamp: 'cmm 12/21/2007 15:02'!childrenClass	^ (Smalltalk hasClassNamed: #MaDictionary) 		ifTrue: [ Smalltalk classNamed: #MaDictionary ]		ifFalse: [ Dictionary ]! !!MaTree methodsFor: 'private' stamp: 'cmm 2/23/2007 17:12'!collect: aBlock into: aMaTree 	"Since some objects may share a parent, we use the map to make sure we only value each parent just once, so an identical version of that object is kept."	| map |	map := IdentityDictionary new.	self withParentsDo: 		[ : eachChild : eachParent | 		eachParent isNil 			ifTrue: 				[ aMaTree add:					(map 						at: eachChild						ifAbsentPut: [ aBlock value: eachChild ]) ]			ifFalse: 				[ aMaTree 					add: 						(map 							at: eachChild							ifAbsentPut: [ aBlock value: eachChild ])					asChildOf: 						(map 							at: eachParent							ifAbsentPut: [ aBlock value: eachParent ]) ] ].	^ aMaTree! !!MaTree methodsFor: 'private' stamp: 'cmm 3/21/2007 12:03'!depthFirstDo: oneArgBlock at: anObject path: path 	anObject ifNotNil: 		[ path addLast: anObject.		oneArgBlock value: path ].	(self childrenOf: anObject) do: 		[ : each | 		self 			depthFirstDo: oneArgBlock			at: each			path: path ].	anObject ifNotNil: [ path removeLast ]! !!MaTree methodsFor: 'private' stamp: 'cmm 2/23/2007 16:04'!errorNotFound: anObject	"Actually, this should raise a special Exception not just an error."	self error: 'Object is not in the collection.'! !!MaTree methodsFor: 'private' stamp: 'cmm 4/13/2007 16:07'!initialize	super initialize.	parents := self parentsClass new.	children := self childrenClass new		at: nil			put: self newChildCollection ;		yourself! !!MaTree methodsFor: 'private' stamp: 'cmm 4/13/2007 16:09'!newChildCollection	^ sortBlock 		ifNil: [ OrderedCollection new ]		ifNotNil: [ SortedCollection sortBlock: sortBlock ]! !!MaTree methodsFor: 'private' stamp: 'cmm 11/29/2007 09:45'!parentsClass	^ MaDictionary! !!MaTree methodsFor: 'private' stamp: 'cmm 4/13/2007 13:52'!removeFromChildren: anObject 	(children at: (self parentOf: anObject)) remove: anObject! !!MaTree methodsFor: 'private' stamp: 'cmm 2/23/2007 15:35'!verifyIncludes: anObject 	(self includes: anObject) ifFalse: 		[ self error: self printString , ' does not include ' , anObject printString ]! !!MaTree methodsFor: 'testing' stamp: 'cmm 4/12/2007 13:31'!hasChildFor: anObject 	"Returns true if anObject has any children.  Signal an error if anObject is not part of the hierarchy."	^ parents includes: anObject! !!MaTree methodsFor: 'testing' stamp: 'cmm 2/23/2007 16:16'!hasParentFor: anObject 	"Returns true if anObject has a parent.  Signal an error if anObject is not part of the hierarchy."	^ (self parentOf: anObject) notNil! !!MaTree methodsFor: 'testing' stamp: 'cmm 2/23/2007 17:59'!ifEmpty: aBlock	"Evaluate the block if I'm empty"	^ self isEmpty ifTrue: aBlock! !!MaTree methodsFor: 'testing'!includes: anObject 	^parents includesKey: anObject! !!MaTree methodsFor: 'testing' stamp: 'cmm 2/23/2007 17:59'!isEmpty	"Answer whether the receiver contains any elements."	^self size = 0! !!MaTree methodsFor: 'printing' stamp: 'cmm 4/12/2007 16:58'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self depthFirstDo:		[ : path |		aStream			cr;			tab: path size - 1 ;			maPrint: path last ]! !!MaTree methodsFor: 'copying' stamp: 'cmm 4/12/2007 13:13'!postCopy	"Private - use Copy"	| newChildren |	parents := parents copy.	newChildren := children class new.	children keysAndValuesDo:		[ : eachNode : eachChildren |		newChildren at: eachNode put: eachChildren copy ].	children := newChildren! !MaTree subclass: #MaIdentityTree	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Ma-Collections-Tree'!!MaIdentityTree methodsFor: 'private' stamp: 'cmm 4/13/2007 13:41'!childrenClass	^ IdentityDictionary! !!MaIdentityTree methodsFor: 'private' stamp: 'cmm 4/13/2007 13:39'!parentsClass	^ IdentityDictionary! !!MaIdentityTree methodsFor: 'private' stamp: 'cmm 4/13/2007 13:53'!removeFromChildren: anObject 	"There is no removeIdentical:, so I just did it this way.."	(children at: (self parentOf: anObject)) removeAllSuchThat: [ : each | each == anObject ]! !