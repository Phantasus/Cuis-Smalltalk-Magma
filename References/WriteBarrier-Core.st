Object subclass: #WBClassBuilder	instanceVariableNames: 'class barrier fieldsCache'	classVariableNames: ''	poolDictionaries: ''	category: 'WriteBarrier-Core'!!WBClassBuilder methodsFor: 'private' stamp: 'cmm 5/30/2018 22:02'!allSelectorsDo: aBlock	| uniqueSelectors | uniqueSelectors := Set new.	((self targetClass withAllSuperclasses copyWithout: Object) copyWithout: ProtoObject) do:		[:cls |		uniqueSelectors addAll: cls selectors].	uniqueSelectors do: aBlock! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 12:01'!checkClassFormat: anEvent	((class format ~~ class superclass format) or: [anEvent areInstVarsModified]) ifTrue:		[self migrateFromTarget: anEvent oldItem to: anEvent itemClass]! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 11/26/2011 13:37'!checkOverrideOf: aSymbol 	| fields |	fields := self fieldsWrittenToBySelector: aSymbol.	fields isEmpty		ifTrue:			[ (class includesSelector: aSymbol) ifTrue: [ class removeSelector: aSymbol ] ]		ifFalse:			[ fields =				(fieldsCache					at: aSymbol					ifAbsent: [  ]) ifFalse:				[ self					installOverrideOf: aSymbol					fields: fields ] ]! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/23/2004 14:28'!createSubclassOf: aClass	| meta |	meta := Metaclass new.	meta		superclass: aClass class		methodDictionary: MethodDictionary new		format: aClass class format.	class := meta new.	class		superclass: aClass		methodDictionary: MethodDictionary new		format: aClass format.	class setName: aClass name, '*'.	^ class! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 11/26/2011 11:04'!fieldsWrittenToBySelector: selectorSymbol	^ self targetClass fieldsWrittenToBySelector: selectorSymbol! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 9/8/2015 14:08'!initializeWithTarget: aClass barrier: aBarrier	barrier := aBarrier.	class := self createSubclassOf: aClass.	fieldsCache := Dictionary new.	self installOverrides.! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 1/14/2013 10:11'!installAccessingOverrides	class				compileSilently: 'writeBarrier	^ #(size) first first'		classified: 'access' ;				compileSilently: 'species		|species|		species := super species.		^ species = self class			ifTrue: [self class superclass]			ifFalse: [species]'		classified: 'accessing'.	((class methodDictionary at: #writeBarrier) literalAt: 2)		at: 1		put: (WeakArray with: barrier)! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 5/30/2018 22:10'!installAtPutOverrides	"This is purposefully written to work for Dictionary's, too."	self shouldOverrideAtPut ifTrue:		[class compileSilently:			'at: aNumber put: anObject				| shouldSignal result |				shouldSignal := (super at: aNumber ifAbsent: ['''']) ~~ anObject.				result := super at: aNumber put: anObject.				shouldSignal ifTrue: [ self writeBarrier modified: self ].				^ result'				classified: 'standard']! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 2/28/2012 17:13'!installCopyingOverrides	class		compileSilently: 'shallowCopy	| copy |	copy := super shallowCopy.	copy == self ifFalse:		[copy primitiveChangeClassTo: (copy class superclass basicNew)].	^ copy'		classified: 'overrides'.	class		compileSilently: 'clone	| copy |	copy := super clone.	copy == self ifFalse:		[copy primitiveChangeClassTo: (copy class superclass basicNew)].	^ copy'		classified: 'overrides'! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 11/26/2011 13:37'!installFieldOverrides	| fields |	self allSelectorsDo:		[:ea |		fields := self fieldsWrittenToBySelector: ea.		fields isEmpty ifFalse: [self installOverrideOf: ea fields: fields]]! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 17:27'!installGOODSOverrides	class class compileSilently: 'goodsClassName ^ self superclass name' classified: 'goods'! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 3/7/2013 10:42'!installInstVarAtPutOverride	self shouldOverrideInstVarAtPut ifTrue:		[ class compileSilently:			'instVarAt: aNumber put: anObject				| shouldSignal result |				shouldSignal := (super instVarAt: aNumber) ~~ anObject.				result := super instVarAt: aNumber put: anObject.				shouldSignal ifTrue: [ self writeBarrier modified: self ].				^ result'				classified: 'standard' ]! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 02:23'!installOverrideOf: aSymbol fields: anArray	class addSelectorSilently: aSymbol withMethod:		(WBMethodBuilder selector: aSymbol class: class fields: anArray)			compiledMethod.	fieldsCache at: aSymbol put: anArray! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/6/2004 14:25'!installOverrides	self installStandardOverrides.	self installFieldOverrides.  ! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 5/30/2018 22:46'!installStandardOverrides	self		 installAtPutOverrides ;		 installInstVarAtPutOverride ;		 installTestingOverrides ;		 installAccessingOverrides ;		 installCopyingOverrides! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 03:13'!installTestingOverrides	class		compileSilently: 'isBehindWriteBarrier ^ true'		classified: 'writebarrier'! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 03:05'!migrateFromTarget: oldSuperclass to: newSuperclass	| oldClass |	oldClass := class.	oldClass superclass: oldSuperclass.	class := self createSubclassOf: newSuperclass.	class updateInstancesFrom: oldClass! !!WBClassBuilder methodsFor: 'private' stamp: 'avi 10/7/2004 11:46'!rebuildMethods	self allSelectorsDo: [:ea | self checkOverrideOf: ea]! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 5/30/2018 21:42'!shouldOverrideAtPut	^ class isVariable or: [ (class whichClassIncludesSelector: #at:put:) ~= Object ]! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 7/13/2009 18:09'!shouldOverrideInstVarAtPut	^ class isPointers! !!WBClassBuilder methodsFor: 'private' stamp: 'cmm 11/23/2011 22:23'!systemChanged: anEvent 	anEvent itemKind = #method ifTrue:		[ (anEvent isRemoved and: [ class includesSelector: anEvent itemSelector ]) ifTrue: [ class removeSelector: anEvent itemSelector ].		self checkOverrideOf: anEvent itemSelector ].	anEvent itemKind = #class ifTrue:		[ anEvent isModified ifTrue:			[ self checkClassFormat: anEvent.			self rebuildMethods ] ]! !!WBClassBuilder methodsFor: 'access' stamp: 'avi 10/6/2004 12:17'!barrierClass	^ class! !!WBClassBuilder methodsFor: 'access' stamp: 'avi 10/6/2004 01:33'!targetClass	^ class superclass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WBClassBuilder class	instanceVariableNames: ''!!WBClassBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:11'!target: aClass barrier: aBarrier	^ self basicNew initializeWithTarget: aClass barrier: aBarrier! !Object subclass: #WBMethodBuilder	instanceVariableNames: 'selector class fields stream'	classVariableNames: 'Cache'	poolDictionaries: ''	category: 'WriteBarrier-Core'!!WBMethodBuilder commentStamp: 'cmm 11/21/2011 23:41' prior: 0!A WBMethodBuilder generates an override of a single method which could potentially alter the receiver's inst-vars.  First, it stores each of the receivers inst-vars into temp vars, calls super, then compares each of the temp-vars to the inst-vars.  If any are different, then "self writeBarrier modified: self" is called.The method source would be something like this:addValue: t1 	| t2 t3 t4 t5 t6 |	t2 := self instVarAt: 2.	t3 := self instVarAt: 3.	t4 := self instVarAt: 4.	t5 := self instVarAt: 5.	t6 := super addValue: t1.	t2 == (self instVarAt: 2) ifFalse:		[ self writeBarrier modified: self.		^ t6 ].	t3 == (self instVarAt: 3) ifFalse:		[ self writeBarrier modified: self.		^ t6 ].	t4 == (self instVarAt: 4) ifFalse:		[ self writeBarrier modified: self.		^ t6 ].	t5 == (self instVarAt: 5) ifFalse:		[ self writeBarrier modified: self.		^ t6 ].	^ t6!!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 12/3/2011 16:48'!buildCompiledMethod	self		 generateSignature ;		 generateTemporaryDeclarations ;		 generateStoreFields ;		 generateCallSuper ;		 generateCheckFields ;		 generateReturn.	class		compileSilently: stream contents		classified: 'overriding'.	^ class methodDictionary at: selector! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 12/3/2011 16:31'!generateCallSuper	"After remembering instVars in temps, call the original version of the method in the superclass."	self generateCallSuperSendingToArgs: nil! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 12/3/2011 16:43'!generateCallSuperSendingToArgs: selectorSymbol 	"After remembering instVars in temps, call the original version of the method in the superclass."	stream		 cr ;		 tab ;		 nextPutAll: 'returnValue := super '.	selector partsAndArgsDo:		[ : eachPart : eachArg | stream nextPutAll: eachPart.		eachArg ifNotNil:			[ stream				 space ;				 nextPutAll: eachArg.			selectorSymbol ifNotNil:				[ stream					 space ;					 nextPutAll: selectorSymbol ].			stream space ] ].	stream nextPut: $.! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 11/22/2011 21:49'!generateCheckField: fieldNumber 	"Compare the fieldNumber'th instVar of the receiver to the temp-var it was stored in and send #modified: if they're not identical."	stream		 cr ;		 tab ;		 nextPut: $t ;		 nextPutAll: fieldNumber asString ;		 nextPutAll: ' == (' ;		 nextPutAll: (class allInstVarNames at: fieldNumber) ;		 nextPutAll: ') ifFalse: [ self writeBarrier modified: self. ^returnValue ].'! !!WBMethodBuilder methodsFor: 'private' stamp: 'avi 10/6/2004 11:49'!generateCheckFields	fields do: [:i | self generateCheckField: i]! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 11/21/2011 23:21'!generateReturn	"Return the temp-var which holds the value of the call to super."	stream		 cr ;		 tab ;		 nextPutAll: '^returnValue'! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 12/3/2011 16:43'!generateSignature	"Write the first-line of the method."	selector partsAndArgsDo:		[ : eachPart : eachArg | stream nextPutAll: eachPart.		eachArg ifNotNil:			[ stream				 space ;				 nextPutAll: eachArg ;				 space ] ]! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 11/22/2011 22:05'!generateStoreField: fieldNumber 	"Store the fieldNumber'th instVar into a temp-var for that field."	stream		 cr ; tab ;		 nextPut: $t ;		 nextPutAll: fieldNumber asString ;		 nextPutAll: ' := ' ;		 nextPutAll: (class allInstVarNames at: fieldNumber) ;		 nextPut: $.! !!WBMethodBuilder methodsFor: 'private' stamp: 'avi 10/6/2004 11:42'!generateStoreFields	fields do: [:i | self generateStoreField: i]! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 11/21/2011 23:20'!generateTemporaryDeclarations	"Write the temps declaration."	stream		 cr ;		 tab ;		 nextPut: $| ;		 space.	fields do:		[ : i | stream			 space ;			 nextPut: $t ;			 nextPutAll: i asString ].	stream nextPutAll: ' returnValue |'! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 12/3/2011 16:48'!initialize	super initialize.	stream := WriteStream on: String empty! !!WBMethodBuilder methodsFor: 'private' stamp: 'avi 10/6/2004 13:51'!initializeWithSelector: aSymbol class: aClass fields: anArray	selector := aSymbol.	class := aClass.	fields := anArray! !!WBMethodBuilder methodsFor: 'private' stamp: 'cmm 11/21/2011 19:58'!selectorPartsAndArgsDo: twoArgBlock 	selector isUnary		ifTrue:			[ twoArgBlock				value: selector				value: nil ]		ifFalse:			[ selector isKeyword				ifTrue:					[ (selector subStrings: ':') withIndexDo:						[ : eachPart : x | twoArgBlock							value: eachPart , ':'							value: 'arg' , x asString ] ]				ifFalse:					[ twoArgBlock						value: selector						value: 'arg1' ] ]! !!WBMethodBuilder methodsFor: 'access' stamp: 'avi 10/7/2004 03:28'!compiledMethod	^ Cache at: (class lookupSelector: selector) ifAbsentPut: [self buildCompiledMethod]! !!WBMethodBuilder methodsFor: 'access' stamp: 'cmm 12/3/2011 16:33'!streamContents	^ stream contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WBMethodBuilder class	instanceVariableNames: ''!!WBMethodBuilder class methodsFor: 'as yet unclassified' stamp: 'cmm 1/2/2012 20:30'!initialize	Cache ifNotNil: [ WeakArray removeWeakDependent: Cache ].	Cache := WeakIdentityKeyDictionary new.	WeakArray addWeakDependent: Cache! !!WBMethodBuilder class methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2011 16:51'!selector: aSymbol class: aClass fields: anArray	^ self new		initializeWithSelector: aSymbol		class: aClass		fields: anArray! !Object subclass: #WriteBarrier	instanceVariableNames: 'builders'	classVariableNames: ''	poolDictionaries: ''	category: 'WriteBarrier-Core'!!WriteBarrier commentStamp: '<historical>' prior: 0!A WriteBarrier provides a way to watch for changes to the state of individual objects.  Any objects that you #add: to a WriteBarrier will be modified in the following ways:- their class will be changed to be a new, anonymous subclass of whatever their class was before.  For example, if you #add: an Array to a WriteBarrier, it will now be of class "Array with write barrier", which is a subclass of Array (although it won't show up in "Array subclasses").- any methods that potentially modify instance variables will be overriden in this new class.  The overridden method stores the original values of the instance variable in temps, then calls the super method, and then compares the current inst var values with the originals.- If the instance variable values have changed, the WriteBarrier will be notified with a send to #modified:, with the object that was modified as the single argument.- For variably-sized classes, #at:put: is also overridden to provide the same notification.- the new class will override #isBehindWriteBarrier to return true, and will implement #writeBarrier to return the WriteBarrier instance.The default implementation of #modified: doesn't do anything.  DirtySetWriteBarrier is a subclass that overrides #modified: to maintain a set of objects that have recently changed.  You may wish to create your own subclass with an alternate implementation.Notes:- You can only add any given object to one WriteBarrier.  If you try to add it to a second one, you will get an error.- The classes of any objects you add to a WriteBarrier will be made uncompact.  For most compact classes (Array, String, Point, etc) the only effect this should have is to increase your image size by a few percent.  For some classes (CompiledMethod, MethodContext), the results are less predictable, and so adding them to a WriteBarrier is not supported.- Because it's special cased by the VM, sending #class to an object will return the special anonymous class.  However, sending #species will still return the normal class (or whatever #species would have returned normally).- The WriteBarrier is semi-permeable: if you want to modify an object directly without triggering notifications, you can use #instVarAt:put: and #basicAt:put:.!!WriteBarrier methodsFor: 'public' stamp: 'cmm 12/27/2012 10:22'!add: anObject 	anObject isBehindWriteBarrier		ifTrue:			[ anObject writeBarrier = self ifFalse: [ self error: 'This object is already behind another write barrier.' ] ]		ifFalse:			[ anObject isClosure				ifTrue: [ self error: 'Should not add BlockClosure''s to a WriteBarrier.' ]				ifFalse:					[ anObject primitiveChangeClassTo: (self barrierClassForClass: anObject class) basicNew.					self assert: anObject writeBarrier = self ] ]! !!WriteBarrier methodsFor: 'public' stamp: 'cmm 3/22/2013 20:30'!remove: anObject 	anObject isBehindWriteBarrier ifTrue:		[ anObject writeBarrier == self ifFalse: [ ^ self ].		anObject primitiveChangeClassTo: anObject class superclass basicNew ]! !!WriteBarrier methodsFor: 'public' stamp: 'avi 10/6/2004 13:56'!unregister	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:25'!barrierClassForClass: aClass	^ (self builderForClass: aClass) barrierClass! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:22'!builderForClass: aClass	^ builders at: aClass ifAbsentPut: [self newBuilderForClass: aClass]! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:57'!initialize	builders := WeakIdentityKeyDictionary new.	WeakArray addWeakDependent: builders.	self registerForNotifications ! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:45'!modified: anObject! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:11'!newBuilderForClass: aClass	^ WBClassBuilder target: aClass barrier: self! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:40'!registerForNotifications	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #systemChanged:! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:18'!storeOn: aStream	aStream nextPutAll: 'self writeBarrier'! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:15'!systemChanged: anEvent	builders keysAndValuesDo:		[:class :builder |		(class withAllSuperclasses includes: anEvent itemClass) ifTrue:			[builder systemChanged: anEvent]]! !WBMethodBuilder initialize!